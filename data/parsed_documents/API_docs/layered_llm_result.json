[
  {
    "method_name": "TesterLibrary.Overall.common.reset_tester",
    "return_type": "bool",
    "return": "布尔值Bool (范围：True / False)",
    "parameters": [],
    "kwargs": [],
    "description": "该函数用于清空测试仪表的所有配置，并将其环境重置为一个干净且初始化的状态。它调用了底层的 Renix 测试框架方法，执行一系列关键操作以确保测试环境正确复位。如果重置失败，则会抛出 ContinuableFailure 异常；若成功，则返回 True。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Reset Tester |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.init_tester",
    "return_type": "sys_entry",
    "return": "The system entry point object obtained from the connected CL instance, which provides access to the system's core functionality for further interactions.",
    "parameters": [
      {
        "name": "Product",
        "type": "str",
        "description": "The type of product to be tested (e.g., 'BIGTAO' or 'DARYU'). This value is set in the system entry to configure product-specific behavior.",
        "default": "'BIGTAO'",
        "range_or_options": "BIGTAO DARYU"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "Operation mode for the system. Typically used to specify database interaction mode or performance testing mode.",
        "default": "'performance'",
        "range_or_options": "performance db"
      },
      {
        "name": "Log",
        "type": "bool",
        "description": "If True, enables logging using the global LOGGER. If False, uses the standard logging module. Also affects configuration saving via Config.save().",
        "default": "True",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Rtsm",
        "type": "str",
        "description": "Host address of the RTSM server. If provided, establishes connection through RTSM. If None and CL is also None, defaults to internal initialization.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RtsmPort",
        "type": "int",
        "description": "Port number of the RTSM server if Rtsm is not None.",
        "default": "10001",
        "range_or_options": "not_found"
      },
      {
        "name": "CL",
        "type": "str",
        "description": "Host address of a direct CL (Command Layer) connection. Used when bypassing RTSM.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "CLPort",
        "type": "int",
        "description": "Port number of the CL server if CL is not None.",
        "default": "9001",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Connection timeout in seconds. Converted to milliseconds internally where needed.",
        "default": "30",
        "range_or_options": "not_found"
      },
      {
        "name": "StartApp",
        "type": "bool",
        "description": "If True and connecting via RTSM, starts the application using RTSM.StartAPP().",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "Show",
        "type": "bool",
        "description": "Controls display output during configuration save. In some contexts, it prints function execution time when Log is enabled.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Check",
        "type": "bool",
        "description": "Controls whether checks are performed during operations. If True, allows functions to continue even when internal exceptions occur.",
        "default": "True",
        "range_or_options": "not_found"
      }
    ],
    "description": "Initializes the tester environment for network testing by establishing necessary connections and configurations. Sets up logging, connects to either RTSM or a direct CL instance based on provided parameters, initializes system components such as ROM manager and IMix profiles, and configures product-specific settings. The function prepares the system for test execution by resetting internal state and setting up required objects.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${result} | init tester | Product=DARYU | Mode=Performance |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.shutdown_tester",
    "return_type": "bool",
    "return": "Always returns True to indicate that the shutdown attempt has completed, regardless of success or failure.",
    "parameters": [],
    "kwargs": [],
    "description": "This function shuts down the tester associated with the current test instance. It attempts to gracefully terminate the test environment by either using a Remote Test Service Manager (RTSM), if available, or by stopping the capture data listener and exiting the client instance otherwise. The method ensures that resources are released properly and should be called at the end of a test session for cleanup.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Shutdown Tester |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.start_app",
    "return_type": "bool",
    "return": "布尔值，表示启动Renix客户端和连接RTSM的CL是否成功（True/False）",
    "parameters": [],
    "kwargs": [],
    "description": "该函数用于启动Renix客户端界面程序，并通过默认主机地址和端口连接到RTSM的CL（Command Layer）。若连接失败，则抛出带有错误信息的ContinuableFailure异常；若成功，则返回True。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Shutdown Tester |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.load_case",
    "return_type": "bool or int",
    "return": "A boolean-like value indicating whether the operation succeeded. Returns True or EnumBase.TRUE.value (likely 1) on success, and False or an exception is raised on failure.",
    "parameters": [
      {
        "name": "Path",
        "type": "str",
        "description": "The file path of the test configuration file to be loaded into the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Loads the test instrument configuration file from the specified path. This function executes a command to load a test case configuration into the system, initializes internal mappings and streams related to the test case, and ensures the system is ready for subsequent operations.",
    "example": "| ${result} | Load Case | Path=='C:/test.xcfg' |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.save_case",
    "return_type": "bool",
    "return": "Indicates whether the test case was successfully saved (True) or not (False).",
    "parameters": [
      {
        "name": "Path",
        "type": "str",
        "description": "The file system path where the configuration file will be saved, e.g., 'C:/test.xcfg'.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Saves the current test case configuration to a specified file path using the Renix API. This function wraps the underlying SaveTestCaseCommand and provides a simplified interface for saving configurations. If the save operation fails, it raises a ContinuableFailure exception.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${result} | Save Case | Path=='C:/test.xcfg' |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.connect_chassis",
    "return_type": "list",
    "return": "A list of connected chassis objects, which allow further interaction with each connected test device.",
    "description": "Connects to one or more chassis devices (typically hardware test instruments) based on the provided IP address(es). If a single string is given, it will be treated as a list with one element. This function ensures all requested chassis are successfully connected and handles any exceptions during the connection process, including retrying in case of product mismatch errors.",
    "parameters": [
      {
        "name": "Chassis",
        "type": "str or list of str",
        "description": "The hostname(s) or IP address(es) of the chassis(es) to connect to.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Hosts} | Create List | 192.168.0.10 | 192.168.0.11 |\n    | ${Chassis} | Connect Chassis | Chassis=${Hosts} |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.del_objects",
    "return_type": "bool",
    "return": "布尔值，表示删除操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Objects",
        "type": "list of objects",
        "description": "需要删除的一个或多个测试仪表相关对象的列表。每个对象必须具有 `delete()` 方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于删除一个或多个测试仪表相关的对象。它通过调用底层 `renix.del_objects` 函数实现，依次尝试调用每个对象的 `delete()` 方法来完成删除操作。如果删除失败，则会抛出可继续执行的异常；否则返回 True 表示删除成功。",
    "example": "RobotFramework 示例：\n\n| ${Port} | Get Ports |\n| Del Objects | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.get_configs",
    "return_type": "dict or raises ContinuableFailure",
    "return": "A dictionary of configuration objects filtered according to the input parameters. Keys are either 'handle' or 'Name' attributes of the configuration objects, depending on KeyType. If no matching configurations are found, returns False and raises ContinuableFailure.",
    "parameters": [
      {
        "name": "Configs",
        "type": "str, list, set, tuple, or None",
        "description": "Specifies which configuration(s) to retrieve. If None (default), all configurations are returned. If a string is provided, it is treated as a single config name to match. If an iterable (list, set, or tuple) is provided, each element is treated as a config name to match. Matching is case-insensitive.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "KeyType",
        "type": "str",
        "description": "Determines the key used in the returned dictionary. If 'handle', keys will be the 'handle' attribute of the configuration objects. If 'name', keys will be the 'Name' attribute of the configuration objects. Case-insensitive comparison for config names.",
        "default": "'handle'",
        "range_or_options": "handle name"
      },
      {
        "name": "Upper",
        "type": "str or object or None",
        "description": "If provided, filters the results to only include configurations whose hierarchical 'upper' attribute matches this value. Uses check_upper_exist() method to verify hierarchy. If None, no filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves configuration objects managed by the RomManager, optionally filtered by name and hierarchical relationship. This function allows retrieving all configuration objects or filtering them based on a provided list of config names. The resulting dictionary can use either 'handle' or 'Name' as the key. If Upper is specified, only configurations with a matching upper hierarchy are returned. If no matching configurations are found, the function raises a ContinuableFailure exception.",
    "example": "| ${Result} | Get Configs | KeyType=name |\n| ${Result} | Get Configs | Configs=StreamTemplate | KeyType=handle |\n| ${Result} | Get Configs | Configs=BgpProtocolConfig | KeyType=name |\n| ${Result} | Get Configs | Configs=StreamTemplate | KeyType=handle | Upper=${Port_1} |\n| ${Result} | Get Configs | Configs=BgpProtocolConfig | KeyType=name | Upper=${Port_1} |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.edit_overall_setting",
    "return_type": "bool",
    "return": "Returns True if all valid configuration parameters are successfully applied; returns False if some or all configurations fail. Invalid parameters are ignored and do not cause failure.",
    "parameters": [],
    "kwargs": [
      {
        "name": "PortSendMode",
        "type": "str",
        "description": "Specifies the port packet transmission mode.",
        "default": "SYNCHRONOUS",
        "range_or_options": "SYNCHRONOUS ASYNCHRONOUS"
      },
      {
        "name": "MeshCreationMode",
        "type": "str",
        "description": "Specifies the mesh creation mode for topology generation.",
        "default": "PortBased",
        "range_or_options": "PortBased EndpointBased"
      },
      {
        "name": "Rate",
        "type": "int",
        "description": "Specifies Layer 2 learning rate in frames per second.",
        "default": "100",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RepeatCount",
        "type": "int",
        "description": "Specifies how many times Layer 2 learning should be repeated.",
        "default": "3",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DelayTime",
        "type": "int",
        "description": "Specifies delay time (in milliseconds) before Layer 2 learning starts.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RxLearningEncapsulation",
        "type": "str",
        "description": "Specifies encapsulation type used during receive learning.",
        "default": "TX_ENCAPSULATION",
        "range_or_options": "NO_ENCAPSULATION TX_ENCAPSULATION"
      },
      {
        "name": "EnableAutoArp",
        "type": "bool",
        "description": "Enables or disables automatic ARP/ND handling.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "StopOnArpFail",
        "type": "bool",
        "description": "If enabled, stops test execution when ARP/ND fails.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoArpWaitTime",
        "type": "int",
        "description": "Specifies maximum wait time (in seconds) for ARP/ND responses.",
        "default": "30",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TestModeType",
        "type": "str",
        "description": "Specifies the Y.1731 LM test mode.",
        "default": "TYPE_NORMAL",
        "range_or_options": "TYPE_NORMAL TYPE_CC_SCALE_MODE TYPE_CC_SCALE_MODE_WITHOUT_RX"
      },
      {
        "name": "LmrRxFCfStart",
        "type": "int",
        "description": "Initial value of RxFCF field in LMR packets.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrRxFCfStep",
        "type": "int",
        "description": "Increment step for RxFCF field in LMR packets.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmrTxFCbStart",
        "type": "int",
        "description": "Initial value of TxFCb field in LMR packets.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrTxFCbStep",
        "type": "int",
        "description": "Increment step for TxFCb field in LMR packets.",
        "default": "9",
        "range_or_options": "1-65535"
      },
      {
        "name": "LmmTxFCfOffset",
        "type": "int",
        "description": "Offset for TxFCf field in LMM packets.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrRxFCfOffset",
        "type": "int",
        "description": "Offset for RxFCF field in LMR packets.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrTxFCbOffset",
        "type": "int",
        "description": "Offset for TxFCF field in LMR packets.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "DmTimeUnit",
        "type": "str",
        "description": "Specifies the unit for DM time measurement.",
        "default": "TIME_MS",
        "range_or_options": "TIME_MS TIME_NS"
      }
    ],
    "description": "Edits global system settings related to network testing, including stream configuration, Layer 2 learning, ARP/ND handling, and Y.1731 LM options. Accepts arbitrary keyword arguments corresponding to known configuration fields. Only valid parameters are applied; invalid ones are ignored.",
    "example": "edit_overall_setting(PortSendMode='ASYNCHRONOUS', RxLearningEncapsulation='TX_ENCAPSULATION', EnableAutoArp=False, TestModeType='TYPE_CC_SCALE_MODE')"
  },
  {
    "method_name": "TesterLibrary.Overall.common.create_peclsp_for_srte",
    "return_type": "bool",
    "return": "Returns True if PCE LSP configurations are successfully created, otherwise False.",
    "parameters": [
      {
        "name": "Excel",
        "type": "str",
        "description": "完整路径的Excel文件，包含SR-TE性能测试所需的配置数据。该文件至少需要5列：源IP地址、目的IP地址、AdjSID（邻接段标识符）、NodeSID（节点段标识符）。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Session",
        "type": "object",
        "description": "用于创建PceLspConfig对象的会话对象，表示配置的上下文环境。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TunnelCount",
        "type": "int",
        "description": "隧道总数，将被分配到不同的对等体中。",
        "default": "16000",
        "range_or_options": "not_found"
      },
      {
        "name": "PcelspCount",
        "type": "int",
        "description": "要创建的PCE LSP数量，决定生成配置时的循环次数。",
        "default": "4000",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SymbolicNameIdentification",
        "type": "str",
        "description": "用于生成每个LSP唯一符号名称的基础字符串。",
        "default": "'Tunnel'",
        "range_or_options": "not_found"
      }
    ],
    "description": "此函数根据提供的Excel文件中的数据为SR-TE（分段路由流量工程）性能测试创建指定数量的PCE LSP（路径计算单元标签交换路径）配置。每个LSP配置包括源和目的IP地址以及带有特定SID值的显式路由对象子对象。",
    "example": ">>> create_peclsp_for_srte('C:\\config\\srte_config.xlsx', session_obj, TunnelCount=2000, PcelspCount=500)"
  },
  {
    "method_name": "TesterLibrary.Overall.common.create_bgp_ipv4_flowspec_performance",
    "return_type": "bool",
    "return": "Returns True upon successful creation of all BGP IPv4 FlowSpec configurations; otherwise False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "The session object representing the current connection or context in which the BGP FlowSpec configurations will be created. It acts as the parent container for each FlowSpec instance.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxRouteCount",
        "type": "int",
        "description": "The maximum number of routes to be generated. This determines how many FlowSpec entries are created, distributed across the combinations of destination and source prefixes and DSCP values.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SourcePrefix",
        "type": "list of str",
        "description": "A list of IPv4 source prefixes used to construct FlowSpec Type 2 components. The list is split into two halves for alternating usage patterns in routing configurations.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DestPrefix",
        "type": "list of str",
        "description": "A list of IPv4 destination prefixes used to construct FlowSpec Type 1 components. The list is split into two halves to divide the configurations evenly across different sets of rules.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Creates BGP IPv4 Flow Specification performance configurations with specific route and traffic marking settings. This function generates a set of BGP IPv4 Flow Specification entries to test performance under various conditions. It divides source and destination prefixes into two halves and creates FlowSpec configurations using combinations of these prefixes and DSCP values. Each configuration includes match conditions (destination prefix, source prefix, and DSCP) and an action that modifies the DSCP value for traffic marking.",
    "example": "create_bgp_ipv4_flowspec_performance(Session=session_obj, MaxRouteCount=1000, SourcePrefix=['192.168.1.0/24', '192.168.2.0/24'], DestPrefix=['10.0.0.0/16', '10.1.0.0/16'])"
  },
  {
    "method_name": "TesterLibrary.Overall.common.smart_scripter_global_group",
    "return_type": "GroupCommand",
    "return": "The global group object managed by SmartScripter, which may contain shared settings, configurations, or utilities relevant across multiple scripts or sessions.",
    "parameters": [],
    "kwargs": [],
    "description": "Retrieves the global group associated with the SmartScripter in the Renix environment. This function acts as a wrapper that calls `get_smart_scripter_global_group()` to obtain the global group object. It is typically used to access shared or global configuration or context within the SmartScripter framework.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Smart Scripter Global Group |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.smart_scripter_command",
    "return_type": "object",
    "return": "The configured SmartScripter command object after applying all edits from keyword arguments. This object represents the created or modified command in the SmartScripter environment.",
    "parameters": [
      {
        "name": "ParentGroup",
        "type": "str or object",
        "description": "The parent group under which the command will be executed. It typically refers to a grouping context in the SmartScripter environment, such as a GroupCommand object or its identifier.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Command",
        "type": "str",
        "description": "The class name of the command to be executed. This identifies the type of operation (e.g., 'StartProtocolCommand'). Refer to the Renix English manual for valid command types.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Rename",
        "type": "str",
        "description": "A custom name to assign to this instance of the command for identification purposes. If not provided, an empty string is used as the default.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict",
        "description": "Arbitrary keyword arguments used to configure or parameterize the command. These are passed directly to the `edit` method of the created command object. For example, use `ProtocolList=[BgpSession1.handle]` to specify protocols to act on.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Executes a command via the SmartScripter interface by creating and configuring a command object based on the provided parameters. The function wraps the creation and configuration of a SmartScripter command. It creates a command object using the specified parent group, command class name, and optional renamed identifier. Then it applies any additional configuration through keyword arguments. If the command fails, a ContinuableFailure exception is raised.",
    "example": "RobotFramework Example:\n\n| Smart Scripter Command | ParentGroup=${GlobalGroup} | Command=StartProtocolCommand | ProtocolList=${bgp} |"
  },
  {
    "method_name": "TesterLibrary.Overall.common.smart_scripter_control_condition",
    "return_type": "object",
    "return": "The newly created and configured condition object that has been associated with the ControlCommand.",
    "parameters": [
      {
        "name": "ControlCommand",
        "type": "object",
        "description": "A command object to which the condition will be applied. Must support the `set_relatives` and `edit` methods for associating the condition and setting its properties.",
        "default": "not_found",
        "range_or_options": "IfCommand ElseIfCommand ElseCommand LoopCommand ContinueCommand BreakCommand GotoCommand WhileCommand"
      },
      {
        "name": "ControlConditionName",
        "type": "str",
        "description": "The name of the condition type to create, e.g., 'StartStreamCommand'. Valid values depend on the system's capabilities and should be referenced from the Renix English manual.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ConditionResult",
        "type": "str",
        "description": "The expected outcome of the condition evaluation. Used primarily when the ControlConditionName is one of ['IfCommand', 'ElseIfCommand', 'WhileCommand'].",
        "default": "PASS",
        "range_or_options": "PASS FALSE"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict",
        "description": "Additional keyword arguments used to configure the created condition. These are passed directly into the `edit` method of the condition object and may vary depending on the condition type.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Applies and configures a control condition on a given command in the SmartScripter framework. This function creates a condition object based on the specified condition type, applies any additional configuration parameters to it, associates it with the provided command, and sets the expected result of the condition if applicable. It is typically used to implement conditional logic such as If, Else If, or While commands in a test or automation script.",
    "example": "robotframework:\n\n| ${IfCommand} | Smart Scripter Command | ParentGroup=${GlobalGroup} | Command=IfCommand |\n| Smart Scripter Control Condition | ControlCommand=${IfCommand} | ControlConditionName=StartStreamCommand | ConditionResult=FALSE | ProtocolList=${bgps} |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.start_capture",
    "return_type": "bool",
    "return": "A boolean indicating whether the packet capture was successfully started (True) or not (False).",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port]], optional",
        "description": "A single Port object or a list of Port objects on which to start packet capture. Each Port object is expected to have a method `get_children('CaptureConfig')` that returns associated capture configurations.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts packet capture on specified test instrument ports using the Renix API. This function triggers a packet capture operation by either directly specifying port(s), or by providing object(s) that contain capture configuration details. If neither 'Ports' nor 'Objects' are provided, it will start capturing on all available ports via StartAllCaptureCommand. Providing both 'Ports' and 'Objects' simultaneously will raise an exception.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Locations} | Create List | //192.168.0.1/1/1 | //192.168.0.1/1/2 |\n    | ${Ports} | Reserve Ports | ${Ports} | ${Locations} |\n    | Start Capture | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.stop_capture",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True 表示成功，False 表示失败）",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port]], optional",
        "description": "一个或多个测试仪表端口对象，用于停止其上的数据包抓包。如果未提供，则会停止所有正在进行的抓包。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于停止指定测试仪表端口上的数据包抓包操作。如果没有提供具体的端口，则会停止所有抓包任务。内部调用 Renix API 的 stop_capture 函数，并在失败时抛出可继续执行的异常（ContinuableFailure）。",
    "example": "robotframework 示例：\n\n| ${Locations} | Create List | //192.168.0.1/1/1 | //192.168.0.1/1/2 |\n| ${Ports} | Reserve Ports | ${Locations} |\n| Start Capture | Ports=${Ports} |\n| Sleep | 30 |\n| Stop Capture | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.edit_capture",
    "return_type": "bool",
    "return": "Returns True if the capture configurations were successfully edited for all specified ports; otherwise returns False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list, set, tuple]",
        "description": "A single port object or a collection (list, set, or tuple) of multiple port objects. Each port must have an associated 'CaptureConfig' child object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Port capture name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "CaptureMode",
        "type": "str",
        "description": "Specifies the capture mode to be used.",
        "default": "ALL",
        "range_or_options": "ALL CTRL_PLANE RealTime_All"
      },
      {
        "name": "CacheCapacity",
        "type": "str",
        "description": "Specifies the maximum buffer size allocated for packet capture.",
        "default": "Cache_Max",
        "range_or_options": "Cache_Max Cache_32KB Cache_64KB Cache_128KB Cache_256KB Cache_512KB Cache_1MB Cache_2MB Cache_4MB Cache_8MB Cache_16MB Cache_32MB Cache_64MB Cache_128MB Cache_256MB Cache_512MB Cache_1GB"
      },
      {
        "name": "FilterMode",
        "type": "str",
        "description": "Specifies whether the capture filter operates at byte level or PDU level.",
        "default": "BYTE",
        "range_or_options": "BYTE PDU"
      },
      {
        "name": "BufferFullAction",
        "type": "str",
        "description": "Action to perform when the capture buffer is full.",
        "default": "STOP",
        "range_or_options": "STOP WRAP"
      },
      {
        "name": "StartingFrameIndex",
        "type": "int",
        "description": "Starting index of the frame to download from the captured data.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "AttemptDownloadPacketCount",
        "type": "int",
        "description": "Number of packets to download. A value of 0 means download all packets.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "FcsError",
        "type": "bool",
        "description": "Whether to include packets with FCS errors in the capture.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv4ChecksumError",
        "type": "bool",
        "description": "Whether to include packets with IPv4 checksum errors in the capture.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PayloadError",
        "type": "bool",
        "description": "Whether to include packets with payload errors in the capture.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableRealtimeCapture",
        "type": "bool",
        "description": "Enables real-time capture mode for control plane and/or data plane traffic.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SliceMode",
        "type": "str",
        "description": "Enables or disables slicing of captured packets.",
        "default": "DISABLE",
        "range_or_options": "DISABLE ENABLE"
      },
      {
        "name": "SliceByteSize",
        "type": "int",
        "description": "Specifies the number of bytes per packet to capture when slice mode is enabled.",
        "default": "128",
        "range_or_options": "32-16383"
      }
    ],
    "description": "Edits the capture configuration for one or more specified ports. This function retrieves the CaptureConfig child object associated with each provided port and applies the given configuration changes using the edit method. The function supports passing a single port or a collection of ports. It raises an exception if any abnormal condition occurs during execution, such as missing CaptureConfig or API-level failures.",
    "example": "| Edit Capture | Ports=${Ports} | CaptureMode=CTRL_PLANE |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.create_capture_byte_pattern",
    "return_type": "str",
    "return": "Byte Pattern唯一索引字符串，例如：CaptureBytePattern_1",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，用于在指定端口上配置捕获字节模式。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CustomCapturePatternOperator",
        "type": "str",
        "description": "表达式位运算符，用于定义如何匹配数据。",
        "default": "AND",
        "range_or_options": "AND OR XOR"
      },
      {
        "name": "CustomCapturePatternNot",
        "type": "bool",
        "description": "表达式取反标志，如果为True，则对匹配结果取反。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UseFrameLength",
        "type": "bool",
        "description": "是否使用帧长度进行过滤。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "要匹配的最小十六进制数据值（以字符串形式提供）。",
        "default": "0x0",
        "range_or_options": "十六进制字符串"
      },
      {
        "name": "MaxData",
        "type": "hex",
        "description": "要匹配的最大十六进制数据值（以字符串形式提供）。",
        "default": "0xff",
        "range_or_options": "十六进制字符串"
      },
      {
        "name": "Mask",
        "type": "hex",
        "description": "掩码，用于定义哪些位需要参与匹配。",
        "default": "0xff",
        "range_or_options": "十六进制字符串"
      },
      {
        "name": "Offset",
        "type": "int",
        "description": "偏移位，表示从包起始位置开始的字节数。",
        "default": "0",
        "range_or_options": "0-16378"
      },
      {
        "name": "MinFrameLength",
        "type": "int",
        "description": "当UseFrameLength为True时生效，表示帧的最小长度。",
        "default": "64",
        "range_or_options": "64-16383"
      },
      {
        "name": "MaxFrameLength",
        "type": "int",
        "description": "当UseFrameLength为True时生效，表示帧的最大长度。",
        "default": "16383",
        "range_or_options": "64-16383"
      }
    ],
    "description": "该函数用于在指定端口上创建一个字节级数据包捕获规则。此功能可帮助根据特定字节级标准（如偏移、掩码、数据范围等）筛选捕获的数据包。它会自动检查或创建必要的捕获基础结构（如CapturePduFilter），并返回可用于后续操作的唯一标识符。",
    "example": "robotframework示例:\n| Create Capture Byte Pattern | Port=${Port} | Data=0x0 0x01 | Mask=0xff 0xff | Offset=0 | CustomCapturePatternOperator=OR | CustomCapturePatternNot=True |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.create_capture_pdu_pattern",
    "return_type": "str",
    "return": "The handle of the created CapturePduPattern instance, e.g., 'CapturePduPattern_1'. This can be used to reference or manipulate the pattern in subsequent operations.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "A port object representing the physical or logical port on which the capture configuration is applied. If a list, set, or tuple is provided, only the first item will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderTypes",
        "type": "list or str",
        "description": "Specifies the protocol headers involved in the PDU pattern match. Each entry must correspond to a valid header type. Case-insensitive; input is transformed internally via `lower()`.",
        "default": "not_found",
        "range_or_options": "ethernetii vlan vxlan arp ipv4 ipv6 tcp udp l2tpv2data l2tpv3controloverip ppp pppoe icmpv4echorequest destunreach icmpv4echoreply informationreply informationrequest icmpv4parameterproblem icmpv4redirect sourcequench timeexceeded timestampreply timestamprequest icmpmaskrequest icmpmaskreply destinationunreachable icmpv6echoreply icmpv6echorequest packettoobig icmpv6parameterproblem timeexceed routersolicit routeradvertise icmpv6redirect neighborsolicit neighboradvertise mldv1query mldv1report mldv1done mldv2query mldv2report igmpv1 igmpv1query igmpv2 igmpv2query igmpv3report igmpv3query custom ospfv2linkstateupdate ospfv2linkstaterequest ospfv2databasedescription ospfv2linkstateacknowledge ospfv2unknown ospfv2hello mpls"
      }
    ],
    "kwargs": [
      {
        "name": "Level",
        "type": "int or str",
        "description": "When dealing with hierarchical headers (e.g., nested protocols), this indicates the level index (dot-separated hierarchy) to extract the field name dynamically. Must be used together with Attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Attribute",
        "type": "str",
        "description": "Used with Level to specify an attribute within the specified header level. Must be used together with Level.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FieldName",
        "type": "str",
        "description": "An alternative way to directly specify the field name. Used if Level and Attribute are not present. The first letter of each segment is automatically converted to lowercase.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomCapturePatternOperator",
        "type": "str",
        "description": "Expression bitwise operator for combining multiple matching rules.",
        "default": "AND",
        "range_or_options": "AND OR XOR"
      },
      {
        "name": "CustomCapturePatternNot",
        "type": "bool",
        "description": "Whether to invert the expression match result.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Value",
        "type": "str",
        "description": "Exact value or minimum value of the field to match.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxValue",
        "type": "str",
        "description": "Maximum acceptable value for range-based matching. If not provided, Value is treated as exact.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mask",
        "type": "str",
        "description": "Bitmask to apply to the field when matching.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TemplateString",
        "type": "str",
        "description": "Optional template string defining the structure of the PDU.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Offset",
        "type": "int",
        "description": "Byte offset from the start of the header where the field is located.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and configures a Capture PDU (Protocol Data Unit) pattern for packet capture filtering. This function sets up a CapturePduPattern object under the given port's CaptureConfig. It allows specifying header types, field names or levels, and various parameters such as Value, Mask, Offset, etc., to define how packets should be matched during capture.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Port} | reserve_port | Locations=//192.168.0.180/1/1 |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 |\n    | ${Stream} | Add Stream | Ports=${Port} |\n    | Create Stream Header |Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header Ipv4 |Stream=${Stream} | Level=0 | TTL=200 | Source=10.1.1.2 |\n    # 使用Level和Attribute参数设置Pdu Pattern\n    | ${Pattern_1} | Create Capture Pdu Pattern | Port=${Port} | HeaderTypes=${HeaderTypes} |  Level=1  | Attribute=${Attribute}[TTL] | Value=200 | MaxValue=200 |\n    # 等价于：使用FieldName参数设置Pdu Pattern\n    | ${Pattern_2} | Create Capture Pdu Pattern | Port=${Port} | HeaderTypes=${HeaderTypes} | FieldName=ipv4_1.ttl | Value=200 | MaxValue=200 |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.edit_capture_pattern",
    "return_type": "bool",
    "return": "True if the capture pattern was successfully edited, False otherwise.",
    "parameters": [
      {
        "name": "Pattern",
        "type": "str",
        "description": "Identifier for the Capture Pattern (e.g., 'CaptureBytePattern_1' or 'CapturePduPattern_1').",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CustomCapturePatternOperator",
        "type": "str",
        "description": "Bitwise operator used in the expression (for both Byte and PDU patterns).",
        "default": "AND",
        "range_or_options": "AND OR XOR"
      },
      {
        "name": "CustomCapturePatternNot",
        "type": "bool",
        "description": "Whether to negate the expression.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UseFrameLength",
        "type": "bool",
        "description": "Whether to use frame length as part of the capture condition.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Data",
        "type": "str",
        "description": "Minimum value for byte pattern matching (hex string like '0x0').",
        "default": "0x0",
        "range_or_options": "Hexadecimal string"
      },
      {
        "name": "MaxData",
        "type": "str",
        "description": "Maximum value for byte pattern matching (hex string like '0xff').",
        "default": "0xff",
        "range_or_options": "Hexadecimal string"
      },
      {
        "name": "Mask",
        "type": "str",
        "description": "Mask applied during byte pattern comparison.",
        "default": "0xff",
        "range_or_options": "Hexadecimal string"
      },
      {
        "name": "Offset",
        "type": "int",
        "description": "Offset position in the packet where the byte pattern should be matched.",
        "default": "0",
        "range_or_options": "0-16378"
      },
      {
        "name": "MinFrameLength",
        "type": "int",
        "description": "Minimum allowed frame length (used only if UseFrameLength is True).",
        "default": "64",
        "range_or_options": "64-16383"
      },
      {
        "name": "MaxFrameLength",
        "type": "int",
        "description": "Maximum allowed frame length (used only if UseFrameLength is True).",
        "default": "16383",
        "range_or_options": "64-16383"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the header type when multiple headers of the same type are present (must be used with Attribute).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Attribute",
        "type": "str",
        "description": "Header field attribute name (must be used with Level).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FieldName",
        "type": "str",
        "description": "Name of the field to filter on; cannot be used with Level and Attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Value",
        "type": "str",
        "description": "Minimum value for a PDU field match.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxValue",
        "type": "str",
        "description": "Maximum value for a PDU field match.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TemplateString",
        "type": "str",
        "description": "A new template string for the capture pattern.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderTypes",
        "type": "list",
        "description": "List of header types associated with the pattern (e.g., EthernetII, IPv4).",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits an existing capture pattern (either Byte Pattern or PDU Pattern) by updating its properties. Supports modifying bit expressions, applying masks, setting frame length limits, or specifying field-based conditions using headers and attributes.",
    "example": "robotframework:\n\n| ${BytePattern} | Create Capture Byte Pattern | Port=${Port} | CustomCapturePatternOperator=OR | CustomCapturePatternNot=True |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | Icmpv4EchoReply |\n| ${PduPattern} | Create Capture Pdu Pattern | Port=${Port} | HeaderTypes=${HeaderTypes} | FieldName=Icmpv4EchoReply_1.code | Value=4 | MaxValue=5 | CustomCapturePatternOperator=OR | CustomCapturePatternNot=True |\n| Edit Capture Pattern | Pattern=${BytePattern} | CustomCapturePatternOperator=XOR|\n| Edit Capture Pattern | Pattern=${PduPattern} | CustomCapturePatternOperator=XOR|"
  },
  {
    "method_name": "TesterLibrary.Port.capture.edit_capture_filter",
    "return_type": "bool",
    "return": "Returns True if the capture filter was successfully edited, otherwise False.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or iterable",
        "description": "A test instrument port object (or an iterable containing a port object). If an iterable is provided, only the first element will be used. The port must have a 'CaptureConfig' child for the filter to be applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Expression",
        "type": "str",
        "description": "A string representing the logic expression to apply as the new capture filter. This can combine byte patterns and PDU patterns using logical operators like && and ||.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Edits the capture filter for a given port using the specified logic expression. If the port already has a CapturePduFilter child, it will be reused and updated with the new logic expression. Otherwise, a new CapturePduFilter object is created under the CaptureConfig of the port and then edited to reflect the provided logic expression.",
    "example": "| ${BytePattern} | Create Capture Byte Pattern | Port=${Port} | CustomCapturePatternOperator=OR | CustomCapturePatternNot=True |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | Icmpv4EchoReply |\n| ${PduPattern} | Create Capture Pdu Pattern | Port=${Port} | HeaderTypes=${HeaderTypes} | FieldName=Icmpv4EchoReply_1.code | Value=4 | MaxValue=5 | CustomCapturePatternOperator=OR | CustomCapturePatternNot=True |\n| Edit Capture Filter | Port=${Port} | Expression=${BytePattern} && ${PduPattern} |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.edit_capture_event",
    "return_type": "bool",
    "return": "Returns True if the capture event was successfully edited, otherwise False.",
    "parameters": [
      {
        "name": "Port",
        "type": "Port",
        "description": "The test instrument port object on which to edit the capture event.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EventType",
        "type": "str",
        "description": "Specifies the type of capture event to configure. Must be one of: 'QUALIFY', 'START', or 'STOP'.",
        "default": "'QUALIFY'",
        "range_or_options": "'QUALIFY' 'START' 'STOP'"
      }
    ],
    "kwargs": [
      {
        "name": "LogicRelation",
        "type": "str",
        "description": "Defines how multiple filter conditions should be combined (And/Or).",
        "default": "not_found",
        "range_or_options": "'AND' 'OR'"
      },
      {
        "name": "PatternMatch",
        "type": "str",
        "description": "Whether frames matching defined patterns are included or excluded from capture.",
        "default": "not_found",
        "range_or_options": "'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "FcsError",
        "type": "str",
        "description": "Controls whether to include frames with Frame Check Sequence (FCS) errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "PrbsError",
        "type": "str",
        "description": "Controls whether to include frames with PRBS (Pseudo-Random Binary Sequence) errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "Ipv4ChecksumError",
        "type": "str",
        "description": "Controls whether to include IPv4 packets with checksum errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "TcpChecksumError",
        "type": "str",
        "description": "Controls whether to include TCP segments with checksum errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "UdpChecksumError",
        "type": "str",
        "description": "Controls whether to include UDP datagrams with checksum errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "IgmpChecksumError",
        "type": "str",
        "description": "Controls whether to include IGMP messages with checksum errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "IcmpChecksumError",
        "type": "str",
        "description": "Controls whether to include ICMP packets with checksum errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "SequenceError",
        "type": "str",
        "description": "Controls whether to include frames with sequence number errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "UndersizedFrame",
        "type": "str",
        "description": "Controls whether to include frames smaller than the minimum Ethernet frame size.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "OversizedFrame",
        "type": "str",
        "description": "Controls whether to include frames larger than the maximum Ethernet frame size.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "JumboFrame",
        "type": "str",
        "description": "Controls whether to include jumbo frames (frames larger than standard MTU).",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "FrameLength",
        "type": "str",
        "description": "Controls whether to apply filtering based on frame length.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "FrameLengthValue",
        "type": "int",
        "description": "Specifies the exact frame length (in bytes) to match if FrameLength is set to 'MATCH'.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SignaturePresent",
        "type": "str",
        "description": "Controls whether to include frames containing a signature.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "StreamIdMatch",
        "type": "str",
        "description": "Controls whether to filter based on Stream ID.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "StreamId",
        "type": "int",
        "description": "Specifies the Stream ID to match if StreamIdMatch is enabled.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4Packets",
        "type": "str",
        "description": "Controls whether to include IPv4 packets in the capture.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "TcpPackets",
        "type": "str",
        "description": "Controls whether to include TCP packets in the capture.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "UdpPackets",
        "type": "str",
        "description": "Controls whether to include UDP packets in the capture.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "Ipv6Packets",
        "type": "str",
        "description": "Controls whether to include IPv6 packets in the capture.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "IgmpPackets",
        "type": "str",
        "description": "Controls whether to include IGMP packets in the capture.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      },
      {
        "name": "PayloadError",
        "type": "str",
        "description": "Controls whether to include frames with payload errors.",
        "default": "not_found",
        "range_or_options": "'IGNORE' 'INCLUDE' 'EXCLUDE'"
      }
    ],
    "description": "This function edits the configuration of a capture event on a specified port. It allows users to define various filters and conditions to qualify, start, or stop frame capturing based on frame properties such as error types, packet types, length, and more.",
    "example": "| Edit Capture Event | Port=${Port} | EventType=QUALIFY | LogicRelation=Or | PrbsError=INCLUDE | FrameLength=INCLUDE | FrameLengthValue=128 |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.download_packages",
    "return_type": "str",
    "return": "The normalized absolute path to the downloaded capture data file (e.g., \"D:\\test\\10.0.5.10_1_1\\download.pcap\")",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "A Port object that contains capture configuration and handle information. Must have a method `get_children` to retrieve associated CaptureConfig, and a `handle` attribute representing the port identifier.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FileDir",
        "type": "str",
        "description": "The directory path where the downloaded file will be saved. If the directory does not exist, it will be created automatically. Example: \"D:/test\"",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FileName",
        "type": "str",
        "description": "The name of the file where the downloaded capture data will be stored (without extension). The file is typically saved in .pcap format.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MaxCount",
        "type": "int",
        "description": "Maximum number of packets to download. A value of 0 indicates no limit, meaning all captured packets will be downloaded.",
        "default": "0",
        "range_or_options": "0 or positive integer"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for the download operation to complete. If the download doesn't finish within this time, an exception is raised.",
        "default": "30",
        "range_or_options": "positive integer"
      },
      {
        "name": "AppendPortHandle",
        "type": "bool",
        "description": "Whether to append the port's handle to the FileDir to ensure separate directories for different ports. Defaults to True.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Downloads captured data packages from a specified test instrument port and saves them into a file at the given location. This function ensures that the target directory exists by creating it if necessary. It waits for the download operation to complete within the specified timeout period and raises an exception on timeout. Returns the absolute path of the downloaded file upon success.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n     | ${Port} | Get Ports |\n     | &{File} | Download Packages | Port=${Port} | FileDir=D:/test | FileName=download |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.get_capture_info",
    "return_type": "dict",
    "return": "A dictionary mapping each requested capture item (e.g., 'CaptureState', 'ElapsedTime') to its current value. If an item's value is an enum, it is returned as a readable string.",
    "parameters": [
      {
        "name": "Port",
        "type": ":class:`Port` or list or set or tuple",
        "description": "The test instrument port object from which capture information will be retrieved. If a collection (list/set/tuple) is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Items",
        "type": "str or list or set or tuple or None",
        "description": "Specifies which capture properties to retrieve. If not provided, all commonly used capture properties are fetched by default.",
        "default": "None",
        "range_or_options": "'CaptureState' 'ElapsedTime' 'CapturedPacketCount' 'BufferFull' 'DownloadedPacketCount' 'CurrentDataFile'"
      }
    ],
    "description": "Retrieve specified packet capture-related information from a given test instrument port. This function supports retrieving specific properties such as capture state, elapsed time, packet count, buffer status, and more. If no specific items are requested, all relevant capture properties are fetched automatically.",
    "example": "| Get Capture Info | Port=${Port} | Items=['CaptureState', 'CapturedPacketCount'] |"
  },
  {
    "method_name": "TesterLibrary.Port.capture.get_capture_data",
    "return_type": "dict",
    "return": "A dictionary containing the captured packet data with keys: 'Timestamp', 'Length', and 'Data'. If the operation fails, an exception is raised.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/tuple/set of objects",
        "description": "The test instrument port object (or collection of port objects) from which to retrieve the capture data. If a list, set, or tuple is provided, only the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the captured packet in the capture buffer. Indexing typically starts at 1 in Renix API.",
        "default": "1",
        "range_or_options": ">=1"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the captured packet data (timestamp, length, and raw data) at the specified index from the given port's capture buffer. This function is typically used after a packet capture has been performed on the specified port. If the input Port is a list, tuple, or set, only the first port object will be considered for retrieving capture data. The returned data includes timestamp (in seconds since epoch), packet length (in bytes), and raw packet data (in hexadecimal or string format). An exception may be raised if no capture data is available or if the index is out of bounds.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Get Capture Data | Port=${Port} | Index=2 |"
  },
  {
    "method_name": "TesterLibrary.Port.common.relocate_ports",
    "return_type": "bool",
    "return": "Indicates whether the relocation of ports was successful. Returns True if all operations completed without error; otherwise, False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list or RenixPort",
        "description": "A single port or a list of port objects to be relocated. Each port must have attributes 'Location' and 'Online', and a property 'handle'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Locations",
        "type": "list or str",
        "description": "A single location or a list of new physical locations for the ports. The location should follow the format '//<chassis-ip>/shelf=<shelf_id>/slot=<slot_id>'. If not prefixed with '//', it will be automatically added.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Force",
        "type": "bool",
        "description": "If set to True, forces release of the port if it is already in use before relocating it.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Debug",
        "type": "bool",
        "description": "If set to True, skips the actual relocation steps such as connecting to chassis, releasing ports, and bringing them online. Useful for testing or dry runs.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Relocates the specified logical ports to new physical locations on test instrument chassis hardware. This function updates the location of one or more ports and optionally brings them online at their new locations. If not in debug mode, it connects to the target chassis, relocates the ports, and ensures they are online. If a port fails to come online (and Debug mode is off), an exception is raised.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Locations} = | Create List | //192.168.0.1/1/1 | //192.168.0.1/1/2 |\n    | ${result} | Relocate Ports | ${Ports} | ${Locations} |"
  },
  {
    "method_name": "TesterLibrary.Port.common.reserve_port",
    "return_type": "list",
    "return": "A list of Port objects representing the successfully reserved ports. If no ports were successfully reserved, returns an empty list.",
    "parameters": [
      {
        "name": "Locations",
        "type": "str or list-like",
        "description": "One or more port locations in the format of '//chassisIP/moduleID/portID'. Example: '//192.168.1.1/1/1' or ['//192.168.1.1/1/1', '//192.168.1.2/2/1']",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Force",
        "type": "bool",
        "description": "If True, any existing reservations on the specified ports will be forcefully released before attempting a new reservation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Debug",
        "type": "bool",
        "description": "If True, the method will not perform actual port reservations and will instead create mock Port objects. Useful for testing or debugging without affecting real hardware.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "WaitForStatusUp",
        "type": "bool",
        "description": "If True, the method will wait until all reserved ports report an operational status of 'up'. If False, the method proceeds once the reservation command is executed, regardless of port status.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Reserves specified physical ports on chassis for test operations. This method connects to the chassis hosting the specified ports and reserves them for use. If a port is already reserved by another user or session, it can be forcefully released if the 'Force' parameter is set to True. The method also checks for necessary licenses on each chassis before attempting reservation. During reservation, it waits for the port status to become 'up' unless WaitForStatusUp is explicitly set to False.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Locations} == [//192.168.0.1/1/1, //192.168.0.1/1/2] |\n    | ${result} | Reserve Port | ${Locations} |"
  },
  {
    "method_name": "TesterLibrary.Port.common.release_port",
    "return_type": "bool",
    "return": "布尔值，表示端口是否成功释放（True 表示成功，False 表示失败）。",
    "parameters": [
      {
        "name": "Locations",
        "type": "list of str, optional",
        "description": "测试仪表物理端口的位置路径列表。格式为 `//$(机箱IP地址)/$(板卡序号)/$(端口序号)`，例如：`[//192.168.0.1/1/1]`。若提供部分路径，会自动添加 `'//'` 前缀。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Ports",
        "type": "list or single Port object, optional",
        "description": "要释放的端口对象或对象列表。函数内部使用其句柄进行操作。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Force",
        "type": "bool, optional",
        "description": "是否强制释放端口。如果为 True，则即使端口正在使用中也会释放；如果为 False，当端口被占用时释放会失败。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Debug",
        "type": "bool, optional",
        "description": "调试模式开关。如果为 True，则不会实际执行任何操作，仅用于模拟调用，配合 reserve_port 的 Debug 模式使用。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "该函数用于释放 Renix 测试仪表系统中的指定物理端口或端口对象，使其可以被其他任务重新使用。支持通过位置路径或端口对象两种方式释放端口，并可选择是否强制释放或启用调试模式。函数在调用底层接口后引入 5 秒延迟以确保操作完成。",
    "example": "robotframework 示例:\n\n| ${Locations} = | Create List | //192.168.0.1/1/1 | //192.168.0.1/1/2 |\n| ${result} | Release Port | ${Locations} | Force=True"
  },
  {
    "method_name": "TesterLibrary.Port.common.get_ports",
    "return_type": "list",
    "return": "A list of Port objects representing the ports configured on the current tester. Each Port object contains properties and methods for interacting with the corresponding hardware or virtual port.",
    "parameters": [],
    "kwargs": [],
    "description": "Retrieve all the port objects configured for the current tester in the system. This function accesses the system entry and fetches all child objects of type 'Port'. It is typically used to obtain a list of available ports that can be used for further operations such as configuration or testing.",
    "example": "| ${result} | Get Ports |"
  },
  {
    "method_name": "TesterLibrary.Port.common.del_port",
    "return_type": "bool",
    "return": "Returns True upon successful deletion of the specified ports and associated resources. Returns False if the operation fails (in which case an exception is raised).",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, list, set, tuple], optional",
        "description": "A single Port object or a collection of Port objects to be deleted. If not provided, all known Port objects managed by the rom_manager will be deleted.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Deletes specified test instrument ports along with their associated stream templates and related internal mappings. If no port(s) are specified, it deletes all available ports. The function ensures that all associated resources are properly cleaned up, including releasing ports using ReleasePortCommand, removing StreamTemplate children, and cleaning up internal maps like map_stream_header and map_stream_imix. Uses @abnormal_check decorator for handling exceptions during abnormal conditions.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Del Port | Ports=${Port_1} |\n    | Del Port |"
  },
  {
    "method_name": "TesterLibrary.Port.common.get_port_speed",
    "return_type": "list",
    "return": "A list of line speeds corresponding to the input ports. Each value is retrieved from a predefined mapping that translates internal speed values into human-readable or standardized speed representations.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list of objects",
        "description": "A single port object or a list of port objects for which the line speed needs to be retrieved. Each port should have a method `get_relatives` that returns related objects based on relation type and direction (specifically looking for 'SelectMedia' relationship).",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the line speed of the specified port(s) by querying their associated media configuration. If a single port is provided, it is internally converted into a list to ensure uniform processing. The function iterates through each port, finds its associated media configuration using the 'SelectMedia' relationship in the target direction, and retrieves the line speed from a predefined mapping (e.g., LINESPEED dictionary). This function is particularly useful in test scenarios where actual link speeds need to be verified or logged.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Get Port Speed | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Port.common.edit_port",
    "return_type": "bool",
    "return": "True if the operation completes successfully, indicating all configuration commands were executed without exceptions. Does not guarantee success of individual configuration steps.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list(:obj:`Port`)",
        "description": "List of Port objects representing the ports to be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableLink",
        "type": "bool",
        "description": "Enables or disables the physical link state of the port.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoNegotiation",
        "type": "bool",
        "description": "Controls whether auto-negotiation is enabled on the port.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "Sets the Maximum Transmission Unit (MTU) value for the port.",
        "default": "not_found",
        "range_or_options": "128-9600"
      },
      {
        "name": "FecType",
        "type": "str",
        "description": "Specifies Forward Error Correction (FEC) type for the port.",
        "default": "TYPE_OFF",
        "range_or_options": "TYPE_OFF TYPE_RS_FEC_CLAUSE91 TYPE_FEC_CLAUSE74 TYPE_RS_FEC_CLAUSE108 TYPE_RS_FEC_CONSORTIUM TYPE_RS_FEC_CLAUSE119"
      },
      {
        "name": "LineSpeed",
        "type": "str",
        "description": "Sets the line speed of the port.",
        "default": "SPEED_1G",
        "range_or_options": "SPEED_UNKNOWN SPEED_10M SPEED_100M SPEED_1G SPEED_2_5G SPEED_5G SPEED_10G SPEED_25G SPEED_40G SPEED_50G SPEED_100G SPEED_200G SPEED_400G"
      },
      {
        "name": "Duplex",
        "type": "str",
        "description": "Configures the duplex mode of the port.",
        "default": "FULL",
        "range_or_options": "HALF FULL"
      },
      {
        "name": "FlowControl",
        "type": "str",
        "description": "Controls flow control behavior on the port.",
        "default": "DISABLE",
        "range_or_options": "DISABLE ENABLE AUTO"
      },
      {
        "name": "Media",
        "type": "str",
        "description": "Specifies the media type used by the port.",
        "default": "not_found",
        "range_or_options": "COPPER FIBER FAKE"
      },
      {
        "name": "PhyMode",
        "type": "str",
        "description": "Sets the PHY mode of the port.",
        "default": "None",
        "range_or_options": "MODE_AUTO MODE_1000BASEX MODE_SGMII"
      },
      {
        "name": "PpmAdjust",
        "type": "int",
        "description": "Adjusts the frequency in parts per million (PPM).",
        "default": "None",
        "range_or_options": "-300-300"
      },
      {
        "name": "DataPathMode",
        "type": "str",
        "description": "Configures the data path mode of the port.",
        "default": "None",
        "range_or_options": "NORMAL LOOPBACK"
      },
      {
        "name": "RemoteFault",
        "type": "str",
        "description": "Configures how the port handles remote fault detection.",
        "default": "None",
        "range_or_options": "NORMAL IGNORE"
      },
      {
        "name": "Master",
        "type": "str",
        "description": "Sets the clock master/slave configuration for the port.",
        "default": "None",
        "range_or_options": "ADVERTISE_SINGLE_PORT ADVERTISE_MULTI_PORT MANUAL_MASTER MANUAL_SLAVE"
      },
      {
        "name": "NoParam",
        "type": "bool",
        "description": "Indicates whether to skip applying any configuration changes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ArpTimeout",
        "type": "int",
        "description": "Sets the timeout for ARP/ND requests (in seconds).",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "ArpRate",
        "type": "int",
        "description": "Sets the rate at which ARP/ND packets are sent (packets per second).",
        "default": "250",
        "range_or_options": "1-1000000"
      },
      {
        "name": "ArpRetryCount",
        "type": "int",
        "description": "Sets the number of retries for ARP/ND requests.",
        "default": "3",
        "range_or_options": "0-100"
      },
      {
        "name": "ArpSuppressDuplicateGateway",
        "type": "bool",
        "description": "Determines whether duplicate gateway detection is suppressed.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ArpDelayTime",
        "type": "int",
        "description": "Sets a delay before sending ARP/ND requests (in seconds).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ArpUseLinkLocalForNd",
        "type": "bool",
        "description": "Determines whether to use link-local addresses for Neighbor Discovery.",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "Modifies the configuration of one or more ports in the Renix system. This function allows editing various port properties including ARP-related settings, link enable/disable status, and other generic port attributes. It supports both direct property assignments and advanced configurations through command execution.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Port | Ports=${Ports} | AutoNegotiation=True | FecType=TYPE_OFF |"
  },
  {
    "method_name": "TesterLibrary.Port.common.edit_port_load_profile",
    "return_type": "bool",
    "return": "A boolean value indicating whether the operation was successful (True) or not (False). If the operation fails, a `ContinuableFailure` exception is raised.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list(IsisIpv4Router)",
        "description": "List of test instrument port objects to apply the load profile configuration on.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TransmitMode",
        "type": "str",
        "description": "Sets the transmission mode for the port(s).",
        "default": "CONTINUOUS",
        "range_or_options": "CONTINUOUS BURST TIME STEP ONSTREAM"
      },
      {
        "name": "BurstSize",
        "type": "int",
        "description": "Number of packets transmitted in a burst. Only applicable when TransmitMode is BURST.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "InterFrameGap",
        "type": "int",
        "description": "Time interval between frames within a burst. Only applicable when BurstSize > 1.",
        "default": "12.0",
        "range_or_options": "not_found"
      },
      {
        "name": "InterFrameGapUnit",
        "type": "str",
        "description": "Unit for InterFrameGap. Only applicable when BurstSize > 1.",
        "default": "BYTES",
        "range_or_options": "NS MS US SEC BYTES"
      },
      {
        "name": "BurstCount",
        "type": "int",
        "description": "Number of bursts to transmit. Only applicable when TransmitMode is BURST.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Seconds",
        "type": "int",
        "description": "Transmission duration in seconds. Only applicable when TransmitMode is TIME.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "Frames",
        "type": "int",
        "description": "Number of frames to transmit. Only applicable when TransmitMode is STEP.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "LoadProfileType",
        "type": "str",
        "description": "Specifies the type of load profile to be used.",
        "default": "PORT_BASE",
        "range_or_options": "PORT_BASE STREAM_BASE PRIORITY_BASE MANUAL_BASE"
      },
      {
        "name": "Rate",
        "type": "int",
        "description": "Transmission rate for the port load.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "Unit",
        "type": "str",
        "description": "Unit of measurement for Rate.",
        "default": "PERCENT",
        "range_or_options": "NS PERCENT FRAME_PER_SEC BYTE_PER_SEC DATABIT_PER_SEC LINEBIT_PER_SEC INTER_FRAME_GAP_BYTE KLINEBIT_PER_SEC MLINEBIT_PER_SEC"
      },
      {
        "name": "GenerateError",
        "type": "str",
        "description": "Specifies if packet errors should be generated.",
        "default": "NO_ERROR",
        "range_or_options": "NO_ERROR CRC"
      },
      {
        "name": "IgnoreLinkState",
        "type": "str",
        "description": "Determines whether to ignore link state status before transmitting traffic.",
        "default": "NO",
        "range_or_options": "NO YES"
      },
      {
        "name": "TimeStampPosTx",
        "type": "str",
        "description": "Position of the timestamp in transmitted frames.",
        "default": "TIMESTAMP_HEAD",
        "range_or_options": "TIMESTAMP_HEAD TIMESTAMP_TAIL"
      },
      {
        "name": "TimeStampPosRx",
        "type": "str",
        "description": "Position of the timestamp in received frames.",
        "default": "TIMESTAMP_HEAD",
        "range_or_options": "TIMESTAMP_HEAD TIMESTAMP_TAIL"
      },
      {
        "name": "LatencyCompensationTx",
        "type": "int",
        "description": "Transmit latency compensation value in nanoseconds.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "LatencyCompensationRx",
        "type": "int",
        "description": "Receive latency compensation value in nanoseconds.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "LatencyCompensationOn",
        "type": "bool",
        "description": "Enables or disables latency compensation.",
        "default": "True",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits the load profile configuration for one or more test instrument ports based on the provided parameters. The function supports various modes like CONTINUOUS, BURST, TIME, STEP, and ONSTREAM, with corresponding configurations applied dynamically. It ensures valid combinations of settings are used and raises exceptions for invalid configurations.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Port Load Profile | Ports=${Ports} | TransmitMode=CONTINUOUS | Unit=PERCENT | Rate=100 |\n    | Edit Port Load Profile | Ports=${Ports} | TransmitMode=BURST | BurstSize=10 | InterFrameGap=20 | InterFrameGapUnit=MS | BurstCount=100 |\n    | Edit Port Load Profile | Ports=${Ports} | TransmitMode=TIME | Seconds=10 |\n    | Edit Port Load Profile | Ports=${Ports} | TransmitMode=STEP | Frames=10 |\n    | Edit Port Load Profile | Ports=${Ports} | TransmitMode=ONSTREAM | Rate=50 | Unit=FRAME_PER_SEC |"
  },
  {
    "method_name": "TesterLibrary.Port.common.wait_port_state",
    "return_type": "bool",
    "return": "True if all ports reach the desired state(s) within the timeout period; False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list(:obj:`Port`)",
        "description": "测试仪表端口对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "测试仪表连接端口状态",
        "default": "UP",
        "range_or_options": "DOWN UP"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "状态查询间隔",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "超时时间",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the specified ports reach the desired state(s) or until a timeout occurs. This function polls the link status of the given ports at regular intervals and waits until all of them are in one of the specified target states. It supports both fiber and copper Ethernet media types by retrieving the appropriate child object for each port. If the timeout is reached before all ports reach the desired state, a message is logged and False is returned.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Port | Ports=${Ports} | EnableLink=False |\n    | Wait Port State | Ports=${Ports} | State=DOWN |"
  },
  {
    "method_name": "TesterLibrary.Port.common.edit_stream_load_profile",
    "return_type": "bool",
    "return": "Returns True if the stream load profile was edited successfully, False otherwise.",
    "parameters": [
      {
        "name": "Streams",
        "type": "list(:obj:`StreamTemplate`)",
        "description": "List of stream template objects representing the streams whose load profiles are to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Rate",
        "type": "int",
        "description": "The traffic load rate value. Only applicable when Unit is set appropriately.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "Unit",
        "type": "str",
        "description": "The unit for the traffic load. This defines how the Rate is interpreted.",
        "default": "PERCENT",
        "range_or_options": "PERCENT FRAME_PER_SEC BYTE_PER_SEC LINEBIT_PER_SEC KLINEBIT_PER_SEC MLINEBIT_PER_SEC INTER_FRAME_GAP"
      },
      {
        "name": "StreamTransmitMode",
        "type": "str",
        "description": "Transmission mode for the stream. Determines whether it's continuous or burst-based.",
        "default": "CONTINUOUS",
        "range_or_options": "CONTINUOUS BURST"
      },
      {
        "name": "FramePerBurst",
        "type": "int",
        "description": "Number of frames per burst. Only valid when StreamTransmitMode is BURST.",
        "default": "100",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BurstCount",
        "type": "int",
        "description": "Number of bursts. Only valid when StreamTransmitMode is BURST.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BurstGap",
        "type": "int",
        "description": "Time gap between bursts in specified units. Only valid when StreamTransmitMode is BURST.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BurstGapUnit",
        "type": "str",
        "description": "Unit for BurstGap. Specifies the time unit used for burst gaps.",
        "default": "not_found",
        "range_or_options": "NS US MS SEC"
      }
    ],
    "description": "Edits the load profile configuration for one or more stream templates. This includes setting traffic rate, unit, transmission mode (continuous or burst), and related burst parameters if applicable. The function ensures consistency with system constraints and raises an exception on failure.",
    "example": "| Edit Stream Load Profile | Streams=${Streams} | Rate=50 | Unit=FRAME_PER_SEC |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.create_interface",
    "return_type": "Interface or list of Interface objects",
    "return": "Returns the created interface(s) associated with the given port(s). If multiple ports are provided, returns a list of Interface objects in the same order as the input ports.",
    "parameters": [
      {
        "name": "Port",
        "type": "Port object or list of Port objects",
        "description": "The physical or logical port(s) on which the interface(s) will be created. If a list of ports is provided, an interface is created for each port.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Layers",
        "type": "list, set, tuple, or str (optional)",
        "description": "A sequence specifying the network layers to be applied in order from bottom to top (e.g., 'eth', 'ipv4'). Each element will be converted to lowercase. If None, defaults to ['eth', 'ipv4']. Used to define the base network stack for the interface.",
        "default": "['eth', 'ipv4']",
        "range_or_options": "eth vlan pppoe l2tp ipv4 ipv6"
      },
      {
        "name": "Tops",
        "type": "list, set, tuple, str, or None (optional)",
        "description": "Specifies additional top layers to insert into the stack after certain conditions (like presence of 'l2tp' in Layers). If None and Layers has more than two elements, Tops will be inferred as Layers[1:]. Otherwise, it can be used to explicitly define top layers.",
        "default": "not_found",
        "range_or_options": "None ipv4 ipv6"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the interface",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of interfaces to create",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableInterfaceCount",
        "type": "bool",
        "description": "Whether to enable interface count",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableLearningGatewayMac",
        "type": "bool",
        "description": "Whether to enable learning gateway MAC address",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdMode",
        "type": "str",
        "description": "Mode for router ID assignment",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterId",
        "type": "str",
        "description": "Router ID value",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "Increment step for router ID",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdList",
        "type": "list",
        "description": "List of router IDs",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6RouterId",
        "type": "str",
        "description": "IPv6 router ID value",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6RouterIdList",
        "type": "list",
        "description": "List of IPv6 router IDs",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableVlansAssociation",
        "type": "bool",
        "description": "Whether to enable VLAN association",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and configures one or more network interfaces on the specified port(s) with the given layer stack. This function builds a network layer stack based on the Layers and Tops parameters, and applies the configuration using BuildInterfaceCommand or edit_interface_stack depending on the complexity of the stack.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Locations} | Create List | //192.168.0.1/1/1 |\n    | ${Layers} | Create List | eth | ipv4 |\n    | ${Port} | Reserve Ports | ${Ports} | ${Location} |\n    | ${Interface} | Create Interface | ${Port} | ${Layers} |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.edit_interface_stack",
    "return_type": "dict",
    "return": "A dictionary mapping each input interface to its updated interface layer stack. Each stack is represented as a list of NetworkLayer objects in order from the topmost layer down to the lowest. Returns False if no result can be generated (e.g., due to invalid inputs).",
    "parameters": [
      {
        "name": "Interfaces",
        "type": "Interface object or list of Interface objects",
        "description": "The network interface(s) whose stack is to be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Layers",
        "type": "list, set, tuple, or str (optional)",
        "description": "A list or string specifying the network layers to be applied in order to the interface stack. If a string is provided, it will be converted into a single-element list. Layers are case-insensitive and converted to lowercase before processing.",
        "default": "['eth']",
        "range_or_options": "eth vlan pppoe l2tp ipv4 ipv6"
      },
      {
        "name": "Tops",
        "type": "list, set, tuple, str, or None (optional)",
        "description": "Specifies additional top layers to insert in the stack. If 'l2tp' is present in Layers, Tops will be inserted between the part before 'l2tp' and after 'l2tp'. If not a list, it will be converted to a lowercase list. If None or empty, no top layers will be added.",
        "default": "ipv4",
        "range_or_options": "None ipv4 ipv6"
      }
    ],
    "description": "Modifies the network interface stack configuration for one or more specified interfaces. This function allows editing of the layer stack associated with network interfaces by specifying a list of layers and optionally top layers. It supports dynamic modification of the network stack, including handling special cases like inserting L2TP layers into the stack. The function first normalizes all inputs to ensure they are in the correct format. It then constructs a new layer stack based on whether 'l2tp' is present in Layers and how Tops is defined. Using ReplaceInterfaceStackCommand, it applies the changes to the interface stacks via the command layer instance (cl_instance). After updating, the function rebuilds the interface layer hierarchy for each interface and returns the resulting structure.",
    "example": ">>> api.edit_interface_stack(interface_obj, Layers=['eth', 'vlan', 'l2tp'], Tops=['ppp'])\n{<Interface...>: [<NetworkLayer eth>, <NetworkLayer vlan>, <NetworkLayer ppp>, <NetworkLayer l2tp>]}"
  },
  {
    "method_name": "TesterLibrary.Port.interface.edit_interface",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful (True) or not (False).",
    "parameters": [
      {
        "name": "Interface",
        "type": ":obj:`Interface`",
        "description": "The Interface object representing the test port interface to be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Layer",
        "type": "str",
        "description": "Specifies the network layer of the interface to modify. Supported values include EthIILayer, VLANLayer, IPv4Layer, and IPv6Layer.",
        "default": "None",
        "range_or_options": "EthIILayer VLANLayer IPv4Layer IPv6Layer"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level within the Layer to apply changes. If None, changes are applied to all levels in the specified Layer.",
        "default": "None",
        "range_or_options": "0-1"
      }
    ],
    "kwargs": [
      {
        "name": "Count",
        "type": "any",
        "description": "Number of interfaces to create or modify.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableInterfaceCount",
        "type": "bool",
        "description": "Whether to enable counting for interfaces.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableLearningGatewayMac",
        "type": "bool",
        "description": "Enables learning of gateway MAC addresses.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdMode",
        "type": "str",
        "description": "Defines how Router IDs are assigned.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterId",
        "type": "str",
        "description": "IPv4 address used as a Router ID.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "Increment step for Router ID assignment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterIdList",
        "type": "list",
        "description": "List of Router IDs to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6RouterId",
        "type": "str",
        "description": "IPv6 address used as a Router ID.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6RouterIdList",
        "type": "list",
        "description": "List of IPv6 Router IDs to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableVlansAssociation",
        "type": "bool",
        "description": "Enables association with VLANs.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "AddressMode",
        "type": "str",
        "description": "Defines how addresses are assigned for the layer (e.g., manual, dhcp, etc.).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Address",
        "type": "str",
        "description": "IP or MAC address assigned to the interface.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Step",
        "type": "str",
        "description": "Increment step for Address assignment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "AddressList",
        "type": "list",
        "description": "List of addresses to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableRandMac",
        "type": "bool",
        "description": "Enables random MAC address generation.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RandomSeed",
        "type": "int",
        "description": "Seed value for random number generator.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanId",
        "type": "int",
        "description": "VLAN identifier assigned to the interface.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Priority value for VLAN traffic.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PriorityStep",
        "type": "str",
        "description": "Increment step for priority assignment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PriorityList",
        "type": "list",
        "description": "List of priorities to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Cfi",
        "type": "int",
        "description": "Canonical Format Indicator for VLAN tags.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Tpid",
        "type": "str",
        "description": "Tag Protocol Identifier for VLAN tags.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Subnet prefix length for IP addressing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Default gateway IP address for routing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "GatewayStep",
        "type": "str",
        "description": "Increment step for Gateway assignment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "GatewayList",
        "type": "list",
        "description": "List of gateways to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "GatewayCount",
        "type": "int",
        "description": "Number of gateways to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "GatewayMac",
        "type": "str",
        "description": "MAC address of the default gateway.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ResolvedMacList",
        "type": "list",
        "description": "List of resolved MAC addresses.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ResolvedState",
        "type": "str",
        "description": "State of MAC address resolution.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalGenType",
        "type": "str",
        "description": "Method for generating link-local IPv6 address.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocal",
        "type": "str",
        "description": "Manually configured link-local IPv6 address.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalStep",
        "type": "str",
        "description": "Increment step for link-local address assignment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalList",
        "type": "list",
        "description": "List of link-local IPv6 addresses to assign.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Modifies attributes of network interface objects based on provided keyword arguments. This function allows editing one or multiple interfaces by setting specified attributes. If a Layer is provided, it modifies attributes within that specific layer. If a Level is also specified, the attribute change applies to a specific level within that layer. Otherwise, it iterates through all layers under the specified Layer and applies the change wherever possible.",
    "example": "| ${Locations} | Create List | //192.168.0.1/1/1 |\n| ${Layers} | Create List | eth | ipv4 |\n| ${Port} | Reserve Ports | ${Ports} | ${Location} |\n| ${Interface} | Create Interface | ${Port} | ${Layers} |\n| Edit Interface | Interfaces=${Interface} | Layer=IPv4Layer | Gateway=192.168.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.start_arp",
    "return_type": "bool",
    "return": "Returns True if the ARP operation was successfully started, False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list of Port objects or Port object",
        "description": "A list (or single) of physical port objects on which to start ARP. Each port should have associated interfaces. If both Ports and Interfaces are None, all available interfaces will be used.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Interfaces",
        "type": "list of Interface objects or Interface object",
        "description": "A list (or single) of logical interface objects on which to start ARP. If provided, Ports must be None. Takes precedence over Ports.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function starts the Address Resolution Protocol (ARP) operation on specified physical ports or logical interfaces. It ensures that only one of 'Ports' or 'Interfaces' is used at a time. If both are None, it starts ARP on all available interfaces in the system. Internally, it constructs either a StartArpCommand or StartAllArpCommand depending on the input parameters and executes it via the internal command engine. If the operation fails, it raises a ContinuableFailure exception.",
    "example": "| Start Arp |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.stop_arp",
    "return_type": "bool",
    "return": "True if the ARP stop operation was successful, False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port]]",
        "description": "A single Port object or a list of Port objects whose associated interfaces will have ARP stopped. If specified, Interfaces must be None.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Interfaces",
        "type": "Union[Interface, List[Interface]]",
        "description": "A single Interface object or a list of Interface objects on which ARP should be stopped. If specified, Ports must be None.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops ARP (Address Resolution Protocol) operations on specified ports or interfaces.\n\nThis function allows stopping ARP either on specific ports or specific interface objects. If both 'Ports' and 'Interfaces' are None, it stops ARP on all available interfaces. The function ensures mutual exclusivity between Ports and Interfaces parameters and internally delegates the operation to the backend system via Renix command layer.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Stop Arp |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.get_gateway_mac",
    "return_type": "list of str",
    "return": "A list of MAC addresses (as strings) representing the gateway(s) associated with the provided interface(s), depending on the specified IP version.",
    "parameters": [
      {
        "name": "Interface",
        "type": "object or iterable of objects",
        "description": "A single interface object or an iterable (e.g., list, set, tuple) of interface objects. Each interface should support querying child layers such as 'Ipv4Layer' and 'Ipv6Layer'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Version",
        "type": "str or None, optional",
        "description": "Specifies which IP version's gateway MAC addresses to return. If not provided, both IPv4 and IPv6 addresses are returned.",
        "default": "None",
        "range_or_options": "'ipv4' 'ipv6'"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the MAC addresses of gateways associated with the provided network interface(s), based on IPv4 and/or IPv6 configurations. This function checks each provided interface for its associated IPv4 and IPv6 layers. For each layer, it collects the resolved MAC addresses from the `ResolvedMacList` property and returns them. The user can optionally specify whether to retrieve only IPv4, only IPv6, or both types of gateway MAC addresses.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Get Gateway Mac | Interface=${Interface} | Version=ipv4 |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.get_interfaces",
    "return_type": "list of Interface",
    "return": "A list of Interface objects associated with the specified ports, potentially filtered by one or more interface types.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or iterable of Ports, optional",
        "description": "A single Port object or an iterable (e.g., list, set, tuple) of Port objects to retrieve interfaces from. If None, all ports under the system entry are considered.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str or iterable of str, optional",
        "description": "Specifies the type(s) of interfaces to filter by. Valid types include 'eth', 'ipv4', 'ipv6', 'vlan', 'pppoe', 'l2tp', and 'gre'. If None, no filtering is applied.",
        "default": "not_found",
        "range_or_options": "eth ipv4 ipv6 vlan pppoe l2tp gre"
      }
    ],
    "kwargs": [],
    "description": "Retrieves a list of Interface objects associated with the specified ports or filtered by specific interface types. If no ports are specified, all ports under the system entry are considered. If types are provided, only interfaces matching those types are returned. Duplicate interfaces are avoided in the final result.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Interfaces} | Get Interfaces | Ports=${Ports} | Types=vlan |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.get_layer_from_interfaces",
    "return_type": "list",
    "return": "A list of layer objects retrieved from the provided interfaces. Each element corresponds to a child of the specified layer type from the interfaces.",
    "parameters": [
      {
        "name": "Interfaces",
        "type": "Interface object or list of Interface objects",
        "description": "The interface(s) from which to retrieve the specified layer objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Layer",
        "type": "str, optional",
        "description": "A string specifying the type of layer to retrieve.",
        "default": "'ipv4'",
        "range_or_options": "'eth' 'ipv6' 'vlan' 'pppoe' 'l2tp' 'gre'"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the specified layer objects from one or more given interface objects. This function checks the provided Layer argument to determine which type of layer to retrieve (e.g., Ethernet, IPv4, VLAN, etc.). It then fetches all children of that layer type from each interface and returns them in a single list.",
    "example": ">>> api = RenixAPI()\n>>> intf1, intf2 = get_interface_objects()  # Assume this gets interface objects\n>>> ipv4_layers = api.get_layer_from_interfaces([intf1, intf2], 'ipv4')\n>>> print(ipv4_layers)\n[<Ipv4Layer object at 0x...>, <Ipv4Layer object at 0x...>]"
  },
  {
    "method_name": "TesterLibrary.Port.interface.ipv4_ping",
    "return_type": "str",
    "return": "返回Ping操作的状态结果，可能的值包括 'NotStart', 'NotEnd', 'Success', 'Failed', 'PartialSuccess', 'Unexpected'",
    "parameters": [
      {
        "name": "Interface",
        "type": "object",
        "description": "仪表的接口对象，必须是一个有效的接口实例，用于指定从哪个端口发出Ping请求。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IpAddr",
        "type": "str",
        "description": "需要Ping的目标IPv4地址，字符串类型（例如：\"192.168.1.1\"）。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketCount",
        "type": "int",
        "description": "发送的Ping数据包数量，默认为5个。此参数控制发送多少个ICMP请求报文。",
        "default": "5",
        "range_or_options": "1-100"
      }
    ],
    "kwargs": [],
    "description": "从指定的IPv4接口发起对目标IP地址的Ping操作，并根据响应情况返回不同的状态结果。该函数通过调用内部命令配置并启动IPv4 Ping，随后等待Ping操作开始和结束。最终依据接收到的响应包数量判断Ping结果。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Ipv4 Ping | Interface=${Interface} | IpAddr=192.168.0.2 |"
  },
  {
    "method_name": "TesterLibrary.Port.interface.ipv6_ping",
    "return_type": "str",
    "return": "返回Ping操作的状态结果，可能的值包括 'NotStart', 'NotEnd', 'Success', 'Failed', 'PartialSuccess', 'Unexpected'",
    "parameters": [
      {
        "name": "Interface",
        "type": "object",
        "description": "表示仪表的一个IPv6接口对象，必须具有 `handle` 属性用于底层识别该接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IpAddr",
        "type": "str",
        "description": "要Ping的目标IPv6地址，格式应为合法的IPv6字符串表示（例如 '2001:db8::1'）。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketCount",
        "type": "int",
        "description": "发送的Ping请求包的数量，默认值为5。可选参数。",
        "default": "5",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "从指定的IPv6接口发起对目标IPv6地址的Ping操作，并根据Ping结果返回相应的状态信息。此方法通过调用内部命令对象（StartIpv6PingCommand 和 WaitConditionCommand）来执行Ping操作，并等待响应。可以根据发送和接收的数据包数量判断网络连通性状态。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Ipv6 Ping | Interface=${Interface} | IpAddr=2000::2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.create_bfd",
    "return_type": "BfdRouter",
    "return": "BFD协议会话对象, 类型：object",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "BFD协议会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能BFD协议会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouterRole",
        "type": "str",
        "description": "BFD会话的角色",
        "default": "Active",
        "range_or_options": "Active Passive"
      },
      {
        "name": "TimeIntervalUnit",
        "type": "str",
        "description": "时间间隔的单位",
        "default": "milliseconds",
        "range_or_options": "milliseconds microseconds"
      },
      {
        "name": "DesiredMinTXInterval",
        "type": "int",
        "description": "期望的最小发送时间间隔",
        "default": "50",
        "range_or_options": "1-10000 (milliseconds); 1-10000000 (microseconds)"
      },
      {
        "name": "RequiredMinRXInterval",
        "type": "int",
        "description": "需要的最小接收时间间隔",
        "default": "50",
        "range_or_options": "1-10000 (milliseconds); 1-10000000 (microseconds)"
      },
      {
        "name": "RequiredMinEchoRXInterval",
        "type": "int",
        "description": "需要的最小Echo报文接收时间间隔",
        "default": "0",
        "range_or_options": "1-10000 (milliseconds); 1-10000000 (microseconds)"
      },
      {
        "name": "DetectMultiple",
        "type": "int",
        "description": "用于检测超时的时间因子",
        "default": "3",
        "range_or_options": "2-100"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "认证方式",
        "default": "None",
        "range_or_options": "NONE SIMPLE_PASSWORD KEYED_MD5 METICULOUS_KEYED_MD5 KEYED_SHA1 METICULOUS_KEYED_SHA1"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "当认证方式不为NONE时，在该单元格输入认证密码。密码可以是数字、字母或者数字和字母的组合，最长为16位。",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "KeyID",
        "type": "int",
        "description": "当认证方式不为NONE时，在该单元格输入Key ID",
        "default": "1",
        "range_or_options": "0-255"
      }
    ],
    "description": "创建并配置一个与指定端口关联的BFD（双向转发检测）路由器会话对象。该函数初始化一个新的BfdRouter实例，并使用提供的`Port`作为父对象以及通过`**kwargs`传递的其他配置参数进行配置。新创建的BFD会话随后通过其句柄在全局映射中注册。",
    "example": "| Create bfd | Port=${Port} | TimeIntervalUnit=microseconds |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.edit_bfd",
    "return_type": "bool",
    "return": "True if the BFD session attributes were successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "BfdRouter",
        "description": "A BFD session object whose attributes can be modified using the provided keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the BFD session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the BFD session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouterRole",
        "type": "str",
        "description": "The role of the router in the BFD session.",
        "default": "Active",
        "range_or_options": "Active Passive"
      },
      {
        "name": "TimeIntervalUnit",
        "type": "str",
        "description": "The unit for time intervals used in the BFD session.",
        "default": "milliseconds",
        "range_or_options": "milliseconds microseconds"
      },
      {
        "name": "DesiredMinTXInterval",
        "type": "int",
        "description": "The desired minimum transmit interval for BFD control packets.",
        "default": "50",
        "range_or_options": "1-10000 (milliseconds); 1-10000000 (microseconds)"
      },
      {
        "name": "RequiredMinRXInterval",
        "type": "int",
        "description": "The required minimum receive interval for BFD control packets.",
        "default": "50",
        "range_or_options": "1-10000 (milliseconds); 1-10000000 (microseconds)"
      },
      {
        "name": "DetectMultiple",
        "type": "int",
        "description": "Multiplier used to calculate detection time based on negotiated transmission interval.",
        "default": "3",
        "range_or_options": "2-100"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "The type of authentication used for securing the BFD session.",
        "default": "None",
        "range_or_options": "NONE SIMPLE_PASSWORD KEYED_MD5 METICULOUS_KEYED_MD5 KEYED_SHA1 METICULOUS_KEYED_SHA1"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password when AuthenticationType is not NONE. Must be up to 16 characters long.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "KeyID",
        "type": "int",
        "description": "Key ID used for authentication when AuthenticationType is not NONE.",
        "default": "1",
        "range_or_options": "0-255"
      }
    ],
    "description": "Updates attributes of the provided BFD session object with values from keyword arguments. This function allows dynamic modification of BFD session parameters such as enabling/disabling the session, changing roles, setting intervals, and configuring authentication.",
    "example": ".. code:: RobotFramework\n\n    | Edit Bfd | Session=${Session} | Enable=True | RouterRole=Passive | DesiredMinTXInterval=100"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.create_bfd_ipv4_session",
    "return_type": "object",
    "return": "BFD IPv4会话对象，类型为：`BfdIpv4SessionConfig`",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "BFD协议会话对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "BFD IPv4会话名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能BFD IPv4会话。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NumberOfSessions",
        "type": "str",
        "description": "BFD IPv4会话的数目。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartDestinationAddress",
        "type": "str",
        "description": "指定第一个目的IPv4地址。",
        "default": "192.0.1.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "DestinationAddressIncrement",
        "type": "str",
        "description": "指定下一个目的IPv4地址的增量。",
        "default": "0.0.0.1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "EnableMyDiscriminator",
        "type": "bool",
        "description": "是否指定本地标识符。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MyDiscriminator",
        "type": "int",
        "description": "指定本地标识符的初始值。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "MyDiscriminatorIncrement",
        "type": "int",
        "description": "指定下一个本地标识符的增量。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableYourDiscriminator",
        "type": "bool",
        "description": "是否指定对端标识符。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "YourDiscriminator",
        "type": "int",
        "description": "指定对端标识符的初始值。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "YourDiscriminatorIncrement",
        "type": "int",
        "description": "指定下一个对端标识符的增量。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "该函数用于创建一个或多个BFD（双向转发检测）IPv4会话。它通过传入的Session对象调用其内部方法create_ipv4_session来实现具体的会话创建逻辑。支持多种配置参数，包括会话名、启用状态、会话数量、目标IP地址及增量、本地和远端标识符等。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bfd | Port=${Port} |\n    | Create Bfd Ipv4 Session | Session=${Session} | NumberOfSessions=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.create_bfd_ipv6_session",
    "return_type": "object",
    "return": "BFD IPv6会话对象，类型为 `BfdIpv6SessionConfig`。",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "BFD协议会话对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "BFD IPv6路由名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能BFD IPv6路由。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NumberOfSessions",
        "type": "str",
        "description": "BFD IPv6会话的数目。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartDestinationAddress",
        "type": "str",
        "description": "指定第一个目的IPv6地址。",
        "default": "2000::1",
        "range_or_options": "有效的ipv6地址"
      },
      {
        "name": "DestinationAddressIncrement",
        "type": "str",
        "description": "指定下一个目的IPv4地址的增量。",
        "default": "::1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "EnableMyDiscriminator",
        "type": "bool",
        "description": "是否指定本地标识符。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MyDiscriminator",
        "type": "int",
        "description": "指定本地标识符的初始值。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "MyDiscriminatorIncrement",
        "type": "int",
        "description": "指定下一个本地标识符的增量。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableYourDiscriminator",
        "type": "bool",
        "description": "是否指定对端标识符。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "YourDiscriminator",
        "type": "int",
        "description": "指定对端标识符的初始值。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "YourDiscriminatorIncrement",
        "type": "int",
        "description": "指定下一个对端标识符的增量。只有使能本地标识符被选中才可编辑。",
        "default": "1",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "创建一个BFD (Bidirectional Forwarding Detection) IPv6会话，并通过提供的Session对象进行实际的会话创建操作。该函数封装了底层实现并可能附加异常检查行为（如装饰器中的处理）。用于在IPv6网络上建立BFD检测机制。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bfd | Port=${Port} |\n    | Create Bfd Ipv6 Session | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_admin_down",
    "return_type": "bool",
    "return": "布尔值，表示BFD会话状态是否成功设置为AdminDown（True表示成功，False表示失败）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`BfdRouter`)",
        "description": "BFD协议会话对象列表，每个会话对象必须支持`admin_down()`方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于将一个或多个BFD（双向转发检测）会话手动设置为管理性关闭状态（AdminDown）。主要用于测试或配置目的。如果操作失败，会抛出ContinuableFailure异常；如果成功，则返回True。",
    "example": ".. code:: RobotFramework\n\n    | Bfd Admin Down | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_admin_up",
    "return_type": "bool",
    "return": "True if the operation is successfully executed on all sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or Session object",
        "description": "A single session object or an iterable collection (like list, set, or tuple) of session objects for which the BFD administrative state should be enabled.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function enables the BFD (Bidirectional Forwarding Detection) administrative state for one or more specified session objects. It calls the `admin_up()` method on each session provided. If any session does not have the `admin_up()` method, a TypeError will be raised during execution. The function returns True upon successful execution.",
    "example": "| Bfd Admin Up | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_enable_demand_mode",
    "return_type": "bool",
    "return": "True if demand mode is successfully enabled for all provided BFD sessions; False will raise an exception (ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of BfdRouter objects",
        "description": "A list of BFD session objects (BfdRouter) for which demand mode needs to be activated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function enables BFD (Bidirectional Forwarding Detection) demand mode for one or more BFD sessions. Demand mode means the session actively sends control packets to monitor and maintain the bidirectional path. Internally, it calls the `enable_demand_mode()` method on each session object. If enabling demand mode fails for any session, a ContinuableFailure exception is raised. Otherwise, it returns True upon success.",
    "example": "| Bfd Enable Demand Mode | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_disable_demand_mode",
    "return_type": "bool",
    "return": "True if the operation was successful, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`BfdRouter`)",
        "description": "A list of BFD session objects for which Demand mode should be disabled.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Disables Demand mode for one or more BFD (Bidirectional Forwarding Detection) sessions. In BFD, Demand mode is a state where the session actively sends control packets to maintain connectivity. Disabling Demand mode transitions the session into a passive state where it does not send periodic control packets. This function calls the backend API to perform the operation and returns True if successful.",
    "example": "| Bfd Disable Demand Mode | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_initiate_poll",
    "return_type": "bool",
    "return": "A boolean value indicating the success of initiating BFD poll operations on all provided sessions (True for success, False for failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or iterable of BfdRouter objects",
        "description": "A single session object or an iterable (such as a list, set, or tuple) containing multiple BFD session objects (`BfdRouter`). Each session must implement the `initiate_poll()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Initiates a Bidirectional Forwarding Detection (BFD) poll operation on one or more session objects. This function wraps the backend call to `renix.bfd_initiate_poll`, and if the result is False, it raises a `ContinuableFailure` exception to signal that the operation did not succeed. If successful, it returns True. The function ensures uniform processing of both single and multiple session objects.",
    "example": "| Bfd Initiate Poll | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_resume_pdus",
    "return_type": "bool",
    "return": "True if all sessions successfully resumed sending PDUs, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "BFDSession or iterable of BFDSession",
        "description": "A single BFD session object or an iterable (list, set, tuple) of BFD session objects for which PDU transmission needs to be resumed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the transmission of BFD (Bidirectional Forwarding Detection) protocol data units (PDUs) for one or more specified BFD sessions. If the provided session(s) are not in an iterable format, the function will convert a single session into a list to uniformly handle all inputs. It then calls the `resume_pdus()` method on each session to resume PDU transmission. If any session fails to resume sending PDUs, the function may raise exceptions depending on the underlying implementation.",
    "example": "| Bfd Resume Pdus | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_stop_pdus",
    "return_type": "bool",
    "return": "Returns True if the BFD PDU transmissions are successfully stopped for all provided sessions; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of BfdRouter objects",
        "description": "A list of BFD session objects (BfdRouter) for which BFD PDU transmission should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the transmission of BFD (Bidirectional Forwarding Detection) Protocol Data Units (PDUs) for one or more specified BFD sessions. This function wraps the underlying API call to stop BFD PDUs and raises a ContinuableFailure exception if stopping fails for any session.",
    "example": "| Bfd Stop Pdus | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.bfd_set_diagnostic_state",
    "return_type": "bool",
    "return": "返回一个布尔值，表示操作是否成功。True 表示操作成功，False 表示操作失败（不会抛出异常）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(BfdRouter)",
        "description": "BFD协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "设置状态诊断码",
        "default": "NO_DIAGNOSTIC",
        "range_or_options": "NO_DIAGNOSTIC CONTROL_DETECTION_TIME_EXPIRED ECHO_FUNCTION_FAILED NEIGHBOR_SIGNAL_SESSION_DOWN FORWARDING_PLANE_RESET PATH_DOWN CONCATENATED_PATH_DOWN ADMINISTRATIVELY_DOWN REVERSE_CONCATENATED_PATH_DOWN"
      }
    ],
    "kwargs": [],
    "description": "Sets the diagnostic state for one or more BFD (Bidirectional Forwarding Detection) sessions. This function accepts a list of session objects and applies the specified diagnostic state to all of them. If the backend call returns False, it raises a ContinuableFailure exception indicating failure.",
    "example": "| Bfd Set Diagnostic State | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.wait_bfd_state",
    "return_type": "bool",
    "return": "Returns True if all BFD sessions reach the specified state within the timeout period. If any session does not reach the desired state, or an error occurs, a ContinuableFailure exception may be raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of `BfdRouter` objects",
        "description": "A list of BFD session objects to monitor for reaching the specified state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the BFD sessions are expected to reach.",
        "default": "'RUNNING'",
        "range_or_options": "DISABLED NOT_STARTED IDLE RUNNING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval (in seconds) between successive checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time (in seconds) to wait for each session to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more BFD (Bidirectional Forwarding Detection) sessions to reach a specified state such as RUNNING, IDLE, etc. This function calls the underlying implementation in the `renix` module and raises a ContinuableFailure exception if the operation fails.",
    "example": "| Wait Bfd State | Sessions=${Sessions} | State=RUNNING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistical items for a single session, a pandas DataFrame if multiple sessions match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None, optional",
        "description": "A single session object or a collection of session objects whose results are to be retrieved. Each session object must have a 'Name' attribute. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve for the BFD session(s). Valid items include SessionID, SessionState, BfdSessionUpCount, BfdSessionDownCount, TXBfdPackets, RXBfdPackets, TimeoutsDetected, FlapsDetected. If None, all available properties are queried. If a string is provided, it is converted into a list containing that string.",
        "default": "None",
        "range_or_options": "SessionID SessionState BfdSessionUpCount BfdSessionDownCount TXBfdPackets RXBfdPackets TimeoutsDetected FlapsDetected"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves BFD (Bidirectional Forwarding Detection) session statistics based on provided session identifiers and statistical items. It wraps an internal call to fetch statistics from the backend, filters by session name if provided, and returns the corresponding values for the requested statistical items. The function supports querying one or more sessions and handles both scalar and bulk return types.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | SessionID | SessionState |\n    | Subscribe Result | Types=BfdSessionResult |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bfd Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_ipv4_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary containing requested BFD IPv4 session statistics if one session matches, a pandas DataFrame if multiple sessions match, or False if no session matches. Keys correspond to the statistical items in `StaItems`.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/tuple/set of objects, optional",
        "description": "Session object(s) for which to retrieve results. Each object must have a `.Name` attribute representing its ID. If None, no session filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "Index of the session to retrieve in case of single session context. Used as 'SessionIndex' in internal index dictionary.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Statistical items (columns) to return in the result. If None, all available properties are queried. If a string, it is converted into a list.",
        "default": "None",
        "range_or_options": "Ipv4SessionKeyID Ipv4SessionID SessionID SessionIndex Ipv4SourceAddress Ipv4DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "description": "Retrieves BFD IPv4 session result statistics for specified session(s) and statistical items. This function wraps `_get_statictis()` to fetch BFD (Bidirectional Forwarding Detection) IPv4 session results. It supports retrieving data for a single session, multiple sessions, or all available sessions. The `SessionId` parameter allows specifying the session index, while `StaItems` controls which statistics are returned.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=BfdIpv4SessionResult |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bfd Ipv4 Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_ipv6_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if one session matches, a pandas DataFrame if multiple sessions match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/tuple/set of objects or None",
        "description": "The BFD IPv6 session object(s) from which to retrieve statistics. Each object must have a 'Name' attribute. If None, no filtering by session name will occur.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "The index or ID of the BFD session used for filtering results (corresponds to 'SessionIndex').",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies the statistical items (columns) to retrieve. If None, all available properties are fetched. If a string, it's converted into a single-item list. Must be a subset of supported statistics.",
        "default": "None",
        "range_or_options": "Ipv6SessionKeyID Ipv6SessionID SessionID SessionIndex Ipv6SourceAddress Ipv6DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "kwargs": [],
    "description": "Retrieves BFD IPv6 session statistics based on the provided session identifier and statistical items. This function wraps an internal method `_get_statictis` to fetch and return the relevant data. It handles various input types for the `Session` parameter and ensures appropriate session identifiers are extracted before querying the backend.",
    "example": "| @{StaItems} | Create List | AdjacencyState | TxUpdate |\n| Subscribe Result | Types=BfdIpv6SessionResult |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Bfd Ipv6 Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_isis_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回匹配的BFD-ISIS会话统计结果。如果找到一行：返回包含指定统计项的字典；如果找到多行：返回pandas DataFrame；如果没有匹配结果：返回False。",
    "parameters": [
      {
        "name": "BfdSession",
        "type": "object or list/set/tuple of objects or None",
        "description": "用于查询的BFD会话对象或集合。若为对象，则使用其Name属性作为ID；若为集合，则提取所有项的Name属性。若为None，则不按BFD会话ID过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IsisSession",
        "type": "object or list/set/tuple of objects or None",
        "description": "用于查询的ISIS会话对象或集合。处理方式与BfdSession相同，用于ISIS会话过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "进一步过滤结果的会话索引，默认为1。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "要获取的统计项列表（列名）。若为None则返回全部列；若为字符串则转换为列表。必须是可用统计属性的一个子集。",
        "default": "None",
        "range_or_options": "IpSessionKeyID IpSessionID SessionID SessionIndex Ipv4SourceAddress Ipv4DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "kwargs": [],
    "description": "该函数用于从底层调用`renix.get_bfd_isis_session_result()`，获取指定BFD和ISIS会话的BFD-ISIS会话统计结果。支持多种输入形式（单个对象、集合等）并可指定返回的统计项。内部通过对象名称提取ID进行过滤。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=IsisBfdSessionResult |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bfd Isis Session Statistic | BfdSession=${BfdSession} | IsisSession=${IsisSession} | SessionId=${SessionId} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_isis_ipv6_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for a BFD over ISIS IPv6 session. If exactly one matching session is found, returns a dictionary with keys corresponding to requested statistical items (StaItems). If multiple matches are found, returns a pandas DataFrame. If no match is found, returns False.",
    "parameters": [
      {
        "name": "BfdSession",
        "type": "object or list or set or tuple, optional",
        "description": "The BFD session object(s) used to extract session identifiers. If None, no filtering is done based on BFD session. If an iterable (list, set, tuple), extracts names from each object. If a single object, uses its Name attribute for filtering.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IsisSession",
        "type": "object or list or set or tuple, optional",
        "description": "The ISIS session object(s) used to extract IP session identifiers. If None, no filtering is done based on ISIS session. If an iterable (list, set, tuple), extracts names from each object. If a single object, uses its Name attribute for filtering.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "The session index used to identify a specific session instance. Used in conjunction with SessionID and IpSessionID to filter results.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, determined automatically by querying ROM properties. If a string, converted into a list. Must be a subset of available properties.",
        "default": "None",
        "range_or_options": "IpSessionKeyID IpSessionID SessionID SessionIndex Ipv6SourceAddress Ipv6DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the BFD over ISIS IPv6 session statistics based on provided session identifiers and statistical items. This function gathers and filters statistics using either a BFD session object, an ISIS session object, or both, along with a session index. Internally, it calls `_get_statictis` to fetch the actual data after extracting necessary identifiers from the provided session objects.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=IsisBfdIpv6SessionResult |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bfd Isis Ipv6 Session Statistic | BfdSession=${BfdSession} | IsisSession=${IsisSession} | SessionId=${SessionId} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_ospfv2_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if one matching session is found, a pandas DataFrame if multiple matches are found, or False if no match is found.",
    "parameters": [
      {
        "name": "BfdSession",
        "type": "object or list/set/tuple of objects or None",
        "description": "A BFD session object or a collection of BFD session objects. If None, no filtering by BFD session is applied. If a collection, the `Name` attribute of each object is used for identification.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Ospfv2Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "An OSPFv2 session object or a collection of OSPFv2 session objects. If None, no filtering by OSPFv2 session is applied. If a collection, the `Name` attribute of each object is used for identification.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "The session index used to identify a specific session instance when multiple sessions exist. Internally converted to integer.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, automatically determined via querying available properties. If a string, it will be converted into a list. Must be a subset of available statistic properties.",
        "default": "None",
        "range_or_options": "Ipv4SessionKeyID Ipv4SessionID SessionID SessionIndex Ipv4SourceAddress Ipv4DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "description": "This function retrieves and filters statistical data related to a specific BFD session running over an OSPFv2 protocol instance. It provides flexibility in selecting sessions and defining which metrics to return, making it suitable for both high-level monitoring and detailed diagnostics.",
    "example": "| @{StaItems} | Create List | TXAvgRate | RXAvgRate |\n| Subscribe Result | Types=Ospfv2BfdSessionResult |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Bfd Ospfv2 Session Statistic | BfdSession=${BfdSession} | Ospfv2Session=${Ospfv2Session} | SessionId=${SessionId} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bfd.get_bfd_ospfv3_session_result",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical items if one matching row is found, a pandas DataFrame if multiple rows match the criteria, or False if no matching result is found.",
    "parameters": [
      {
        "name": "BfdSession",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A BFD session object or collection of session objects used to filter results by BFD session(s). If None, no filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ospfv3Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "An OSPFv3 session object or collection of session objects used to filter results by OSPFv3 session(s). If None, no filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "The index or identifier for the session. Used to specify which session instance's data to retrieve.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve from the result. If None, all available properties are queried. If a string or list, only those specific columns are included in the output.",
        "default": "None",
        "range_or_options": "Ipv6SessionKeyID Ipv6SessionID SessionID SessionIndex Ipv6SourceAddress Ipv6DestinationAddress BfdSessionState MyDiscriminator YourDiscriminator BfdDiagnostic LastBfdDiagnosticErrorRx BfdControlBits_PFCADM ReceiveCount TransmitCount TransmitInterval ReceivedRequiredMinRXInterval ReceivedRequiredMinEchoRXInterval FlapsDetected TimeoutsDetected RXAvgRate RXMaxRate RXMinRate TXAvgRate TXMaxRate TXMinRate"
      }
    ],
    "description": "Retrieves the BFD and OSPFv3 session result statistics based on provided session objects or identifiers. This function gathers statistical data related to a BFD session associated with an OSPFv3 session. It internally calls `_get_statictis` with appropriate parameters to fetch and filter the required statistics.",
    "example": "| @{StaItems} | Create List | AdjacencyState | TxUpdate |\n| Subscribe Result | Types=Ospfv3BfdSessionResult |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Bfd Ospfv3 Session Statistic | BfdSession=${BfdSession} | Ospfv3Session=${Ospfv3Session} | SessionId=${SessionId} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp",
    "return_type": "BgpRouter",
    "return": "A newly created and configured BGP protocol session object associated with the specified port.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent port or network interface to which the BGP router will be bound. This is typically a test instrument port object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the BGP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the BGP session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version for the BGP session.",
        "default": "BOTH",
        "range_or_options": "BOTH IPV4 IPV6"
      },
      {
        "name": "BgpInitiator",
        "type": "bool",
        "description": "Determines if this device initiates the BGP session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AsNumber",
        "type": "int",
        "description": "Autonomous System (AS) number for the local BGP speaker.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "AsNumberStep",
        "type": "int",
        "description": "Step value for incrementing AS numbers in configurations with multiple sessions.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Enable4ByteAs",
        "type": "bool",
        "description": "Enables 4-byte autonomous system numbers.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AsNumber4Byte",
        "type": "int",
        "description": "4-byte autonomous system number.",
        "default": "1.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "AsNumber4ByteStep",
        "type": "int",
        "description": "Step value for 4-byte AS numbers.",
        "default": "0.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "DutAsNumber",
        "type": "int",
        "description": "Autonomous System number of the Device Under Test (DUT).",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "DutAsNumberStep",
        "type": "int",
        "description": "Step value for DUT's AS number.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Enable4ByteDutAs",
        "type": "bool",
        "description": "Enables 4-byte AS numbers for the DUT.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Dut4ByteAsNumber",
        "type": "int",
        "description": "4-byte AS number for the DUT.",
        "default": "1.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "Dut4ByteAsNumberStep",
        "type": "int",
        "description": "Step value for 4-byte DUT AS numbers.",
        "default": "0.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "BgpType",
        "type": "str",
        "description": "Type of BGP session.",
        "default": "IBGP",
        "range_or_options": "EBGP IBGP"
      },
      {
        "name": "UseGatewayAsDutIp",
        "type": "bool",
        "description": "Uses the gateway address as the DUT IP address.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "BgpSessionIpAddressType",
        "type": "str",
        "description": "Specifies how the BGP session IP address is determined.",
        "default": "INTERFACE_IP",
        "range_or_options": "INTERFACE_IP ROUTE_ID"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "DUT IPv4 address used when UseGatewayAsDutIp is False and IPv4 is selected.",
        "default": "2.1.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DutIpv4AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv4 addresses.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DutIpv6Address",
        "type": "str",
        "description": "DUT IPv6 address used when UseGatewayAsDutIp is False and IPv6 is selected.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "DutIpv6AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv6 addresses.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "HoldTime",
        "type": "int",
        "description": "Hold time interval in seconds for BGP session keepalive.",
        "default": "90",
        "range_or_options": "3-65535"
      },
      {
        "name": "KeepaliveTime",
        "type": "int",
        "description": "Keepalive time interval in seconds.",
        "default": "30",
        "range_or_options": "1-65535"
      },
      {
        "name": "ConnectRetryCount",
        "type": "int",
        "description": "Number of times to retry connecting to the DUT.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ConnectRetryInterval",
        "type": "int",
        "description": "Interval between connection retries in seconds.",
        "default": "30",
        "range_or_options": "10-300"
      },
      {
        "name": "MaxRoutesPerUpdateMessage",
        "type": "int",
        "description": "Maximum number of routes per BGP Update message.",
        "default": "2000",
        "range_or_options": "10-300"
      },
      {
        "name": "RouteRefreshMode",
        "type": "str",
        "description": "Route refresh mode for BGP.",
        "default": "None",
        "range_or_options": "None Route Refresh"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables graceful restart for BGP.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RestartTime",
        "type": "int",
        "description": "Graceful restart time in seconds.",
        "default": "90",
        "range_or_options": "3-4095"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables viewing of routing information.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Authentication",
        "type": "str",
        "description": "Authentication type for BGP session.",
        "default": "None",
        "range_or_options": "None MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Password for BGP authentication.",
        "default": "xinertel",
        "range_or_options": "1-255 characters"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables Bidirectional Forwarding Detection (BFD) for fast failure detection.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSr",
        "type": "bool",
        "description": "Enables Segment Routing (SR) functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MiniLabel",
        "type": "int",
        "description": "Minimum label value used in segment routing.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "EnableExMsg",
        "type": "bool",
        "description": "Enables extended BGP messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCustomize",
        "type": "bool",
        "description": "Enables custom BGP configuration options.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AfiSubAfi",
        "type": "str",
        "description": "AFI/SAFI values for address family negotiation.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableParseRxUpdateMsg",
        "type": "bool",
        "description": "Enables parsing of received BGP update messages.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates and configures a BGP (Border Gateway Protocol) router instance associated with the specified port. This function initializes a BGP router using the provided parent port and additional configuration parameters. It also registers the created BGP protocol object in a global mapping for future reference.",
    "example": "| Create Bgp | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.edit_bgp",
    "return_type": "bool",
    "return": "Returns True if the BGP session attributes were successfully updated, False otherwise (though in practice, failure raises an exception).",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "The BGP session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the BGP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the BGP session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version used for the session.",
        "default": "BOTH",
        "range_or_options": "BOTH IPV4 IPV6"
      },
      {
        "name": "BgpInitiator",
        "type": "bool",
        "description": "Indicates whether this session is initiated by the local device.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AsNumber",
        "type": "int",
        "description": "Autonomous System (AS) number of the local device.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "AsNumberStep",
        "type": "int",
        "description": "Increment step for AS numbers when multiple sessions are created.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Enable4ByteAs",
        "type": "bool",
        "description": "Enables 4-byte AS support.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AsNumber4Byte",
        "type": "int",
        "description": "4-byte AS number for extended AS support.",
        "default": "1.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "AsNumber4ByteStep",
        "type": "int",
        "description": "Increment step for 4-byte AS numbers.",
        "default": "0.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "DutAsNumber",
        "type": "int",
        "description": "Autonomous System (AS) number of the DUT (Device Under Test).",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "DutAsNumberStep",
        "type": "int",
        "description": "Increment step for DUT AS numbers.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Enable4ByteDutAs",
        "type": "bool",
        "description": "Enables 4-byte AS support for DUT.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Dut4ByteAsNumber",
        "type": "int",
        "description": "4-byte AS number for DUT.",
        "default": "1.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "Dut4ByteAsNumberStep",
        "type": "int",
        "description": "Increment step for 4-byte DUT AS numbers.",
        "default": "0.1",
        "range_or_options": "0.1-65535.65535"
      },
      {
        "name": "BgpType",
        "type": "str",
        "description": "Type of BGP session.",
        "default": "IBGP",
        "range_or_options": "EBGP IBGP"
      },
      {
        "name": "UseGatewayAsDutIp",
        "type": "bool",
        "description": "Uses gateway IP address as the DUT IP.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "BgpSessionIpAddressType",
        "type": "str",
        "description": "Type of IP address used for the BGP session.",
        "default": "INTERFACE_IP",
        "range_or_options": "INTERFACE_IP ROUTE_ID"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "IPv4 address of the DUT router ID (when not using gateway).",
        "default": "2.1.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DutIpv4AddressStep",
        "type": "str",
        "description": "Increment step for IPv4 DUT addresses.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DutIpv6Address",
        "type": "str",
        "description": "IPv6 address of the DUT router ID (when not using gateway).",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "DutIpv6AddressStep",
        "type": "str",
        "description": "Increment step for IPv6 DUT addresses.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "HoldTime",
        "type": "int",
        "description": "Hold time for BGP session in seconds.",
        "default": "90",
        "range_or_options": "3-65535"
      },
      {
        "name": "KeepaliveTime",
        "type": "int",
        "description": "Interval between keepalive messages in seconds.",
        "default": "30",
        "range_or_options": "1-65535"
      },
      {
        "name": "ConnectRetryCount",
        "type": "int",
        "description": "Number of retry attempts for reconnecting.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ConnectRetryInterval",
        "type": "int",
        "description": "Interval between reconnection attempts in seconds.",
        "default": "30",
        "range_or_options": "10-300"
      },
      {
        "name": "MaxRoutesPerUpdateMessage",
        "type": "int",
        "description": "Maximum number of routes per update message.",
        "default": "2000",
        "range_or_options": "10-300"
      },
      {
        "name": "RouteRefreshMode",
        "type": "str",
        "description": "Route refresh capability mode.",
        "default": "None",
        "range_or_options": "None Route Refresh"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables graceful restart for BGP.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RestartTime",
        "type": "int",
        "description": "Time for which the peer will wait for a restart before tearing down session.",
        "default": "90",
        "range_or_options": "3-4095"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables viewing of routing information.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Authentication",
        "type": "str",
        "description": "Authentication method used for BGP session.",
        "default": "None",
        "range_or_options": "None MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password for MD5 authentication.",
        "default": "xinertel",
        "range_or_options": "1-255 characters"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables Bidirectional Forwarding Detection (BFD) for fast failure detection.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSr",
        "type": "bool",
        "description": "Enables Segment Routing (SR) functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MiniLabel",
        "type": "int",
        "description": "Minimum label value used in SR.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "EnableExMsg",
        "type": "bool",
        "description": "Enables extended messages for BGP.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCustomize",
        "type": "bool",
        "description": "Enables custom configuration options.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AfiSubAfi",
        "type": "str",
        "description": "Address Family Identifier (AFI)/Sub-AFI for advanced routing.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableParseRxUpdateMsg",
        "type": "bool",
        "description": "Enables parsing of received update messages.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Edits the attributes of an existing BGP session object based on provided keyword arguments. This function allows dynamic updating of BGP session configurations such as IP versions, AS numbers, timers, authentication settings, and more.",
    "example": "| Edit Bgp | Session=${Session} | Name=NewSessionName | Enable=True | IpVersion=IPV4 | AsNumber=65000 | HoldTime=120 | KeepaliveTime=40"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv4_route_pool",
    "return_type": ":obj:`BgpIpv4RoutepoolConfig`",
    "return": "An object representing the created BGP IPv4 route pool configuration.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "The session object used to interact with the underlying API or system. This session must have a method called create_ipv4_route_pool.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "BGP IPv4 route name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the BGP IPv4 route.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SubAfi",
        "type": "str",
        "description": "Sub-AFI value for the route.",
        "default": "UNICAST",
        "range_or_options": "UNICAST MULTICAST VPN LABELED"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "ORIGIN value in the route attributes.",
        "default": "IGP",
        "range_or_options": "Incomplete IGP EGP"
      },
      {
        "name": "AsPath",
        "type": "int",
        "description": "AS Path value for the route.",
        "default": "not_found",
        "range_or_options": "1-255"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "AS Path type.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE CONFED_SEQUENCE CONFED_SET"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Uses the session address as the next hop.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLocalPref",
        "type": "bool",
        "description": "Enables Local Preference.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "LocalPref value when EnableLocalPref is True.",
        "default": "10",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMed",
        "type": "bool",
        "description": "Enables Multi Exit Discriminator.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Multi Exit Discriminator value when EnableMed is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AtomicAggregate",
        "type": "bool",
        "description": "Enables Atomic Aggregate.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableAggregator",
        "type": "bool",
        "description": "Enables Aggregator.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AggregatorAsNumber",
        "type": "int",
        "description": "Aggregator autonomous system number.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "AggregatorIp",
        "type": "str",
        "description": "Aggregator IP address.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enables Originator ID.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OriginatorId",
        "type": "str",
        "description": "Originator ID value.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "EnableClusterIdList",
        "type": "bool",
        "description": "Enables Cluster ID List.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ClusterIdList",
        "type": "str",
        "description": "Cluster ID List value.",
        "default": "",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "EnableCommunity",
        "type": "bool",
        "description": "Enables community settings.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CommunityType",
        "type": "str",
        "description": "Community type.",
        "default": "AA_NN",
        "range_or_options": "AA_NN NO_EXPORT NO_ADVERTISE LOCAL_AS"
      },
      {
        "name": "CommunityAsNumber",
        "type": "int",
        "description": "Community autonomous system number when CommunityType is AA:NN.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "CommunityId",
        "type": "int",
        "description": "Community ID when CommunityType is AA:NN.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Community",
        "type": "list",
        "description": "Community values.",
        "default": "[]",
        "range_or_options": "not_found"
      },
      {
        "name": "CommunityIncrement",
        "type": "list",
        "description": "Community increment steps.",
        "default": "[]",
        "range_or_options": "not_found"
      },
      {
        "name": "CommunityPerBlockCount",
        "type": "int",
        "description": "Number of communities per route block.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "ExtendedCommunity",
        "type": "list",
        "description": "Extended community values.",
        "default": "[]",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRd",
        "type": "str",
        "description": "VRF route distinguisher.",
        "default": "1:1",
        "range_or_options": "AS:Number or IPv4:Number"
      },
      {
        "name": "VrfRdStep",
        "type": "str",
        "description": "VRF route distinguisher step.",
        "default": "0:1",
        "range_or_options": "AS:Number or IPv4:Number"
      },
      {
        "name": "VrfRt",
        "type": "str",
        "description": "VRF route target.",
        "default": "100:1",
        "range_or_options": "AS:Number"
      },
      {
        "name": "VrfRtStep",
        "type": "str",
        "description": "VRF route target step.",
        "default": "0:1",
        "range_or_options": "AS:Number"
      },
      {
        "name": "VrfCount",
        "type": "int",
        "description": "Number of VRFs.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartingLabel",
        "type": "int",
        "description": "Starting label value.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "LabelType",
        "type": "str",
        "description": "Route label type.",
        "default": "Fixed",
        "range_or_options": "Fixed Incremental Explicit Null Implicit Null"
      },
      {
        "name": "FirstRoute",
        "type": "str",
        "description": "Initial IPv4 route value.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RandomRoute",
        "type": "bool",
        "description": "Generates random routes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes per session.",
        "default": "1",
        "range_or_options": "1-8000000"
      },
      {
        "name": "RouteStep",
        "type": "str",
        "description": "IPv4 route step size.",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "Ipv4RouteStep",
        "type": "int",
        "description": "IPv4 route step size as an integer.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "IPv4 route prefix length.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "NextHopAddrType",
        "type": "str",
        "description": "Next hop address type.",
        "default": "IPv4",
        "range_or_options": "IPv4 IPv6"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "Next hop address.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NextHopStep",
        "type": "str",
        "description": "Next hop step size.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "IPv6NextHop",
        "type": "str",
        "description": "IPv6 next hop address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "IPv6NextHopStep",
        "type": "str",
        "description": "IPv6 next hop step size.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables Link Local address as the next hop.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6LinkLocalNextHop",
        "type": "str",
        "description": "IPv6 Link Local next hop address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "Ipv6LinkLocalNextHopStep",
        "type": "str",
        "description": "IPv6 Link Local next hop step size.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EncodeSrTlvs",
        "type": "list",
        "description": "SR TLVs to encode.",
        "default": "[0]",
        "range_or_options": "LABEL_INDEX SRGB SRV6_VPN_SID SRV6_SERVICES"
      },
      {
        "name": "OverrideGlobalSrgb",
        "type": "bool",
        "description": "Overrides global SRGB settings.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SrgbBase",
        "type": "int",
        "description": "SRGB base value.",
        "default": "16000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "SrgbRange",
        "type": "int",
        "description": "SRGB range.",
        "default": "1000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "LabelIndex",
        "type": "int",
        "description": "Label index value.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LabelStep",
        "type": "int",
        "description": "Label step value.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Srv6SidInfoSubTlvType",
        "type": "int",
        "description": "SRv6 SID Information Sub TLV type.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6LocatorBlockLength",
        "type": "int",
        "description": "SRv6 Locator Block Length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "Srv6LocatorNodeLength",
        "type": "int",
        "description": "SRv6 Locator Node Length.",
        "default": "32",
        "range_or_options": "1-128"
      },
      {
        "name": "Srv6FuncLength",
        "type": "int",
        "description": "SRv6 Function Length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "Srv6FuncOpcode",
        "type": "str",
        "description": "SRv6 Function Opcode.",
        "default": "0",
        "range_or_options": "ff:ff:ff"
      },
      {
        "name": "Srv6ArguLength",
        "type": "int",
        "description": "SRv6 Argument Length.",
        "default": "32",
        "range_or_options": "1-128"
      },
      {
        "name": "Srv6Argument",
        "type": "str",
        "description": "SRv6 Argument value.",
        "default": "0",
        "range_or_options": "ff:ff:ff"
      },
      {
        "name": "EncodedSrv6ServiceDataSubTlvs",
        "type": "list",
        "description": "Encodes SRv6 Service Data Sub TLVs.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW SRV6_ID_STRUCTURE"
      },
      {
        "name": "Srv6TranspositionLength",
        "type": "int",
        "description": "SRv6 Transposition Length.",
        "default": "0",
        "range_or_options": "0-24"
      },
      {
        "name": "Srv6TranspositionOffset",
        "type": "int",
        "description": "SRv6 Transposition Offset.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "Srv6Locator",
        "type": "str",
        "description": "Authentication type used (None or MD5).",
        "default": "None",
        "range_or_options": "None MD5"
      },
      {
        "name": "Srv6LocatorStep",
        "type": "str",
        "description": "Authentication password.",
        "default": "xinertel",
        "range_or_options": "String of 1-255 characters"
      },
      {
        "name": "Srv6EndpointBehavior",
        "type": "str",
        "description": "SRv6 Endpoint Behavior.",
        "default": "CUSTOM",
        "range_or_options": "END_DX6 END_DX4 END_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DT2U END_DT2M CUSTOM"
      },
      {
        "name": "Srv6CustomEndpointBehavior",
        "type": "int",
        "description": "Custom SRv6 Endpoint Behavior.",
        "default": "0xFFFF",
        "range_or_options": "0x0-0xFFFF"
      }
    ],
    "description": "Creates a BGP IPv4 route pool configuration using the provided session and customizable parameters.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${Community} | Create List | AA_NN | NO_EXPORT | NO_ADVERTISE | LOCAL_AS |\n    | ${CommunityIncrement} | Create List | 1:1 | 1:2 | 1:3 | 1:4 |\n    | ${ExtendedCommunity} | Create List | 0x00:0x02:1:1 | 0x01:0x02:1:2 | 0x02:0x02:1:3 |\n    | ${RoutePool} | Create Bgp Ipv4 Route Pool | Session=${Session} | Community=${Community} | CommunityIncrement=${CommunityIncrement} | ExtendedCommunity=${ExtendedCommunity} |\n    | ${Community} | Create List | AA_NN | NO_EXPORT |\n    | ${CommunityIncrement} | Create List | 2:1 | 2:2 |\n    | Edit Configs | Configs=${RoutePool} | Community=${Community} | CommunityIncrement=${CommunityIncrement} | CommunityPerBlockCount=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv6_route_pool",
    "return_type": "BgpIpv6RoutepoolConfig",
    "return": "The created BGP IPv6 route pool configuration object.",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpRouter",
        "description": "A list of BGP protocol session objects used to associate the route pool with an active BGP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the BGP IPv6 route pool.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable or disable the BGP IPv6 route pool.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SubAfi",
        "type": "str",
        "description": "Sub-AFI value for the route pool, specifying the type of routes.",
        "default": "UNICAST",
        "range_or_options": "UNICAST MULTICAST VPN LABELED"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "ORIGIN attribute for the route, indicating where the route was learned.",
        "default": "IGP",
        "range_or_options": "Incomplete IGP EGP"
      },
      {
        "name": "AsPath",
        "type": "int",
        "description": "AS Path length for the route. This is a number between 0 and 255.",
        "default": "not_found",
        "range_or_options": "0-255"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Type of AS Path attribute used in the route.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE CONFED_SEQUENCE CONFED_SET"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Use the session address as the next hop for this route.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLocalPref",
        "type": "bool",
        "description": "Enable or disable Local Preference for this route.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "Local Preference value when enabled, which affects route selection preference.",
        "default": "10",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMed",
        "type": "bool",
        "description": "Enable or disable Multi Exit Discriminator (MED) for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Multi Exit Discriminator (MED) value when enabled, used for path selection.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AtomicAggregate",
        "type": "bool",
        "description": "Enable or disable the Atomic Aggregate attribute for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableAggregator",
        "type": "bool",
        "description": "Enable or disable the Aggregator attribute for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AggregatorAsNumber",
        "type": "int",
        "description": "Autonomous System number for the Aggregator attribute.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "AggregatorIp",
        "type": "str",
        "description": "IPv4 address for the Aggregator attribute.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enable or disable the Originator ID attribute for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OriginatorId",
        "type": "str",
        "description": "Originator ID value, typically an IPv4 address.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "EnableClusterIdList",
        "type": "bool",
        "description": "Enable or disable Cluster ID List for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ClusterIdList",
        "type": "str",
        "description": "Cluster ID List value, typically an IPv4 address.",
        "default": "",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "EnableCommunity",
        "type": "bool",
        "description": "Enable or disable community attributes for this route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CommunityType",
        "type": "str",
        "description": "Type of community attribute applied to the route.",
        "default": "AA:NN",
        "range_or_options": "AA:NN NO_EXPORT NO_ADVERTISE LOCAL_AS"
      },
      {
        "name": "CommunityAsNumber",
        "type": "int",
        "description": "AS number used when the community type is AA:NN.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Community",
        "type": "list",
        "description": "List of community values assigned to the route.",
        "default": "[]",
        "range_or_options": "AA_NN NO_EXPORT NO_ADVERTISE LOCAL_AS"
      },
      {
        "name": "CommunityIncrement",
        "type": "list",
        "description": "Community increment step values for route blocks.",
        "default": "[]",
        "range_or_options": "AA:NN"
      },
      {
        "name": "CommunityPerBlockCount",
        "type": "int",
        "description": "Number of communities per route block.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "ExtendedCommunity",
        "type": "list",
        "description": "Extended community attributes for the route.",
        "default": "[]",
        "range_or_options": "['0x00:0x02:1:1', '0x01:0x02:1:2', '0x02:0x02:1:3']"
      },
      {
        "name": "VrfRd",
        "type": "str",
        "description": "Route distinguisher for VRF routing.",
        "default": "1:1",
        "range_or_options": "AS:Number or IPv4:Number"
      },
      {
        "name": "VrfRdStep",
        "type": "str",
        "description": "Step increment for VRF route distinguisher.",
        "default": "0:1",
        "range_or_options": "AS:Number or IPv4:Number"
      },
      {
        "name": "VrfRt",
        "type": "str",
        "description": "Route target for VRF routing.",
        "default": "100:1",
        "range_or_options": "AS:Number"
      },
      {
        "name": "VrfRtStep",
        "type": "str",
        "description": "Step increment for VRF route target.",
        "default": "0:1",
        "range_or_options": "AS:Number"
      },
      {
        "name": "VrfCount",
        "type": "int",
        "description": "Number of VRF instances associated with the route pool.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartingLabel",
        "type": "int",
        "description": "Starting label value for labeled routing.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "LabelType",
        "type": "str",
        "description": "Type of label used in routing.",
        "default": "Fixed",
        "range_or_options": "Fixed Incremental Explicit Null Implicit Null"
      },
      {
        "name": "FirstIpv6Route",
        "type": "str",
        "description": "Starting IPv6 route address.",
        "default": "2000::1",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes generated per session.",
        "default": "1",
        "range_or_options": "1-8000000"
      },
      {
        "name": "RouteStep",
        "type": "str",
        "description": "Step increment for IPv6 route addresses.",
        "default": "'0:0:0:1::'",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "Ipv6RouteStep",
        "type": "int",
        "description": "Numerical step increment for IPv6 routes.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv6 routes.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "NextHopAddrType",
        "type": "str",
        "description": "Type of next hop address used (IPv4 or IPv6).",
        "default": "IPv4",
        "range_or_options": "IPv4 IPv6"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "Next hop IPv4 address for route forwarding.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "NextHopStep",
        "type": "str",
        "description": "Step increment for IPv4 next hop addresses.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "IPv6NextHop",
        "type": "str",
        "description": "IPv6 next hop address for route forwarding.",
        "default": "2000::1",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "IPv6NextHopStep",
        "type": "str",
        "description": "Step increment for IPv6 next hop addresses.",
        "default": "::1",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enable or disable using Link Local address as next hop.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6LinkLocalNextHop",
        "type": "str",
        "description": "IPv6 Link Local next hop address.",
        "default": "2000::1",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "Ipv6LinkLocalNextHopStep",
        "type": "str",
        "description": "Step increment for IPv6 Link Local next hop addresses.",
        "default": "::1",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "EncodeSrTlvs",
        "type": "list",
        "description": "List of Segment Routing TLVs to encode.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW SRV6_VPN_SID SRV6_SERVICES"
      },
      {
        "name": "OverrideGlobalSrgb",
        "type": "bool",
        "description": "Override global SRGB settings for Segment Routing.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SrgbBase",
        "type": "int",
        "description": "Base value for Segment Routing Global Block (SRGB).",
        "default": "16000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "SrgbRange",
        "type": "int",
        "description": "Range of Segment Routing Global Block (SRGB).",
        "default": "1000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "LabelIndex",
        "type": "int",
        "description": "Label index used in Segment Routing.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LabelStep",
        "type": "int",
        "description": "Label index increment step.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Srv6SidInfoSubTlvType",
        "type": "int",
        "description": "Type of SRv6 SID Information Sub-TLV.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6LocatorBlockLength",
        "type": "int",
        "description": "Length of the SRv6 Locator Block.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "Srv6LocatorNodeLength",
        "type": "int",
        "description": "Length of the SRv6 Locator Node.",
        "default": "32",
        "range_or_options": "1-128"
      },
      {
        "name": "Srv6FuncLength",
        "type": "int",
        "description": "Length of the SRv6 Function.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "Srv6FuncOpcode",
        "type": "str",
        "description": "Function Opcode for SRv6.",
        "default": "0",
        "range_or_options": "ff:ff:ff"
      },
      {
        "name": "Srv6ArguLength",
        "type": "int",
        "description": "Length of SRv6 arguments.",
        "default": "32",
        "range_or_options": "1-128"
      },
      {
        "name": "Srv6Argument",
        "type": "str",
        "description": "Arguments for SRv6 function.",
        "default": "0",
        "range_or_options": "ff:ff:ff"
      },
      {
        "name": "EncodedSrv6ServiceDataSubTlvs",
        "type": "list",
        "description": "List of SRv6 Service Data Sub-TLVs to encode.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW SRV6_ID_STRUCTURE"
      },
      {
        "name": "Srv6TranspositionLength",
        "type": "int",
        "description": "Length of SRv6 transposition data.",
        "default": "0",
        "range_or_options": "0-24"
      },
      {
        "name": "Srv6TranspositionOffset",
        "type": "int",
        "description": "Offset for SRv6 transposition data.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "Srv6Locator",
        "type": "str",
        "description": "Authentication method for SRv6 Locator.",
        "default": "None",
        "range_or_options": "None MD5"
      },
      {
        "name": "Srv6LocatorStep",
        "type": "str",
        "description": "Password for SRv6 Locator authentication.",
        "default": "xinertel",
        "range_or_options": "String (1-255 characters)"
      },
      {
        "name": "Srv6EndpointBehavior",
        "type": "str",
        "description": "Endpoint behavior for SRv6.",
        "default": "CUSTOM",
        "range_or_options": "END_DX6 END_DX4 END_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DT2U END_DT2M CUSTOM"
      },
      {
        "name": "Srv6CustomEndpointBehavior",
        "type": "int",
        "description": "Custom endpoint behavior for SRv6, specified as a hexadecimal number.",
        "default": "0xFFFF",
        "range_or_options": "0x0-0xFFFF"
      }
    ],
    "description": "Creates a BGP IPv6 route pool configuration object with the provided session and keyword arguments. This allows detailed control over BGP IPv6 route generation and behavior, including advanced features like Segment Routing and VRF configurations.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| ${Community} | Create List | AA_NN | NO_EXPORT | NO_ADVERTISE | LOCAL_AS |\n| ${CommunityIncrement} | Create List | 1:1 | 1:2 | 1:3 | 1:4 |\n| ${ExtendedCommunity} | Create List | 0x00:0x02:1:1 | 0x01:0x02:1:2 | 0x02:0x02:1:3 |\n| ${RoutePool} | Create Bgp Ipv6 Route Pool | Session=${Session} | Community=${Community} | CommunityIncrement=${CommunityIncrement} | ExtendedCommunity=${ExtendedCommunity} |\n| ${Community} | Create List | AA_NN | NO_EXPORT |\n| ${CommunityIncrement} | Create List | 2:1 | 2:2 |\n| Edit Configs | Configs=${RoutePool} | Community=${Community} | CommunityIncrement=${CommunityIncrement} | CommunityPerBlockCount=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.get_bgp_router_from_route_pool",
    "return_type": "list",
    "return": "A list of BGP routers (each being the source of either IPv4 or IPv6 route generation) corresponding to each configuration in `Configs`.",
    "parameters": [
      {
        "name": "Configs",
        "type": "object or iterable",
        "description": "A single configuration object or an iterable (list, set, tuple) of configuration objects. These objects are expected to have a method `get_relatives` which can retrieve related elements based on a relation name and direction.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of IP routes to consider. If set to 'ipv4', it will look for IPv4 route generators. If set to 'ipv6', it will look for IPv6 route generators.",
        "default": "'ipv4'",
        "range_or_options": "ipv4 ipv6"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the BGP routers associated with the given route configurations based on the specified IP version. This function checks the type of IP (IPv4 or IPv6) and finds the corresponding BGP router(s) that generate routes for the provided configuration objects. If `Configs` is not a list, set, or tuple, it will be converted into a list internally. The function uses the `get_relatives` method of each configuration object with the relation names 'GenerateIpv4Route' or 'GenerateIpv6Route' depending on the value of `Type`. The `direction` parameter used in `get_relatives` is always set to `EnumRelationDirection.SOURCE`, meaning it retrieves only the source routers that generate the routes.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${RouterPool} | Create Bgp Ipv4 Route Pool | Session=${Session} |\n    | ${Point} | Get Router From Route Pool | Configs=${RouterPool} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_capability",
    "return_type": ":obj:`BgpCapabilityConfig`",
    "return": "返回创建的 BGP Capability 对象，类型为 object。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "BGP协议会话对象列表，用于在其上创建BGP Capability。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "BGP Capability 的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该 BGP Capability。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CapabilityCode",
        "type": "int",
        "description": "Capability Code 值，用于标识特定的 BGP Capability 类型。",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "CapabilityValue",
        "type": "str",
        "description": "BGP Capability 的具体值，类型为字符串表示的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "此函数用于创建一个 BGP Capability 对象，并绑定到指定的会话(Session)上。它通过调用底层 Renix API 实现功能，并根据传入的参数及关键字参数配置 Capability 的各项属性。如果创建失败，将抛出异常 ContinuableFailure。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${CapabilityValue} | Create List | 1 | 2 | 3 | 4 | 5 |\n    | Create Bgp Capability | Session=${Session} | CapabilityCode=5 | CapabilityValue=${CapabilityValue} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_evpn_route_ad",
    "return_type": "object",
    "return": "An object representing the created BGP EVPN Ethernet Auto-Discovery (AD) route configuration, specifically of type `EvpnRouteAdConfig`.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "A list of BGP session objects (`BgpRouter`) used to establish and manage BGP protocol sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the BGP EVPN Ethernet Auto-Discovery route.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the BGP EVPN Ethernet Auto-Discovery route.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the ORIGIN attribute for the route.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "list",
        "description": "AS path value for the route, represented as a list of AS numbers.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "AdRouteType",
        "type": "str",
        "description": "Type of Ethernet Auto-Discovery route.",
        "default": "ESI",
        "range_or_options": "EVI ESI VPWS"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Uses the session address as the next hop address.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "IPv4 address used as the next hop.",
        "default": "100.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NextHopIpv6",
        "type": "str",
        "description": "IPv6 address used as the next hop.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables the use of IPv6 link-local address as the next hop.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str",
        "description": "IPv6 link-local address used as the next hop.",
        "default": "fe80::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enables the Originator ID for the route.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OriginatorId",
        "type": "str",
        "description": "IPv4 address used as the Originator ID.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "VRF route target in the format 'AS:Number'.",
        "default": "100:1",
        "range_or_options": "AS:Number"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Incremental step for VRF route target values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "VRF route distinguisher value in the format 'AS:Number' or 'IPv4:Number'.",
        "default": "10.0.0.2:1",
        "range_or_options": "AS:Number IPv4:Number"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Incremental step for VRF route distinguisher values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetSegmentType",
        "type": "str",
        "description": "Type of Ethernet segment.",
        "default": "OPERATOR",
        "range_or_options": "OPERATOR IEEE802 BRIDGEDLAN MACBASED ROUTEID AS"
      },
      {
        "name": "EthernetSegmentIdentifier",
        "type": "str",
        "description": "Identifier for the Ethernet segment.",
        "default": "OPERATOR",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetTagId",
        "type": "str",
        "description": "Ethernet tag ID, typically formatted as a colon-separated string.",
        "default": "00:00:00:00:00:00:00:00:00",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetTagIdStep",
        "type": "int",
        "description": "Step value for incrementing Ethernet tag IDs.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EthernetTagCountPerEvi",
        "type": "int",
        "description": "Number of Ethernet tags per EVI (Ethernet Virtual Instance).",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "ActiveStandbyMode",
        "type": "str",
        "description": "Sets the active/standby mode for redundancy.",
        "default": "SINGLE",
        "range_or_options": "ALL SINGLE"
      },
      {
        "name": "EviCount",
        "type": "int",
        "description": "Number of EVIs to create.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DataPlanEncapsulation",
        "type": "str",
        "description": "Specifies the data plane encapsulation method.",
        "default": "NONE",
        "range_or_options": "NONE VXLAN MPLS SRv6"
      },
      {
        "name": "Label1",
        "type": "int",
        "description": "Encapsulation label (e.g., VNI for VXLAN or VSID for MPLS).",
        "default": "100",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Label1Step",
        "type": "int",
        "description": "Step value for Label1 increments.",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "IncludeLayer2AttributeExtendedCommunity",
        "type": "bool",
        "description": "Whether to include Layer 2 extended community attributes (visible only for VPWS AD routes).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PBit",
        "type": "bool",
        "description": "P Bit - indicates primary PE in multi-homing single-active scenarios.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "BBit",
        "type": "bool",
        "description": "B Bit - indicates backup PE in multi-homing single-active scenarios.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CBit",
        "type": "bool",
        "description": "C Bit - when set, control word is required in EVPN packets sent to this PE.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "L2Mtu",
        "type": "bool",
        "description": "Specifies whether to set the L2 MTU (Maximum Transmission Unit).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCustomMplsLabel",
        "type": "bool",
        "description": "Enables the use of a custom MPLS label.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MplsLabel",
        "type": "int",
        "description": "Custom MPLS label value.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "MplsLabelStep",
        "type": "int",
        "description": "Step value for incrementing MPLS labels.",
        "default": "0",
        "range_or_options": "0-1048575"
      }
    ],
    "description": "This function creates a BGP EVPN Ethernet Auto-Discovery (AD) route using a provided session object. It allows flexible configuration of various BGP EVPN parameters through keyword arguments. This includes settings such as route origin, next hop addresses, encapsulation methods, Ethernet segment types, and more. The function delegates the actual creation logic to the underlying session object's implementation.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| Create Bgp Evpn Route Ad | Session=${Session} | EnableCustomMplsLabel=True | MplsLabel=1000 | MplsLabelStep=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.establish_bgp",
    "return_type": "bool",
    "return": "Returns True if all BGP sessions are successfully established, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "A single session object or an iterable (list, set, or tuple) containing multiple session objects that support the `establish()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Establishes BGP sessions for the provided session objects. This function takes one or more session objects and invokes the `establish()` method on each of them to establish BGP connectivity. If a single session is provided, it is converted into a list to ensure uniform processing. The function iterates through the list of sessions and calls the `establish()` method on each.",
    "example": "| Establish Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.connect_bgp",
    "return_type": "bool",
    "return": "True if the BGP connection initiation is successful for all provided sessions; False will raise an exception to indicate failure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or an iterable containing session objects. Each session must have a `connect()` method to establish a BGP connection.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function establishes BGP connections by invoking the `connect()` method on one or more provided session objects. It ensures consistent handling by converting a single session into a list internally and then iterating through each session to initiate the connection. If any session fails to connect, it raises an exception indicating the failure. Otherwise, it returns True to indicate success.",
    "example": ">>> api = RenixAPI()\n>>> session1 = SomeBGPSession(...)\n>>> session2 = SomeBGPSession(...)\n>>> api.connect_bgp(session1)\nTrue\n>>> api.connect_bgp([session1, session2])\nTrue"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.disconnect_bgp",
    "return_type": "bool",
    "return": "Returns True if all specified BGP sessions were successfully disconnected, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or an iterable of session objects representing the BGP sessions to be disconnected.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Disconnects one or more BGP sessions by calling the `disconnect()` method on each provided session object. The function handles both single session inputs and multiple session iterables uniformly by converting non-iterable input into a list before processing.",
    "example": "| Disconnect Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.advertise_bgp",
    "return_type": "bool",
    "return": "Returns True if the BGP route advertisement command was executed successfully, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "BgpSession or iterable of BgpSession",
        "description": "A single BGP session object or an iterable (list, set, tuple) of BGP session objects for which route advertisement should be triggered.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Advertises BGP routes for the given BGP session(s). This function takes one or more BGP session objects, collects their handles, and executes a command to advertise routes for those sessions. If a single session is provided, it is automatically wrapped into a list. The function internally uses `BgpAdvertiseRoutesCommand` to execute the route advertisement.",
    "example": "| Advertise Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.withdraw_bgp",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the command. Returns False if the underlying API call fails, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "BgpSession or iterable of BgpSession",
        "description": "A single BGP session object or an iterable (list, set, tuple) containing multiple BgpSession objects. Each session must have a 'handle' attribute used to identify the session block in the API.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Withdraws BGP routes associated with the specified BGP sessions. This function sends a command to withdraw routes for the given BGP sessions. The sessions can be provided as a single session object or as a collection (list, set, or tuple) of session objects. If a single session is passed, it is automatically wrapped into a list. This function internally constructs and executes a BgpWithdrawnRoutesCommand.",
    "example": "| Withdraw Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.advertise_bgp_route",
    "return_type": "bool",
    "return": "Returns True if the command was successfully executed; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Routes",
        "type": "BgpRoute or list[BgpRoute] or set[BgpRoute] or tuple[BgpRoute]",
        "description": "A single BGP route or an iterable (list, set, or tuple) of BGP routes to be advertised. Each route object must have a `handle` attribute that uniquely identifies the route block in the underlying system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Advertises one or more BGP routes using the underlying BGP protocol stack. This method acts as a wrapper around the `BgpRouter.advertise_route` class method. It takes either a single BGP route object or an iterable (list, set, or tuple) of BGP route objects and triggers the advertisement process. Internally, it ensures that the input is properly formatted and then executes the corresponding command to advertise the given routes.",
    "example": ".. code:: RobotFramework\n\n    | Advertise Bgp Route | Routes=${Routes} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.withdraw_bgp_route",
    "return_type": "bool",
    "return": "Returns True if the withdrawal command was successfully executed for all provided routes. If any error occurs during the operation, an exception may be raised.",
    "parameters": [
      {
        "name": "Routes",
        "type": "BgpRoute or list(BgpRoute) or set(BgpRoute) or tuple(BgpRoute)",
        "description": "A single route object or an iterable (list, set, or tuple) of route objects that should be withdrawn. Each route object must have a `handle` attribute that uniquely identifies the route in the BGP protocol context.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Withdraws one or more BGP routes from the BGP routing table. This function acts as a wrapper around the `BgpRouter.withdraw_route` method, enabling route withdrawal operations to be performed through the RenixAPI interface. When invoked, it sends a command to the BGP routing system to remove the specified routes from the routing table and inform peers that these routes are no longer available. It raises a ContinuableFailure exception if the underlying API returns False.",
    "example": ".. code:: RobotFramework\n\n    | Withdraw Bgp Route | Routes=${Routes} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.graceful_restart_bgp",
    "return_type": "bool",
    "return": "True if the graceful restart is initiated successfully on all provided sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "BgpRouter or iterable of BgpRouter",
        "description": "A single BGP session object or an iterable (list, set, tuple) of BGP session objects that support the graceful restart operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates a graceful restart of BGP sessions for the provided session object(s). It ensures that the restart is performed in a controlled manner, typically to allow session recovery without disrupting network traffic. The function internally calls the `graceful_restart()` method on each session object provided. If any session does not support this method, it may raise an AttributeError.",
    "example": "| Graceful Restart Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.refresh_bgp",
    "return_type": "bool",
    "return": "True if the refresh operation is successfully executed for all provided BGP sessions; otherwise, False (which raises a ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "BgpRouter or iterable of BgpRouter objects",
        "description": "A single BGP session object or an iterable (e.g., list, set, tuple) containing one or more BgpRouter session objects to be refreshed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Refreshes the state of one or more BGP session(s) by calling their `refresh()` method. This function ensures uniform processing by converting single session inputs into a list-like structure and then iterating over all provided sessions. If any session fails to refresh, a ContinuableFailure is raised. Otherwise, it returns True upon successful execution.",
    "example": "| Refresh Bgp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.wait_bgp_state",
    "return_type": "bool",
    "return": "Returns True if the BGP protocol state reaches the specified target within the timeout; otherwise, False (which raises a ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of session objects",
        "description": "A single session object or an iterable (e.g., list, set, tuple) representing BGP sessions. If multiple sessions are provided, the first one determines which attribute to monitor.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The expected BGP protocol state to wait for. If None, defaults to 'RUNNING'. Comparison is case-insensitive. Supported values: DISABLED, NOT_START, RUNNING, STARTING, STOPPING.",
        "default": "'RUNNING'",
        "range_or_options": "DISABLED NOT_START RUNNING STARTING STOPPING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval (in seconds) between successive checks of the BGP protocol state.",
        "default": "1",
        "range_or_options": ">=1"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for the BGP protocol to reach the desired state. Raises ContinuableFailure if exceeded.",
        "default": "60",
        "range_or_options": ">=1"
      }
    ],
    "kwargs": [],
    "description": "Waits until the BGP protocol state associated with the given session(s) reaches a specified target state. Internally, this function calls `_wait_state` and selects the appropriate attribute ('BgpProtocolState' for `BgpProtocolConfig` type or generic 'State' for others) to monitor. The function polls at the specified interval until either the target state is reached or the timeout is exceeded.",
    "example": "| Wait Bgp State | Sessions=${Sessions} | State=RUNNING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.wait_bgp_router_state",
    "return_type": "bool",
    "return": "Returns True if all specified BGP sessions reach one of the expected states within the timeout period. If any session fails to reach an expected state within the timeout, a Failure exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list/set/tuple of objects",
        "description": "A single session object or a collection of session objects representing BGP routers. Each session should have attributes such as IpVersion and either Ipv4RouterState/Ipv6RouterState or BgpV4RouterState/BgpV6RouterState depending on the IP version in use.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list/set/tuple of str, optional",
        "description": "The expected router state(s) that the function will wait for. If multiple states are provided, each session must reach at least one of these states. Supported values: 'NOT_START', 'IDLE', 'CONNECT', 'ACTIVE', 'OPEN_SENT', 'OPEN_CONFIRM', 'ESTABLISHED'.",
        "default": "'ESTABLISHED'",
        "range_or_options": "'NOT_START' 'IDLE' 'CONNECT' 'ACTIVE' 'OPEN_SENT' 'OPEN_CONFIRM' 'ESTABLISHED'"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "The time interval (in seconds) between consecutive state checks.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "The maximum time (in seconds) to wait for all sessions to reach the desired state(s). If the timeout is reached before all sessions reach the desired state, a TesterException is raised.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until all specified BGP sessions (IPv4 or IPv6) reach one of the desired states, or raises an exception if the timeout is exceeded. This function continuously polls the current state of each session at defined intervals and verifies whether it matches any of the target states.",
    "example": ".. code:: RobotFramework\n\n    | Wait Bgp Router State | Sessions=${Sessions} | State=ESTABLISHED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.wait_bgp_ipv4_router_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach the desired state within the timeout period; otherwise, it raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A session object or a collection of session objects whose router state will be monitored. The function determines whether these are BGP or IPv4 router sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state to wait for in each session. If not specified, defaults to 'ESTABLISHED'. Comparison is case-insensitive.",
        "default": "'ESTABLISHED'",
        "range_or_options": "'NOT_START' 'IDLE' 'CONNECT' 'ACTIVE' 'OPEN_SENT' 'OPEN_CONFIRM' 'ESTABLISHED'"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired state before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the BGP or IPv4 router state of each session in 'Sessions' reaches the specified target state. This function supports both BGP and IPv4 sessions. For BGP sessions, it monitors the 'BgpV4RouterState' attribute, while for IPv4 sessions, it monitors the 'Ipv4RouterState' attribute. It polls at regular intervals defined by 'Interval' and waits up to 'TimeOut' seconds. If all sessions reach the desired state within the timeout, it returns True; otherwise, a TesterException is raised.",
    "example": "| Wait Bgp IPv4 Router State | Sessions=${Sessions} | State=ESTABLISHED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.wait_bgp_ipv6_router_state",
    "return_type": "bool",
    "return": "Returns True if all BGP IPv6 sessions reach one of the expected states within the timeout; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A session object or a list of session objects representing BGP IPv6 routers whose state needs to be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list, optional",
        "description": "The target state(s) that each session's router should reach. If not provided, defaults to 'ESTABLISHED'.",
        "default": "'ESTABLISHED'",
        "range_or_options": "'NOT_START' 'IDLE' 'CONNECT' 'ACTIVE' 'OPEN_SENT' 'OPEN_CONFIRM' 'ESTABLISHED'"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Time interval (in seconds) between successive checks for the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the desired state before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the BGP IPv6 router state of each session in 'Sessions' reaches a specified target state. The function internally determines whether the session is of type BgpProtocolConfig and monitors either 'BgpV6RouterState' or 'Ipv6RouterState' accordingly. It polls the state at regular intervals until all sessions are in one of the expected states or the timeout is reached.",
    "example": "| Wait Bgp IPv6 Router State | Sessions=${Sessions} | State=ESTABLISHED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_route_pool_custom_path_attribute",
    "return_type": "BgpPathAttributeConfig or list",
    "return": "返回一个配置好的BGP路径属性对象（BgpPathAttributeConfig）或其列表，具体取决于输入的RoutePool是单个对象还是多个对象。",
    "parameters": [
      {
        "name": "RoutePool",
        "type": "object or iterable (e.g., list, set, tuple)",
        "description": "指定要为其创建自定义BGP路径属性的一个或多个BgpIpv4RoutepoolConfig对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PathAttributeType",
        "type": "int",
        "description": "指定路径属性的类型编号。取值范围为1到255。",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "OptionalFlag",
        "type": "str",
        "description": "指定路径属性的Optional Flag值。",
        "default": "OPTION",
        "range_or_options": "WELL_KNOWN OPTION"
      },
      {
        "name": "TransitiveFlag",
        "type": "str",
        "description": "指定路径属性的Transitive Flag值。",
        "default": "NONTRANSITIVE",
        "range_or_options": "NONTRANSITIVE TRANSITIVE"
      },
      {
        "name": "PartialFlag",
        "type": "str",
        "description": "指定路径属性的Partial Flag值。",
        "default": "PARTIAL",
        "range_or_options": "COMPLETE PARTIAL"
      },
      {
        "name": "ExtendedLengthFlag",
        "type": "bool",
        "description": "是否启用扩展长度标志。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AttributeExtendedLength",
        "type": "int",
        "description": "指定路径属性的扩展长度值。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "AttributeValue",
        "type": "str",
        "description": "指定路径属性的值，通常是一个十六进制字符串。",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于为一个或多个BGP路由池（BgpIpv4RoutepoolConfig）创建并配置自定义的BGP路径属性（BgpPathAttributeConfig）。它允许设置路径属性的各种标志和值，并确保每个路由池都应用相同的配置参数。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${RoutePool} | Create Bgp Ipv4 Route Pool | Session=${Session} |\n    | ${AttributeValue} | Set Variable | 0500220001001E00AAAA000100010001000000000000000100001300010006301014000000 |\n    | Create Bgp Route Pool Custom Path Attribute | RoutePool=${RoutePool} | AttributeValue=${AttributeValue} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_evpn_mac_ip_routes",
    "return_type": "object or list of EvpnRouteMacIpConfig",
    "return": "Returns a configuration object (`EvpnRouteMacIpConfig`) representing the created BGP EVPN MAC-IP routes for one or more sessions. If multiple sessions are provided, returns a list of such objects.",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpRouter or iterable (list, tuple, set)",
        "description": "A single session object or an iterable containing multiple session objects for which BGP EVPN MAC-IP routes will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the ORIGIN attribute value in the route. Used to indicate the origin of the route.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for the route. Used to record the sequence of ASes through which the route has passed.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Determines whether to use the session address as the next hop address in the UPDATE message.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str (IPv4)",
        "description": "The next hop IPv4 address in the BGP UPDATE message.",
        "default": "100.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "NextHopIpv6",
        "type": "str (IPv6)",
        "description": "The next hop IPv6 address in the BGP UPDATE message.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables the use of IPv6 link-local next hop address.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str (IPv6)",
        "description": "The IPv6 link-local next hop address.",
        "default": "fe80::1",
        "range_or_options": "valid IPv6 link-local address"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enables the Originator ID attribute when simulating a BGP route reflector.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OriginatorId",
        "type": "str (IPv4)",
        "description": "Specifies the Originator ID used to identify the source router of the route.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Specifies the starting VRF route target value for route filtering and distribution.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Specifies the step increment for VRF route target values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Specifies the starting VRF route distinguisher value for route separation.",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Specifies the step increment for VRF route distinguisher values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetSegmentType",
        "type": "str",
        "description": "Specifies the type of Ethernet segment identifier used to format the identifier.",
        "default": "OPERATOR",
        "range_or_options": "OPERATOR IEEE802 BRIDGEDLAN MACBASED ROUTEID AS"
      },
      {
        "name": "EthernetSegmentIdentifier",
        "type": "str",
        "description": "Specifies the CE-PE connection identifier for multi-homing scenarios.",
        "default": "00:00:00:00:00:00:00:00:00",
        "range_or_options": "valid Ethernet Segment Identifier"
      },
      {
        "name": "EthernetTagId",
        "type": "int",
        "description": "Specifies the broadcast domain identifier (e.g., VLAN ID).",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "NetWorkCount",
        "type": "int",
        "description": "Specifies the number of network entries to create.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartMacAddress",
        "type": "str",
        "description": "Specifies the starting MAC address for route blocks.",
        "default": "00:10:01:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "MacIncrement",
        "type": "str",
        "description": "Specifies the MAC address increment step between consecutive routes.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "EviCount",
        "type": "int",
        "description": "Specifies the number of EVPN instances (EVIs) to create.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "VpnDistributionType",
        "type": "str",
        "description": "Specifies how RTs, RDs, and VNIs are distributed across VPNs.",
        "default": "ROUNDROBIN",
        "range_or_options": "ROUNDROBIN LINEAR"
      },
      {
        "name": "AssociatedIpType",
        "type": "str",
        "description": "Specifies the IP version (IPv4/IPv6) associated with host routes.",
        "default": "IPV4",
        "range_or_options": "NONE IPV4 IPV6"
      },
      {
        "name": "DataPlanEncapsulation",
        "type": "str",
        "description": "Specifies the data plane encapsulation header type.",
        "default": "NONE",
        "range_or_options": "NONE VXLAN MPLS SRv6"
      },
      {
        "name": "EnableMacMobility",
        "type": "bool",
        "description": "Enables MAC address mobility support.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "StickyStatic",
        "type": "bool",
        "description": "Indicates whether the MAC address is static.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Specifies the starting sequence number for MAC mobility extended community TLV.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Label1",
        "type": "int",
        "description": "Specifies the encapsulation label (VNI/VSID) for Layer 2 traffic.",
        "default": "0",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Label1Step",
        "type": "int",
        "description": "Specifies the step increment for Label1 values.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "StartIpv4Address",
        "type": "str",
        "description": "Specifies the starting IPv4 address for route advertisements.",
        "default": "100.0.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4Increment",
        "type": "str",
        "description": "Specifies the IPv4 address increment step.",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "Specifies the prefix length for IPv4 addresses.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "StartIpv6Address",
        "type": "str",
        "description": "Specifies the starting IPv6 address for route advertisements.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6Increment",
        "type": "str",
        "description": "Specifies the IPv6 address increment step.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "Specifies the prefix length for IPv6 addresses.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "EnableLabel2",
        "type": "bool",
        "description": "Enables the second MPLS label (L3 VNI).",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Label2",
        "type": "int",
        "description": "Specifies the second MPLS label (L3 VNI) for Layer 3 traffic.",
        "default": "2000",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Label2Step",
        "type": "int",
        "description": "Specifies the step increment for Label2 values.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "EnableIncludeRouterMac",
        "type": "bool",
        "description": "Determines whether to include the router's MAC address in the route advertisement.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterMac",
        "type": "str",
        "description": "Specifies the router's MAC address to include in the route advertisement.",
        "default": "00:00:00:00:00:00",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "EnableIncludeDefaultGateway",
        "type": "bool",
        "description": "Specifies whether to include a default gateway in the route advertisement.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableCustomMplsLabel",
        "type": "bool",
        "description": "Enables custom MPLS label assignment.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MplsLabel",
        "type": "int",
        "description": "Specifies a custom MPLS label value.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "MplsLabelStep",
        "type": "int",
        "description": "Specifies the step increment for custom MPLS label values.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "EnableCustomMplsLabel2",
        "type": "bool",
        "description": "Enables custom second MPLS label assignment.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MplsLabel2",
        "type": "int",
        "description": "Specifies a custom second MPLS label value.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "MplsLabel2Step",
        "type": "int",
        "description": "Specifies the step increment for custom second MPLS label values.",
        "default": "0",
        "range_or_options": "1-1048575"
      }
    ],
    "description": "This function creates BGP EVPN MAC-IP routes for one or more BGP sessions. It wraps the session-level `create_evpn_mac_ip_routes` method and supports both single and multiple session configurations. All parameters except 'Session' are optional keyword arguments that configure various aspects of the routes, including next hop settings, route targets, MAC/IP assignments, and advanced features like MAC mobility and custom labels.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | Create Bgp Evpn Mac Ip Routes | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_evpn_inclusive_multicast_routes",
    "return_type": "object or list",
    "return": "Returns an `EvpnRouteInclusiveMulticastConfig` object or a list of such objects depending on the number of input sessions. Each object represents the created BGP EVPN inclusive multicast route configuration.",
    "parameters": [
      {
        "name": "Session",
        "type": "object / list",
        "description": "BGP protocol session object or a collection (list, set, tuple) of session objects. Each session must have a method to create EVPN inclusive multicast routes.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the ORIGIN attribute value in the BGP route. This indicates where the route was learned from.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for the BGP route. Used to represent the path of autonomous systems that the route has passed through.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Determines whether the session address should be used as the next hop address in the BGP UPDATE message.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str (valid IPv4)",
        "description": "IPv4 address to be used as the NEXT_HOP in the BGP UPDATE message.",
        "default": "100.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHopIpv6",
        "type": "str (valid IPv6)",
        "description": "IPv6 address to be used as the NEXT_HOP in the BGP UPDATE message.",
        "default": "2001::1",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables the use of IPv6 link-local address as the next hop.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str (valid IPv6 link-local)",
        "description": "IPv6 link-local next hop address used when EnableLinkLocalNextHop is True.",
        "default": "fe80::1",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enables the Originator ID attribute, typically used by BGP route reflectors to identify the source of a reflected route.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OriginatorId",
        "type": "str (valid IPv4)",
        "description": "IPv4 address identifying the originator of the route, used when EnableOriginatorId is True.",
        "default": "192.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Specifies the starting value for the VRF route target extended community attribute.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Specifies the step increment for the VRF route target values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Specifies the starting value for the VRF route distinguisher.",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Specifies the step increment for the VRF route distinguisher values.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "EviCount",
        "type": "int",
        "description": "Number of EVPN instances (EVIs) to be configured.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EthernetTagId",
        "type": "int",
        "description": "Ethernet Tag ID associated with the EVPN route.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PmsiTunnelType",
        "type": "str",
        "description": "Specifies the type of tunnel used for multicast traffic. Only 'INGRESS_REPLICATION' is supported.",
        "default": "INGRESS_REPLICATION",
        "range_or_options": "INGRESS_REPLICATION"
      },
      {
        "name": "DataPlanEncapsulation",
        "type": "str",
        "description": "Specifies the data plane encapsulation used for forwarding traffic.",
        "default": "NONE",
        "range_or_options": "NONE VXLAN MPLS SRv6"
      },
      {
        "name": "Label1",
        "type": "int",
        "description": "Starting value for the encapsulation label (e.g., VNI/VSID) used with VXLAN encapsulation.",
        "default": "0",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Label1Step",
        "type": "int",
        "description": "Step increment for Label1 values.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "EnableCustomMplsLabel",
        "type": "bool",
        "description": "Enables the use of custom MPLS labels.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MplsLabel",
        "type": "int",
        "description": "MPLS label value used if EnableCustomMplsLabel is True.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "MplsLabelStep",
        "type": "int",
        "description": "Step increment for the MPLS label values.",
        "default": "0",
        "range_or_options": "1-1048575"
      }
    ],
    "description": "This function creates BGP EVPN inclusive multicast route configurations for one or more provided BGP sessions. It wraps the internal `create_evpn_inclusive_multicast_routes` method of each session object and provides consistent handling across multiple sessions. The return value depends on the number of sessions: a single result is returned for one session, and a list of results is returned for multiple sessions.",
    "example": ".. code:: RobotFramework\n\n     | ${Session} | Create Bgp | Port=${Port} |\n     | Create Bgp Evpn Inclusive Multicast Routes | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_evpn_ethernet_segment_routes",
    "return_type": "object or list",
    "return": "返回创建的BGP EVPN Ethernet Segment路由配置对象或对象列表，类型为`EvpnRouteEthernetSegmentConfig`。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (list, set, tuple)",
        "description": "提供一个会话对象或多个会话对象（如BgpRouter实例）用于创建BGP EVPN Ethernet Segment路由。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Origin",
        "type": "str",
        "description": "指定BGP路由的ORIGIN属性值。",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "指定BGP路由的AS路径值。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "是否使用BGP会话地址作为下一跳地址。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str (IPv4 address)",
        "description": "指定IPv4下一跳地址（NEXT_HOP字段）。",
        "default": "100.0.0.1",
        "range_or_options": "有效的IPv4地址"
      },
      {
        "name": "NextHopIpv6",
        "type": "str (IPv6 address)",
        "description": "指定IPv6下一跳地址（NEXT_HOP字段）。",
        "default": "2001::1",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "是否启用IPv6链路本地下一跳。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str (IPv6 link-local address)",
        "description": "指定IPv6链路本地下一跳地址。",
        "default": "fe80::1",
        "range_or_options": "有效的IPv6链路本地地址"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "是否启用Originator ID属性（通常用于路由反射器场景）。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OriginatorId",
        "type": "str (IPv4 address)",
        "description": "指定Originator ID值，用于标识路由发起者的router id。",
        "default": "192.0.0.1",
        "range_or_options": "有效的IPv4地址"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "指定VRF路由目标起始值。",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "指定VRF路由目标的步长。",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "指定VRF路由标识符起始值。",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "指定VRF路由标识符的步长。",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetSegmentType",
        "type": "str",
        "description": "指定以太网段类型。",
        "default": "OPERATOR",
        "range_or_options": "OPERATOR IEEE802 BRIDGEDLAN MACBASED ROUTEID AS"
      },
      {
        "name": "EthernetSegmentIdentifier",
        "type": "str",
        "description": "指定以太网段标识符（ESI）。",
        "default": "00:00:00:00:00:00:00:00:00",
        "range_or_options": "not_found"
      },
      {
        "name": "EviCount",
        "type": "int",
        "description": "指定要创建的EVPN实例（EVI）数量。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DataPlanEncapsulation",
        "type": "str",
        "description": "指定数据平面封装方式。",
        "default": "NONE",
        "range_or_options": "NONE VXLAN MPLS SRv6"
      },
      {
        "name": "EsImportRoute",
        "type": "str (MAC address)",
        "description": "指定导入的ES导入路由的MAC地址。",
        "default": "00:00:00:00:00:00",
        "range_or_options": "有效的MAC地址"
      }
    ],
    "description": "该函数用于在给定的一个或多个BGP会话上创建BGP EVPN Ethernet Segment路由。它将参数传递给底层会话对象的create_evpn_ethernet_segment_routes方法，并返回对应的配置对象。如果传入单个会话，则返回单个配置对象；如果传入多个会话，则返回配置对象列表。",
    "example": "RobotFramework 示例：\n\n| ${Session} | Create Bgp | Port=${Port} |\n| Create Bgp Evpn Ethernet Segment Routes | Session=${Session} | Origin=IGP | AsPath=100 | EthernetSegmentType=OPERATOR | EthernetSegmentIdentifier=00:00:00:00:00:00:00:00:01 | EviCount=2"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_evpn_ip_prefix_routes",
    "return_type": "object or list of EvpnRouteIpPrefixConfig",
    "return": "Returns a configuration object or a list of configuration objects for BGP EVPN IP prefix routes created on the provided session(s).",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpRouter or iterable (list, set, tuple)",
        "description": "A single BGP session object or an iterable of session objects representing BGP routers. Each session must have a method `create_evpn_ip_prefix_routes` that creates EVPN IP prefix routes on that session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the ORIGIN attribute in BGP route updates.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for the routes.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "If True, uses the session address as the next hop in route updates.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "ipv4 address",
        "description": "IPv4 address to be used as the next hop in BGP UPDATE messages.",
        "default": "100.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "NextHopIpv6",
        "type": "ipv6 address",
        "description": "IPv6 address to be used as the next hop in BGP UPDATE messages.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables use of IPv6 link-local next hop addresses.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "ipv6 address",
        "description": "IPv6 link-local next hop address.",
        "default": "fe80::1",
        "range_or_options": "valid IPv6 link-local address"
      },
      {
        "name": "EnableOriginatorId",
        "type": "bool",
        "description": "Enables the Originator ID attribute when acting as a BGP route reflector.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OriginatorId",
        "type": "ipv4 address",
        "description": "Specifies the originator ID, which identifies the router that originated the route.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Start value for VRF route target.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Step increment for VRF route targets.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Start value for VRF route distinguisher.",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Step increment for VRF route distinguishers.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetSegmentType",
        "type": "str",
        "description": "Type of Ethernet segment identifier used.",
        "default": "OPERATOR",
        "range_or_options": "OPERATOR IEEE802 BRIDGEDLAN MACBASED ROUTEID AS"
      },
      {
        "name": "EthernetSegmentIdentifier",
        "type": "str",
        "description": "Identifier for the connection between CE and PE devices.",
        "default": "00:00:00:00:00:00:00:00:00",
        "range_or_options": "not_found"
      },
      {
        "name": "EthernetTagId",
        "type": "int",
        "description": "Identifies the broadcast domain such as VLAN ID.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "NetWorkCount",
        "type": "int",
        "description": "Number of networks to create.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EviCount",
        "type": "int",
        "description": "Number of EVPN instances (EVIs) to create.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "VpnDistributionType",
        "type": "str",
        "description": "Allocation strategy for RT, RD, and VNI values across VPNs.",
        "default": "ROUNDROBIN",
        "range_or_options": "ROUNDROBIN LINEAR"
      },
      {
        "name": "DataPlanEncapsulation",
        "type": "str",
        "description": "Type of encapsulation header used for payload.",
        "default": "NONE",
        "range_or_options": "NONE VXLAN MPLS SRv6"
      },
      {
        "name": "EnableCustomMplsLabel",
        "type": "bool",
        "description": "Enables custom MPLS label assignment.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Label1",
        "type": "int",
        "description": "Starting value for layer 2 traffic encapsulation label (e.g., VNI/VSID).",
        "default": "0",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Label1Step",
        "type": "int",
        "description": "Increment step for Label1.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "IpType",
        "type": "str",
        "description": "IP version type for the routes.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "StartIpv4Address",
        "type": "ipv4 address",
        "description": "Starting IPv4 address for route creation.",
        "default": "100.0.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4Increment",
        "type": "ipv4 address",
        "description": "Increment value for IPv4 addresses.",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "IPv4 prefix length.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "GatewayIp",
        "type": "ipv4 address",
        "description": "IPv4 gateway address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "StartIpv6Address",
        "type": "ipv6 address",
        "description": "Starting IPv6 address for route creation.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6Increment",
        "type": "ipv6 address",
        "description": "Increment value for IPv6 addresses.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "IPv6 prefix length.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "GatewayIpv6",
        "type": "ipv6 address",
        "description": "IPv6 gateway address.",
        "default": "::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableIncludeRouterMac",
        "type": "bool",
        "description": "Determines whether to include the router's MAC address in routes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterMac",
        "type": "mac address",
        "description": "MAC address of the router.",
        "default": "00:00:00:00:00:00",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "MplsLabel",
        "type": "int",
        "description": "MPLS label value.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "MplsLabelStep",
        "type": "int",
        "description": "Increment step for MPLS labels.",
        "default": "0",
        "range_or_options": "1-1048575"
      }
    ],
    "description": "This function creates BGP EVPN IP prefix routes on one or more BGP session objects. It abstracts the route creation process by delegating to each session's internal `create_evpn_ip_prefix_routes` method with the provided parameters. If a single session is provided, it is internally converted into a list. The result is either a single configuration object or a list of them, depending on the number of sessions processed.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| Create Bgp Evpn Ip Prefix Routes | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv4_vpls",
    "return_type": "object or list",
    "return": "BGP IPv4 VPLS configuration object(s), either a single object or a list of objects depending on the input session(s).",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "BGP protocol session object(s) on which to create the IPv4 VPLS configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for BGP routes.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Type of AS Path used in route advertisement.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE CONFED_SEQUENCE CONFED_SET"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Whether to use the session address as the next hop address.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str (valid IPv4)",
        "description": "The next hop address to be used in the BGP UPDATE message.",
        "default": "100.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Multi-Exit Discriminator attribute to influence incoming route selection.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LocalPreference",
        "type": "int",
        "description": "Local preference attribute to influence outbound route selection.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "VeId",
        "type": "int",
        "description": "VPLS endpoint identifier.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "VeIdStep",
        "type": "int",
        "description": "Increment step for VeId across multiple configurations.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockOffset",
        "type": "int",
        "description": "Offset value for block-based VeId allocation.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockOffsetStep",
        "type": "int",
        "description": "Increment step for BlockOffset across configurations.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockSize",
        "type": "int",
        "description": "Number of VeIds allocated per block.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "MtuSize",
        "type": "int",
        "description": "Maximum Transmission Unit size for VPLS packets.",
        "default": "1500",
        "range_or_options": "64-9000"
      },
      {
        "name": "EncapType",
        "type": "str",
        "description": "Encapsulation type used for VPLS traffic.",
        "default": "VLAN",
        "range_or_options": "VLAN ETHERNET VPLS"
      },
      {
        "name": "ControlFlag",
        "type": "int",
        "description": "Decimal representation of control flags for VPLS signaling.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Route target extended community for importing/exporting VRF routes.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Increment step for VrfRouteTarget across configurations.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Route distinguisher for uniquely identifying VRF routes.",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Increment step for VrfRouteDistinguisher across configurations.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfCount",
        "type": "int",
        "description": "Number of VRFs to be configured.",
        "default": "1",
        "range_or_options": "1-65535"
      }
    ],
    "description": "Creates an IPv4 VPLS configuration over one or more BGP sessions. This function wraps the underlying `create_ipv4_vpls` method of each session object, allowing uniform configuration across multiple sessions by abstracting iteration and result aggregation.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | Create Bgp Ipv4 Vpls | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv6_vpls",
    "return_type": "object or list",
    "return": "The created BGP IPv6 VPLS configuration object(s), matching the input session(s). If a single session is provided, returns one `BgpIpv6VplsConfig` object. If multiple sessions are provided, returns a list of such objects.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (list, set, tuple)",
        "description": "A BGP protocol session object or an iterable containing multiple session objects for which IPv6 VPLS configurations are to be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for the BGP route.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Determines whether to use the session address as the next hop address in the UPDATE message.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str (valid IPv6 address)",
        "description": "The next hop address used in the UPDATE message's NEXT_HOP field.",
        "default": "2000::1",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str (valid link-local IPv6 address)",
        "description": "The link-local next hop address used in the UPDATE message.",
        "default": "fe80::1",
        "range_or_options": "not_found"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "The Multi-Exit Discriminator (MED) attribute to influence inbound traffic from neighboring ASes.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LocalPreference",
        "type": "int",
        "description": "The Local Preference attribute that determines the preferred route within the same AS.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "VeId",
        "type": "int",
        "description": "Virtual Ethernet ID used for identifying VPLS instances.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "VeIdStep",
        "type": "int",
        "description": "Increment step for VeId when multiple configurations are generated.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockOffset",
        "type": "int",
        "description": "Offset for the block number used in VPLS label assignment.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockOffsetStep",
        "type": "int",
        "description": "Increment step for BlockOffset when generating multiple configurations.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "BlockSize",
        "type": "int",
        "description": "Size of the block used in VPLS label assignment.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "MtuSize",
        "type": "int",
        "description": "Maximum Transmission Unit size for VPLS packets.",
        "default": "1500",
        "range_or_options": "64-65535"
      },
      {
        "name": "EncapType",
        "type": "str",
        "description": "Encapsulation type for VPLS traffic.",
        "default": "VLAN",
        "range_or_options": "VLAN ETHERNET VPLS"
      },
      {
        "name": "EnableRfc4761",
        "type": "bool",
        "description": "Enables RFC 4761-based signaling for VPLS control plane.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "ControlFlag",
        "type": "int",
        "description": "Control flag associated with VPLS operations, represented in decimal.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "StripVlan",
        "type": "bool",
        "description": "Determines whether to strip VLAN tags before forwarding packets.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "VeFlooding",
        "type": "bool",
        "description": "Enables flooding of unknown unicast and multicast traffic in the VPLS instance.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Specifies the starting value for the VRF route target.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Specifies the increment step for the VRF route target when generating multiple configurations.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Specifies the starting value for the VRF route distinguisher.",
        "default": "10.0.0.2:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Specifies the increment step for the VRF route distinguisher when generating multiple configurations.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfCount",
        "type": "int",
        "description": "Number of VRFs to create for this VPLS configuration.",
        "default": "1",
        "range_or_options": "1-65535"
      }
    ],
    "description": "Creates an IPv6 VPLS (Virtual Private LAN Service) configuration for one or more BGP sessions. This function wraps the underlying `create_ipv6_vpls` method of each session object and uniformly applies the provided configuration parameters across all given sessions. It supports both single session and multiple session inputs.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | Create Bgp Ipv6 Vpls | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv4_flow_specs",
    "return_type": "object or list",
    "return": "Returns a BgpIpv4FlowSpecConfig object or a list of such objects corresponding to the created IPv4 flow specifications for each session.",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpRouter or iterable of BgpRouter",
        "description": "A single BGP protocol session object or an iterable (list, set, tuple) containing multiple session objects for which IPv4 flow specifications will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes to be configured in the flow specification.",
        "default": "1",
        "range_or_options": "1-8000000"
      },
      {
        "name": "FlowSpecSubAfi",
        "type": "str",
        "description": "Specifies the SubAFI value for the flow specification.",
        "default": "FlowSpec",
        "range_or_options": "FlowSpec FlowSpecVpn"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the ORIGIN attribute value for the route.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "Specifies the AS path value for the route.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Specifies the type of the AS path.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE"
      },
      {
        "name": "EnableLocalPref",
        "type": "bool",
        "description": "Enables or disables the Local Preference attribute.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "Specifies the Local Preference value if enabled.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableMed",
        "type": "bool",
        "description": "Enables or disables the Multi-Exit Discriminator (MED).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Specifies the MED value if enabled.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableClusterIdList",
        "type": "bool",
        "description": "Enables or disables the Cluster ID List attribute.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ClusterIdList",
        "type": "str",
        "description": "Specifies the cluster ID list value as a valid IPv4 address.",
        "default": "\"\"",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "EnableCommunity",
        "type": "bool",
        "description": "Enables or disables community attributes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CommunityType",
        "type": "str",
        "description": "Specifies the type of community to apply.",
        "default": "AA_NN",
        "range_or_options": "AA_NN NO_EXPORT NO_ADVERTISE LOCAL_AS"
      },
      {
        "name": "CommunityAsNumber",
        "type": "int",
        "description": "Specifies the AS number when using AA:NN community type.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "CommunityId",
        "type": "int",
        "description": "Specifies the community ID when using AA:NN community type.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Community",
        "type": "str",
        "description": "Specifies the community value for predefined types (NO_EXPORT, NO_ADVERTISE, LOCAL_AS).",
        "default": "\"\"",
        "range_or_options": "0xffffff01 0xffffff02 0xffffff03"
      },
      {
        "name": "ExtendedCommunity",
        "type": "str",
        "description": "Specifies extended community values.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "ComponentType",
        "type": "list",
        "description": "Specifies filtering rules applied in the flow specification.",
        "default": "['Type1']",
        "range_or_options": "Type1 Type2 Type3 Type4 Type5 Type6 Type7 Type8 Type9 Type10 Type11 Type12"
      },
      {
        "name": "VrfNum",
        "type": "int",
        "description": "Specifies the number of VRFs to configure.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Specifies the starting value for the VRF route target.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Specifies the step increment for the VRF route target.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Specifies the starting value for the VRF route distinguisher.",
        "default": "1:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Specifies the step increment for the VRF route distinguisher.",
        "default": "0:1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates IPv4 flow specifications for one or more BGP sessions. It abstracts the configuration process across individual or multiple session objects and allows extensive customization of BGP route attributes, community settings, and VRF configurations. Each session is processed by calling its internal `create_ipv4_flow_specs` method with the provided parameters.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| Create Bgp Ipv4 Flow Specs | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_flow_specs_actions",
    "return_type": "BgpIpv4FlowSpecAction or list",
    "return": "如果输入是单个 BGP Flow Spec 对象，则返回对应的 BgpIpv4FlowSpecAction 对象；如果输入是多个对象，则返回包含对应动作的列表。",
    "parameters": [
      {
        "name": "FlowSpec",
        "type": "BgpIpv4FlowSpecConfig or iterable (list, set, tuple)",
        "description": "一个或多个 BGP IPv4 Flow Specification 配置对象，用于定义匹配流量的规则。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableTrafficRate",
        "type": "bool",
        "description": "启用流量限速动作。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TrafficRate",
        "type": "int",
        "description": "指定流量限速速率（单位：bps）。",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "AsNum",
        "type": "int",
        "description": "指定AS号。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableTrafficAction",
        "type": "bool",
        "description": "启用 Traffic Action 功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SampleBit",
        "type": "bool",
        "description": "启用流量抽样记录功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TerminateBit",
        "type": "bool",
        "description": "撤销已生效的匹配规则。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableRedirect",
        "type": "bool",
        "description": "启用流量重定向到指定路由目标的功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RouteTarget",
        "type": "str",
        "description": "指定重定向的目标路由标识符（格式为 'X:Y'）。",
        "default": "\"100:1\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableTrafficMarking",
        "type": "bool",
        "description": "启用重新标记报文 DSCP 值的动作。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "DSCPValue",
        "type": "int",
        "description": "以十六进制形式指定重新标记报文所使用的 DSCP 值。",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableRedirectToIpNextHop",
        "type": "bool",
        "description": "启用将流量重定向到下一跳 IP 的动作。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "指定重定向的目标下一跳 IPv4 地址。",
        "default": "\"0.0.1.0\"",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "CopyBit",
        "type": "bool",
        "description": "复制一份匹配的流量并执行重定向到下一跳动作。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建或配置基于提供的 BGP 流量规范（Flow Specs）的动作对象。支持传入单个 Flow Spec 或多个 Flow Spec（通过列表、集合或元组）。对于每个 Flow Spec，会根据传入的参数生成对应的 Flow Spec Action。若仅处理一个 Flow Spec，则返回单个动作对象；否则返回动作对象列表。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${FlowSpec} | Create Bgp Ipv4 Flow Specs | Session=${Session} |\n    | Create Bgp Ipv4 Flow Specs Action | FlowSpec=${FlowSpec} | EnableTrafficRate=True | TrafficRate=1000000 | RouteTarget=\"200:1\""
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_flow_spec_conponent_type",
    "return_type": "object or list of objects",
    "return": "Returns a BGP IPv4 Flow Spec component type object if a single valid type is provided, or a list of such objects in the same order as the input types. If any type is invalid, the corresponding entry will be False.",
    "parameters": [
      {
        "name": "FlowSpec",
        "type": "BgpIpv4FlowSpecConfig",
        "description": "A BGP IPv4 Flow Specification configuration object used to determine the context for creating or retrieving flow spec components. It can be either an object or a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "int or iterable",
        "description": "Specifies the type(s) of BGP IPv4 Flow Spec components to create or retrieve. Each type must be an integer between 1 and 12 inclusive.",
        "default": "not_found",
        "range_or_options": "1-12"
      }
    ],
    "kwargs": [
      {
        "name": "IpValue",
        "type": "str",
        "description": "Specifies the starting IP address for generating addresses. Must be a valid IPv4 address.",
        "default": "\"192.0.1.0\"",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Specifies the prefix length for generated addresses.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "AddressList",
        "type": "str",
        "description": "When using a list type, specifies the list of IPv4 addresses.",
        "default": "\"\"",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "InputType",
        "type": "str",
        "description": "Specifies the input generation method.",
        "default": "\"RANGE\"",
        "range_or_options": "RANGE LIST RFC_4814"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of addresses to generate.",
        "default": "1",
        "range_or_options": "1-99"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "Increment step for generating subsequent addresses.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EqualBit",
        "type": "bool",
        "description": "Match if data equals the specified value.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LessThanBit",
        "type": "bool",
        "description": "Match if data is less than the specified value.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MoreThanBit",
        "type": "bool",
        "description": "Match if data is greater than the specified value.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AndBit",
        "type": "bool",
        "description": "If True, logical AND with previous option; otherwise OR.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ValueField",
        "type": "int",
        "description": "Specifies which value field to configure.",
        "default": "1",
        "range_or_options": "1-15"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of values to generate (second Count parameter).",
        "default": "1",
        "range_or_options": "0-99"
      },
      {
        "name": "ValueIncrement",
        "type": "int",
        "description": "Increment step for value generation.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "ValueList",
        "type": "int",
        "description": "List of values for List-type configurations.",
        "default": "\"\"",
        "range_or_options": "0-65535"
      },
      {
        "name": "ValueType",
        "type": "str",
        "description": "Specifies how to generate values.",
        "default": "\"Increment\"",
        "range_or_options": "Increment List"
      },
      {
        "name": "NotBit",
        "type": "bool",
        "description": "If True, bitwise NOT applied to result.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MatchBit",
        "type": "bool",
        "description": "If True, match using bitwise AND comparison.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DSCPValue",
        "type": "int",
        "description": "Specifies the DSCP value for matching traffic.",
        "default": "0",
        "range_or_options": "0-63"
      }
    ],
    "description": "This function creates or retrieves one or more BGP IPv4 Flow Specification component types based on the provided FlowSpec and list of Types. It acts as a wrapper around the `BgpRouter.create_flow_spec_conponent_type` method, allowing both singular and plural operations. The function handles dynamic instantiation and supports optional post-creation configuration via keyword arguments. For multiple Types, it returns a list of objects in the same order as input, replacing invalid entries with False.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${FlowSpec} | Create Bgp Ipv4 Flow Specs | Session=${Session} |\n    | Create Bgp Flow Spec Conponent Type | FlowSpec=${FlowSpec} | Type=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_flow_spec_custom_path_attribute",
    "return_type": "BgpFlowSpecPathAttributeConfig or list of BgpFlowSpecPathAttributeConfig",
    "return": "Returns a single `BgpFlowSpecPathAttributeConfig` object or a list of such objects depending on whether the input `FlowSpec` is a single object or an iterable.",
    "parameters": [
      {
        "name": "FlowSpec",
        "type": "object or iterable (list, set, tuple)",
        "description": "A BGP flow specification object or an iterable containing multiple flow specification objects. Each will be used as the parent context for creating a corresponding custom path attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PathAttributeType",
        "type": "int",
        "description": "The type code for the custom path attribute being created.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "OptionalFlag",
        "type": "str",
        "description": "Determines whether the path attribute is well-known or optional.",
        "default": "OPTION",
        "range_or_options": "WELL_KNOWN OPTION"
      },
      {
        "name": "TransitiveFlag",
        "type": "str",
        "description": "Specifies whether the path attribute is transitive across AS boundaries.",
        "default": "NONTRANSITIVE",
        "range_or_options": "NONTRANSITIVE TRANSITIVE"
      },
      {
        "name": "PartialFlag",
        "type": "str",
        "description": "Indicates if the information in the path attribute is complete or partial.",
        "default": "PARTIAL",
        "range_or_options": "COMPLETE PARTIAL"
      },
      {
        "name": "ExtendedLengthFlag",
        "type": "bool",
        "description": "If True, enables extended length encoding for this path attribute.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AttributeValue",
        "type": "str",
        "description": "Raw value to be assigned to the path attribute. If present, it may be transformed before application.",
        "default": "",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and configures one or more BGP flow specification custom path attributes based on the provided flow specification(s). It allows both single and multiple flow specification inputs by accepting either a single object or an iterable (e.g., list, set, or tuple) of flow specs. For each flow spec, a corresponding custom path attribute is created and configured using the provided keyword arguments.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| ${FlowSpecs} | Create Bgp Ipv4 Flow Specs | Session=${Session} |\n| Create Bgp Flow Spec Custom Path Attribute | FlowSpec=${FlowSpecs} | PathAttributeType=100 | OptionalFlag=WELL_KNOWN | TransitiveFlag=TRANSITIVE | PartialFlag=COMPLETE | ExtendedLengthFlag=True | AttributeValue=\\x01\\x02\\x03\\x04 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv6_flow_spec",
    "return_type": "object or list",
    "return": "A BGP IPv6 Flow Specification configuration object or a list of such objects depending on the input sessions.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable",
        "description": "A single BGP session object or an iterable (e.g., list) of BGP session objects. Each session must have a method `create_ipv6_flow_spec` to generate flow specifications.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes to create.",
        "default": "1",
        "range_or_options": "1-8000000"
      },
      {
        "name": "FlowSpecSubAfi",
        "type": "str",
        "description": "Specifies the SubAFI value for Flow Spec.",
        "default": "FlowSpec",
        "range_or_options": "FlowSpec FlowSpecVpn"
      },
      {
        "name": "FlowSpecActionType",
        "type": "str",
        "description": "Optional Flag value for Flow Spec action type.",
        "default": "RedirectRT",
        "range_or_options": "RedirectRT"
      },
      {
        "name": "ComponentType",
        "type": "list",
        "description": "Transitive Flag value for component type.",
        "default": "['Type1']",
        "range_or_options": "Type1 Type2"
      },
      {
        "name": "DestinationPrefix",
        "type": "str",
        "description": "IPv6 address representing the destination prefix.",
        "default": "2000::1",
        "range_or_options": "valid ipv6 address"
      },
      {
        "name": "DestinationPrefixLength",
        "type": "bool",
        "description": "Whether to enable Extended Length Flag for destination prefix.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DestinationPrefixIncrement",
        "type": "int",
        "description": "Increment value for destination prefix attribute length.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "DestinationPrefixCount",
        "type": "int",
        "description": "Number of destination prefixes to generate.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "DestinationPrefixOffset",
        "type": "int",
        "description": "Offset value for destination IP prefix.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SourcePrefix",
        "type": "str",
        "description": "IPv6 address representing the source prefix.",
        "default": "2000::1",
        "range_or_options": "valid ipv6 address"
      },
      {
        "name": "SourcePrefixLength",
        "type": "int",
        "description": "Length of the source IP prefix.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "SourcePrefixIncrement",
        "type": "int",
        "description": "Increment value for source prefix offset.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "SourcePrefixCount",
        "type": "int",
        "description": "Number of source prefixes to generate.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "SourcePrefixOffset",
        "type": "int",
        "description": "Offset value for source IP prefix.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "ORIGIN attribute value for the route.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "AS path string value for the route.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Type of AS Path used in the route.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE"
      },
      {
        "name": "EnableLocalPref",
        "type": "bool",
        "description": "Enables or disables the Local_PREF attribute.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "Value of the Local_PREF attribute.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableMed",
        "type": "bool",
        "description": "Enables or disables the MULTI_EXIT_DISC attribute.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Value of the Multi Exit Discriminator attribute.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableClusterIdList",
        "type": "bool",
        "description": "Enables or disables Cluster ID List.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ClusterIdList",
        "type": "str",
        "description": "Cluster ID list value as a valid IPv4 address.",
        "default": "\"\"",
        "range_or_options": "valid ipv4 address"
      },
      {
        "name": "EnableCommunity",
        "type": "bool",
        "description": "Enables or disables Community attribute.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CommunityType",
        "type": "str",
        "description": "Type of community used in the route.",
        "default": "AA_NN",
        "range_or_options": "AA_NN NO_EXPORT NO_ADVERTISE LOCAL_AS"
      },
      {
        "name": "CommunityAsNumber",
        "type": "int",
        "description": "AS number for AA:NN community type.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "CommunityId",
        "type": "int",
        "description": "ID value for AA:NN community type.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Community",
        "type": "str",
        "description": "Community value for specific types like NO_EXPORT, NO_ADVERTISE, or LOCAL_AS.",
        "default": "\"\"",
        "range_or_options": "0xffffff01 0xffffff02 0xffffff03"
      },
      {
        "name": "ExtendedCommunity",
        "type": "str",
        "description": "Extended community value.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfNum",
        "type": "int",
        "description": "Number of VRFs to configure.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTarget",
        "type": "str",
        "description": "Starting value for VRF route target.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteTargetStep",
        "type": "str",
        "description": "Step increment for VRF route target.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisher",
        "type": "str",
        "description": "Starting value for VRF route distinguisher.",
        "default": "1:1",
        "range_or_options": "not_found"
      },
      {
        "name": "VrfRouteDistinguisherStep",
        "type": "str",
        "description": "Step increment for VRF route distinguisher.",
        "default": "0:1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates IPv6 flow specifications for BGP sessions. It accepts one or more BGP session objects and applies the specified configurations to each session to generate flow specification data. If only one session is provided, it returns a single configuration object; if multiple sessions are provided, it returns a list of configuration objects.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| ${FlowSpecs} | Create Bgp Ipv6 Flow Specs | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_ipv6_flow_spec_action",
    "return_type": "object or list",
    "return": "返回一个或多个BgpIpv6FlowSpecAction对象，表示IPv6 Flow Specification动作的配置。",
    "parameters": [
      {
        "name": "FlowSpec",
        "type": "BgpIpv6FlowSpecConfig or iterable",
        "description": "包含或应包含IPv6 Flow Specification动作配置的单个FlowSpec对象或可迭代对象（如列表、集合、元组）。",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "EnableTrafficRate",
        "type": "bool",
        "description": "启用流量限速动作。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TrafficRate",
        "type": "int",
        "description": "指定流量的最大传输速率。",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "AsNum",
        "type": "int",
        "description": "指定AS号。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableTrafficAction",
        "type": "bool",
        "description": "启用Traffic Action。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SampleBit",
        "type": "bool",
        "description": "启用流量抽样记录。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TerminateBit",
        "type": "bool",
        "description": "撤销已生效的匹配规则。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableRedirect",
        "type": "bool",
        "description": "启用流量重定向到指定的路由目标动作。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RedirectIpv6RouteTarget",
        "type": "str",
        "description": "指定重定向的路由目标。",
        "default": "\"100:1\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableRedirectToIpv6NextHop",
        "type": "bool",
        "description": "启用重定向到下一跳动作。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "指定类型。",
        "default": "\"TYPE_0x000c\"",
        "range_or_options": "TYPE_0x0800 TYPE_0x000c"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "指定下一跳IP地址。",
        "default": "\"2000::1\"",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "CopyBit",
        "type": "bool",
        "description": "复制一份规则匹配的流量，并执行重定向到下一跳动作。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "创建或修改一个或多个IPv6 Flow Specification动作配置。该函数处理单个FlowSpec对象或多个FlowSpec对象的可迭代输入。对于每个FlowSpec，调用类级方法`BgpRouter.create_ipv6_flow_spec_action`来获取并可能修改其关联的IPv6 Flow Specification动作配置。如果只处理了一个FlowSpec，则返回单个配置对象；否则返回配置对象的列表。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${FlowSpec} | Create Bgp Ipv6 Flow Specs | Session=${Session} |\n    | Create Bgp Ipv6 Flow Specs Action | FlowSpec=${FlowSpec} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_sr_te_policy",
    "return_type": "BgpSrTePolicyConfig or list of BgpSrTePolicyConfig",
    "return": "Returns a BGP SR-TE policy configuration object or a list of such objects, one per session.",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpRouter or list of BgpRouter",
        "description": "The BGP protocol session object(s) to which the SR-TE policy will be applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "BindingSidCount",
        "type": "int",
        "description": "Number of Binding SIDs to allocate for the policy.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PolicyColor",
        "type": "int",
        "description": "Starting Color value for the SR Policy.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "PolicyColorStep",
        "type": "int",
        "description": "Increment step for the Policy Color value.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version for the prefix type (IPv4 or IPv6).",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "EndpointCount",
        "type": "int",
        "description": "Number of destination endpoints. Must not exceed Binding SID count.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv4Endpoint",
        "type": "str",
        "description": "Start IPv4 address for the destination endpoint in the policy block.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv4EndpointStep",
        "type": "str",
        "description": "IPv4 address increment step for the destination endpoint.",
        "default": "0.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv6Endpoint",
        "type": "str",
        "description": "Start IPv6 address for the destination endpoint in the policy.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Ipv6EndpointStep",
        "type": "str",
        "description": "IPv6 address increment step for the destination endpoint.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "EndpointIncrementMode",
        "type": "str",
        "description": "Method to generate IP addresses for destination endpoints.",
        "default": "RoundRobin",
        "range_or_options": "RoundRobin Sequential"
      },
      {
        "name": "Origin",
        "type": "str",
        "description": "ORIGIN attribute value for the route.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "AS path value for the route.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Type of AS path used.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE CONFED_SEQUENCE CONFED_SET"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "Value for Local_PREF attribute.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Whether to use session address as next hop.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4NextHop",
        "type": "str",
        "description": "IPv4 next hop address for the UPDATE message.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv6NextHop",
        "type": "str",
        "description": "IPv6 next hop address for the UPDATE message.",
        "default": "2001::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Distinguisher",
        "type": "int",
        "description": "Input SR Policy identifier.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RouteTarget",
        "type": "str",
        "description": "Route target for redirection.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Community",
        "type": "str",
        "description": "Community values based on specific types.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "ExtendedCommunity",
        "type": "str",
        "description": "Extended community attributes.",
        "default": "\"0x03:0x0b:0:0\"",
        "range_or_options": "not_found"
      },
      {
        "name": "SrTePolicySubTlv",
        "type": "list",
        "description": "List of TLVs to include in the SR-TE policy.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW REMOTE_ENDPOINT COLOR PREFERENCE BINDING_SID ENLP PRIORITY EGRESS_ENDPOINT POLICY_CP_NAME SRV6_BSID POLICY_NAME"
      },
      {
        "name": "RemoteEndpointAsn",
        "type": "int",
        "description": "Autonomous system number for remote endpoint.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv4RemoteEndpoint",
        "type": "str",
        "description": "IPv4 remote endpoint address.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv6RemoteEndpoint",
        "type": "str",
        "description": "IPv6 remote endpoint address.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Color",
        "type": "int",
        "description": "Color value field in the Color extended community.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "ColorFlags",
        "type": "list",
        "description": "Flags field in the Color extended community.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW C_FLAG O_FLAG"
      },
      {
        "name": "Preference",
        "type": "int",
        "description": "Priority of the candidate path in the SR Policy.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BsidFlags",
        "type": "str",
        "description": "Flags for the Binding SID.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW S_FLAG I_FLAG"
      },
      {
        "name": "BsidLength",
        "type": "str",
        "description": "Length of the Binding SID.",
        "default": "NO_SHOW",
        "range_or_options": "OCTET_0 OCTET_4 OCTET_16"
      },
      {
        "name": "BsidLabel",
        "type": "int",
        "description": "Label value for the Binding SID.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BsidLabelStep",
        "type": "int",
        "description": "Increment step for the Binding SID label.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BsidTc",
        "type": "int",
        "description": "Traffic Class field in the Binding SID.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "BsidS",
        "type": "int",
        "description": "S field in the Binding SID.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "BsidTtl",
        "type": "int",
        "description": "Time-to-live field in the Binding SID.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6Bsid",
        "type": "str",
        "description": "IPv6 Binding SID value.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Ipv6BsidStep",
        "type": "str",
        "description": "IPv6 Binding SID increment step.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Enlp",
        "type": "str",
        "description": "Explicit null label policy setting.",
        "default": "IPV4",
        "range_or_options": "RESERVED0 IPV4 IPV6"
      },
      {
        "name": "PolicyPriority",
        "type": "int",
        "description": "Priority for re-computation of the SR Policy after topology changes.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BsidFlags",
        "type": "list",
        "description": "Flags included in the SRv6 Binding SID sub-TLV.",
        "default": "NO_SHOW(0x0)",
        "range_or_options": "NO_SHOW S_FLAG I_FLAG B_FLAG"
      },
      {
        "name": "Srv6Bsid",
        "type": "str",
        "description": "SRv6 Binding SID value.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Srv6BsidStep",
        "type": "str",
        "description": "SRv6 Binding SID increment step.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Srv6BsidEndpointBehavior",
        "type": "int",
        "description": "SRv6 SID Endpoint Behavior value.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "Srv6BsidLbLength",
        "type": "int",
        "description": "Length of the SRv6 SID Function.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BsidLnLength",
        "type": "int",
        "description": "Length of the SRv6 SID Locator Node (in bits).",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BsidFunLength",
        "type": "int",
        "description": "Length of the SRv6 SID Function (in bits).",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BsidArgLength",
        "type": "int",
        "description": "Length of the SRv6 SID argument (in bits).",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "CandidatePathName",
        "type": "str",
        "description": "Name of the candidate path in the policy.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "PolicyName",
        "type": "str",
        "description": "Name of the SR Policy.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "TunnelEgressEndpointAfi",
        "type": "str",
        "description": "AFI (Address Family Identifier) for tunnel egress endpoint.",
        "default": "IPV4",
        "range_or_options": "RESERVED0 IPV4 IPV6"
      },
      {
        "name": "Ipv4TunnelEgressEndpoint",
        "type": "str",
        "description": "IPv4 tunnel egress endpoint address.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv6TunnelEgressEndpoint",
        "type": "str",
        "description": "IPv6 tunnel egress endpoint address.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      }
    ],
    "description": "This function creates a BGP SR-TE (Segment Routing Traffic Engineering) policy on one or more provided BGP sessions. It allows fine-grained control over various aspects of the SR-TE policy including endpoints, binding SIDs, color, preference, and other routing attributes. The function abstracts the process of applying the same configuration across multiple sessions and returns corresponding configuration objects.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | Create Bgp Sr Te Policy | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_sr_te_policy_Segement_list",
    "return_type": "object or list of :obj:`BgpSrTePolicySegmentList`",
    "return": "Returns a BGP SR-TE Segment List object or a list of such objects depending on the input. If only one policy is provided, returns a single object; if multiple policies are provided, returns a list.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "A BGP protocol session object or list of session objects that represent the active connection context to the system under test.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SrTePolicy",
        "type": ":obj:`BgpSrTePolicyConfig`",
        "description": "A BGP SR-TE Policy configuration object or list of such objects for which Segment Lists will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SubTlvs",
        "type": "list",
        "description": "Optional sub-TLVs to include in the Segment List. Valid options are: NO_SHOW, WEIGHT.",
        "default": "NO_SHOW",
        "range_or_options": "NO_SHOW WEIGHT"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Specifies the weight associated with this Segment List (SID list). This value determines preference when multiple paths exist.",
        "default": "1",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "This function creates one or more Segment Lists for a BGP SR-TE (Segment Routing Traffic Engineering) policy using an active BGP session. It allows optional configuration parameters like SubTLVs and Weight to be specified during creation. The return type depends on whether a single or multiple Segment Lists are created.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${SrTe} | Create Bgp Sr Te Policy | Session=${Session} |\n    | Create Bgp Sr Te Policy Segement List | Session=${Session} | SrTePolicy=${SrTe} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_segement_sub_tlv",
    "return_type": "object or list",
    "return": "A single BGP segment sub-TLV object if one is created, or a list of objects if multiple types are specified.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "The BGP protocol session object(s) used to associate the segment sub-TLV with an active session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SegementList",
        "type": "object",
        "description": "BGP SR-TE policy segment list object that will be associated with the segment sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str",
        "description": "Type of the BGP segment sub-TLV to create. Can be a single value from A-K.",
        "default": "A",
        "range_or_options": "A B C D E F G H I J K"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "One or more flags to apply to the segment sub-TLV.",
        "default": "['NO_SHOW']",
        "range_or_options": "NO_SHOW V_FLAG A_FLAG S_FLAG B_FLAG"
      },
      {
        "name": "Label",
        "type": "int",
        "description": "MPLS label value for the segment.",
        "default": "1600",
        "range_or_options": "1-1048575"
      },
      {
        "name": "LabelStep",
        "type": "int",
        "description": "Step increment for label values when creating multiple segments.",
        "default": "1",
        "range_or_options": "1-1048575"
      },
      {
        "name": "Tc",
        "type": "int",
        "description": "Traffic Class (TC) value for traffic associated with this segment.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "Sbit",
        "type": "int",
        "description": "Bottom of stack flag indicating whether this is the last segment in the stack.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Ttl",
        "type": "int",
        "description": "Time-to-live (TTL) value for packets using this segment.",
        "default": "255",
        "range_or_options": "1-1048575"
      },
      {
        "name": "Srv6Sid",
        "type": "str",
        "description": "SRv6 Segment Identifier (SID) in IPv6 format.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Srv6SidStep",
        "type": "str",
        "description": "Increment step for SRv6 SID when generating multiple SIDs.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "EndpointBehavior",
        "type": "int",
        "description": "SRv6 endpoint behavior code for this segment.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "LbLength",
        "type": "int",
        "description": "Locator Block length for SRv6 SID.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "LnLength",
        "type": "int",
        "description": "Locator Node length for SRv6 SID.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "FunLength",
        "type": "int",
        "description": "Function length for SRv6 SID.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "ArgLength",
        "type": "int",
        "description": "Argument length for SRv6 SID.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "SrAlgorithm",
        "type": "int",
        "description": "Segment Routing algorithm to use.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "Ipv4NodeAddress",
        "type": "str",
        "description": "IPv4 node address associated with the segment.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv4NodeAddressStep",
        "type": "str",
        "description": "Increment step for IPv4 node address when generating multiple addresses.",
        "default": "0.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "Ipv6NodeAddress",
        "type": "str",
        "description": "IPv6 node address associated with the segment.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "Ipv6NodeAddressStep",
        "type": "str",
        "description": "Increment step for IPv6 node address when generating multiple addresses.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "LocalInterfaceId",
        "type": "int",
        "description": "Local interface ID for identifying local interfaces.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "LocalIpv4Address",
        "type": "str",
        "description": "Local IPv4 address associated with the segment.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "LocalIpv4AddressStep",
        "type": "str",
        "description": "Increment step for local IPv4 address when generating multiple addresses.",
        "default": "0.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "RemoteIpv4Address",
        "type": "str",
        "description": "Remote IPv4 address associated with the segment.",
        "default": "192.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "RemoteIpv4AddressStep",
        "type": "str",
        "description": "Increment step for remote IPv4 address when generating multiple addresses.",
        "default": "0.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "LocalIpv6NodeAddress",
        "type": "str",
        "description": "Local IPv6 node address associated with the segment.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "LocalIpv6NodeAddressStep",
        "type": "str",
        "description": "Increment step for local IPv6 node address when generating multiple addresses.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "RemoteInterfaceId",
        "type": "int",
        "description": "Remote interface ID for identifying remote interfaces.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "RemoteIpv6NodeAddress",
        "type": "str",
        "description": "Remote IPv6 node address associated with the segment.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "RemoteIpv6NodeAddressStep",
        "type": "str",
        "description": "Increment step for remote IPv6 node address when generating multiple addresses.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      }
    ],
    "description": "This function creates one or more BGP segment sub-TLVs based on the provided session and configuration parameters. It allows specifying various attributes like labels, flags, IP addresses, and SRv6-related properties depending on the segment type (A-K).",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| ${SrTe} | Create Bgp Sr Te Policy | Session=${Session} |\n| ${SrTeSegmentList} | Create Bgp Sr Te Policy Segement List | Session=${Session} | SrTePolicys=${SrTe} |\n| Create Bgp Segement Sub Tlv | Session=${Session} | SrTePolicys=${SrTe} | Types=B"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_link_states",
    "return_type": "object or list of BgpLsNodeConfig",
    "return": "A single BGP link state configuration object if one session is processed, or a list of objects if multiple sessions are processed.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter` or iterable of :obj:`BgpRouter`",
        "description": "The BGP protocol session object or a list of session objects for which link states will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Origin",
        "type": "str",
        "description": "Specifies the source of the route information.",
        "default": "IGP",
        "range_or_options": "IGP EGP INCOMPLETE"
      },
      {
        "name": "AsPath",
        "type": "str",
        "description": "Autonomous System path information.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "AsPathType",
        "type": "str",
        "description": "Type of AS path encoding.",
        "default": "SEQUENCE",
        "range_or_options": "SET SEQUENCE CONFED_SEQUENCE CONFED_SET"
      },
      {
        "name": "NextHop",
        "type": "str (IPv4 address)",
        "description": "IPv4 next hop address.",
        "default": "10.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "IPv6NextHop",
        "type": "str (IPv6 address)",
        "description": "IPv6 next hop address.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableLinkLocalNextHop",
        "type": "bool",
        "description": "Enables use of link-local next-hop addresses.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LinkLocalNextHop",
        "type": "str (IPv6 address)",
        "description": "Link-local next-hop IPv6 address.",
        "default": "fe80::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "LocalPreference",
        "type": "int",
        "description": "Local preference value used in BGP path selection.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "Community",
        "type": "str",
        "description": "BGP community values encoded as strings.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "ExtendedCommunity",
        "type": "str",
        "description": "Extended BGP community values encoded as strings.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "ProtocolID",
        "type": "str",
        "description": "Identifier for the routing protocol that provided the route.",
        "default": "DIRECT",
        "range_or_options": "ISIS_LEVEL_1 ISIS_LEVEL_2 OSPFV2 DIRECT STATIC OSPFV3 BGP"
      },
      {
        "name": "IdentifierType",
        "type": "str",
        "description": "Type of identifier used to identify the node.",
        "default": "CUSTOMIZED",
        "range_or_options": "DEFAULT_LAYER3 CUSTOMIZED"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Numeric identifier for the node.",
        "default": "0",
        "range_or_options": "1-1048575"
      },
      {
        "name": "EnableNodeNLRI",
        "type": "bool",
        "description": "Enables Node NLRI advertisements.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LocalNodeDescriptorFlag",
        "type": "list",
        "description": "List of flags indicating types of local node descriptors.",
        "default": "[\"IGP_ROUTER_ID\"]",
        "range_or_options": "AS_NUMBER BGPLS_IDENTIFIER OSPF_AREA_ID IGP_ROUTER_ID BGP_ROUTER_ID MEMBER_ASN"
      },
      {
        "name": "AsNumber",
        "type": "int",
        "description": "Autonomous system number.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BgpLsIdentifier",
        "type": "str (IPv4 address)",
        "description": "BGP-LS identifier for the node.",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "OspfAreaId",
        "type": "str (IPv4 address)",
        "description": "OSPF area ID associated with the node.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "IGPRouterIdType",
        "type": "str",
        "description": "Type of IGP router ID being used.",
        "default": "OSPF_NONPSEUDONODE",
        "range_or_options": "ISIS_NONPSEUDONODE ISIS_PSEUDONODE OSPF_NONPSEUDONODE OSPF_PSEUDONODE"
      },
      {
        "name": "IsisNonPseud",
        "type": "str",
        "description": "ISIS non-pseudonode router ID representation.",
        "default": "\"00:10:12:00:00:01\"",
        "range_or_options": "not_found"
      },
      {
        "name": "IsisPseud",
        "type": "str",
        "description": "ISIS pseudonode router ID representation.",
        "default": "\"00:10:12:00:00:01.02\"",
        "range_or_options": "not_found"
      },
      {
        "name": "OspfNonPseud",
        "type": "str (IPv4 address)",
        "description": "OSPF non-pseudonode router ID.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "OspfPseud",
        "type": "str",
        "description": "OSPF pseudonode router ID string.",
        "default": "\"192.0.0.1:192.0.0.1\"",
        "range_or_options": "not_found"
      },
      {
        "name": "BgpRouterId",
        "type": "str (IPv4 address)",
        "description": "BGP router ID for the session.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "MemberAsn",
        "type": "int",
        "description": "Autonomous system member identifier.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LocalNodeAttributeFlag",
        "type": "str",
        "description": "Flags representing additional attributes of the local node.",
        "default": "NODE_FLAG_BITS",
        "range_or_options": "MULTI_TOPO_ID NODE_FLAG_BITS NODE_NAME ISIS_AREA_ID IPV4_LOCAL_NODE_ROUTERID IPV6_LOCAL_NODE_ROUTERID SR_CAPABILITIES SR_ALGORITHM SR_LOCAL_BLOCK SR_SRMA_PREF SRV6_CAPABILITIES SRV6_NODE_MSD"
      },
      {
        "name": "MultiTopoId",
        "type": "str",
        "description": "Multi-topology identifier.",
        "default": "\"\"",
        "range_or_options": "1-4095"
      },
      {
        "name": "NodeFlagBitIsis",
        "type": "str",
        "description": "ISIS-specific node flag bits.",
        "default": "ATTACHED",
        "range_or_options": "OVERLOAD ATTACHED"
      },
      {
        "name": "NodeFlagBitOspfv2",
        "type": "list",
        "description": "OSPFv2-specific node flag bits.",
        "default": "[\"ABR\"]",
        "range_or_options": "EXTERNAL ABR"
      },
      {
        "name": "NodeFlagBitOspfv3",
        "type": "list",
        "description": "OSPFv3-specific node flag bits.",
        "default": "[\"ABR\"]",
        "range_or_options": "EXTERNAL ABR ROUTER V6"
      },
      {
        "name": "NodeName",
        "type": "str",
        "description": "Name of the node.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "IsisAreaId",
        "type": "int",
        "description": "IS-IS area identifier.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LocalIpv4RouterIds",
        "type": "str (IPv4 address)",
        "description": "Local IPv4 router IDs.",
        "default": "\"\"",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "LocalIpv6RouterIds",
        "type": "str (IPv6 address)",
        "description": "Local IPv6 router IDs.",
        "default": "\"\"",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "SidLabelType",
        "type": "str",
        "description": "Type of SID/Label used for Segment Routing.",
        "default": "BIT20_LABEL",
        "range_or_options": "BIT20_LABEL BIT32_SID"
      },
      {
        "name": "SrCapabilitiesFlags",
        "type": "list",
        "description": "Segment Routing capability flags.",
        "default": "[\"MPLS_IPv4\"]",
        "range_or_options": "MPLS_IPv4 MPLS_IPv6"
      },
      {
        "name": "SrCapabilities",
        "type": "str",
        "description": "String representation of Segment Routing capabilities.",
        "default": "\"16:100\"",
        "range_or_options": "not_found"
      },
      {
        "name": "SrAlgorithm",
        "type": "int",
        "description": "SR algorithm number.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "SrLocalBlock",
        "type": "str",
        "description": "Range of SIDs reserved for the local block.",
        "default": "\"16:100\"",
        "range_or_options": "not_found"
      },
      {
        "name": "SrmsPref",
        "type": "int",
        "description": "SRMS preference value.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6CapabilitiesFlags",
        "type": "list",
        "description": "SRv6 capability flags.",
        "default": "[\"O_FLAG\"]",
        "range_or_options": "UNUSED0 O_FLAG UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7 UNUSED8 UNUSED9 UNUSED10 UNUSED11 UNUSED12 UNUSED13 UNUSED14 UNUSED15"
      },
      {
        "name": "Srv6MsdFlags",
        "type": "list",
        "description": "SRv6 MSD type flags.",
        "default": "[\"NONE\"]",
        "range_or_options": "NONE MAX_SEGMENTS_LELT MAX_END_POP MAX_T_INSERT_SRH MAX_T_ENCAPS_SRH MAX_END_D_SRH"
      },
      {
        "name": "Srv6MsdMaxSegmentLeft",
        "type": "int",
        "description": "Maximum number of segments allowed.",
        "default": "8",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6MsdMaxEndPop",
        "type": "int",
        "description": "Maximum End Pop operations.",
        "default": "8",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6MsdMaxInsert",
        "type": "int",
        "description": "Maximum T.Insert SRH operations.",
        "default": "8",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6MsdMaxEncap",
        "type": "int",
        "description": "Maximum T.Encaps SRH operations.",
        "default": "8",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6MsdMaxEndD",
        "type": "int",
        "description": "Maximum End D SRH operations.",
        "default": "8",
        "range_or_options": "1-255"
      }
    ],
    "description": "Creates BGP link state configurations for one or more provided session objects. This function wraps each session into an iterable and calls the internal `create_link_states` method on each session with the provided keyword arguments to configure BGP link states.",
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| Create Bgp Link States | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_link_states_link",
    "return_type": "object or list",
    "return": "A single `BgpLsLinkConfig` object if one link is created, or a list of `BgpLsLinkConfig` objects if multiple links are created.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "The BGP protocol session(s) used to create the link state. This must be an instance or list of instances of `BgpRouter`.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkState",
        "type": "object or list",
        "description": "The BGP link state configuration data. This can be a single `BgpLsNodeConfig` object or a list of them.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "LinkLocalRemoteIdFlag",
        "type": "str",
        "description": "Specifies where the local/remote link ID is located in the BGP LS configuration.",
        "default": "NONE",
        "range_or_options": "NONE LINK_DESCRIPTOR LINK_ATTRIBUTE"
      },
      {
        "name": "LinkLocalId",
        "type": "int",
        "description": "The local link identifier.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LinkRemoteId",
        "type": "int",
        "description": "The remote link identifier.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RemoteNodeDescriptorFlag",
        "type": "str",
        "description": "Describes how the remote node is identified in the BGP LS update.",
        "default": "IGP_ROUTER_ID",
        "range_or_options": "AS_NUMBER BGPLS_IDENTIFIER OSPF_AREA_ID IGP_ROUTER_ID BGP_ROUTER_ID MEMBER_ASN"
      },
      {
        "name": "AsNumber",
        "type": "int",
        "description": "Autonomous System (AS) number for the remote node.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BgpLsIdentifier",
        "type": "str",
        "description": "BGP-LS identifier as an IPv4 address.",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "OspfAreaId",
        "type": "str",
        "description": "OSPF area identifier as an IPv4 address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "IGPRouterIdType",
        "type": "str",
        "description": "Type of IGP router ID used for identifying the node.",
        "default": "OSPF_NONPSEUDONODE",
        "range_or_options": "ISIS_NONPSEUDONODE ISIS_PSEUDONODE OSPF_NONPSEUDONODE OSPF_PSEUDONODE"
      },
      {
        "name": "LinkDescriptorFlag",
        "type": "list",
        "description": "Flags indicating types of link descriptors included in the BGP LS update.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN LINK_IDENTIFIES IPV4_INTERFACE IPV4_NEIGHBOR IPV6_INTERFACE IPV6_NEIGHBOR MULTI_TOPOLOGY"
      },
      {
        "name": "Ipv4InterfaceAddr",
        "type": "str",
        "description": "IPv4 interface address associated with the link.",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4NeighborAddr",
        "type": "str",
        "description": "IPv4 neighbor address for the link.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv6InterfaceAddr",
        "type": "str",
        "description": "IPv6 interface address associated with the link.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6NeighborAddr",
        "type": "str",
        "description": "IPv6 neighbor address for the link.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "Multi-topology identifier for the link.",
        "default": "",
        "range_or_options": "1-4095"
      },
      {
        "name": "LinkAttributeFlag",
        "type": "list",
        "description": "List of flags specifying additional attributes for the link.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN IPV4_LOCAL_NODE IPV4_REMOTE_NODE IPV6_LOCAL_NODE IPV6_REMOTE_NODE LINK_IDENTIFIES LINK_PROTECTION_TYPE IGP_METRIC SHARED_RISE ADI_SID LAN_ADJ_SID PEERNODE_SID PEERADJ_SID PEERSET_SID SRV6_LINK_MSD SRV6_END_X_SID SRV6_LAN_END_X_SID"
      },
      {
        "name": "EnableInterfaceIp",
        "type": "bool",
        "description": "Enables setting of a specific IPv4 interface IP address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIp",
        "type": "str",
        "description": "Manually set IPv4 interface address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableNeighborIp",
        "type": "bool",
        "description": "Enables setting of a specific IPv4 neighbor IP address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIp",
        "type": "str",
        "description": "Manually set IPv4 neighbor address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableInterfaceIpv6",
        "type": "bool",
        "description": "Enables setting of a specific IPv6 interface address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIpv6",
        "type": "str",
        "description": "Manually set IPv6 interface address.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableNeighborIpv6",
        "type": "bool",
        "description": "Enables setting of a specific IPv6 neighbor address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIpv6",
        "type": "str",
        "description": "Manually set IPv6 neighbor address.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableTeDefaultMetric",
        "type": "bool",
        "description": "Enables setting of the TE default metric.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TeDefaultValue",
        "type": "int",
        "description": "Value of the TE default metric.",
        "default": "0",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "Creates one or more BGP Link State configurations using provided session and link state data. It wraps the backend method and allows passing various options to configure BGP link properties such as IP addresses, metrics, capabilities, and extensions like Segment Routing.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${LinkState} | Create Bgp Link States | Sessions=${Session} |\n    | Create Bgp Link States Link | Sessions=${Session} | LinkState=${LinkState} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_link_states_prefix",
    "return_type": "object or list of :obj:`BgpLsPrefixConfig`",
    "return": "A BGP Link States Prefix configuration object, or a list of such objects depending on the input.",
    "description": "创建BGP链路状态前缀配置，用于在指定的会话中为一个或多个给定的链路状态生成BGP链路状态前缀对象。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "BGP协议会话对象列表，类型为：object / list。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkState",
        "type": ":obj:`BgpLsNodeConfig`",
        "description": "Bgp Link States对象列表，类型为：object / list。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PrefixDescriptorFlag",
        "type": "list",
        "description": "LS前缀描述符标志，类型为：list，默认值：IP_REACH_INFO。",
        "default": "IP_REACH_INFO",
        "range_or_options": "MULTI_TOPOLOGY OSPF_ROUTE_TYPE IP_REACH_INFO"
      },
      {
        "name": "OspfRouteType",
        "type": "str",
        "description": "OSPF路由类型，类型为：string，默认值：INTRA_AREA。",
        "default": "INTRA_AREA",
        "range_or_options": "INTRA_AREA INTER_AREA EXTERNAL1 EXTERNAL2 NSSA1 NSSA2"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "地址前缀个数，取值范围：1-65535，默认值：1。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "PrefixType",
        "type": "str",
        "description": "地址前缀类型，类型为：string，默认值：IPV4。",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "Ipv4Prefix",
        "type": "str",
        "description": "IPv4地址前缀，类型为：有效的ipv4地址，默认值：1.0.0.0。",
        "default": "1.0.0.0",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "IPv4地址前缀步长，类型为：number，取值范围：1-32，默认值：24。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4PrefixStep",
        "type": "int",
        "description": "IPv4地址前缀步长，类型为：number，取值范围：1-65535，默认值：1。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv6Prefix",
        "type": "str",
        "description": "IPv6地址前缀，类型为：有效的ipv6地址，默认值：2000::1。",
        "default": "2000::1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "IPv6地址前缀步长，类型为：number，取值范围：1-128，默认值：64。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6PrefixStep",
        "type": "int",
        "description": "IPv6地址前缀长度，类型为：number，取值范围：1-65535，默认值：1。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "多拓扑ID，类型为：number，取值范围：1-4095，默认值：空字符串。",
        "default": "\"\"",
        "range_or_options": "1-4095"
      },
      {
        "name": "OspfSrPrefixSidFlag",
        "type": "list",
        "description": "OSPF SR前缀SID标志，类型为：list，默认值：UNKNOWN。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN NO_PHP MAPPING_SERVER EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "IsisSrPrefixSidFlag",
        "type": "list",
        "description": "ISIS SR前缀SID标志，类型为：list，默认值：UNKNOWN。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN RE_ADVER NODESID NO_PHP EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "PrefixAttributeFlag",
        "type": "str",
        "description": "LS前缀描述符标志，类型为：string，默认值：UNKNOWN|IGP_FLAGS。",
        "default": "UNKNOWN|IGP_FLAGS",
        "range_or_options": "UNKNOWN IGP_FLAGS PREFIX_METRIC OSPF_FORWARDING SR_PREFIX_SID SR_RANGE SR_ATTRIBUTE_FLAG SR_SOURCE SRV6_LOCATOR_TLV"
      },
      {
        "name": "IgpFlag",
        "type": "str",
        "description": "IGP标志，类型为：string，默认值：UNKNOWN。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN ISIS_UP_DOWN OSPF_NO_UNICAST OSPF_LOCAL_ADDRESS OSPF_PROPAGATE_NSSA"
      },
      {
        "name": "PrefixMetric",
        "type": "int",
        "description": "前缀度量，类型为：number，取值范围：1-4294967295，默认值：0。",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "OspfForwardtype",
        "type": "str",
        "description": "OSPF转发地址类型，类型为：string，默认值：OSPFV2。",
        "default": "OSPFV2",
        "range_or_options": "OSPFV2 OSPFV3"
      },
      {
        "name": "Ospfv2ForwardAddr",
        "type": "str",
        "description": "OSPFv2转发地址，类型为：有效的ipv4地址，默认值：192.168.1.1。",
        "default": "192.168.1.1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ospfv3ForwardAddr",
        "type": "str",
        "description": "OSPFv3转发地址，类型为：有效的ipv6地址，默认值：2000::1。",
        "default": "2000::1",
        "range_or_options": "not_found"
      },
      {
        "name": "OspfSrPrefixFlag",
        "type": "str",
        "description": "OSPF SR前缀SID标志，类型为：string，默认值：UNKNOWN。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN NO_PHP MAPPING_SERVER EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "IsisSrPrefixFlag",
        "type": "str",
        "description": "ISIS SR前缀SID标志，类型为：string，默认值：UNKNOWN。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN RE_ADVER NODESID NO_PHP EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "算法，类型为：number，取值范围：1-255，默认值：0。",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "SidLabelIndex",
        "type": "int",
        "description": "SID/Label/Index，类型为：number，取值范围：0-1048575 (20比特值), 0-4294967295 (32比特值)，默认值：0。",
        "default": "0",
        "range_or_options": "0-1048575 0-4294967295"
      },
      {
        "name": "Ospfv2SrPrefixAttributeFlag",
        "type": "list",
        "description": "OSPFv2 SR前缀属性标志，类型为：list，默认值：NODE。",
        "default": "NODE",
        "range_or_options": "ATTACH NODE"
      },
      {
        "name": "Ospfv3SrPrefixAttributeFlag",
        "type": "list",
        "description": "OSPFv3 SR前缀属性标志，类型为：list，默认值：NO_UNICAST。",
        "default": "NO_UNICAST",
        "range_or_options": "NO_UNICAST LOCAL_ADDRESS MULTICAST PROPAGATE RE_ADVER HOST"
      },
      {
        "name": "IsisSrPrefixAttributeFlag",
        "type": "list",
        "description": "ISIS SR前缀属性标志，类型为：list，默认值：NODE。",
        "default": "NODE",
        "range_or_options": "EXTERNAL_PREFIX RE_ADVER NODE"
      },
      {
        "name": "SrSourceIpv4Id",
        "type": "str",
        "description": "SR IPv4源路由ID，类型为：有效的ipv4地址，默认值：192.168.1.0。",
        "default": "192.168.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "SrSourceIpv6Id",
        "type": "str",
        "description": "SR IPv6源路由ID，类型为：有效的ipv6地址，默认值：2000::1。",
        "default": "2000::1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ospfv2SrRangeFlag",
        "type": "list",
        "description": "OSPFv2 SR范围标志，类型为：list，默认值：INTER_AREA。",
        "default": "INTER_AREA",
        "range_or_options": "INTER_AREA"
      },
      {
        "name": "IsisSrRangeFlag",
        "type": "list",
        "description": "ISIS SR范围标志，ISIS SR前缀SID标志，类型为：list，默认值：ATTACHED。",
        "default": "ATTACHED",
        "range_or_options": "ADDRESS_FAMILY MIRROR_CONTEXT S_FLAG D_FLAG ATTACHED"
      },
      {
        "name": "SrRangeSubTlv",
        "type": "str",
        "description": "SR范围Sub-TLVs，类型为：string，默认值：\"0 Range Sub-TLV\"。",
        "default": "\"0 Range Sub-TLV\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Srv6LocatorFlag",
        "type": "str",
        "description": "SRv6 Locator标志，类型为：string，默认值：NONE。",
        "default": "NONE",
        "range_or_options": "NONE D_FLAG"
      },
      {
        "name": "Srv6LocatorAlgorithm",
        "type": "int",
        "description": "SRv6 Locator算法，类型为：number，取值范围：1-255，默认值：0。",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6LocatorMetric",
        "type": "int",
        "description": "SRv6 Locator度量值，类型为：number，取值范围：1-4294967295，默认值：0。",
        "default": "0",
        "range_or_options": "1-4294967295"
      }
    ],
    "example": "| ${Session} | Create Bgp | Port=${Port} |\n| ${LinkState} | Create Bgp Link States | Sessions=${Session} |\n| Create Bgp Link States Prefix | Sessions=${Session} | LinkState=${LinkState} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_link_states_prefix_sr_range_sub_tlv",
    "return_type": "object or list of :obj:`BgpLsSrRangeSubTlvConfig`",
    "return": "Returns a single BGP Link-State Prefix Segment Routing (SR) Range sub-TLV configuration object or a list of such objects, depending on whether a single or multiple `LinkStatePrefix` entries were provided.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list of :obj:`BgpRouter`",
        "description": "The BGP session(s) used to create the SR Range sub-TLV. It must have a method to interact with the protocol stack for creating SR Range sub-TLVs.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkStatePrefix",
        "type": "object or list of :obj:`BgpLsPrefixConfig`",
        "description": "A single BGP Link-State prefix or an iterable of prefixes under which the SR Range sub-TLVs will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Algorithm associated with the SR Range sub-TLV. Used to specify the routing algorithm for Segment Routing.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "OspfSrPrefixSidFlag",
        "type": "list",
        "description": "OSPF SR Prefix SID Flags that control behavior like PHP, Mapping Server, Explicit Null, etc.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN NO_PHP MAPPING_SERVER EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "IsisSrPrefixSidFlag",
        "type": "list",
        "description": "ISIS SR Prefix SID Flags that control behavior like Re-advertisement, Node SID, PHP, etc.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN RE_ADVER NODESID NO_PHP EXPLICIT_NULL VALUE LOCAL"
      },
      {
        "name": "SidLabelIndex",
        "type": "int",
        "description": "SID/Label/Index value used in Segment Routing context.",
        "default": "0",
        "range_or_options": "1-255"
      }
    ],
    "description": "This function creates one or more BGP Link-State Prefix Segment Routing (SR) Range sub-TLVs associated with the given LinkStatePrefix(es). If a single `LinkStatePrefix` is provided, it returns a single configuration object; if multiple are provided, it returns a list of configuration objects. The function interacts with the underlying protocol stack using the provided `Session` object and passes all keyword arguments directly to the backend implementation.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${LinkState} | Create Bgp Link States | Sessions=${Session} |\n    | ${prefix} | Create Bgp Link States Prefix | LinkState=${LinkState} |\n    | Create Bgp Link States Prefix Sr Range Sub Tlv | Sessions=${Session} | LinkStatePrefix=${prefix} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.create_bgp_link_states_srv6_sid",
    "return_type": "object / list",
    "return": "Returns a single BGP Link-State SRv6 SID configuration object or a list of such objects depending on the input. Each object corresponds to a configured SRv6 SID for a given link state.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`BgpRouter`",
        "description": "BGP protocol session object(s) used to apply SRv6 SID configurations, typically representing a connection context to a BGP peer.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkState",
        "type": ":obj:`BgpLsNodeConfig`",
        "description": "BGP Link-State node configuration object(s) for which the SRv6 SID will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Srv6AttributeFlag",
        "type": "list",
        "description": "List of SRv6 SID attribute flags that define what type of SID is being advertised.",
        "default": "['SRV6_ENDPOINT_BEHAVIOR']",
        "range_or_options": "SRV6_ENDPOINT_BEHAVIOR SRV6_BGP_PEER_NODE_SID SRV6_SID_STRUCTURE"
      },
      {
        "name": "Srv6EndpointBehavior",
        "type": "str",
        "description": "Specifies the behavior associated with the SRv6 endpoint.",
        "default": "CUSTOM",
        "range_or_options": "END END_WITH_PSP END_WITH_USP END_WITH_PSP_USP END_X END_X_WITH_PSP END_X_WITH_USP END_X_WITH_PSP_USP END_T END_T_WITH_PSP END_T_WITH_USP END_T_WITH_PSP_USP END_B6_ENCAPS END_BM END_DX6 END_DX4 END_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DT2U END_DT2M END_B6_ENCAPS_RED END_WITH_USD END_WITH_PSP_USD END_WITH_USP_USD END_WITH_PSP_USP_USD END_X_WITH_USD END_X_WITH_PSP_USD END_X_WITH_USP_USD END_X_WITH_PSP_USP_USD END_T_WITH_USD END_T_WITH_PSP_USD END_T_WITH_USP_USD END_T_WITH_PSP_USP_USD CUSTOM"
      },
      {
        "name": "Srv6EndpointBehaviorFlag",
        "type": "list",
        "description": "Flags related to SRv6 endpoint behavior.",
        "default": "['NONE']",
        "range_or_options": "NONE UNUSED0 UNUSED1 UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "Srv6EndpointBehaviorAlgorithm",
        "type": "int",
        "description": "Algorithm associated with the SRv6 endpoint behavior.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BgpPeerNodeSidFlag",
        "type": "list",
        "description": "Flags for EPE (End-Point Peer) Node SID.",
        "default": "[0]",
        "range_or_options": "NONE BACKUP_FLAG SET_FLAG PERSISTENT_FLAG"
      },
      {
        "name": "Srv6BgpPeerNodeSidWeight",
        "type": "int",
        "description": "Weight assigned to the EPE Peer Node SID.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6BgpPeerNodeSidPeerAsNumber",
        "type": "int",
        "description": "Autonomous system number of the peer.",
        "default": "1001",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Srv6BgpPeerNodeSidPeerBgpId",
        "type": "int",
        "description": "BGP identifier of the peer.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Srv6SidStructureLbLength",
        "type": "int",
        "description": "Length of the SRv6 Locator Block in bits.",
        "default": "32",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6SidStructureLnLength",
        "type": "int",
        "description": "Length of the SRv6 Locator Node in bits.",
        "default": "32",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6SidStructureFunLength",
        "type": "int",
        "description": "Length of the SRv6 Function field in bits.",
        "default": "32",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6SidStructureArgLength",
        "type": "int",
        "description": "Length of the SRv6 Argument field in bits.",
        "default": "32",
        "range_or_options": "1-255"
      },
      {
        "name": "Srv6Sid",
        "type": "str",
        "description": "IPv6 address representing the SRv6 SID.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "Multi-topology ID associated with the SRv6 SID.",
        "default": "\"\"",
        "range_or_options": "1-4095"
      }
    ],
    "description": "This function creates SRv6 Segment Identifier (SID) configurations for BGP Link-State advertisements. It supports both individual and multiple session and link-state inputs. Internally, it ensures consistent handling by converting non-list inputs into lists and applying the configuration for each link state. The resulting output is either a single configuration object or a list of such objects.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Bgp | Port=${Port} |\n    | ${LinkState} | Create Bgp Link States | Sessions=${Session} |\n    | Create Bgp Link States Srv6 Sid | Sessions=${Session} | LinkState=${LinkState} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.get_bgp_evpn_routes_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for BGP EVPN routes. If one matching row is found, returns a dictionary with statistical items as keys and values. If multiple rows match, returns a pandas DataFrame. If no match is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the BGP session(s) to query for EVPN route statistics. If None, no session filter is applied. If a single object (assumed to be a session block), its `Name` attribute is used. If a collection of sessions, their names are extracted.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items to retrieve. Supported items include TxAdRouteCount, RxAdRouteCount, etc. If None, all available items are queried. If a string, it is converted into a single-element list internally.",
        "default": "None",
        "range_or_options": "TxAdRouteCount RxAdRouteCount TxMacIpRouteCount RxMacIpRouteCount TxInclusiveMcastRouteCount RxInclusiveMcastRouteCount TxEthernetSegmentRouteCount RxEthernetSegmentRouteCount TxIpPrefixRouteCount RxIpPrefixRouteCount TxWithdrawnAdRouteCount RxWithdrawnAdRouteCount TxWithdrawnMacIpRouteCount RxWithdrawnMacIpRouteCount TxWithdrawnInclusiveMcastRouteCount RxWithdrawnInclusiveMcastRouteCount TxWithdrawnEthernetSegmentRouteCount RxEthernetSegmentRouteCount TxWithdrawnIpPrefixRouteCount RxWithdrawnIpPrefixRouteCount"
      }
    ],
    "description": "This function retrieves BGP EVPN route statistics for specified session(s). It serves as a wrapper around an internal method `_get_statictis`, translating session inputs into appropriate identifiers and handling various types of session objects. It supports filtering by specific statistical items or retrieving all available statistics.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxAdRouteCount | RxAdRouteCount |\n    | Subscribe Result | Types=EvpnRoutesStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bgp Evpn Routes Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.get_bgp_link_state_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics related to BGP link state for the specified session(s) and statistical items. If one matching row is found, returns a dictionary; if multiple rows are found, returns a pandas DataFrame; if no match is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects, optional",
        "description": "Specifies the session(s) for which BGP link state statistics should be retrieved. Each session object must have a `Name` attribute representing its ID. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies the statistical items (columns) to retrieve. Supported values include: TxAdvertisedNodeCount, RxAdvertisedNodeCount, TxWithdrawnNodeCount, RxWithdrawnNodeCount, TxAdvertisedLinkCount, RxAdvertisedLinkCount, TxWithdrawnLinkCount, RxWithdrawnLinkCount, TxAdvertisedIpv4PrefixCount, RxAdvertisedIpv4PrefixCount, TxWithdrawnIpv4PrefixCount, RxWithdrawnIpv4PrefixCount, TxAdvertisedIpv6PrefixCount, RxAdvertisedIpv6PrefixCount, TxWithdrawnIpv6PrefixCount, RxWithdrawnIpv6PrefixCount, TxAdvertisedSrv6SidCount, RxAdvertisedSrv6SidCount, TxWithdrawnSrv6SidCount, RxWithdrawnSrv6SidCount. If None, all available items may be queried dynamically.",
        "default": "None",
        "range_or_options": "TxAdvertisedNodeCount RxAdvertisedNodeCount TxWithdrawnNodeCount RxWithdrawnNodeCount TxAdvertisedLinkCount RxAdvertisedLinkCount TxWithdrawnLinkCount RxWithdrawnLinkCount TxAdvertisedIpv4PrefixCount RxAdvertisedIpv4PrefixCount TxWithdrawnIpv4PrefixCount RxWithdrawnIpv4PrefixCount TxAdvertisedIpv6PrefixCount RxAdvertisedIpv6PrefixCount TxWithdrawnIpv6PrefixCount RxWithdrawnIpv6PrefixCount TxAdvertisedSrv6SidCount RxAdvertisedSrv6SidCount TxWithdrawnSrv6SidCount RxWithdrawnSrv6SidCount"
      }
    ],
    "kwargs": [],
    "description": "Retrieves BGP link state statistics for specified session(s), optionally filtered to specific statistical items. This function gathers BGP link state statistics by calling an internal method `_get_statictis` with appropriate parameters tailored for 'BgpLinkStateStatistic'. The statistical items can be used to specify which metrics or properties to return, such as number of routes advertised or received.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxAdvertisedNodeCount | RxAdvertisedNodeCount |\n    | Subscribe Result | Types=BgpLinkStateStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bgp Link State Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.get_bgp_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to requested statistical items if exactly one matching row is found. Returns a pandas DataFrame if multiple rows match the criteria. Returns False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects, optional",
        "description": "The session object(s) for which statistics are requested. If None, no session filtering is applied. If a collection is provided, the `.Name` attribute of each object is used to identify the session(s).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Id",
        "type": "int, optional",
        "description": "The BGP peer identifier used to filter statistics for a specific peer within the session. Corresponds to 'BgpPeerId' in index filters.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a list containing one item. Must be a subset of available statistic properties for 'BgpSessionStatistic'.",
        "default": "None",
        "range_or_options": "PeerState TxOpen RxOpen TxKeepalive RxKeepalive TxUpdate RxUpdate TxAdvertisedUpdate RxAdvertisedUpdate TxWithdrawnUpdate RxWithdrawnUpdate TxAdvertisedRoutes RxAdvertisedRoutes TxWithdrawnRoutes RxWithdrawnRoutes LastTxUpdateRoutes LastRxUpdateRoutes TxNotification RxNotification TxRefresh RxRefresh"
      }
    ],
    "kwargs": [],
    "description": "Retrieves BGP session statistics for the specified session(s) and peer ID. This function wraps `_get_statictis()` to fetch BGP-specific session-level statistics. It supports single or multiple session inputs and allows filtering of statistical items. Internally, it prepares session identifiers and delegates the actual data fetching to `_get_statictis()`.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=BgpSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bgp Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.get_bgp_session_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if exactly one session matches, a pandas DataFrame if multiple sessions match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects, optional",
        "description": "A single session object or a collection of session objects for which statistics are to be retrieved. If None, no session filtering is applied. The Name attribute of each session object is used as the identifier.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties will be queried. If a string, it will be converted into a list. Must be a subset of available BGP session block statistics.",
        "default": "None",
        "range_or_options": "PeerState TxOpen RxOpen TxKeepalive RxKeepalive TxUpdate RxUpdate TxAdvertisedUpdate RxAdvertisedUpdate TxWithdrawnUpdate RxWithdrawnUpdate TxAdvertisedRoutes RxAdvertisedRoutes TxWithdrawnRoutes RxWithdrawnRoutes LastTxUpdateRoutes LastRxUpdateRoutes TxNotification RxNotification TxRefresh RxRefresh"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for BGP session blocks based on the provided session identifiers and statistical items. This function wraps the internal `_get_statictis` method to fetch statistics specific to BGP session blocks. It prepares session identifiers by extracting their names from the provided Session parameter and delegates the actual retrieval logic to the underlying method with appropriate arguments.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=BgpSessionBlockStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Bgp Session Block Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.edit_bgp_port_config",
    "return_type": "bool or BgpPortRateConfig / list of BgpPortRateConfig",
    "return": "Returns True/False based on success, but the actual backend returns a BgpPortRateConfig object or a list of objects corresponding to the provided ports.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list of Port",
        "description": "Test instrument port(s) to configure BGP settings on. Can be a single port or a list of port objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "BgpUpdateMessageRate",
        "type": "int",
        "description": "BGP Update Messages Tx Rate in messages/sec.",
        "default": "10",
        "range_or_options": "1-1000"
      },
      {
        "name": "SessionConnectDelay",
        "type": "int",
        "description": "BGP Session Connect Delay in milliseconds.",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "SessionDisconnectDelay",
        "type": "int",
        "description": "BGP Session Disconnect Delay in milliseconds.",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "BgpSrVersion",
        "type": "str",
        "description": "BGP Segment Routing Version; accepts enumeration keys as strings (e.g., 'RFC8669'). These are converted to numeric values and summed internally.",
        "default": "RFC8669",
        "range_or_options": "RFC8669"
      },
      {
        "name": "SrgbBase",
        "type": "int",
        "description": "Global SRGB Base value for Segment Routing.",
        "default": "16000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "SrgbRange",
        "type": "int",
        "description": "Global SRGB Range value for Segment Routing.",
        "default": "1000",
        "range_or_options": "0-16777215"
      }
    ],
    "description": "Modifies BGP-related configuration parameters on one or more specified test ports. This function supports setting values such as message rates, session delays, and Segment Routing configurations. Special handling is applied when 'BgpSrVersion' is provided, converting string-based enum keys to their numeric equivalents and summing them before applying the configuration.",
    "example": "| Edit Bgp Port Config | Ports=${Ports} | BgpUpdateMessageRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.bgp.sent_bgp_data",
    "return_type": "bool",
    "return": "True if the data was successfully processed for sending, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "BgpProtocolConfig or session object, or list/tuple/set of these",
        "description": "The session through which the BGP data should be sent. If a collection (list, set, tuple) is provided, the first element will be selected. If a BgpProtocolConfig object is passed, it will be used to execute a BgpSendDataCommand with its handle and the provided data. Otherwise, it is assumed that the session object has a `sent_data` method that can be used directly.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Data",
        "type": "str or bytes",
        "description": "The BGP data to be sent. Typically this would be in hexadecimal string format when dealing with low-level BGP protocol operations.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends raw BGP data through the specified session. This function handles sending raw BGP data either by using a BgpProtocolConfig object to construct and execute a BGP send data command, or by directly calling the `sent_data` method on the session object.",
    "example": ".. code:: RobotFramework\n\n    | Sent Bgp Data | Session=${Session} | Data=0x1234567890"
  },
  {
    "method_name": "TesterLibrary.Protocol.common.start_protocol",
    "return_type": "bool",
    "return": "True if the protocol(s) were successfully started, False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list of Port objects or single Port object (optional)",
        "description": "Specifies the physical or logical port(s) on which to start protocols. If not provided and Protocols is also None, all available protocols will be started.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Protocols",
        "type": "str or list of str (optional)",
        "description": "The name(s) of the protocol(s) to start on the given ports. Supported values include 'ospfv2', 'ospfv3', 'dhcpv4', 'dhcpv6', and 'vxlan'. Case-insensitive. If None, all protocols on the given ports will be started.",
        "default": "None",
        "range_or_options": "'ospfv2' 'ospfv3' 'dhcpv4' 'dhcpv6' 'vxlan'"
      },
      {
        "name": "Objects",
        "type": "Protocol object or list of Protocol objects (optional)",
        "description": "Direct reference to specific protocol instance(s) to start. If provided, Ports and Protocols must both be None.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts one or more protocols either on specified ports or directly using protocol session objects. This function supports multiple modes of operation: starting by port and protocol type, starting specific protocol objects directly, or starting all protocols if no parameters are provided. It raises an exception if invalid combinations of parameters are used.",
    "example": ".. code:: RobotFramework\n\n    | Start Protocol |"
  },
  {
    "method_name": "TesterLibrary.Protocol.common.stop_protocol",
    "return_type": "bool",
    "return": "Returns True if the operation is successful, False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list], optional",
        "description": "A single port object or a list of port objects whose associated protocols need to be stopped. If None, all running protocols may be affected depending on other parameters.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Protocols",
        "type": "Union[str, list], optional",
        "description": "A string or list of strings representing protocol names to stop on the given ports. Supported values include 'ospfv2', 'ospfv3', 'dhcpv4', 'dhcpv6', and 'vxlan'. Case-insensitive.",
        "default": "None",
        "range_or_options": "'ospfv2' 'ospfv3' 'dhcpv4' 'dhcpv6' 'vxlan'"
      },
      {
        "name": "Objects",
        "type": "Union[object, list], optional",
        "description": "A single protocol object or a list of protocol objects to stop directly. If this is not None, Ports and Protocols must both be None.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops one or more protocols either by specifying ports, protocol types, or specific protocol objects. This function ensures that only valid combinations of input are used: either Objects alone, or a combination of Ports and/or Protocols. It wraps the underlying stop_protocol implementation and raises an exception if it fails.",
    "example": ".. code:: RobotFramework\n\n    | Stop Protocol |"
  },
  {
    "method_name": "TesterLibrary.Protocol.common.get_sessions",
    "return_type": "List of session objects",
    "return": "A list of session objects corresponding to the specified protocols and/or ports. Each session object is an instance of a class specific to its protocol (e.g., BgpSession, Dhcpv4Session).",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "A port or list of ports from which to retrieve session objects. If None, all ports under the system entry are considered.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Protocols",
        "type": "str or list of str",
        "description": "A protocol or list of protocols used to filter sessions. Each string represents a valid protocol name. Case-insensitive. If None, all available protocols are considered.",
        "default": "not_found",
        "range_or_options": "bgp bfd isis ospfv2 ospfv3 pim rip dot1x dhcpv4server dhcpv4 dhcpv6server dhcpv6 vxlan saa IGMP igmpquery mld mldquery l2tp pppoe ldp lspping pcep"
      }
    ],
    "kwargs": [],
    "description": "Retrieves session objects associated with specified ports and/or protocols. The function dynamically identifies the appropriate session objects based on protocol mappings, and ensures that each session is represented by its corresponding class instance. If a session object has already been created, it is retrieved from a global mapping; otherwise, it is instantiated and cached for future access.",
    "example": "| ${result} | Get Sessions |"
  },
  {
    "method_name": "TesterLibrary.Protocol.common.get_sessions_from_type",
    "return_type": "list",
    "return": "A list of session objects that are instances of the specified protocol type. If no matching sessions are found, an empty list is returned.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of sessions to retrieve. This must be a supported protocol type as listed in the options. It maps to a corresponding session class via `PROTOCOL_MAP` or directly refers to a session class name.",
        "default": "not_found",
        "range_or_options": "bgp bfd isis ospfv2 ospfv3 pim rip dot1x dhcpv4server dhcpv4 dhcpv6server dhcpv6 vxlan saa IGMP igmpquery mld mldquery l2tp pppoe ldp lspping pcep"
      }
    ],
    "kwargs": [],
    "description": "Retrieves all session objects of a specified protocol type from the ROM manager. The function checks if the provided protocol type exists in the global `PROTOCOL_MAP`. If it does, it resolves the actual session type name and filters all objects managed by `self.rom_manager` that match this type. If no matching type is found, it attempts to find a class with the given name directly.",
    "example": ".. code:: RobotFramework\n\n    | ${result} | Get Sessions |"
  },
  {
    "method_name": "TesterLibrary.Protocol.common.select_interface",
    "return_type": "bool",
    "return": "True if the interface selection and binding to session(s) is successful, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "Session object or list of Session objects",
        "description": "The session or list of sessions to which the interface(s) will be assigned. Each session must have a 'handle' attribute used internally by the Renix API for reference.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Interface",
        "type": "Interface object or list of Interface objects",
        "description": "The network interface or list of interfaces to be selected for the given session(s). Each interface must have a 'handle' attribute used internally by the Renix API for reference.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function binds one or more specified network interfaces to one or more test sessions using the Renix API. It ensures that both the Session and Interface parameters are in list format (if not already provided), and then executes the command to associate them via the `SelectInterfaceCommand`. This abstraction allows users to work with high-level Session and Interface objects instead of directly managing internal handles.",
    "example": "| Select Interface | Session=${Session} | Interface=${Interface} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.create_dhcp_client",
    "return_type": "DhcpClient",
    "return": "DHCP协议会话对象，用于后续管理和交互该DHCP客户端实例。",
    "parameters": [
      {
        "name": "Port",
        "type": "Port",
        "description": "测试仪表端口对象，表示DHCP客户端所绑定的物理或逻辑端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCP协议会话名称，用于标识此客户端会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "DHCPv4客户端模式，定义客户端的行为方式。",
        "default": "CLIENT",
        "range_or_options": "CLIENT RELAY_AGENT"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "主机名，用于在DHCP请求中发送给服务器。",
        "default": "XINERTEL",
        "range_or_options": "not_found"
      },
      {
        "name": "ParameterRequests",
        "type": "list",
        "description": "客户端希望从服务器获取的选项列表。",
        "default": "['NONEOPTION', 'SUBNET_MASK', 'DOMAIN_NAME_SERVERS', 'DOMAIN_NAME', 'STATIC_ROUTES']",
        "range_or_options": "SUBNET_MASK ROUTERS DOMAIN_NAME_SERVERS DOMAIN_NAME STATIC_ROUTES IP_LEASE_TIME SERVER_IDENTIFIER T1 T2"
      },
      {
        "name": "EnableRouterOption",
        "type": "bool",
        "description": "是否启用路由选项。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "VendorClassIdentifier",
        "type": "str",
        "description": "供应商类标识符，用于向服务器标识客户端类型。",
        "default": "XINERTEL",
        "range_or_options": "not_found"
      },
      {
        "name": "BroadcastFlag",
        "type": "str",
        "description": "指定DHCP消息的传输标志是单播还是广播。",
        "default": "BROADCAST",
        "range_or_options": "UNICAST BROADCAST"
      },
      {
        "name": "RelayAgentIp",
        "type": "str",
        "description": "当处于RELAY_AGENT模式时，使用的代理IP地址。",
        "default": "1.1.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "ServerIp",
        "type": "str",
        "description": "DHCPv4服务端的IP地址。",
        "default": "2.1.1.3",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "EnableRelayAgentCircuitID",
        "type": "bool",
        "description": "是否启用代理电路标识（Circuit ID）。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentCircuitID",
        "type": "str",
        "description": "代理电路标识字符串。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableRelayAgentRemoteID",
        "type": "bool",
        "description": "是否启用代理远程标识（Remote ID）。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentRemoteID",
        "type": "str",
        "description": "代理远程标识字符串。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableSyncAddressToInterface",
        "type": "bool",
        "description": "是否将分配的IP地址同步到接口配置。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "HostInterface",
        "type": "Interface",
        "description": "客户端所关联的网络接口对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "创建并配置一个DHCPv4客户端实例，并将其注册到全局协议对象映射中以便后续引用。该函数初始化了一个与指定端口相关联的DhcpClient对象，并通过关键字参数提供额外的配置选项。",
    "example": "| ${Session} | Create Dhcp Client | Port=${Port} | Name=DHCP_Client_1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.edit_dhcp_client",
    "return_type": "bool",
    "return": "A boolean value indicating whether the operation was successful (True) or failed (False).",
    "description": "Updates the attributes of an existing DHCPv4 client session object with the provided configuration parameters. This function allows modifying various properties of a DHCP client such as its mode, host name, request options, IP addresses, and relay agent settings.",
    "example": "| Edit Dhcp Client | Session=${Session} | RelayAgentIp=2.2.2.2 |",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`DhcpClient`",
        "description": "The DHCPv4 client protocol session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCP protocol session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "DHCPv4 client mode of operation.",
        "default": "CLIENT",
        "range_or_options": "CLIENT RELAY_AGENT"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "Hostname of the DHCPv4 client.",
        "default": "XINERTEL",
        "range_or_options": "not_found"
      },
      {
        "name": "ParameterRequests",
        "type": "list",
        "description": "List of requested DHCP options by the client.",
        "default": "['NONEOPTION', 'SUBNET_MASK', 'DOMAIN_NAME_SERVERS', 'DOMAIN_NAME', 'STATIC_ROUTES']",
        "range_or_options": "SUBNET_MASK ROUTERS DOMAIN_NAME_SERVERS DOMAIN_NAME STATIC_ROUTES IP_LEASE_TIME SERVER_IDENTIFIER T1 T2"
      },
      {
        "name": "EnableRouterOption",
        "type": "bool",
        "description": "Flag to enable router option in DHCP requests.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "VendorClassIdentifier",
        "type": "str",
        "description": "Vendor class identifier for the DHCP client.",
        "default": "XINERTEL",
        "range_or_options": "not_found"
      },
      {
        "name": "BroadcastFlag",
        "type": "str",
        "description": "Specifies whether the client should send broadcast messages.",
        "default": "BROADCAST",
        "range_or_options": "UNICAST BROADCAST"
      },
      {
        "name": "RelayAgentIp",
        "type": "str (IPv4)",
        "description": "IP address of the relay agent if acting in RELAY_AGENT mode.",
        "default": "1.1.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "ServerIp",
        "type": "str (IPv4)",
        "description": "IP address of the DHCP server.",
        "default": "2.1.1.3",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "EnableRelayAgentCircuitID",
        "type": "bool",
        "description": "Flag to enable Circuit ID in relay agent suboptions.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentCircuitID",
        "type": "str",
        "description": "Circuit ID used in relay agent suboption 1.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableRelayAgentRemoteID",
        "type": "bool",
        "description": "Flag to enable Remote ID in relay agent suboptions.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentRemoteID",
        "type": "str",
        "description": "Remote ID used in relay agent suboption 2.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableSyncAddressToInterface",
        "type": "bool",
        "description": "If True, the obtained IP address will be synchronized with the interface.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "HostInterface",
        "type": ":obj:`Interface`",
        "description": "Interface object associated with the DHCP client.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_bind",
    "return_type": "bool",
    "return": "布尔值，表示 DHCP 会话绑定操作是否成功。总是返回 True 表示所有提供的会话都已成功处理；若返回 False 则抛出异常。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "一个DHCP客户端会话对象或一组会话对象的集合（如列表、集合或元组）。每个会话对象必须包含 `bind()` 方法以执行实际的绑定逻辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "将指定的一个或多个 DHCP 会话绑定到关联的网络接口。此函数确保 DHCP 客户端能够与物理或逻辑网络接口相关联，以便进行通信。如果任何提供的会话对象不支持 `bind()` 方法，则会抛出 TypeError 异常。",
    "example": ".. code:: RobotFramework\n\n    | Dhcp Bind | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_abort",
    "return_type": "bool",
    "return": "布尔值，表示DHCP会话中断操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpClient or iterable of DhcpClient",
        "description": "DHCPv4客户端协议对象或其集合，代表需要中断的DHCP会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于中断一个或多个DHCPv4客户端会话。如果传入的是单个Session对象，则会被转换为列表以统一处理。函数内部对每个Session调用其abort()方法，完成DHCP会话的实际终止操作。",
    "example": ".. code:: RobotFramework\n\n    | Dhcp Abort | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_rebind",
    "return_type": "bool",
    "return": "True if the rebind operation was successfully initiated on all provided sessions; False is not returned directly, but may raise a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpClient or iterable of DhcpClient",
        "description": "A single DHCP client session object or an iterable (list, set, tuple) of such objects that support the `rebind()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the DHCPv4 rebind operation on one or more provided DHCP client session objects. It wraps the backend call to `renix.dhcp_rebind`, and if the result is False, it raises a ContinuableFailure exception to indicate failure in Robot Framework context.",
    "example": "| Dhcp Rebind | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_reboot",
    "return_type": "bool",
    "return": "布尔值，表示DHCP客户端重启操作是否成功启动。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpClient or iterable of DhcpClient",
        "description": "一个或多个DHCP客户端会话对象。支持传入单个会话对象或包含多个会话的可迭代对象（如列表、集合或元组）。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于重新启动指定的一个或多个DHCPv4客户端会话。在底层，它会遍历所有提供的会话并调用每个会话的`reboot()`方法。通常用于网络测试或配置过程中模拟DHCP客户端的重启行为。如果任意会话的`reboot()`失败，可能会抛出异常。",
    "example": "| Dhcp Reboot | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_release",
    "return_type": "bool",
    "return": "True if the DHCP release operation was successfully performed on all provided sessions, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpClient or list or set or tuple",
        "description": "A single DHCPv4 client session object or a collection of session objects to be released.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Releases the DHCPv4 address for the specified client session(s). This function accepts either a single DhcpClient session or a collection (list, set, or tuple) of sessions. If a single session is provided, it is converted into a list for uniform processing. Each session in the list is then released by calling its 'release' method. The function returns True if all releases are successful; otherwise, it returns False.",
    "example": "| Dhcp Release | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_renew",
    "return_type": "bool",
    "return": "True if the DHCP renewal process is successfully initiated for all sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpClient or iterable of DhcpClient objects",
        "description": "DHCPv4 client session(s) to renew. Can be a single DhcpClient object or an iterable (list, set, tuple) of multiple DhcpClient objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates a DHCPv4 unicast renewal operation for one or more DHCP client sessions. It forwards the provided session(s) to the backend Renix API's `dhcp_renew` method. If any session fails to renew, a TypeError may be raised by the backend. If the renewal fails at the framework level, a ContinuableFailure exception is raised to indicate test continuation capability.",
    "example": "| Dhcp Renew | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.create_dhcp_client_custom_option",
    "return_type": "Dhcpv4ClientOption or list of Dhcpv4ClientOption",
    "return": "返回创建的DHCP协议会话option对象。如果传入单个Session，则返回单个对象；如果传入多个Session，则返回对象列表。",
    "description": "该函数用于在一个或多个DHCP客户端会话对象上创建自定义的DHCP选项（Option）。它封装了底层`create_option`方法的调用，并根据传入的Session数量返回单个结果或结果列表。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "DHCPv4客户端会话对象，可以是单个对象或者一个包含多个对象的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OptionTag",
        "type": "number",
        "description": "可选项类型标识符。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "OptionType",
        "type": "str",
        "description": "可选项的数据类型。",
        "default": "HEX",
        "range_or_options": "HEX STRING BOOLEAN INT8 INT16 INT32 IP"
      },
      {
        "name": "EnableOptionValueList",
        "type": "bool",
        "description": "是否启用选项值列表。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionValue",
        "type": "str",
        "description": "可选项的具体值。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "MessageType",
        "type": "list",
        "description": "指定该选项应携带在哪类DHCP消息中。",
        "default": "['DISCOVER']",
        "range_or_options": "DISCOVER REQUEST"
      }
    ],
    "example": "| Create Dhcp Client Custom Option | Session=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.edit_dhcp_client_port_config",
    "return_type": "Dhcpv4PortConfig or list of Dhcpv4PortConfig",
    "return": "If a single port is processed, returns the modified Dhcpv4PortConfig object. If multiple ports are processed, returns a list of modified Dhcpv4PortConfig objects in the same order as the input.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list",
        "description": "The test instrument port object(s) for which DHCPv4 client configuration will be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SetupRate",
        "type": "int",
        "description": "Specifies the rate at which sessions are created, in sessions per second.",
        "default": "100",
        "range_or_options": "1-65535"
      },
      {
        "name": "TeardownRate",
        "type": "int",
        "description": "Specifies the rate at which sessions are deleted, in sessions per second.",
        "default": "100",
        "range_or_options": "1-65535"
      },
      {
        "name": "MaxOutstanding",
        "type": "int",
        "description": "Maximum number of outstanding session creation or deletion requests allowed at any time.",
        "default": "100",
        "range_or_options": "1-65535"
      },
      {
        "name": "LeaseTime",
        "type": "int",
        "description": "Desired lease time in seconds that the client requests from the server.",
        "default": "600",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "SessionRetryCount",
        "type": "int",
        "description": "Number of times to retry creating a session if it fails initially.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MessageRetryCount",
        "type": "int",
        "description": "Number of times to retry sending a message if it times out.",
        "default": "5",
        "range_or_options": "0-65535"
      },
      {
        "name": "MessageTimeout",
        "type": "int",
        "description": "Time (in seconds) to wait before timing out and retrying a message.",
        "default": "10",
        "range_or_options": "1-99999"
      },
      {
        "name": "MaxMessageSize",
        "type": "int",
        "description": "Maximum payload size (in bytes) allowed for DHCP messages.",
        "default": "576",
        "range_or_options": "291-1500"
      }
    ],
    "description": "Edits the DHCPv4 client configuration for one or more specified ports. This function modifies the 'Dhcpv4PortConfig' child object associated with each provided port, applying the specified configuration changes via keyword arguments.",
    "example": "| Edit Dhcp Client Port Config | Port=${Port} | SetupRate=65535 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.get_dhcp_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary containing the requested DHCPv4 port statistics if exactly one port matches, a pandas DataFrame if multiple ports match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects or None",
        "description": "A single test instrument port object or a collection of port objects for which to retrieve DHCPv4 port statistics. Each port object must have a `handle` attribute used internally for indexing. If None, statistics may be retrieved globally (if supported).",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items to retrieve. If None, all available properties are fetched. Supported statistical items include: CurrentAttempt, CurrentBound, TotalAttempt, TotalBound, TotalFailed, TotalReboot, TotalRenew, TotalRebind, TotalRetry, TxDiscover, RxOffer, TxRequest, RxAck, RxNak, TxRenew, TxRebind, TxReboot, TxRelease, RxForceRenew. If a string is provided, it will be converted into a list.",
        "default": "None",
        "range_or_options": "CurrentAttempt CurrentBound TotalAttempt TotalBound TotalFailed TotalReboot TotalRenew TotalRebind TotalRetry TxDiscover RxOffer TxRequest RxAck RxNak TxRenew TxRebind TxReboot TxRelease RxForceRenew"
      }
    ],
    "kwargs": [],
    "description": "Retrieves DHCPv4 port-level statistics for one or more specified ports. This function wraps an internal method to fetch performance-based statistics or from existing result views. The returned value depends on the number of matching rows: a dictionary if exactly one row matches, a DataFrame for multiple rows, or False if no match is found. It optionally supports refreshing statistics before retrieval based on the mode set in the backend.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | CurrentAttempt | CurrentBound |\n    | Subscribe Result | Types=Dhcpv4PortStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcp Port Statistic | Port=${Port} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.get_dhcp_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary containing requested DHCP client statistics if one matching row is found. If multiple rows match, returns a pandas DataFrame with the data. Returns False if no matching result is found.",
    "description": "Retrieves DHCP client statistics for specified session(s) and session index. This function wraps an internal method to fetch DHCPv4 client-related statistics. It processes the input session information, constructs appropriate index values, and filters to return specific statistical data related to DHCP clients.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "The session object(s) representing DHCP client handles. If None, no session filtering is applied. If a single object, its name is used as 'ClientHandle'. If multiple objects, their names are collected into a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Id",
        "type": "int or str, optional",
        "description": "The session index used to further identify a specific DHCP client within the session. Passed as 'SessionIndex' in the index dictionary to filter results.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCP client stats. If None, all available properties are queried automatically. If a string, it's converted into a list. Must be a subset of available columns.",
        "default": "not_found",
        "range_or_options": "ClientState IpAddress LeaseTime LeaseLeft ErrorStatus DiscoverResponseTime RequestResponseTime"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | LeaseTime | DiscoverResponseTime |\n    | Subscribe Result | Types=Dhcpv4ClientStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcp Client Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.get_dhcp_client_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary if one matching row is found, a DataFrame if multiple rows are found, and False if no results match.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "The session object(s) representing DHCP client blocks. Each session should have a `Name` attribute. If None, no session filtering is applied in the statistic query.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCP client block statistics. Must be a subset of available properties defined for 'Dhcpv4ClientBlockStats'.",
        "default": "None",
        "range_or_options": "BlockState AttemptRate SetupRate CurrentAttempt CurrentBound TotalAttempt TotalBound TotalFailed TotalReboot TotalRenew TotalRebind TotalRetry TxDiscover RxOffer TxRequest RxAck RxNak TxRenew TxRebind TxReboot TxRelease TxDecline RxForceRenew"
      }
    ],
    "kwargs": [],
    "description": "Retrieves DHCP client block statistics for the specified session(s). This function wraps around `_get_statictis()` to fetch DHCPv4 client block-level statistics. It accepts a session or list of sessions and optionally specifies which statistical items to retrieve. If a session is provided, it extracts session names accordingly before delegating to the internal method.",
    "example": "| @{StaItems} | Create List | CurrentAttempt | CurrentBound |\n| Subscribe Result | Types=Dhcpv4ClientBlockStats |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Dhcp Client Block Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.wait_dhcp_client_state",
    "return_type": "bool",
    "return": "Returns True if all DHCP client sessions reach the desired state within the timeout period. Returns False only if the result from the backend function is explicitly False and failure is non-fatal.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of DHCP client session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list",
        "description": "The target state or list of states that each DHCP client session must reach. Defaults to 'BOUND'.",
        "default": "'BOUND'",
        "range_or_options": "NOT_READY IDLE BINDING BOUND RELEASING RENEWING REBINDING REBOOTING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval in seconds between successive checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time in seconds to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until one or more DHCPv4 client sessions reach a specified state (e.g., 'BOUND'). The function polls the session states at regular intervals and ensures all sessions transition to one of the expected states before the timeout occurs. If any session fails to reach the expected state within the timeout, a failure is raised.",
    "example": "| Wait Dhcp Client State | Sessions=${Sessions} | State=${State} | Interval=${Interval} | TimeOut=${TimeOut} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.create_dhcp_server",
    "return_type": "DhcpServer",
    "return": "DHCP Server会话对象",
    "parameters": [
      {
        "name": "Port",
        "type": "Port",
        "description": "测试仪表端口对象，表示DHCP Server所绑定的网络接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCP Server协议会话名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LeaseTime",
        "type": "number",
        "description": "租约时间（秒）。",
        "default": "600",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RenewTime",
        "type": "number",
        "description": "T1租约更新时间（%）。客户端在租约过半时尝试续租。",
        "default": "50",
        "range_or_options": "0-200"
      },
      {
        "name": "RebindTime",
        "type": "number",
        "description": "T2租约更新时间（%）。客户端在租约快到期时尝试重新绑定。",
        "default": "87.5",
        "range_or_options": "0-200"
      },
      {
        "name": "MinLeaseTime",
        "type": "number",
        "description": "最小允许租约时间（秒），用于限制客户端请求的最短租期。",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DeclineReserveTime",
        "type": "number",
        "description": "资源释放等待时间（秒），当地址被拒绝后保留的时间。",
        "default": "10",
        "range_or_options": "1-600"
      },
      {
        "name": "OfferReserveTime",
        "type": "number",
        "description": "租约申请超时时间（秒），服务器发送OFFER后等待客户端响应的最大时间。",
        "default": "10",
        "range_or_options": "1-600"
      },
      {
        "name": "ServerHostName",
        "type": "str",
        "description": "服务端名字，用于标识DHCP服务器的身份。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "DuplicateAddressDetection",
        "type": "bool",
        "description": "是否启用重复地址检测（DAD）功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DuplicateAddressDetectionTimeout",
        "type": "number",
        "description": "DAD检测超时时间（秒）。",
        "default": "0.5",
        "range_or_options": "0-60"
      }
    ],
    "description": "创建并配置一个DHCP Server会话对象，并将其与指定端口绑定。该函数初始化DhcpServer实例，并通过提供的关键字参数进行动态配置。创建完成后，该实例会被注册到全局协议对象映射中以便后续使用。",
    "example": ".. code:: RobotFramework\n\n    | Create Dhcp Server | Port=${Port} | RenewTime=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.edit_dhcp_server",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was attempted successfully. Returns True if successful, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`DhcpServer`",
        "description": "DHCPv4 server session object whose attributes are to be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCP Server session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LeaseTime",
        "type": "number",
        "description": "Lease time in seconds.",
        "default": "600",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RenewTime",
        "type": "number",
        "description": "T1 lease renewal time (in percentage).",
        "default": "50",
        "range_or_options": "0-200"
      },
      {
        "name": "RebindTime",
        "type": "number",
        "description": "T2 lease renewal time (in percentage).",
        "default": "87.5",
        "range_or_options": "0-200"
      },
      {
        "name": "MinLeaseTime",
        "type": "number",
        "description": "Minimum allowed lease time in seconds.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DeclineReserveTime",
        "type": "number",
        "description": "Resource release wait time in seconds.",
        "default": "10",
        "range_or_options": "1-600"
      },
      {
        "name": "OfferReserveTime",
        "type": "number",
        "description": "Lease request timeout in seconds.",
        "default": "10",
        "range_or_options": "1-600"
      },
      {
        "name": "ServerHostName",
        "type": "str",
        "description": "Hostname of the DHCP server.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DuplicateAddressDetection",
        "type": "bool",
        "description": "Enable or disable Duplicate Address Detection (DAD).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DuplicateAddressDetectionTimeout",
        "type": "number",
        "description": "Timeout for Duplicate Address Detection (DAD) in seconds.",
        "default": "0.5",
        "range_or_options": "0-60"
      }
    ],
    "description": "Modifies the attributes of a DHCP server session object based on the provided keyword arguments. This function is typically used to update configuration parameters of an existing DHCPv4 server session within a test or automation framework.",
    "example": ".. code:: RobotFramework\n\n    | Edit Dhcp Server | Session=${Session} | LeaseTime=1000 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.create_dhcp_server_custom_option",
    "return_type": "object or list",
    "return": "A single Dhcpv4ClientOption object if one option is created, or a list of Dhcpv4ClientOption objects if multiple options are created based on combinations of Session and Upper.",
    "parameters": [
      {
        "name": "Session",
        "type": "object / list",
        "description": "DHCPv4 Client protocol object or list of such objects under which the DHCP server custom option will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Upper",
        "type": "object / list",
        "description": "DhcpClient or Dhcpv4AddressPool object(s) where the custom option will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OptionTag",
        "type": "number",
        "description": "The numeric identifier for the custom DHCP option (code).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "OptionType",
        "type": "str",
        "description": "The data type used to interpret the option value.",
        "default": "HEX",
        "range_or_options": "HEX STRING BOOLEAN INT8 INT16 INT32 IP"
      },
      {
        "name": "EnableOptionValueList",
        "type": "bool",
        "description": "Whether to treat the OptionValue as a list of values.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionValue",
        "type": "str",
        "description": "The value of the custom DHCP option. Interpreted according to OptionType.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "MessageType",
        "type": "list",
        "description": "Specifies in which DHCP message types this option should be included.",
        "default": "['OFFER', 'ACK']",
        "range_or_options": "OFFER ACK NAK"
      }
    ],
    "description": "创建测试仪表DHCP协议会话option对象。该函数在给定的一个或多个DHCP客户端会话和上层对象（如地址池）下创建自定义的DHCP服务器选项，并根据提供的参数配置其属性。",
    "example": "| Create Dhcp Server Custom Option | Session=${Sessions} | OptionTag=120 | OptionType=STRING | OptionValue=mydomain.com | MessageType=['OFFER', 'ACK']"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.create_dhcp_server_address_pool",
    "return_type": "object or list of objects",
    "return": "DHCP地址池对象列表。如果传入单个会话，则返回单个DHCP地址池对象；如果传入多个会话，则返回对象列表。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of objects",
        "description": "DHCPv4 Server协议会话对象或其列表，每个会话应包含`create_pool`方法用于实际创建地址池。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCP Server协议会话的名称。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "PoolAddressStart",
        "type": "str",
        "description": "地址池起始IP地址。",
        "default": "1.1.1.2",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "PoolAddressStep",
        "type": "str",
        "description": "地址分配步长。",
        "default": "0.0.0.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "PrefixLength",
        "type": "number",
        "description": "子网前缀长度。",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "RouterList",
        "type": "list",
        "description": "默认网关地址列表。",
        "default": "\"\"",
        "range_or_options": "列表元素为有效的IPv4地址"
      },
      {
        "name": "LimitPoolCount",
        "type": "bool",
        "description": "是否限制地址池中地址数量。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PoolAddressCount",
        "type": "number",
        "description": "地址池中的地址总数。",
        "default": "255",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DomainName",
        "type": "str",
        "description": "分配给客户端的域名。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "DnsList",
        "type": "list",
        "description": "DNS服务器地址列表。",
        "default": "\"\"",
        "range_or_options": "列表元素为有效的IPv4地址"
      }
    ],
    "description": "该函数用于为一个或多个DHCPv4 Server会话对象创建DHCP地址池。它调用每个会话对象的`create_pool`方法，并将所有关键字参数传递给这些方法。若传入的是单个会话对象，函数内部将其转换为列表以保持一致性。最终根据结果数量决定返回单个对象还是对象列表。",
    "example": "| Create Dhcp Server Address Pool | Sessions=${Sessions} | PoolAddressStart=2.2.2.2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.edit_dhcp_server_port_config",
    "return_type": "Dhcpv4ServerPortConfig or list of Dhcpv4ServerPortConfig",
    "return": "If a single port is provided, returns the modified Dhcpv4ServerPortConfig object. If multiple ports are provided, returns a list containing the modified configuration objects for each port.",
    "description": "Modifies the DHCPv4 server port configuration for one or more specified ports by updating configuration parameters such as RenewRate and MaxOutstanding. This function internally retrieves the 'Dhcpv4ServerPortConfig' child object associated with each port and applies the provided changes via keyword arguments.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or iterable",
        "description": "A single port object or an iterable (list, set, tuple) of port objects for which the DHCP server configuration needs to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RenewRate",
        "type": "int",
        "description": "Forced unicast renewal rate, representing how many renewals per second.",
        "default": "100",
        "range_or_options": "1-65535"
      },
      {
        "name": "MaxOutstanding",
        "type": "int",
        "description": "Maximum number of outstanding requests allowed at any given time.",
        "default": "1000",
        "range_or_options": "1-65535"
      }
    ],
    "example": "| Edit Dhcp Server Port Config | Port=${Port} | RenewRate=1000 |",
    "raises": [
      {
        "exception": "IndexError",
        "description": "If a port does not have a 'Dhcpv4ServerPortConfig' child object."
      },
      {
        "exception": "TypeError",
        "description": "If any of the provided ports is not a valid port object with expected methods."
      },
      {
        "exception": "ContinuableFailure",
        "description": "If the internal edit operation returns False, indicating failure."
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.get_dhcp_server_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns DHCP server statistics based on the provided session(s) and statistical items. If exactly one matching row is found, returns a dictionary of requested statistics. If multiple rows match, returns a pandas DataFrame. If no match is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "A session object or collection of session objects representing the DHCP server sessions. Each session object must have a `Name` attribute used as the session identifier in the index. If None, no filtering by session is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCP server statistics. Supported values include 'CurrentBound', 'TotalBound', 'TotalExpire', 'TotalReboot', 'TotalRenew', 'TotalRebind', 'TotalRelease', 'RxDiscover', 'TxOffer', 'RxRequest', 'TxAck', 'TxNak', 'RxDecline', 'RxRelease', 'TxForceRenew'. If None, all available properties are queried. If a string is passed, it will be converted into a list containing that string.",
        "default": "None",
        "range_or_options": "'CurrentBound' 'TotalBound' 'TotalExpire' 'TotalReboot' 'TotalRenew' 'TotalRebind' 'TotalRelease' 'RxDiscover' 'TxOffer' 'RxRequest' 'TxAck' 'TxNak' 'RxDecline' 'RxRelease' 'TxForceRenew'"
      }
    ],
    "kwargs": [],
    "description": "Retrieves DHCP server statistics based on the provided session(s) and statistical items. This function wraps around `_get_statictis()` to specifically fetch DHCPv4 server-related statistics. It accepts a session or list of sessions and optionally specifies which statistical items to retrieve. Internally, it processes the `Session` argument to extract session names and delegates the actual statistic retrieval to `_get_statictis()` with appropriate parameters. If no matching result is found, it returns False, otherwise returning either a dictionary or DataFrame depending on the number of matched rows.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | CurrentBound | TotalBound |\n    | Subscribe Result | Types=Dhcpv4ServerStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcp Server Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.get_dhcp_server_lease_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns DHCP server lease statistics based on the session, client identifier, and requested statistical items. If exactly one match is found, returns a dictionary of results; if multiple matches are found, returns a pandas DataFrame; if no matches are found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "A session object or collection of session objects representing the DHCP server. If None, no session filtering is applied. Each session object must have a 'Name' attribute used as the session identifier.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ClientId",
        "type": "str or None",
        "description": "The identifier of the DHCP client to filter lease statistics. If None, statistics are not filtered by client ID.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available items are queried. If a string is provided, it is converted into a single-element list. Supported items: ClientIp, LeaseTime, LeaseLeft.",
        "default": "not_found",
        "range_or_options": "ClientIp LeaseTime LeaseLeft"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves DHCPv4 server lease statistics based on a given session, client identifier, and specified statistical items. It acts as a wrapper around the internal `_get_statictis` function and processes input parameters accordingly. It can return a dictionary for a single result, a pandas DataFrame for multiple results, or False if no matching data is found.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | LeaseTime | LeaseLeft |\n    | Subscribe Result | Types=Dhcpv4LeaseStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcp Server Lease Statistic | Session=${Session} | ClientId=00:00:12:01:01:03 | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.wait_dhcp_server_state",
    "return_type": "bool",
    "return": "Returns True if all DHCP server sessions reach one of the desired states within the timeout period. If not, returns False (which raises a ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of DHCP Server session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list of str",
        "description": "The target state(s) that the DHCP server sessions must reach. If None, defaults to 'UP'.",
        "default": "'UP'",
        "range_or_options": "'NOT_READY' 'DOWN' 'UP'"
      },
      {
        "name": "Interval",
        "type": "number",
        "description": "The time interval in seconds between successive checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "number",
        "description": "The maximum time in seconds to wait for all sessions to reach the desired state(s).",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until all provided DHCP server sessions reach a specified state. This function blocks execution and polls each session at regular intervals until either all sessions match one of the expected states or the timeout is reached. If the timeout occurs before all sessions are in the desired state, it raises a failure exception.",
    "example": "| Wait Dhcp Server State | Sessions=${Sessions} | State=${State} | Interval=${Interval} | TimeOut=${TimeOut} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_force_renew",
    "return_type": "bool",
    "return": "True if the DHCP force renew operation is successfully initiated, False if it fails (though in practice, False raises an exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpServer or iterable of DhcpServer",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing the DHCP client sessions for which to force a lease renewal.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Forces a DHCP lease renewal for one or more session objects. If the input is not a list, set, or tuple, it is converted into a list containing that single session. Then, it iterates over each session and calls the `renew()` method to force DHCP lease renewal. This function is typically used in automated testing environments to simulate or trigger DHCP lease renewal events.",
    "example": "| Dhcp Force Renew | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv4.dhcp_abort_server",
    "return_type": "bool",
    "return": "True if the operation completes successfully, False if any session could not be aborted (though in practice, False raises an exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "DhcpServer or iterable of DhcpServer objects",
        "description": "The DHCP server session or a collection of sessions to be gracefully aborted.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function is used to gracefully abort one or more DHCPv4 server sessions. It internally calls the backend function which iterates over each provided session and invokes its `abort()` method. The function ensures that all given sessions are processed properly and returns True upon successful completion. If the result is False, it raises a ContinuableFailure exception indicating a failure in aborting the sessions.",
    "example": "| Dhcp Abort Server | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_client",
    "return_type": "Dhcpv6Client",
    "return": "DHCPv6客户端会话对象",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCPv6客户端会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能DHCPv6客户端会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "会话模式",
        "default": "DHCPV6",
        "range_or_options": "DHCPV6 DHCPV6PD DHCPV6ANDPD"
      },
      {
        "name": "EnableRenewMsg",
        "type": "bool",
        "description": "使能Renew消息",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableRebindMsg",
        "type": "bool",
        "description": "使能Rebind消息",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableReconfigAccept",
        "type": "bool",
        "description": "使能Reconfigure消息",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSyncAddressInterface",
        "type": "bool",
        "description": "启用地址同步接口",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "T1Timer",
        "type": "int",
        "description": "T1时刻（秒）",
        "default": "302400",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "T2Timer",
        "type": "int",
        "description": "T2时刻（秒）",
        "default": "483840",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "PreferredLifetime",
        "type": "int",
        "description": "首选生命周期（秒）",
        "default": "604800",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "有效生命周期（秒）",
        "default": "2592000",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "RapidCommitOptMode",
        "type": "str",
        "description": "快速交互模式",
        "default": "DISABLE",
        "range_or_options": "DISABLE ENABLE SERVERSET"
      },
      {
        "name": "DuidType",
        "type": "str",
        "description": "DUID类型",
        "default": "LL",
        "range_or_options": "LLT EN LL CUSTOM"
      },
      {
        "name": "DuidCustomValue",
        "type": "int",
        "description": "自定义DUID编号",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "DuidEnterpriseNumber",
        "type": "int",
        "description": "DUID企业编号",
        "default": "3456",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DuidStartValue",
        "type": "str",
        "description": "DUID起始值，匹配正则表达式'^([0-9a-fA-F]{1,256})$'",
        "default": "3456",
        "range_or_options": "Regex: ^([0-9a-fA-F]{1,256})$"
      },
      {
        "name": "DuidStepValue",
        "type": "int",
        "description": "DUID标识符跳变",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DestinationAddress",
        "type": "str",
        "description": "目的地址",
        "default": "ALL",
        "range_or_options": "ALL SERVER"
      },
      {
        "name": "EnableRelayAgent",
        "type": "bool",
        "description": "使能中继代理",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RelayAgentIp",
        "type": "str",
        "description": "中继代理IP地址",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "ServerIp",
        "type": "str",
        "description": "服务端IP地址",
        "default": "2001::2",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableUseRelayAgentMacForTraffic",
        "type": "bool",
        "description": "使用中继代理MAC地址进行流量传输",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RequestPrefixLength",
        "type": "int",
        "description": "请求前缀长度",
        "default": "64",
        "range_or_options": "0-128"
      },
      {
        "name": "RequestPrefixStartAddress",
        "type": "str",
        "description": "请求前缀地址",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "ControlPlaneSrcIPv6Addr",
        "type": "str",
        "description": "控制平面源IPv6地址",
        "default": "LINKLOCAL",
        "range_or_options": "LINKLOCAL ROUTEADVERTISEMENT"
      },
      {
        "name": "RequestStartAddress",
        "type": "str",
        "description": "请求起始地址",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableAuthentication",
        "type": "bool",
        "description": "使能认证",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AuthenticationProtocol",
        "type": "str",
        "description": "认证协议",
        "default": "DELAYED",
        "range_or_options": "DELAYED RECONFIGURATION"
      },
      {
        "name": "DhcpRealm",
        "type": "str",
        "description": "认证域名称",
        "default": "'xinertel.com'",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationKeyId",
        "type": "int",
        "description": "认证秘钥ID",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthenticationKey",
        "type": "str",
        "description": "认证密钥",
        "default": "''",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationKeyType",
        "type": "str",
        "description": "认证秘钥类型",
        "default": "ASCII",
        "range_or_options": "ASCII HEX"
      },
      {
        "name": "EnableDad",
        "type": "bool",
        "description": "使能重复地址检测（DAD）",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DadTimeout",
        "type": "int",
        "description": "DAD超时时间（秒）",
        "default": "2",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DadTransmits",
        "type": "int",
        "description": "DAD传输次数",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "HostInterface",
        "type": "object",
        "description": "接口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "该方法用于在指定的端口上创建并配置一个DHCPv6客户端实例。此客户端将绑定到提供的端口，并通过全局协议对象映射进行注册。可以通过关键字参数对客户端进行进一步的配置。",
    "example": "| Create Dhcpv6 Client | Port=${Port} | DadTransmits=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_client_custom_options",
    "return_type": "object or list of Dhcpv6ClientCustomOptionsConfig",
    "return": "DHCPv6 Client Custom Options configuration object(s). If a single session is provided, returns a single configuration object. If multiple sessions are provided, returns a list of configuration objects in the same order.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dhcpv6Client or iterable of Dhcpv6Client",
        "description": "DHCPv6 client session object(s) for which custom options will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OptionVal",
        "type": "int",
        "description": "Option identifier (0-255). This specifies the numeric code of the DHCPv6 option to configure.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "IncludeMsg",
        "type": "list of str",
        "description": "List of message types in which the custom option should be included. Default: ['SOLICIT', 'REQUEST'].",
        "default": "['SOLICIT', 'REQUEST']",
        "range_or_options": "SOLICIT REQUEST CONFIRM RENEW REBIND RELEASE INFOREQUEST RELAYFORWARD"
      },
      {
        "name": "Wildcards",
        "type": "bool",
        "description": "Enable wildcard matching for this option. Default: False.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StringIsHexadecimal",
        "type": "bool",
        "description": "Interpret string values as hexadecimal if True. Default: False.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OptionPayload",
        "type": "str",
        "description": "String payload for the option content. Default: empty string (''). Length must be between 0 and 512 characters.",
        "default": "",
        "range_or_options": "string length in [0,512]"
      },
      {
        "name": "OptionHexPayload",
        "type": "int",
        "description": "Hexadecimal representation of the option payload. Default: None.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "RemoveOption",
        "type": "bool",
        "description": "If True, removes the specified option from the client. Default: False.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Configures custom DHCPv6 client options for one or more session objects. It allows users to define specific behaviors or payloads for DHCPv6 options that are sent during various message exchanges. The function ensures uniform configuration across all provided sessions and returns the corresponding configuration object(s).",
    "example": ".. code:: RobotFramework\n\n    | ${Dhcpv6} | Create Dhcpv6 Client | Port=${Port} |\n    | Create Dhcpv6 Client Custom Options | Sessions=${Dhcpv6} | Wildcards=True | OptionVal=23 | OptionPayload='ABC' | IncludeMsg=['INFOREQUEST', 'SOLICIT']"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_bind",
    "return_type": "bool",
    "return": "布尔值，表示是否成功绑定所有提供的DHCPv6客户端会话。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "一个或多个DHCPv6客户端会话对象，用于绑定到各自的网络接口。如果提供的是单个会话对象，则会被自动放入列表中以进行统一处理。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数调用底层API将一个或多个DHCPv6客户端会话绑定到其对应的网络接口上，确保能够进行DHCPv6客户端操作的网络通信。每个会话对象必须具有`bind()`方法。如果传入的是单个会话对象，函数内部会将其转换为列表形式进行统一处理。如果绑定失败，该函数将抛出ContinuableFailure异常；否则返回True。",
    "example": "| Dhcpv6 Client Bind | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_release",
    "return_type": "bool",
    "return": "Always returns True if the release operation is successfully initiated. Returns False if any error occurs during the release process.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dhcpv6Client or list/set/tuple of Dhcpv6Client",
        "description": "A single DHCPv6 client session object or a collection (list, set, or tuple) of such objects to be released.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function is used to release one or more DHCPv6 client sessions. It accepts either a single session or multiple sessions in the form of a list, set, or tuple. Each session's `release()` method is called internally to perform the address release operation. If any session fails to release, the result will be False; otherwise, it returns True to indicate successful execution. If the result is False, a ContinuableFailure exception is raised.",
    "example": "| Dhcpv6 Client Release | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_renew",
    "description": "Renews the DHCPv6 client sessions for the provided session objects. This function triggers the renewal process for one or more DHCPv6 client session objects by calling their `renew()` method.",
    "return_type": "bool",
    "return": "Returns True if the renewal process is successfully initiated for all provided sessions. Returns False if any error occurs during the process (e.g., invalid session objects).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of Dhcpv6Client",
        "description": "A single Dhcpv6Client session object or a list of such objects representing active DHCPv6 client sessions that need to renew their IPv6 addresses.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Dhcpv6 Client Renew | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_rebind",
    "return_type": "bool",
    "return": "True if the rebind operation was successfully initiated for all sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single DHCPv6 client session object or a collection of such objects. Each object must have a `rebind()` method that performs the actual rebind operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates a DHCPv6 client rebind operation on one or more session objects. If a single session is provided, it is rebound directly. If multiple sessions are provided in an iterable, each session is rebound in sequence.",
    "example": "| Dhcpv6 Client Rebind | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_confirm",
    "return_type": "bool",
    "return": "True if the DHCPv6 Confirm messages are successfully sent to all sessions; otherwise, False (rarely used as return value in practice).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dhcpv6Client or iterable of Dhcpv6Client objects",
        "description": "A single DHCPv6 client session object or a collection (list, set, tuple) of such objects for which DHCPv6 Confirm messages should be sent.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends DHCPv6 Confirm messages through the provided DHCPv6 client session(s) to validate the IPv6 address configuration currently assigned to each client. If a single session is provided, it will be wrapped into a list automatically. The function iterates over each session and invokes the `confirm()` method on it. This ensures consistent behavior regardless of whether one or multiple sessions are passed.",
    "example": "| Dhcpv6 Client Confirm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_abort",
    "return_type": "bool",
    "return": "Returns True if the DHCPv6 client sessions were successfully aborted; otherwise, False (though False raises an exception in practice).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "A single Dhcpv6Client session object or a list of such objects representing the DHCPv6 client sessions to be aborted. Each session must have an `abort()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Aborts one or more DHCPv6 client sessions by invoking the `abort()` method on each provided session object. This function wraps the backend logic and returns True upon successful termination of the sessions. If the underlying operation fails, it raises a ContinuableFailure exception.",
    "example": "| Dhcpv6 Client Abort | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_info_request",
    "return_type": "bool",
    "return": "布尔值，表示信息请求是否成功发起。如果成功，则返回True；否则抛出ContinuableFailure异常。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of objects",
        "description": "DHCPv6客户端会话对象或会话对象的列表。每个会话必须具有`info_request()`方法以触发信息请求。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于在指定的DHCPv6客户端会话上触发信息请求操作。通常用于从DHCPv6服务器获取配置信息，而无需执行完整的地址分配过程。函数内部确保输入始终作为列表处理（即使仅提供一个会话），然后对每个会话调用其`info_request()`方法。",
    "example": "| Dhcpv6 Client Info Request | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_lease_query",
    "return_type": "bool",
    "return": "布尔值，表示DHCPv6客户端租借查询是否成功发送。返回True表示方法调用成功，但不代表实际的查询操作一定成功；返回False表示发送失败。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dhcpv6Client or list",
        "description": "DHCPv6客户端会话对象或其列表，表示需要发送租借查询请求的一个或多个会话。",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "QueryType",
        "type": "str",
        "description": "Leasequery消息中的query-type类型，用于指定查询方式。",
        "default": "QUERY_BY_ADDRESS",
        "range_or_options": "QUERY_BY_ADDRESS QUERY_BY_CLIENTID"
      },
      {
        "name": "ClientAddress",
        "type": "str",
        "description": "客户端IPv6地址，用于基于地址的租借查询。",
        "default": "'2000::1'",
        "range_or_options": "有效的ipv6地址"
      },
      {
        "name": "ClientId",
        "type": "str",
        "description": "客户端ID，用于基于客户端ID的租借查询，格式为十六进制字符串。",
        "default": "''",
        "range_or_options": "^([0-9a-fA-F]{0,512})$"
      }
    ],
    "description": "该函数用于向一个或多个DHCPv6客户端会话发送租借查询（Lease Query）请求。它是一个封装函数，支持单个或多个会话处理，并将所有提供的参数直接传递给底层会话对象的lease_query方法。",
    "example": ".. code:: RobotFramework\n\n    | Dhcpv6 Client Lease Query | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_bulk_lease_query",
    "return_type": "bool",
    "return": "布尔值，表示批量租借查询操作是否成功发起。如果失败会抛出ContinuableFailure异常。",
    "description": "对一个或多个DHCPv6客户端会话执行批量租借查询操作。该函数通过指定的会话发送Bulk Leasequery请求到DHCPv6服务器，以批量获取IPv6地址分配信息。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dhcpv6Client or list of Dhcpv6Client",
        "description": "DHCPv6客户端会话对象，可以是单个会话对象或者会话对象的集合（列表、元组或集合）。",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "QueryType",
        "type": "str",
        "description": "指定Bulk Leasequery消息中的查询类型。",
        "default": "QUERY_BY_ADDRESS",
        "range_or_options": "QUERY_BY_ADDRESS QUERY_BY_CLIENTID QUERY_BY_RELAY_ID QUERY_BY_LINK_ADDRESS QUERY_BY_REMOTE_ID"
      },
      {
        "name": "ClientAddress",
        "type": "str",
        "description": "当QueryType为QUERY_BY_ADDRESS时使用的客户端IPv6地址。",
        "default": "'2000::1'",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "ClientId",
        "type": "str",
        "description": "当QueryType为QUERY_BY_CLIENTID时使用的客户端唯一标识。",
        "default": "''",
        "range_or_options": "^([0-9a-fA-F]{0,512})$"
      },
      {
        "name": "RelayIdentifier",
        "type": "str",
        "description": "当中继器ID用于查询时提供。",
        "default": "''",
        "range_or_options": "^([0-9a-fA-F]{0,512})$"
      },
      {
        "name": "LinkAddress",
        "type": "str",
        "description": "当QueryType为QUERY_BY_LINK_ADDRESS时使用的链路地址。",
        "default": "'2000::1'",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "RemoteId",
        "type": "str",
        "description": "中继代理Remote-ID值，当QueryType为QUERY_BY_REMOTE_ID时使用。",
        "default": "''",
        "range_or_options": "任意字符串"
      }
    ],
    "example": "| Dhcpv6 Client Bulk Lease Query | Sessions=${Sessions} |",
    "additional_notes": "该函数底层调用renix.dhcpv6_client_bulk_lease_query方法，并在返回False时抛出ContinuableFailure异常。每个提供的Session必须支持bulk_lease_query方法。"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_active_lease_query",
    "return_type": "bool",
    "return": "True if the active lease query is successfully initiated on all sessions; otherwise, False (in such case, a ContinuableFailure exception will be raised).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single DHCPv6 client session object or an iterable (e.g., list, set, tuple) of multiple DHCPv6 client session objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends an active lease query to one or more DHCPv6 client sessions to retrieve current lease information from the DHCPv6 server. It ensures that each session performs its own `active_lease_query()` method, which communicates with the server and updates the session's lease state accordingly. If the operation fails (i.e., returns False), a ContinuableFailure exception is raised.",
    "example": "| Dhcpv6 Client Active Lease Query | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_client_start_tls",
    "return_type": "bool",
    "return": "True if TLS communication was successfully initiated for all sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single DHCPv6 client session object or a collection of session objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts TLS communication for one or more DHCPv6 client sessions. This function accepts either a single session object or an iterable of session objects. Each session must have a `start_tls()` method to initiate TLS communication. The function returns True if the operation is attempted successfully on all provided sessions, and raises exceptions if any session does not support TLS or invalid input is passed.",
    "example": "| Dhcpv6 Client Start Tls | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.edit_dhcpv6_client_port_config",
    "return_type": "object or list",
    "return": "If a single port is provided, returns the modified Dhcpv6PortRateConfig object for that port. If multiple ports are provided, returns a list of modified Dhcpv6PortRateConfig objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list or object",
        "description": "Test instrument port object(s) for which the DHCPv6 client configuration will be edited. Can be a single port object or a list of port objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RequestRate",
        "type": "int",
        "description": "The rate (in sessions per second) at which Request messages are sent.",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "ReleaseRate",
        "type": "int",
        "description": "The rate (in sessions per second) at which Release messages are sent.",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "RenewRate",
        "type": "int",
        "description": "The rate (in sessions per second) at which Renew messages are sent.",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "MaxOutstanding",
        "type": "int",
        "description": "Maximum number of outstanding sessions allowed.",
        "default": "1000",
        "range_or_options": "1-2048"
      },
      {
        "name": "SolicitInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Solicit message retries in seconds.",
        "default": "5",
        "range_or_options": "1-99999"
      },
      {
        "name": "SolicitMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Solicit message retries in seconds.",
        "default": "120",
        "range_or_options": "1-99999"
      },
      {
        "name": "SolicitRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Solicit messages.",
        "default": "10",
        "range_or_options": "0-32"
      },
      {
        "name": "SolicitIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Solicit messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SolicitDisableRetries",
        "type": "bool",
        "description": "Disable retries for Solicit messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RequestInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Request message retries in seconds.",
        "default": "2",
        "range_or_options": "1-99999"
      },
      {
        "name": "RequestMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Request message retries in seconds.",
        "default": "30",
        "range_or_options": "1-99999"
      },
      {
        "name": "RequestRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Request messages.",
        "default": "10",
        "range_or_options": "0-32"
      },
      {
        "name": "RequestIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Request messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RequestDisableRetries",
        "type": "bool",
        "description": "Disable retries for Request messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ConfirmInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Confirm message retries in seconds.",
        "default": "2",
        "range_or_options": "1-99999"
      },
      {
        "name": "ConfirmMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Confirm message retries in seconds.",
        "default": "4",
        "range_or_options": "1-99999"
      },
      {
        "name": "ConfirmMaxDuration",
        "type": "int",
        "description": "Maximum number of retries for Confirm messages.",
        "default": "5",
        "range_or_options": "0-32"
      },
      {
        "name": "RenewInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Renew message retries in seconds.",
        "default": "10",
        "range_or_options": "0-32"
      },
      {
        "name": "RenewMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Renew message retries in seconds.",
        "default": "600",
        "range_or_options": "1-99999"
      },
      {
        "name": "RenewRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Renew messages.",
        "default": "5",
        "range_or_options": "0-32"
      },
      {
        "name": "RenewIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Renew messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RenewDisableRetries",
        "type": "bool",
        "description": "Disable retries for Renew messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RebindInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Rebind message retries in seconds.",
        "default": "10",
        "range_or_options": "1-99999"
      },
      {
        "name": "RebindMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Rebind message retries in seconds.",
        "default": "600",
        "range_or_options": "1-99999"
      },
      {
        "name": "RebindRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Rebind messages.",
        "default": "5",
        "range_or_options": "0-32"
      },
      {
        "name": "RebindIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Rebind messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RebindDisableRetries",
        "type": "bool",
        "description": "Disable retries for Rebind messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ReleaseInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Release message retries in seconds.",
        "default": "1",
        "range_or_options": "1-99999"
      },
      {
        "name": "ReleaseRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Release messages.",
        "default": "3",
        "range_or_options": "0-32"
      },
      {
        "name": "ReleaseIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Release messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ReleaseDisableRetries",
        "type": "bool",
        "description": "Disable retries for Release messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DeclineInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Decline message retries in seconds.",
        "default": "1",
        "range_or_options": "1-99999"
      },
      {
        "name": "DeclineRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Decline messages.",
        "default": "5",
        "range_or_options": "0-32"
      },
      {
        "name": "DeclineIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Decline messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DeclineDisableRetries",
        "type": "bool",
        "description": "Disable retries for Decline messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InfoRequestInitialTimeout",
        "type": "int",
        "description": "Initial timeout for Information-Request message retries in seconds.",
        "default": "1",
        "range_or_options": "1-99999"
      },
      {
        "name": "InfoRequestMaxTimeout",
        "type": "int",
        "description": "Maximum timeout for Information-Request message retries in seconds.",
        "default": "120",
        "range_or_options": "1-99999"
      },
      {
        "name": "InfoRequestRetryCount",
        "type": "int",
        "description": "Number of times to retry sending Information-Request messages.",
        "default": "5",
        "range_or_options": "0-32"
      },
      {
        "name": "InfoRequestIndefiniteRetry",
        "type": "bool",
        "description": "Enable indefinite retries for Information-Request messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InfoRequestDisableRetries",
        "type": "bool",
        "description": "Disable retries for Information-Request messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TcpServerPort",
        "type": "int",
        "description": "TCP server port used by the DHCPv6 client.",
        "default": "547",
        "range_or_options": "1-65535"
      }
    ],
    "description": "Edits the DHCPv6 client port configuration for one or more specified ports. This function retrieves the corresponding Dhcpv6PortRateConfig child object for each provided port and applies the specified configuration changes using keyword arguments. The modified configuration object(s) are returned based on the number of ports processed.",
    "example": ".. code:: RobotFramework\n\n        | Edit Dhcpv6 Client Port Config | Ports=${Port} | TcpServerPort=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.wait_dhcpv6_client_state",
    "return_type": "bool",
    "return": "Returns True if all DHCPv6 client sessions reach the specified state within the timeout; otherwise, False or an exception may be raised depending on backend behavior.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "One or more Dhcpv6Client session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the DHCPv6 client(s) should reach. If not provided, it defaults to 'BOUND'.",
        "default": "'BOUND'",
        "range_or_options": "DISABLED IDLE BOUND SOLICITING REQUESTING RELEASING RENEWING REBINDING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval in seconds between each check of the current session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for the session(s) to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for one or more DHCPv6 client sessions to reach a specified protocol state. It periodically checks the state of each session at defined intervals until either all sessions have reached the desired state or the timeout duration has been exceeded. If the timeout is reached before the desired state is achieved, the function may raise an exception depending on backend implementation.",
    "example": "| Wait Dhcpv6 Client State | Sessions=${Sessions} | State=BOUND | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.wait_dhcpv6_pd_client_state",
    "return_type": "bool",
    "return": "Returns True if all DHCPv6 PD client sessions reach the specified state within the timeout; otherwise returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of Dhcpv6Client",
        "description": "One or more Dhcpv6 PD client session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str, optional",
        "description": "The target state that each DHCPv6 PD client session should reach. If not provided, it may default to waiting for a specific implicit state depending on implementation.",
        "default": "'BOUND'",
        "range_or_options": "DISABLED IDLE BOUND SOLICITING REQUESTING RELEASING RENEWING REBINDING"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "The time interval (in seconds) between successive checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "The maximum time (in seconds) to wait for all sessions to reach the expected state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for one or more DHCPv6 Prefix Delegation (PD) client sessions to transition into a specified state (e.g., 'BOUND', 'SOLICITING'). It polls each session at regular intervals until either all sessions reach the desired state or the timeout is reached. If the timeout occurs before all sessions reach the expected state, the function returns False. Otherwise, it returns True. If the result is False, an exception is raised with a failure message.",
    "example": "| Wait Dhcpv6 Pd Client State | Sessions=${Sessions} | State=BOUND | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "If exactly one row matches the filter criteria: Returns a dictionary where keys correspond to the requested statistical items (`StaItems`) and values are the corresponding statistic values. If multiple rows match (e.g., across multiple ports): Returns a pandas DataFrame with each row representing statistics for a matching port, filtered to include only the requested columns. If no matching result is found: Returns False.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple of objects, optional",
        "description": "A port object or collection of port objects for which DHCPv6 statistics are to be retrieved. Each object is expected to have a `handle` attribute representing its identifier. If None, the function will query statistics without filtering by port handle.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCPv6PortStatistics class. If None (default), all available properties are queried. If a string is provided, it will be converted into a list containing that string.",
        "default": "not_found",
        "range_or_options": "['CurrentlyAttempting', 'CurrentlyIdl', 'CurrentlyBound', 'AverageSetupTime', 'MaxSetupTime', 'MinSetupTime', 'SolicitTxCount', 'RequestTxCount', 'ReleaseTxCount', 'RenewTxCount', 'RebindTxCount', 'ConfirmTxCount', 'InfoRequestTxCount', 'AdvertiseRxCount', 'ReconfigureRxCount', 'ReplyRxCount', 'SuccessPercentage', 'TotalAttempted', 'TotalBound', 'TotalBoundFailed', 'TotalRebound', 'TotalReleased', 'TotalReleaseRetried', 'TotalRenewed', 'TotalRenewedRetried', 'TotalRetired']"
      }
    ],
    "description": "Retrieves DHCPv6 port-level statistics based on specified port(s) and statistical items. This function wraps the `_get_statictis` method to fetch DHCPv6-specific port statistics. It supports querying for a single port, multiple ports (provided as list/set/tuple of objects), and allows specifying which statistical properties (StaItems) to retrieve.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | CurrentlyBound | SolicitTxCount |\n    | Subscribe Result | Types=Dhcpv6PortStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcpv6 Port Statistic | Port=${Port} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested DHCPv6 client statistics if one matching row is found, a pandas DataFrame for multiple matches, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple, optional",
        "description": "The session object(s) representing DHCPv6 clients. If None, no session filtering is applied. If a list, set, or tuple of session objects, their names are used as filters.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Id",
        "type": "int, optional",
        "description": "The session index used to further identify or filter the DHCPv6 client statistics. Typically corresponds to a specific test scenario or instance.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are determined dynamically. If a string, it is converted into a list containing that string. Must be a subset of available properties in the Dhcpv6ClientStatistics.",
        "default": "None",
        "range_or_options": "IaidValue MacAddr LeaseRx AddressType SessionState StateCode IpAddress LeaseRemaining PrefixLength RequestResponseTime SolicitResponseTime"
      }
    ],
    "description": "Retrieves DHCPv6 client statistics based on session information, session index, and desired statistical items. This function wraps the internal `_get_statistics` method to specifically fetch DHCPv6 client-related statistics. It supports filtering by one or more sessions, a session index, and specific statistical properties (StaItems). If no session is provided, it defaults to querying without session filtering. If StaItems is None, all available statistical items are queried dynamically.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Dhcpv6ClientStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcpv6 Client Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_client_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if exactly one matching row is found, a pandas DataFrame if multiple rows match, or False if no data matches the query.",
    "parameters": [
      {
        "name": "Session",
        "type": "Dhcpv6Client or list or set or tuple of Dhcpv6Client objects, optional",
        "description": "The session object(s) whose Name attribute(s) will be used to filter DHCPv6 client block statistics. If None, no filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCPv6 client block statistics. Must be a subset of available properties from 'Dhcpv6ClientBlockStatistics'.",
        "default": "None",
        "range_or_options": "BlockSessionState CurrentlyAttempting CurrentlyIdl CurrentlyBound AttemptRate BindRate RebindRate ReleaseRate RenewRate AverageRebindToReplyTime AverageReleaseToReplyTime AverageRenewToReplyTime AverageRequestToReplyTime AverageSolicitToAdvertiseTime AverageSolicitToReplyTime MaxRebindToReplyTime MaxReleaseToReplyTime MaxRenewToReplyTime MaxRequestToReplyTime MaxSolicitToAdvertiseTime MaxSolicitToReplyTime MinRebindToReplyTime MinReleaseToReplyTime MinRenewToReplyTime MinRequestToReplyTime MinSolicitToAdvertiseTime MinSolicitToReplyTime AdvertiseRxCount ReplyRxCount ReconfigureRxCount SolicitTxCount RequestTxCount ReleaseTxCount RenewTxCount RebindTxCount ConfirmTxCount InfoRequestTxCount TotalAttempted TotalBound TotalFailed TotalRebound TotalReleased TotalReleaseRetried TotalRenewed TotalRenewedRetried TotalRetired"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves DHCPv6 client block statistics based on provided session identifiers and statistical items. It wraps an internal `_get_statictis` method, handling input flexibility for sessions (single object, collection, or None) and converting them into session names for filtering purposes. It supports querying specific columns (StaItems), returning either a dictionary for single results, a DataFrame for multiple results, or False if no match is found.",
    "example": "| @{StaItems} | Create List | TotalRenewed TotalFailed |\n| Subscribe Result | Types=Dhcpv6ClientBlockStatistics |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Dhcpv6 Client Block Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_pd_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary if one matching row is found, a pandas DataFrame if multiple rows match the criteria, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple, optional",
        "description": "A session object or collection of session objects representing DHCPv6 PD client sessions. If None, no session filtering is applied. If multiple sessions are provided, their names are extracted for filtering.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Id",
        "type": "int, optional",
        "description": "The session index used to further filter statistics when multiple sessions exist.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve from 'Dhcpv6PdClientStatistics' data. If None, all available properties are queried. If a string is provided, it is converted into a list. Must be a subset of available properties.",
        "default": "None",
        "range_or_options": "Dhcpv6PdClientId IaidValue SessionIndex MacAddr VlanId LeaseRx AddressType SessionState StateCode IpAddress LeaseRemaining PrefixLength RequestResponseTime SolicitResponseTime"
      }
    ],
    "description": "Retrieves DHCPv6 Prefix Delegation (PD) client statistics based on session and index information. This function wraps the `_get_statictis` method to fetch and filter DHCPv6 PD client-related statistics. If `Session` is provided as an object or a collection of objects, it extracts their names to identify the session(s). The function then queries the 'Dhcpv6PdClientStatistics' statistic type, filtering by session ID and session index (`Id`). Optionally, specific statistical items can be selected via `StaItems`.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | RequestResponseTime | SolicitResponseTime |\n    | Subscribe Result | Types=Dhcpv6PdClientStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcpv6 Pd Client Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_server",
    "return_type": "Dhcpv6Server",
    "return": "The newly created and configured Dhcpv6Server instance associated with the specified port.",
    "description": "创建DHCPv6服务端会话对象，并将其与指定的端口关联。该函数用于初始化一个 DHCPv6 服务端实例，并根据提供的配置参数对其进行设置。",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，用于建立 DHCPv6 服务端与物理或逻辑端口之间的关系。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "DHCPv6服务端会话名称",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能DHCPv6服务端会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "DHCP仿真模式",
        "default": "DHCPV6",
        "range_or_options": "DHCPV6 DHCPV6PD"
      },
      {
        "name": "RenewalTimer",
        "type": "int",
        "description": "T1租约更新时间（%）",
        "default": "50",
        "range_or_options": "1-200"
      },
      {
        "name": "RebindingTimer",
        "type": "int",
        "description": "T2租约更新时间（%）",
        "default": "80",
        "range_or_options": "1-200"
      },
      {
        "name": "DnsList",
        "type": "str",
        "description": "DNS地址列表，IPv6格式",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "EnableDelayedAuth",
        "type": "bool",
        "description": "使能延时认证",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DhcpRealm",
        "type": "str",
        "description": "DHCP认证域名",
        "default": "xinertel.com",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationKeyId",
        "type": "int",
        "description": "认证秘钥ID",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthenticationKey",
        "type": "str",
        "description": "认证秘钥",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationKeyType",
        "type": "str",
        "description": "认证秘钥类型",
        "default": "ASCII",
        "range_or_options": "ASCII HEX"
      },
      {
        "name": "EnabledReconfigureKey",
        "type": "bool",
        "description": "使能重新配置认证",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ReconfigureKey",
        "type": "str",
        "description": "重新配置秘钥",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "ReconfigureKeyType",
        "type": "str",
        "description": "重新配置秘钥类型",
        "default": "ASCII",
        "range_or_options": "ASCII HEX"
      },
      {
        "name": "EnabledDhcpv6Only",
        "type": "bool",
        "description": "使能单独DHCPv6",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnabledTcp",
        "type": "bool",
        "description": "使能TCP协议",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TcpPort",
        "type": "int",
        "description": "TCP端口号",
        "default": "547",
        "range_or_options": "1-65535"
      },
      {
        "name": "LeaseQueryStatusCode",
        "type": "str",
        "description": "租借查询应答码",
        "default": "SUCCESS",
        "range_or_options": "SUCCESS UNKNOWN_QUERY_TYPE MALFORMED_QUERY NOT_CONFIGURED NOT_ALLOWED"
      },
      {
        "name": "BulkLeaseQueryStatusCode",
        "type": "str",
        "description": "批量租借查询应答码",
        "default": "SUCCESS",
        "range_or_options": "SUCCESS UNKNOWN_QUERY_TYPE MALFORMED_QUERY NOT_CONFIGURED NOT_ALLOWED QUERY_TERMINATED"
      },
      {
        "name": "ActiveLeaseQueryStatusCode",
        "type": "str",
        "description": "活动租借查询应答码",
        "default": "SUCCESS",
        "range_or_options": "SUCCESS UNKNOWN_QUERY_TYPE MALFORMED_QUERY NOT_CONFIGURED NOT_ALLOWED QUERY_TERMINATED DATA_MISSING CATCH_UP_COMPLETE NOT_SUPPORTED"
      },
      {
        "name": "StartTlsStatusCode",
        "type": "str",
        "description": "启动TLS应答码",
        "default": "SUCCESS",
        "range_or_options": "SUCCESS TLS_CONNECTION_REFUSED"
      }
    ],
    "example": "| Create Dhcpv6 Server | Port=${Port} | DadTransmits=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_server_custom_options",
    "return_type": "object or list of objects",
    "return": "DHCPv6 Server Custom Options configuration object(s). Returns a single object if one session is provided, or a list of objects if multiple sessions are provided.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single Dhcpv6Server session object or an iterable (list, set, tuple) of such session objects for which custom DHCPv6 server options will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OptionVal",
        "type": "int",
        "description": "Specifies the option identifier (code) for the custom DHCPv6 server option. This typically represents a numeric DHCPv6 option code.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "IncludeMsg",
        "type": "list",
        "description": "List of message types in which the custom option should be included. If not specified, defaults to ['ADVERTISE', 'REPLY'].",
        "default": "['ADVERTISE', 'REPLY']",
        "range_or_options": "ADVERTISE REPLY RECONFIGURE RELAYREPLY"
      },
      {
        "name": "Wildcards",
        "type": "bool",
        "description": "Enables wildcard matching for this option. When enabled, the option may match multiple scenarios.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StringIsHexadecimal",
        "type": "bool",
        "description": "Interprets string payloads as hexadecimal values when enabled.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OptionPayload",
        "type": "str",
        "description": "Text-based payload for the custom option. Used when OptionHexPayload is not needed.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionHexPayload",
        "type": "str",
        "description": "Hexadecimal string representing the raw payload for the custom option. Takes precedence over OptionPayload if used.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "Configures custom DHCPv6 server options for one or more Dhcpv6Server session objects. This function acts as a wrapper that simplifies setting custom options across multiple sessions by internally invoking the `custom_options` method on each session with the provided keyword arguments. It returns the resulting configuration object(s), depending on whether the input was a single session or multiple sessions.",
    "example": "| ${Dhcpv6} | Create Dhcpv6 Server | Port=${Port} |\n| Create Dhcpv6 Server Custom Options | Sessions=${Dhcpv6} | Wildcards=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_server_address_pool",
    "return_type": "object or list",
    "return": "DHCPv6 Server Address Pool configuration object(s). Returns a single object if one session is provided, otherwise returns a list of objects.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing DHCPv6 server sessions to configure the address pool for.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "The prefix length for the IPv6 address pool. Must be between 0 and 128.",
        "default": "64",
        "range_or_options": "0-128"
      },
      {
        "name": "AssignMode",
        "type": "str",
        "description": "The mode used to assign addresses in the pool.",
        "default": "SUCCESS",
        "range_or_options": "CUSTOM EUI64"
      },
      {
        "name": "StartAddress",
        "type": "str",
        "description": "The starting IPv6 address of the address pool.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "HostStep",
        "type": "str",
        "description": "The increment step between assigned IPv6 addresses.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "AddressCount",
        "type": "int",
        "description": "The total number of addresses in the pool.",
        "default": "65535",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PreferredLifetime",
        "type": "int",
        "description": "The preferred lifetime of assigned addresses in seconds.",
        "default": "604800",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "The valid lifetime of assigned addresses in seconds.",
        "default": "2592000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MinIaidValue",
        "type": "int",
        "description": "The minimum IAID (Identity Association Identifier) value.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MaxIaidValue",
        "type": "int",
        "description": "The maximum IAID (Identity Association Identifier) value.",
        "default": "4294967295",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures a DHCPv6 server address pool for one or more session objects. It allows defining various properties such as prefix length, start address, address count, and lifetimes. The method standardizes handling of both single and multiple session inputs by converting non-list inputs into a list internally. It then iterates over each session and applies the provided configuration using the session's `address_pool` method. If only one session is processed, it returns a single configuration object; otherwise, it returns a list of configuration objects.",
    "example": "| ${Dhcpv6} | Create Dhcpv6 Server | Port=${Port} |\n| Create Dhcpv6 Server Address Pool | Sessions=${Dhcpv6} | MinIaidValue=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.create_dhcpv6_server_prefix_pool",
    "return_type": "object or list of Dhcpv6PrefixPoolsConfig",
    "return": "Returns a DHCPv6 Server Prefix Pool configuration object (`Dhcpv6PrefixPoolsConfig`) if a single session is provided, or a list of such objects for multiple sessions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "DHCPv6 server session object(s) to configure the prefix pool on. Can be a single session or a list of sessions.",
        "default": "not_found",
        "range_or_options": "object or iterable (list, set, tuple)"
      }
    ],
    "kwargs": [
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "The prefix length for the IPv6 prefix pool.",
        "default": "64",
        "range_or_options": "0-128"
      },
      {
        "name": "PrefixPoolStart",
        "type": "str",
        "description": "The starting IPv6 address of the prefix pool.",
        "default": "\"2001::1\"",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixPoolStep",
        "type": "str",
        "description": "The step increment between prefixes in the pool as an IPv6 address difference.",
        "default": "\"0:0:0:1::\"",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixAddressCount",
        "type": "int",
        "description": "The number of addresses in the prefix pool.",
        "default": "16",
        "range_or_options": "1-65535"
      },
      {
        "name": "PreferredLifetime",
        "type": "int",
        "description": "The preferred lifetime of assigned prefixes in seconds.",
        "default": "604800",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "The valid lifetime of assigned prefixes in seconds.",
        "default": "2592000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MinIaidValue",
        "type": "int",
        "description": "The minimum IAID value to assign for clients.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MaxIaidValue",
        "type": "int",
        "description": "The maximum IAID value to assign for clients.",
        "default": "4294967295",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures or retrieves a prefix pool for one or more DHCPv6 server sessions. It applies the specified prefix pool settings to each session by calling its internal `prefix_pool` method with the provided parameters. The function supports both single and multiple session inputs and returns the corresponding configuration result(s).",
    "example": "| ${Dhcpv6} | Create Dhcpv6 Server | Port=${Port} |\n| Create Dhcpv6 Server Prefix Pool | Sessions=${Dhcpv6} | MinIaidValue=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_server_start",
    "return_type": "bool",
    "return": "True if the DHCPv6 server was successfully initiated for all provided sessions; False if any session failed to start.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (e.g., list, set, tuple) of session objects representing DHCPv6 server sessions. Each session must have a `start_server()` method to initiate the DHCPv6 service for that session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the DHCPv6 server operation for one or more provided session objects. It ensures that each session's `start_server()` method is called. If the input is a single session, it is internally converted into a list to simplify iteration. The function returns True only if all sessions successfully begin their DHCPv6 server operation; otherwise, it returns False.",
    "example": "| Dhcpv6 Server Start | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_server_stop",
    "return_type": "bool",
    "return": "True if all server sessions are successfully stopped, otherwise False (though backend always returns True).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single Dhcpv6Server session object or a collection of such objects representing the DHCPv6 servers to be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops one or more DHCPv6 server sessions. If a single session is provided, it is converted into a list for uniform processing. The function iterates through each session and invokes its 'stop_server' method to stop the corresponding DHCPv6 server.",
    "example": "| Dhcpv6 Server Stop | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_server_reconfigure_renew",
    "return_type": "bool",
    "return": "True if the reconfigure and renew operation is successfully initiated for all sessions, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing the DHCPv6 server sessions to be reconfigured and renewed. Each session object must have a 'renew()' method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function reconfigures and renews one or more DHCPv6 server sessions by calling the 'renew()' method on each session. It ensures that the input is converted into a list format before initiating the renewal process. If any session does not have a 'renew()' method, an AttributeError will be raised. The function returns True upon successful initiation of the operation.",
    "example": "| Dhcpv6 Server Reconfigure Renew | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_server_reconfigure_rebind",
    "return_type": "bool",
    "return": "True if the rebind operation was successfully initiated for all provided sessions, otherwise False (raises ContinuableFailure on failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (e.g., list, set, tuple) containing multiple session objects representing DHCPv6 server sessions. Each session must have a `rebind()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function triggers a rebind operation on one or more DHCPv6 server sessions. It is typically used to dynamically reconfigure and renegotiate leases or update client configurations. The function abstracts away manual iteration over session objects and ensures uniform handling of rebind operations across all provided sessions.",
    "example": "| Dhcpv6 Server Reconfigure Rebind | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.dhcpv6_server_abort",
    "return_type": "bool",
    "return": "布尔值Bool (范围：True / False)",
    "parameters": [],
    "kwargs": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing the DHCPv6 server sessions to be aborted. Each session object is expected to have an `abort()` method that performs the actual abort operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Aborts one or more DHCPv6 server sessions. If a single session is provided, it is converted into a list internally for uniform processing. The function then iterates through each session and calls its `abort()` method to terminate the corresponding DHCPv6 server session. The return value is a boolean indicating success.",
    "example": "| Dhcpv6 Server Abort | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.wait_dhcpv6_server_state",
    "return_type": "bool",
    "return": "Returns True if all DHCPv6 server sessions have reached the specified state within the timeout period. If any session fails to reach the desired state, an exception may be raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of Dhcpv6Server objects",
        "description": "The DHCPv6 server session object(s) to monitor for state change.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state to wait for in the DHCPv6 server session(s). Supported states: NOTSTART, UP, DISABLED. If not provided, defaults to waiting for 'UP'.",
        "default": "UP",
        "range_or_options": "NOTSTART UP DISABLED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval (in seconds) used to check the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for the session(s) to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more DHCPv6 server sessions to transition to a specified state. This function is typically used during automated testing to synchronize test execution with the actual state of DHCPv6 server sessions. It wraps the internal `Session.wait_session_state` method for each session and raises an exception if the expected state is not achieved within the given timeout.",
    "example": "| Wait Dhcpv6 Server State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_server_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary of requested statistical items if one matching row is found, a pandas DataFrame if multiple rows match the filter criteria, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects",
        "description": "A session object or a collection of session objects representing the DHCPv6 server sessions. Each object is expected to have a `Name` attribute that uniquely identifies the session. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str",
        "description": "Specifies which statistical items (columns) to retrieve from the DHCPv6 server statistics. If None, all available properties are queried. If a string is provided, it is converted into a list. Must be a subset of available properties.",
        "default": "None",
        "range_or_options": "ServerState CurrentlyBound ReconfigureRebindTxCount ReconfigureRenewTxCount ReconfigureTxCount AdvertiseTxCount ReplyTxCount SolicitRxCount RequestRxCount ReleaseRxCount RenewRxCount RebindRxCount TotalBound TotalExpired TotalReleased TotalRenewed"
      }
    ],
    "kwargs": [],
    "description": "Retrieves DHCPv6 server statistics for the specified session(s). This function wraps the `_get_statictis` method to fetch and filter DHCPv6 server statistics. It supports both single and multiple session inputs. For each session, it extracts the session name to be used as an identifier for filtering the statistics. The actual data retrieval and filtering logic is handled by `_get_statictis`.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Dhcpv6ServerStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcpv6 Server Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dhcpv6.get_dhcpv6_server_lease_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary containing requested statistics if one matching row is found, a pandas DataFrame if multiple rows match, or False if no result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "The DHCPv6 server session(s) for which to retrieve lease statistics. If an object, its Name attribute is used. If a collection, all items are expected to have a 'Name' attribute. If None, no session-based filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Pool",
        "type": "object or list or set or tuple or None",
        "description": "The DHCPv6 lease pool(s) for which to retrieve statistics. If an object, its Name attribute is used. If a collection, all items are expected to have a 'Name' attribute. If None, no pool-based filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, defaults to all available properties. If a string, it will be converted into a list containing that string. Valid options include: ServerState, CurrentlyBound, ReconfigureRebindTxCount, ReconfigureRenewTxCount, ReconfigureTxCount, AdvertiseTxCount, ReplyTxCount, SolicitRxCount, RequestRxCount, ReleaseRxCount, RenewRxCount, RebindRxCount, TotalBound, TotalExpired, TotalReleased, TotalRenewed.",
        "default": "None",
        "range_or_options": "ServerState CurrentlyBound ReconfigureRebindTxCount ReconfigureRenewTxCount ReconfigureTxCount AdvertiseTxCount ReplyTxCount SolicitRxCount RequestRxCount ReleaseRxCount RenewRxCount RebindRxCount TotalBound TotalExpired TotalReleased TotalRenewed"
      }
    ],
    "kwargs": [],
    "description": "Retrieves DHCPv6 server lease statistics based on provided session and pool identifiers. This function gathers statistical data related to DHCPv6 leases by calling _get_statictis with the appropriate statistic type ('Dhcpv6LeaseStatistics') and index parameters derived from the Session and Pool inputs. It supports filtering by one or more sessions and pools, allowing flexible querying of lease-related metrics.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Dhcpv6ServerStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dhcpv6 Server Lease Statistic | Session=${Session} | Pool=${Pool} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag",
    "return_type": "Dot1ag",
    "return": "The newly created and configured Dot1ag protocol instance representing IEEE 802.1ag Connectivity Fault Management.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper-layer object (typically a port) to which this Dot1ag instance will be attached. This establishes the context within the protocol stack for IEEE 802.1ag operations.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Specifies the name of the 802.1ag session. This is typically used for identification purposes in test scenarios.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Controls whether the 802.1ag session should be enabled upon creation. If set to True, the session is activated immediately after creation.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates and configures a new IEEE 802.1ag (Connectivity Fault Management - CFM) protocol session associated with the specified test port. It allows optional configuration parameters such as Name and Enable via keyword arguments. The function internally calls the backend method 'renix.create_dot1ag' to instantiate the Dot1ag protocol object and dynamically assigns any applicable configuration attributes passed through '**kwargs'. Additionally, the created Dot1ag instance is registered in a global mapping (`map_protocol_object`) using its handle for future reference and management by the framework. This function is typically used during test setup to simulate or manage CFM functionalities on network devices under test.",
    "example": "| Create Dot1ag | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.edit_dot1ag_link_trace",
    "return_type": "Dot1agLinkTraceConfig or list of Dot1agLinkTraceConfig",
    "return": "配置后的802.1ag Link Trace对象或对象列表。",
    "parameters": [
      {
        "name": "Session",
        "type": "Dot1ag or iterable (list, tuple, set)",
        "description": "一个会话对象或多个会话对象的集合，表示需要配置的IEEE 802.1AG会话。每个会话必须包含`edit_link_trace`方法以接受关键字参数。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TxType",
        "type": "str",
        "description": "设置数据包的发送方式。",
        "default": "SINGLE",
        "range_or_options": "SINGLE MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "设置数据包的发送速率。",
        "default": "TXRATE_10_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "InitTransactionId",
        "type": "int",
        "description": "设置初始Transaction ID。",
        "default": "1",
        "range_or_options": "uint32 in [0,4294967295]"
      },
      {
        "name": "InitTtl",
        "type": "int",
        "description": "设置初始TTL（Time to Live）值。",
        "default": "64",
        "range_or_options": "uint8 in [1,255]"
      }
    ],
    "description": "该函数用于修改IEEE 802.1AG协议中的Link Trace配置。支持对单个或多个会话对象进行配置。内部将传入的会话对象统一处理为列表形式，并逐个调用其`edit_link_trace`方法，将提供的关键字参数传递给底层配置方法。如果仅处理了一个会话，则直接返回对应的结果；若处理了多个会话，则返回结果列表。",
    "example": ".. code:: RobotFramework\n\n    | Edit Dot1ag Link Trace | Session=${Session} | InitTtl=255 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.edit_dot1ag_loopback",
    "return_type": "object or list",
    "return": "If a single session is provided, returns the result of its `edit_loopback` method. If multiple sessions are provided, returns a list of results from each session's `edit_loopback` method.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (list, tuple, set)",
        "description": "A single session object or an iterable containing session objects for which the Dot1ag loopback configuration needs to be modified. Each session must have an `edit_loopback` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TxType",
        "type": "str",
        "description": "Specifies the transmission type for the loopback operation.",
        "default": "'SINGLE'",
        "range_or_options": "SINGLE MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "Specifies the rate at which packets are transmitted during loopback.",
        "default": "'TXRATE_10_PER_SEC'",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "InitTransactionId",
        "type": "int",
        "description": "Initial Transaction ID used in the loopback operation. Must be within the range of uint32.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function modifies the 802.1ag loopback configuration for one or more session objects by calling their respective `edit_loopback` methods. It allows uniform configuration across multiple sessions and supports various loopback settings such as transmission type, rate, and transaction ID.",
    "example": "| Edit Dot1ag Loopback | Session=${Session} | InitTransactionId=50 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag_ma",
    "return_type": "Dot1agMaConfig",
    "return": "802.1ag MA (Maintenance Association) configuration object, which represents a newly created and optionally configured Maintenance Association.",
    "parameters": [],
    "kwargs": [
      {
        "name": "OperationMode",
        "type": "str",
        "description": "Specifies the operation mode of the protocol.",
        "default": "IEEE",
        "range_or_options": "IEEE"
      },
      {
        "name": "MaidType",
        "type": "str",
        "description": "Specifies the type of Maintenance Association Identifier (MAID).",
        "default": "STRING",
        "range_or_options": "PRI_VID STRING"
      },
      {
        "name": "MdName",
        "type": "str",
        "description": "Specifies the name of the Maintenance Domain (MD).",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "MdLevel",
        "type": "str",
        "description": "Specifies the level of the Maintenance Domain (MD).",
        "default": "Level1",
        "range_or_options": "Level0 Level1 Level2 Level3 Level4 Level5 Level6 Level7"
      },
      {
        "name": "PrimaryVid",
        "type": "int",
        "description": "Specifies the primary VLAN ID (VID) for the MA.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "CcPeriod",
        "type": "str",
        "description": "Specifies the Continuity Check (CC) message transmission period.",
        "default": "CC_1S",
        "range_or_options": "CC_3MS CC_10MS CC_100MS CC_1S CC_10S CC_1MIN CC_10MIN"
      },
      {
        "name": "LckPeriod",
        "type": "str",
        "description": "Specifies the Lock (LCK) message transmission period.",
        "default": "LCK_1S",
        "range_or_options": "LCK_1S LCK_1MIN"
      },
      {
        "name": "CcPriority",
        "type": "str",
        "description": "Specifies the priority level for Continuity Check (CC) messages.",
        "default": "Level0",
        "range_or_options": "Level0 Level1 Level2 Level3 Level4 Level5 Level6 Level7"
      },
      {
        "name": "LbPriority",
        "type": "str",
        "description": "Specifies the priority level for Loopback (LB) messages.",
        "default": "Level0",
        "range_or_options": "Level0 Level1 Level2 Level3 Level4 Level5 Level6 Level7"
      },
      {
        "name": "LtPriority",
        "type": "str",
        "description": "Specifies the priority level for Link Trace (LT) messages.",
        "default": "Level0",
        "range_or_options": "Level0 Level1 Level2 Level3 Level4 Level5 Level6 Level7"
      }
    ],
    "description": "This function creates a new IEEE 802.1ag Maintenance Association (MA) configuration object with optional parameters. It allows users to configure various properties of the MA such as MD name, level, VID, and message periods during creation via keyword arguments. If no parameters are provided, default values are used.",
    "example": "| Create Dot1ag Ma | PrimaryVid=200 | MdLevel=Level3 | CcPeriod=CC_10S |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag_mp",
    "return_type": "object or list",
    "return": "The result of the `create_mp` call from the first session if only one session is processed, otherwise a list of results from all sessions. Returns an instance (or list) of type `Dot1agMpConfig` representing the configured 802.1ag Maintenance Point(s).",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) containing multiple session objects. Each session object must have a `create_mp` method that will be used to configure the MP for that specific session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SelectMa",
        "type": "obj",
        "description": "关联MA，e.g: SelectMa=config_ma (config_ma = create_dot1ag_ma())",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MpType",
        "type": "str",
        "description": "MP类型",
        "default": "MEP",
        "range_or_options": "MEP"
      },
      {
        "name": "Rdi",
        "type": "str",
        "description": "RDI设置",
        "default": "AUTO",
        "range_or_options": "AUTO OFF ON"
      },
      {
        "name": "EnableLbResponse",
        "type": "bool",
        "description": "使能Lb Response",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLtResponse",
        "type": "bool",
        "description": "使能Lt Response",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MpId",
        "type": "int",
        "description": "MP ID",
        "default": "1",
        "range_or_options": "1-8191"
      },
      {
        "name": "EnableOverrideMdLevel",
        "type": "bool",
        "description": "使能Override Md Level",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideMdLevel",
        "type": "str",
        "description": "重写MD级别",
        "default": "Level1",
        "range_or_options": "Level0 Level1 Level2 Level3 Level4 Level5 Level6 Level7"
      },
      {
        "name": "EnableOverrideCcPeriod",
        "type": "bool",
        "description": "使能Override Cc Period",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideCcPeriod",
        "type": "str",
        "description": "重写CC周期",
        "default": "CC_1S",
        "range_or_options": "CC_3MS CC_10MS CC_100MS CC_1S CC_10S CC_1MIN CC_10MIN"
      },
      {
        "name": "IsCcmRunning",
        "type": "bool",
        "description": "Whether CCM is running",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsLtmRunning",
        "type": "bool",
        "description": "Whether LTM is running",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsLbmRunning",
        "type": "bool",
        "description": "Whether LBM is running",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "创建一个或多个802.1ag Maintenance Point（MP）配置。该函数封装了对一个或多个会话对象的`create_mp`调用，并将提供的关键字参数传递给每个会话的`create_mp`方法以进行配置。",
    "example": "| Create Dot1ag Mp | Session=${Session} | Rdi=ON |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag_org_specific_tlv",
    "return_type": "object or list",
    "return": "A Dot1agOrgSpecificTlv object or a list of objects representing the created Organization-Specific TLVs. Returns a single object if one session is provided, or a list if multiple sessions are used.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable",
        "description": "A single session object or an iterable (e.g., list, tuple) containing multiple session objects. Each session must have a `create_org_specific_tlv` method to be called with the provided keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OrgUniqueId",
        "type": "list",
        "description": "Organization Unique ID used to identify the organization that defines this TLV.",
        "default": "[0, 0, 0]",
        "range_or_options": "each element: 0-255 (decimal numbers)"
      },
      {
        "name": "SubType",
        "type": "int",
        "description": "Sub-type of the Organization-Specific TLV.",
        "default": "0",
        "range_or_options": "uint8: 0-255"
      },
      {
        "name": "Data",
        "type": "list",
        "description": "The data content of the TLV as a list of decimal numbers.",
        "default": "[]",
        "range_or_options": "length: 0-250, each element: 0-255"
      }
    ],
    "description": "This function creates a Dot1ag-compliant Organization-Specific TLV (Type-Length-Value) object or a list of such objects associated with one or more session(s). It wraps the `create_org_specific_tlv` method of the session object(s), allowing consistent creation of TLVs across different sessions based on the provided configuration parameters.",
    "example": "| Create Dot1ag Org Specific Tlv | Session=${Session} | SubType=1 | OrgUniqueId=[1,2,3] | Data=[10,20,30] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag_custom_mp",
    "return_type": "Dot1agCustomMpConfig",
    "return": "A configured Dot1agCustomMpConfig instance representing the created custom Maintenance Point (MP) for IEEE 802.1ag protocols.",
    "parameters": [],
    "kwargs": [
      {
        "name": "CustomTargetMacAddr",
        "type": "str",
        "description": "The MAC address of the custom target MP. This is used to uniquely identify the remote maintenance point in IEEE 802.1ag connectivity fault management tests.",
        "default": "",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates a custom Maintenance Point (MP) configuration for IEEE 802.1ag protocols. This function wraps the backend method `Dot1ag.create_custom_mp`, and allows setting key parameters such as the target MAC address for identifying the remote MP. The created MP can be used for testing connectivity and fault management within Ethernet networks.",
    "example": "| Create Dot1ag Custom Mp | CustomTargetMacAddr=00:00:00:01:01:01 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.create_dot1ag_expected_mp",
    "return_type": "Dot1agExpectedMpConfig or list of Dot1agExpectedMpConfig",
    "return": "A single configured Dot1agExpectedMpConfig object if only one Ma was provided, or a list of configured Dot1agExpectedMpConfig objects corresponding to each Maintenance Association (Ma).",
    "parameters": [
      {
        "name": "Ma",
        "type": "object or iterable of objects",
        "description": "A single Maintenance Association object or an iterable (list, tuple, set) of Maintenance Association objects to associate with the expected MP configuration(s). If a single object is provided, it will be wrapped in a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MpId",
        "type": "int",
        "description": "MEP ID used for identifying the Maintenance Endpoint within the protocol.",
        "default": "1",
        "range_or_options": "1-8191"
      },
      {
        "name": "MacAddress",
        "type": "str",
        "description": "MAC address associated with the Expected MP configuration.",
        "default": "\"00:00:00:00:00:01\"",
        "range_or_options": "valid MAC address format"
      }
    ],
    "description": "This function creates and returns one or more configured Dot1agExpectedMpConfig objects associated with the provided Maintenance Association(s) (Ma). It wraps the creation process provided by the backend API and supports passing a single Ma or an iterable of Ma objects. Each resulting configuration can be further customized using optional keyword arguments such as MpId and MacAddress.",
    "example": ".. code:: RobotFramework\n\n    | Create Dot1ag Expected Mp | Ma=${Ma} | MacAddress=00:00:00:01:01:01 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.start_cc_dot1ag",
    "return_type": "bool",
    "return": "Returns True if the Continuity Check (CC) for IEEE 802.1ag is successfully started on the provided session(s), otherwise raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot1ag or list of Dot1ag",
        "description": "A single Dot1ag session object or a list of such objects representing IEEE 802.1ag sessions where the Continuity Check needs to be initiated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the Continuity Check (CC) operation for IEEE 802.1ag on the specified session(s). If a single session is provided, it is internally converted into a list. The function ensures that the CC command is executed successfully and returns True upon success. If execution fails, it raises a ContinuableFailure exception with a descriptive message.",
    "example": ".. code:: RobotFramework\n\n    | Start Cc Dot1ag | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.start_link_trace_dot1ag",
    "return_type": "bool",
    "return": "True if the command was successfully executed, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot1ag",
        "description": "The IEEE 802.1ag session object or list of objects on which to start the link trace operation.",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies the message type for the Link Trace operation.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MpMaps",
        "type": "str",
        "description": "MP source and target map list used in the Link Trace operation.",
        "default": "",
        "range_or_options": "string"
      }
    ],
    "description": "Starts a Link Trace operation for IEEE 802.1ag on the specified session(s). This function sends a command to initiate a Link Trace test on one or more provided Dot1ag sessions. If any abnormal condition is detected during execution, it may raise an exception or return False.",
    "example": "| Start Link Trace Dot1ag | Sessions=${Sessions} | MpMaps=['Dot1agMpConfig_1,00:00:00:00:00:01', 'Dot1agMpConfig_2,00:00:00:00:00:02'] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.start_loopback_dot1ag",
    "return_type": "bool",
    "return": "Returns True if the loopback operation is successfully initiated; False otherwise (though failure typically raises an exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot1ag or list of Dot1ag",
        "description": "The IEEE 802.1ag session object(s) on which to start the loopback operation.",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies the message type used in the loopback operation.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MpMaps",
        "type": "str",
        "description": "MP source and target map list for mapping maintenance points.",
        "default": "\"\"",
        "range_or_options": "string"
      }
    ],
    "description": "Starts a loopback operation for IEEE 802.1ag Connectivity Fault Management (CFM) sessions. This operation is used for fault detection and verification of network connectivity. The function sends the loopback command to the provided session(s), which must be valid Dot1ag configuration objects with appropriate handles. If the operation fails, it raises a ContinuableFailure exception.",
    "example": "| Start LoopBack Dot1ag | Sessions=${Sessions} | MsgType=UNICAST | MpMaps=mp1:mp2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.stop_cc_dot1ag",
    "return_type": "bool",
    "return": "Returns True if the continuity check was successfully stopped for all provided sessions, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list / tuple / set",
        "description": "A session object or a collection of session objects (of type Dot1ag) for which the continuity check should be stopped. Each session must have a valid 'handle' attribute used internally to execute the command.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the Continuity Check (CC) for IEEE 802.1ag sessions. This function sends a command to stop the continuity check on the specified session(s). The sessions can be provided as a single object or as a collection (list, tuple, or set) of session objects. Underlying command execution is handled by the Dot1agStopCCCommand class.",
    "example": ".. code:: RobotFramework\n\n    | Stop Cc Dot1ag | Sessions=${Sessions} |\n\n.. code-block:: python\n\n    api.stop_cc_dot1ag(session)  # Stop CC for a single session\n    api.stop_cc_dot1ag([session1, session2])  # Stop CC for multiple sessions"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.stop_link_trace_dot1ag",
    "return_type": "bool",
    "return": "Returns True if the IEEE 802.1AG link trace operation is successfully stopped, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list or tuple or set",
        "description": "A single session object or a collection of session objects for which the link trace needs to be stopped. Each session object must have a valid 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MpObjects",
        "type": "list or tuple or set",
        "description": "A collection of maintenance point objects involved in the link trace operation. Each maintenance point object must have a valid 'handle' attribute.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the IEEE 802.1AG link trace operation for the specified sessions and maintenance points using their respective handles. This function internally uses the `Dot1agStopLinkTraceCommand` class to construct and execute the stop command.",
    "example": "| Stop Link Trace Dot1ag | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.stop_loopback_dot1ag",
    "return_type": "bool",
    "return": "True if the loopback operation was successfully stopped, otherwise False (but in practice, it raises an exception on failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot1ag or list/tuple/set of Dot1ag",
        "description": "Specifies one or more IEEE 802.1ag CFM session objects for which to stop the loopback operation.",
        "default": "not_found",
        "range_or_options": "object list",
        "notes": "If not a collection (list/tuple/set), it will be converted into a list containing a single session object."
      },
      {
        "name": "MpObjects",
        "type": "list",
        "description": "A list of maintenance point (MP) objects associated with the sessions used to uniquely identify MPs involved in the loopback operation.",
        "default": "\"\"",
        "range_or_options": "list of MP objects",
        "notes": "Each MP object must contain a 'handle' attribute that is used to identify it internally."
      }
    ],
    "kwargs": [],
    "description": "Stops the loopback operation for IEEE 802.1ag connectivity fault management (CFM) sessions. This function sends a command to stop loopback operations on the specified CFM sessions using the provided maintenance point (MP) objects. It ensures that the loopback is stopped and returns a success status as a boolean value.",
    "example": ".. code:: RobotFramework\n\n    | Stop LoopBack | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.wait_dot1ag_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired states within the timeout period. Otherwise, it raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "The 802.1ag session object(s) to monitor. It can be a single session or a list of sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str / list of str",
        "description": "One or more acceptable states to wait for. If None, defaults to 'RUNNING'. Supported states: DISABLED, IDLE, RUNNING. Comparison is case-insensitive.",
        "default": "RUNNING",
        "range_or_options": "DISABLED IDLE RUNNING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval (in seconds) between successive checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the provided 802.1ag sessions reach one of the specified target states. The function polls the session states at regular intervals and returns successfully once all sessions have reached any of the expected states. If the timeout is exceeded before all sessions reach the desired state, a failure is raised.",
    "example": "| Wait Dot1ag State | Sessions=${Sessions} | State=RUNNING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1ag.get_dot1ag_mp_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary of statistics if one matching row is found, a pandas DataFrame if multiple rows are found, or False if no results are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list of objects",
        "description": "The Dot1ag session object(s) to retrieve statistics for. If None, no filtering by session is applied. Each session object must have a 'Name' attribute used as the session handle.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list",
        "description": "List of statistical items (columns) to retrieve. Valid items include: MepId, RemoteMeps, CcmTimeout, CcmUnexpectMaid, CcmUnexpectMdLevel, TxCcm300Hz, TxCcm10ms, TxCcm100ms, TxCcm1s, TxCcm10s, TxCcm1min, TxCcm10min, RxCcm, LastTxCcmSeqNum, LbTimeout, LbTransIdMismatch, TxLbm, RxLbm, TxLbr, RxLbr, TxLtm, RxLtm, TxLtr, RxLtr, LtTimeout.",
        "default": "None",
        "range_or_options": "MepId RemoteMeps CcmTimeout CcmUnexpectMaid CcmUnexpectMdLevel TxCcm300Hz TxCcm10ms TxCcm100ms TxCcm1s TxCcm10s TxCcm1min TxCcm10min RxCcm LastTxCcmSeqNum LbTimeout LbTransIdMismatch TxLbm RxLbm TxLbr RxLbr TxLtm RxLtm TxLtr RxLtr LtTimeout"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistics for IEEE 802.1ag Maintenance Points (MPs) based on the provided session(s). The function supports filtering by session and specifying which statistical items to return. It wraps internal methods to fetch data either from result views or via dynamic querying with commands.",
    "example": "| @{StaItems} | Create List | TxLtr RxLtr |\n| Subscribe Result | Types=Dot1agMpStats |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Dot1ag Mp stats | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.create_dot1x",
    "return_type": "Dot1x",
    "return": "802.1x会话对象，类型为object",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，作为Dot1x协议的上层引用",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "802.1x会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用802.1x会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AuthMode",
        "type": "str",
        "description": "认证模式",
        "default": "MD5",
        "range_or_options": "MD5 TLS TTLS"
      },
      {
        "name": "Identity",
        "type": "str",
        "description": "身份标识",
        "default": "xinertel",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "认证密码",
        "default": "xinertel",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "UseAuthenticatorMac",
        "type": "bool",
        "description": "是否使用认证器MAC地址",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AuthenticatorMac",
        "type": "str",
        "description": "认证器MAC地址",
        "default": "01:80:c2:00:00:03",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "RetryCount",
        "type": "int",
        "description": "重试次数",
        "default": "5",
        "range_or_options": "uint32"
      },
      {
        "name": "RetryTimeout",
        "type": "int",
        "description": "单次重试超时时间（单位：秒）",
        "default": "5",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "RetransmitCount",
        "type": "int",
        "description": "重新传输次数",
        "default": "5",
        "range_or_options": "uint32"
      },
      {
        "name": "RetransmitTimeout",
        "type": "int",
        "description": "单次重新传输超时时间（单位：秒）",
        "default": "5",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "SupplicantCertificateName",
        "type": "str",
        "description": "客户端证书名称",
        "default": "''",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "CertificatePassword",
        "type": "str",
        "description": "证书密码",
        "default": "''",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "DuplicateUserInfoToInner",
        "type": "bool",
        "description": "是否将用户信息复制到内部隧道",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "InnerIdentity",
        "type": "str",
        "description": "内部隧道身份标识",
        "default": "xinertel",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "InnerPassword",
        "type": "str",
        "description": "内部隧道认证密码",
        "default": "xinertel",
        "range_or_options": "string length in [1,255]"
      },
      {
        "name": "InnerTunnelAuthMode",
        "type": "str",
        "description": "内部隧道认证模式",
        "default": "AUTO",
        "range_or_options": "AUTO GTC MS_CHAPV2 MD5"
      },
      {
        "name": "EnableClientCertificate",
        "type": "bool",
        "description": "启用客户端证书",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建并配置与指定端口关联的802.1x协议会话。它初始化一个Dot1x会话对象，并允许通过关键字参数进行详细配置。创建的会话被注册在全局协议对象映射中，以便后续引用。",
    "example": "| Create Dot1x | Port=${Port} | DadTransmits=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.edit_dot1x_port_config",
    "return_type": "Dot1xPortConfig object or list of Dot1xPortConfig objects",
    "return": "返回更新后的802.1x端口配置对象。如果只传入一个端口，返回单个Dot1xPortConfig对象；如果传入多个端口，返回与输入顺序一致的Dot1xPortConfig对象列表。",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "需要修改802.1X配置的一个或多个测试仪表端口对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "AuthenticationRate",
        "type": "int",
        "description": "认证请求的最大速率，单位是每秒请求数。",
        "default": "100",
        "range_or_options": "1-16384"
      },
      {
        "name": "LogoutRate",
        "type": "int",
        "description": "登出请求的最大速率，单位是每秒请求数。",
        "default": "100",
        "range_or_options": "1-16384"
      },
      {
        "name": "OutstandingSessions",
        "type": "int",
        "description": "允许的最大未完成会话数。",
        "default": "100",
        "range_or_options": "1-10000"
      }
    ],
    "description": "该函数用于修改指定端口的802.1X认证协议配置。对于每个提供的Port对象，它会获取其关联的Dot1xPortConfig子对象，并应用通过关键字参数传递的配置更改（如果有）。支持一次配置多个端口，并根据输入端口的数量返回相应的Dot1xPortConfig对象或对象列表。",
    "example": "| Edit dot1x Port Config | Ports=${Port} | OutstandingSessions=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.dot1x_upload_certificate",
    "return_type": "bool",
    "return": "布尔值，表示证书上传是否成功。始终返回 True 表示操作成功执行，若返回 False 则会抛出异常。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "802.1x会话对象或其列表，每个对象需具备 upload_certificate 方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Folder",
        "type": "str",
        "description": "证书文件所在路径，应为可访问的本地目录路径。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "在指定的一个或多个802.1X会话上上传并配置认证证书。该函数支持单个会话对象或多个会话的集合（如列表、元组、集合），并统一处理为列表形式进行操作。每个会话对象必须实现 upload_certificate 方法以接受 Folder 参数。",
    "example": "| Dot1x Upload Certificate | Sessions=${Sessions} | Folder=${Folder} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.dot1x_delete_certificate",
    "return_type": "bool",
    "return": "Always returns True if the operation is successful. Returns False if it fails, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot1x or iterable of Dot1x",
        "description": "The 802.1X session object(s) for which the certificate should be deleted. Can be a single session or a list, tuple, or set of sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function deletes the certificate associated with one or more 802.1X session objects. It accepts either a single session or an iterable (such as a list, tuple, or set) of sessions. Internally, it ensures that the input is iterable and then calls `delete_certificate()` on each session to remove its certificate. If any failure occurs during the deletion process, a ContinuableFailure exception is raised to indicate the error while allowing test execution to continue.",
    "example": "| Dot1x Delete Certificate | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.abort_dot1x",
    "return_type": "bool",
    "return": "Returns True if all provided sessions are successfully aborted; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, tuple, set]",
        "description": "A single session object or a collection of session objects that implement an `abort()` method. These objects typically represent active 802.1X authentication sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function terminates one or more 802.1X authentication sessions by invoking the `abort()` method on each session object. If a single session is provided, it is internally converted into a list for uniform processing. The function ensures that all sessions are properly aborted and returns True upon successful completion. If any error occurs during abortion, a ContinuableFailure exception is raised.",
    "example": "| Abort Dot1x | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.wait_dot1x_state",
    "return_type": "bool",
    "return": "True if all provided IEEE 802.1X sessions reach the specified state within the timeout, otherwise behavior depends on backend implementation.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (e.g., list) of IEEE 802.1X session objects to monitor for reaching the desired state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or None",
        "description": "The desired state to wait for in the session(s). If None, waits for a default condition defined by the session's implementation.",
        "default": "AUTHENTICATED",
        "range_or_options": "DISABLED DOWN UNAUTHORIZED AUTHENTICATING AUTHENTICATED FAILED LOGGING_OFF"
      },
      {
        "name": "Interval",
        "type": "int or float",
        "description": "Time interval (in seconds) between successive checks of session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or float",
        "description": "Maximum time (in seconds) to wait for the session(s) to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for the specified IEEE 802.1X (dot1x) session(s) to reach the desired state. This function internally calls `wait_session_state` on each session object periodically until the target state is reached or the timeout is exceeded. The function raises an exception if the result returned by the backend is False; otherwise, it returns True.",
    "example": "| Wait Dot1x State | Sessions=${Sessions} | State=AUTHENTICATED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.get_dot1x_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics related to 802.1X block sessions. If one result is found, returns a dictionary of statistical items and values. If multiple results are found, returns a pandas DataFrame. If no results are found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects (optional)",
        "description": "A session object or collection of session objects representing the 802.1X block handle(s). If provided, only statistics for these sessions will be retrieved. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str (optional)",
        "description": "Specifies which statistical properties to retrieve. If a string is provided, it will be converted into a list. If None, all available statistical properties are retrieved dynamically.",
        "default": "None",
        "range_or_options": "BlockState CurrentAuthenticatedAttempt CurrentAuthenticated CurrentFailed CurrentLogoff AuthenticatedAttemptRate AuthenticatedRate LogoffRate TotalAttempt TotalAuthenticated TotalFailed TotalLogoff TotalRetry TotalRetransmit RxEapFailure RxEapRequest RxEapSucess TxEapResponse MaxAuthenticatedTime MaxLogoffTime"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves 802.1X block statistics associated with the provided session(s). It wraps an internal method that queries performance data and filters by session identifiers and specified statistical items. The function handles paginated results and includes internal delays to ensure data consistency. It may raise exceptions in case of command execution failure or database errors.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | BlockState | AuthenticatedRate |\n    | &{Result} | Get Dot1x Block Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.get_dot1x_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to the requested statistical items if exactly one matching row is found. If multiple rows match, returns a pandas DataFrame. Returns False if no matching result is found.",
    "parameters": [
      {
        "name": "Port",
        "type": "Port object or list/set/tuple of Port objects or None",
        "description": "A single port object or a collection of port objects for which statistics should be retrieved. If None, statistics may be retrieved for all ports.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Statistical items (columns) to retrieve from Dot1xPortStatistics. Supported items include: CurrentAuthenticatedAttempt, CurrentAuthenticated, CurrentFailed, CurrentLogoff, TotalAttempt, TotalAuthenticated, TotalFailed, TotalLogoff, TotalRetry, TotalRetransmit.",
        "default": "None",
        "range_or_options": "CurrentAuthenticatedAttempt CurrentAuthenticated CurrentFailed CurrentLogoff TotalAttempt TotalAuthenticated TotalFailed TotalLogoff TotalRetry TotalRetransmit"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves 802.1X authentication statistics at the port level. It wraps an internal method `_get_statictis()` and provides flexibility in specifying the target port(s) and desired statistical items. If `Port` is not specified, it may return statistics for all available ports. If `StaItems` is not provided, it defaults to querying all available properties for the Dot1xPortStatistics class. The function supports both singular and batch queries and can return results as a dictionary, DataFrame, or boolean flag depending on the query outcome.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TotalRetry | TotalRetransmit |\n    | Subscribe Result | Types=Dot1xPortStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dot1x Port Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot1x.get_dot1x_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if one matching row is found, a DataFrame if multiple rows match, or False if no data matches the criteria.",
    "parameters": [
      {
        "name": "Session",
        "type": "object / list / None",
        "description": "The session object(s) whose 802.1X statistics are to be retrieved. If an iterable is provided, the `.Name` attribute of each session object is extracted into a list. If None, no specific session filter is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The session index used to identify the correct row in the statistics table. Typically corresponds to the position or identifier of the session within a multi-session context.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list / str / None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a list internally. Must be a subset of the available properties in the 'Dot1xStatistics' class.",
        "default": "None",
        "range_or_options": "State ReqIdentity RespIdentity ReqChallenge RespChallenge TLSEstablish ReceiveOK ReceiveFail"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves 802.1X authentication-related statistics based on session information, index, and specified statistical items. It acts as a wrapper around `_get_statictis`, preparing session identifiers and delegating actual retrieval logic. The function may return a dictionary for a single result, a pandas DataFrame for multiple results, or False if none are found.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | State | ReceiveOK |\n    | Subscribe Result | Types=Dot1xStatistics |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dot1x Statistic | Session=${Session} | Index=1 | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.create_dot3ah",
    "return_type": "Dot3ah",
    "return": "802.3ah会话对象, 类型：object",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "802.3ah会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能802.3ah会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MaxPduSize",
        "type": "int",
        "description": "最大PDU范围",
        "default": "1500",
        "range_or_options": "60-2047"
      },
      {
        "name": "TransmitType",
        "type": "str",
        "description": "发送方式",
        "default": "SINGLE",
        "range_or_options": "SINGLE BATCH"
      },
      {
        "name": "LoopBackRespTime",
        "type": "int",
        "description": "Loopback响应时间",
        "default": "1",
        "range_or_options": "1-10"
      },
      {
        "name": "EnableLinkFault",
        "type": "bool",
        "description": "使能Link Fault",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableDyingGasp",
        "type": "bool",
        "description": "使能Dying Gasp",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCriticalEvent",
        "type": "bool",
        "description": "使能Critical Event",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLoopBackResp",
        "type": "bool",
        "description": "使能Loopback Response",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableVarResp",
        "type": "bool",
        "description": "使能Variable Response",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "VarReqPeriod",
        "type": "int",
        "description": "Variable Request周期",
        "default": "1",
        "range_or_options": "0-10"
      }
    ],
    "description": "创建并配置一个与指定端口关联的Dot3ah协议实例。该函数使用提供的`Port`初始化Dot3ah协议配置，并通过关键字参数传递其他配置属性。创建后，Dot3ah实例将使用其句柄注册到全局协议对象映射中。",
    "example": "| Create Dot3ah | Port=${Port} | MaxPduSize=1300 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.edit_dot3ah_event_notification",
    "return_type": "Dot3ahEventNotificationConfig or list",
    "return": "The modified Dot3ah Event Notification configuration object(s). Returns a single object if one session is provided, or a list of objects if multiple sessions are provided.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "A Dot3ah session object or an iterable (list, tuple, set) of session objects for which the event notification configuration should be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "InitialTime",
        "type": "int",
        "description": "Initial time in milliseconds before sending the first event notification.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EventRepeatPeriod",
        "type": "int",
        "description": "Repeat period in seconds between subsequent notifications.",
        "default": "2",
        "range_or_options": "0-10"
      },
      {
        "name": "EnableErroredFrameEvent",
        "type": "bool",
        "description": "Enables/disables Errored Frame Event notification.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EfeWindow",
        "type": "int",
        "description": "Errored Frame Event window size in milliseconds.",
        "default": "10",
        "range_or_options": "10-600"
      },
      {
        "name": "EfeThreshold",
        "type": "int",
        "description": "Errored Frame Event threshold count to trigger the notification.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "EfeErrorCount",
        "type": "int",
        "description": "Errored Frame Event error count that must be exceeded to trigger the notification.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableErroredFramePeriodEvent",
        "type": "bool",
        "description": "Enables/disables Errored Frame Period Event notification.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EfpeWindow",
        "type": "int",
        "description": "Errored Frame Period Event window size in milliseconds.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EfpeThreshold",
        "type": "int",
        "description": "Errored Frame Period Event threshold count to trigger the notification.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "EfpeErrorCount",
        "type": "int",
        "description": "Errored Frame Period Event error count that must be exceeded to trigger the notification.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableErroredSymbolPeriodEvent",
        "type": "bool",
        "description": "Enables/disables Errored Symbol Period Event notification.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EspeWindow",
        "type": "int",
        "description": "Errored Symbol Period Event window size in milliseconds.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EspeThreshold",
        "type": "int",
        "description": "Errored Symbol Period Event threshold count to trigger the notification.",
        "default": "600",
        "range_or_options": "100-900"
      },
      {
        "name": "EspeErrorCount",
        "type": "int",
        "description": "Errored Symbol Period Event error count that must be exceeded to trigger the notification.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableErroredFrameSecondsSummaryEvent",
        "type": "bool",
        "description": "Enables/disables Errored Frame Seconds Summary Event notification.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EfsseWindow",
        "type": "int",
        "description": "Errored Frame Seconds Summary Event window size in seconds.",
        "default": "600",
        "range_or_options": "1-65535"
      },
      {
        "name": "EfsseThreshold",
        "type": "int",
        "description": "Errored Frame Seconds Summary Event threshold count to trigger the notification.",
        "default": "600",
        "range_or_options": "100-900"
      },
      {
        "name": "EfsseCount",
        "type": "int",
        "description": "Errored Frame Seconds Summary Event count that must be exceeded to trigger the notification.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableOrgSpecEvent",
        "type": "bool",
        "description": "Enables/disables Organization-Specific Event notification.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OrgSpecEventOUI",
        "type": "list",
        "description": "Organizationally Unique Identifier (OUI) for the custom event. Must be a list of three integers in range [0,255].",
        "default": "[0, 0, 0]",
        "range_or_options": "Each element: 0-255"
      },
      {
        "name": "OrgSpecEventData",
        "type": "list",
        "description": "Custom data payload for the organization-specific event. Each element must be an integer in range [0,255].",
        "default": "[]",
        "range_or_options": "Each element: 0-255"
      }
    ],
    "description": "Modifies the Dot3ah event notification configuration for one or more session objects. This function wraps the internal `edit_event_notification` method and ensures consistent behavior whether a single session or multiple sessions are passed. It forwards all keyword arguments directly to the session's implementation for actual configuration changes.",
    "example": "| Edit Dot3ah Event Notification | Session=${Session} | InitialTime=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.edit_dot3ah_info_pdu",
    "return_type": "Dot3ahInfoPduConfig or list of Dot3ahInfoPduConfig",
    "return": "Returns the modified 802.3ah Info PDU configuration object(s). If a single session is provided, returns one object; if multiple sessions are provided, returns a list of objects.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "The 802.3ah session object or a list of session objects to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PduTime",
        "type": "int",
        "description": "Sets the PDU time interval for OAM keepalive messages.",
        "default": "1",
        "range_or_options": "1-10"
      },
      {
        "name": "LostLinkTime",
        "type": "int",
        "description": "Sets the time after which a link is considered lost if no PDU is received.",
        "default": "5",
        "range_or_options": "2-90"
      },
      {
        "name": "OamModeType",
        "type": "str",
        "description": "Sets the OAM mode type (ACTIVE or PASSIVE).",
        "default": "ACTIVE",
        "range_or_options": "PASSIVE ACTIVE"
      },
      {
        "name": "OrgUniqueId",
        "type": "list",
        "description": "Sets the organizationally unique identifier in decimal format (3-element list).",
        "default": "[0, 0, 0]",
        "range_or_options": "Each element must be an integer between 0 and 255"
      },
      {
        "name": "OamVersion",
        "type": "int",
        "description": "Sets the OAM protocol version number.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "VendorSpecInfo",
        "type": "int",
        "description": "Sets vendor-specific information as a 32-bit unsigned integer.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableOverrideRevision",
        "type": "bool",
        "description": "Enables overriding the revision number in the PDU.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideRevision",
        "type": "int",
        "description": "Sets the overridden revision number (if enabled).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableVarRetrieval",
        "type": "bool",
        "description": "Enables variable retrieval capability in the OAM session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableInterpLinkEvent",
        "type": "bool",
        "description": "Enables interpretation of link events.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLoopBack",
        "type": "bool",
        "description": "Enables loopback functionality for testing purposes.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableUnidirMode",
        "type": "bool",
        "description": "Enables unidirectional operation mode.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function modifies the 802.3ah Information PDU (Protocol Data Unit) configuration for one or more Ethernet OAM sessions. It allows fine-grained control over various OAM parameters such as timing, operational mode, vendor-specific fields, and capabilities like loopback or variable retrieval.",
    "example": "| Edit Dot3ah Info Pdu | Session=${Session} | PduTime=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.edit_dot3ah_org_spec",
    "return_type": "Dot3ahOrgSpecConfig or list of Dot3ahOrgSpecConfig",
    "return": "The modified 802.3ah organization-specific configuration object(s). If a single session is provided, returns a single object; if multiple sessions are provided, returns a list of objects.",
    "parameters": [
      {
        "name": "Session",
        "type": "Dot3ah or list of Dot3ah",
        "description": "An 802.3ah session object or a list of such objects for which the organization-specific configuration will be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableOrgSpec",
        "type": "bool",
        "description": "Enables or disables the organization-specific configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Period",
        "type": "int",
        "description": "The period for the organization-specific event, in seconds.",
        "default": "1",
        "range_or_options": "0-10"
      },
      {
        "name": "OrgSpecOUI",
        "type": "list of int",
        "description": "Organizationally Unique Identifier (OUI) for the organization-specific event, represented as a list of three integers between 0 and 255.",
        "default": "[0, 0, 0]",
        "range_or_options": "0-255"
      },
      {
        "name": "OrgSpecEventData",
        "type": "list of int",
        "description": "Data payload for the organization-specific event, represented as a list of integers between 0 and 255.",
        "default": "[]",
        "range_or_options": "0-255"
      }
    ],
    "description": "Modifies the organization-specific configuration for one or more 802.3ah session objects. This function allows enabling/disabling the feature, setting the event period, specifying the OUI, and providing custom event data. It supports both single and multiple session inputs, processing them uniformly and returning results accordingly.",
    "example": "| Edit Dot3ah Org Spec | Session=${Session} | Period=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.create_dot3ah_org_spec_tlv",
    "return_type": "object or list",
    "return": "创建的802.3ah Org Spec TLV对象或对象列表，具体取决于输入的Session数量。",
    "parameters": [
      {
        "name": "Session",
        "type": "Dot3ah or iterable of Dot3ah",
        "description": "一个802.3ah会话对象或者包含多个会话对象的可迭代对象（如list、tuple、set）。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OrgUniqueId",
        "type": "list of int",
        "description": "组织唯一标识符，默认值为[0, 0, 0]。",
        "default": "[0, 0, 0]",
        "range_or_options": "0-255"
      },
      {
        "name": "Data",
        "type": "list of int",
        "description": "TLV数据内容，默认为空列表[]。",
        "default": "[]",
        "range_or_options": "0-255"
      }
    ],
    "description": "根据提供的会话对象和配置参数，创建一个或多个802.3ah Organization-Specific TLV（Type-Length-Value）对象。该函数封装了会话对象的`create_org_spec_tlv`方法，并统一处理单个或多个会话的输入。",
    "example": "| Create Dot3ah Org Spec Tlv | Session=${Session} | Data=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.create_dot3ah_var_req",
    "return_type": "object or list of :obj:`Dot3ahVarReqConfig`",
    "return": "Returns a Dot3ah variable request configuration object or a list of such objects depending on the number of input sessions.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (e.g., list, tuple, set)",
        "description": "A single session object or an iterable of session objects for which Dot3ah variable requests will be created. Each session must have a 'create_var_req' method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Branch",
        "type": "int",
        "description": "Specifies the branch value for the Dot3ah variable request configuration.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Leaf",
        "type": "int",
        "description": "Specifies the leaf value for the Dot3ah variable request configuration.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "This function creates a Dot3ah variable request configuration for one or more provided session objects by calling their respective 'create_var_req' methods with the given parameters. If a single session is provided, it is internally converted to a list to ensure uniform processing. The function returns either a single configuration object (if only one session is processed) or a list of configuration objects in the same order as the input sessions.",
    "example": "| Create Dot3ah Var Req | Session=${Session} | Branch=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.create_dot3ah_var_resp",
    "return_type": "object or list",
    "return": "A Dot3ahVarRespConfig object or a list of such objects depending on the number of input sessions processed.",
    "parameters": [
      {
        "name": "Session",
        "type": "Dot3ah or iterable",
        "description": "802.3ah session object or an iterable (list, tuple, set) of session objects for which the Dot3ah variable response is to be created. Each session object must have a `create_var_resp` method that can accept the provided keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Branch",
        "type": "int",
        "description": "The branch identifier used in the Dot3ah Variable Response configuration.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Leaf",
        "type": "int",
        "description": "The leaf identifier used in the Dot3ah Variable Response configuration.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Indication",
        "type": "bool",
        "description": "Flag indicating whether a specific indication should be set in the configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Width",
        "type": "int",
        "description": "The width parameter used in the Dot3ah Variable Response configuration.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Data",
        "type": "list",
        "description": "List of decimal values (0-255) representing data bytes for the Dot3ah Variable Response.",
        "default": "[]",
        "range_or_options": "Each element must be an integer between 0 and 255"
      }
    ],
    "description": "Creates a Dot3ah Variable Response configuration for one or more Session objects. This function accepts either a single session object or an iterable of session objects. For each session, it invokes the `create_var_resp` method with the provided keyword arguments to generate a configuration. The result is either a single configuration object (if only one session was provided) or a list of configuration objects (if multiple sessions were provided).",
    "example": "| Create Dot3ah Var Resp | Session=${Session} | Branch=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.start_event_notification_dot3ah",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the command. Returns False if the backend operation fails, but this is not expected under normal conditions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (e.g., list, tuple, set)",
        "description": "A session object or a collection of session objects representing IEEE 802.3ah links. Each session must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts event notification for IEEE 802.3ah link monitoring on one or more provided session(s). This function sends a command to initiate event notifications for Dot3ah (IEEE 802.3ah) sessions. It wraps around an internal command (`Dot3ahStartEventNotificationCommand`) responsible for preparing and sending the appropriate command to the backend.",
    "example": "| Start Event Notification Dot3ah | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.start_link_trace_dot3ah",
    "return_type": "bool",
    "return": "Always returns True to indicate successful initiation of the link trace operation. Returns False if the operation failed.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, tuple, set) containing multiple session objects. Each session object must have a 'handle' attribute that is used in the command execution.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts a link trace operation for the specified list of sessions using the Dot3ah protocol. This function wraps the execution of the `Dot3ahStartLinkTraceCommand`, which initiates a link trace on the provided session handles. If a single session is passed, it will be automatically wrapped into a list. The function blocks until the operation completes.",
    "example": "| Start Link Trace | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.start_loopback_dot3ah",
    "return_type": "bool",
    "return": "True if the loopback command executed successfully, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": ":obj:`Dot3ah` or iterable of :obj:`Dot3ah`",
        "description": "The Dot3ah session object or a list/tuple/set of session objects for which to start loopback.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts loopback mode on one or more Dot3ah sessions. If the command fails, a ContinuableFailure exception is raised.",
    "example": "| Start Loopback Dot3ah | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.start_org_spec_dot3ah",
    "return_type": "bool",
    "return": "True if the command was executed successfully, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot3ah",
        "description": "802.3ah session object(s) to start the organization-specific EtherType (0x8870) for Ethernet OAM protocols based on IEEE 802.3ah. Each session must have a valid 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts the organization-specific Dot3ah protocol for one or more provided session objects. This function prepares and executes a command to initiate the protocol on sessions that have valid handles. The underlying implementation calls into a backend system (renix.start_org_spec_dot3ah), which performs the actual operation.",
    "example": ".. code:: RobotFramework\n\n    | Start Org Spec | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.start_var_req_dot3ah",
    "return_type": "bool",
    "return": "True if the command was successfully executed, False otherwise (though it raises an exception on failure instead of returning False in practice).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot3ah session object or iterable of objects",
        "description": "A single Dot3ah session object or a list/tuple/set of such objects on which to start the IEEE 802.3ah variable request (VarReq). Each session must have a 'handle' attribute for identification in the Renix API.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts a variable request (VarReq) operation for the IEEE 802.3ah protocol on one or more specified sessions. This operation sends a command to initiate the VarReq procedure on each provided session handle via the underlying Renix API. If any session is invalid or lacks a required 'handle' attribute, a TypeError will be raised.",
    "example": "| Start Var Req | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.stop_event_notification_dot3ah",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the command.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session or list or tuple or set",
        "description": "A single session object or an iterable (list, tuple, or set) of session objects for which event notification should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends a command to stop event notifications on the specified IEEE 802.3ah (Ethernet OAM) sessions. It accepts a single session object or a collection of session objects, and stops event notifications on all corresponding handles.",
    "example": ">>> api.stop_event_notification_dot3ah(session)\nTrue\n>>> api.stop_event_notification_dot3ah([session1, session2])\nTrue"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.stop_link_trace_dot3ah",
    "return_type": "bool",
    "return": "Returns True if the stop command was successfully executed; otherwise, False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, tuple, set]",
        "description": "A session object or a collection of session objects representing the IEEE 802.3ah sessions on which to stop the link trace operation. Each session is expected to have a `handle` attribute used in constructing the command.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the IEEE 802.3ah link trace operation on the specified session(s). This function sends a command to stop the link trace process for one or more Dot3ah sessions. If any of the provided session objects do not have the required attributes (e.g., `handle`), a TypeError may be raised. Similarly, if the execution of the stop link trace command fails, an error may occur during command execution.",
    "example": "| Stop Link Trace Dot3ah | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.stop_loopback_dot3ah",
    "return_type": "bool",
    "return": "True if the loopback operation was successfully stopped on all specified Dot3ah sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot3ah session object or iterable of session objects",
        "description": "The IEEE 802.3ah (Ethernet OAM) session object(s) for which loopback needs to be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the loopback operation on the specified IEEE 802.3ah (Ethernet OAM) session(s). The function sends a command to stop loopback for one or more Dot3ah session objects and returns a boolean indicating success or failure. Each session must have a 'handle' attribute used internally by the framework to identify the session.",
    "example": "| Stop Loopback Dot3ah | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.stop_org_spec_dot3ah",
    "return_type": "bool",
    "return": "Always returns `True` to indicate successful execution of the command. Returns `False` only if the underlying command fails, which results in an exception being raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session object or iterable of Session objects",
        "description": "A single session object or an iterable (list, tuple, or set) of session objects representing the Dot3ah sessions to stop. Each session object must have a `handle` attribute that uniquely identifies the session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the organization-specific IEEE 802.3ah (Ethernet in the First Mile) sessions for the provided list of session objects. This function wraps the execution of the `Dot3ahStopOrgSpecCommand`, which sends a command to stop the organization-specific functionality (e.g., OAM - Operations, Administration, and Maintenance) on the specified Dot3ah sessions. The function ensures that the input `Sessions` is always treated as an iterable, converting it into a list if necessary.",
    "example": ".. code-block:: python\n\n    # Assuming `session1` and `session2` are valid session objects with a `handle` attribute\n    api.stop_org_spec_dot3ah(session1)  # Stops a single session\n    api.stop_org_spec_dot3ah([session1, session2])  # Stops multiple sessions"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.stop_var_req_dot3ah",
    "return_type": "bool",
    "return": "Returns True if the variable request was successfully stopped for the provided sessions, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Dot3ah session object or iterable of session objects",
        "description": "A single IEEE 802.3ah session object or a list, tuple, or set of such objects for which the variable request needs to be stopped. Each session must have a `handle` attribute that uniquely identifies the session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the variable request operation for the specified IEEE 802.3ah sessions. If a single session is provided, it is internally converted into a list for uniform handling. This function sends a command to stop the variable request on the given sessions by utilizing their handles.",
    "example": ".. code:: RobotFramework\n\n    | Stop Var Req | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.wait_dot3ah_state",
    "return_type": "bool",
    "return": "Returns True if all Dot3ah sessions reach the specified state within the timeout period, otherwise returns False (which raises an exception in this wrapper function).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "A single session object or a list of Dot3ah session objects to monitor for reaching the target state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "Target state that each session must reach. If not provided, defaults to 'RESERVED' according to backend logic.",
        "default": "'RESERVED'",
        "range_or_options": "NONE UNSATISFIED NOTCOMPLETED COMPLETED RESERVED DISABLED IDLE"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval (in seconds) to check the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the target state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits until the 'State' attribute of each Dot3ah session in the provided `Sessions` reaches the specified target state. It internally calls a backend method (`renix.wait_dot3ah_state`) and raises an exception if the operation fails (i.e., if it times out or any session does not reach the desired state). This function is typically used in test automation to synchronize protocol state transitions.",
    "example": "| Wait Dot3ah State | Sessions=${Sessions} | State=COMPLETED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.get_dot3ah_error_event_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics related to Dot3ah error events for specified sessions. If one row matches, returns a dictionary; if multiple rows match, returns a pandas DataFrame; if no results are found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "A session object or a collection of session objects. Each session object must have a `Name` attribute. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a single string is provided, it is converted into a list with one item. Must be a subset of the available properties for 'Dot3ahErrorEventStats'.",
        "default": "None",
        "range_or_options": "EventType TimeStamp WindowsSize Threshold ErrorCount ErrorRunningTotal EventRunningTotal OrgUniqueId OrgSpecificData"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves statistics related to Dot3ah error events for specified sessions. It wraps around the `_get_statictis` method and supports filtering based on session identifiers and selecting specific statistical items to return. Data can be fetched either from an existing result view or by dynamically querying the system.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | EventType | ErrorCount |\n    | Subscribe Result | Types=Dot3ahErrorEventStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dot3ah Error Event Stats | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.dot3ah.get_dot3ah_session_statistic",
    "return_type": "dict",
    "return": "A dictionary containing the requested statistical values for the specified Dot3ah session(s). Each key corresponds to a statistic item in `StaItems`, with its value representing the measured count or state.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list, optional",
        "description": "The Dot3ah session object or list of objects for which statistics are to be retrieved. Each object must have a 'Name' attribute used as an identifier. If not provided, no session filter is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list",
        "description": "Specifies which statistical items (counters/states) to retrieve. It can include any subset of the supported statistics such as 'State', 'TxOrgSpecPduCounter', 'RxLinkFaultCounter', etc. If None, all available statistics are queried.",
        "default": "None",
        "range_or_options": "State LocalMultiplexerAction LocalParserAction RemoteMultiplexerAction RemoteParserAction RemoteMode RemoteOamVersion RemoteRevision RemoteOui RemoteEnableVarRetrieval RemoteEnableInterpretLinkEvent RemoteEnableLoopBack RemoteEnableUnidirMode RemoteMaxPduSize RemoteVendorSpecificInfo TxDyingGaspCounter RxDyingGaspCounter TxLinkFaultCounter RxLinkFaultCounter TxCriticalCounter RxCriticalCounter TxEfeCounter RxEfeCounter TxEspeCounter RxEspeCounter TxEfpeCounter RxEfpeCounter TxEfsseCounter RxEfsseCounter TxOrgSpecEventCounter RxOrgSpecEventCounter TxInfoPduCounter RxInfoPduCounter TxEventNotificationPduCounter RxEventNotificationPduCounter TxLoopBackCounter RxLoopBackCounter TxVarReqCounter RxVarReqCounter TxVarRespCounter RxVarRespCounter TxOrgSpecPduCounter RxOrgSpecPduCounter"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves statistical information for one or more Dot3ah sessions. It provides detailed counters and current states related to IEEE 802.3ah OAM (Operations, Administration, and Maintenance) sessions. The function internally handles data retrieval from result views or via dynamic querying based on context and filters.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxOrgSpecPduCounter | RxOrgSpecPduCounter |\n    | Subscribe Result | Types=Dot3ahSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Dot3ah Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.create_ieee8021as",
    "return_type": "Ieee8021as",
    "return": "创建并返回一个IEEE 802.1AS协议会话对象，用于进一步配置或与该协议实例交互。",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，表示此IEEE 802.1AS协议会话所绑定的上层（父）对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "指定IEEE 802.1AS会话的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用或禁用IEEE 802.1AS会话。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MaxPduSize",
        "type": "int",
        "description": "设置最大PDU大小。",
        "default": "1500",
        "range_or_options": "60-2047"
      },
      {
        "name": "TransmitType",
        "type": "str",
        "description": "定义数据发送方式。",
        "default": "SINGLE",
        "range_or_options": "SINGLE BATCH"
      },
      {
        "name": "LoopBackRespTime",
        "type": "int",
        "description": "设置Loopback响应时间（单位：毫秒）。",
        "default": "1",
        "range_or_options": "1-10"
      },
      {
        "name": "EnableLinkFault",
        "type": "bool",
        "description": "启用或禁用Link Fault功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableDyingGasp",
        "type": "bool",
        "description": "启用或禁用Dying Gasp功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCriticalEvent",
        "type": "bool",
        "description": "启用或禁用Critical Event功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLoopBackResp",
        "type": "bool",
        "description": "启用或禁用Loopback Response功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableVarResp",
        "type": "bool",
        "description": "启用或禁用Variable Response功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "VarReqPeriod",
        "type": "int",
        "description": "设置Variable Request周期（单位：秒）。",
        "default": "1",
        "range_or_options": "0-10"
      }
    ],
    "description": "该函数用于创建并配置与指定端口相关联的IEEE 802.1AS协议会话。它初始化一个Ieee8021as协议配置对象，并使用提供的`Port`作为其上层对象。通过关键字参数可以传递额外的配置选项，这些选项会被动态应用到协议会话中。创建的会话对象将被注册到全局协议对象映射表中，以便后续可以通过其句柄检索。",
    "example": "| Create Ieee801as | Port=${Port} | MaxPduSize=1300 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.edit_ieee8021as",
    "return_type": "bool or Ieee801as",
    "return": "Returns True if attributes were successfully applied to all applicable sessions. If the backend returns False, a ContinuableFailure exception is raised. Otherwise, it may return the modified session object(s).",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "The IEEE 802.1AS session object or a list of such objects that need to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Sets the name of the IEEE 802.1AS session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the IEEE 802.1AS session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MaxPduSize",
        "type": "int",
        "description": "Sets the maximum PDU size for the session.",
        "default": "1500",
        "range_or_options": "60-2047"
      },
      {
        "name": "TransmitType",
        "type": "str",
        "description": "Specifies how packets are transmitted.",
        "default": "SINGLE",
        "range_or_options": "SINGLE BATCH"
      },
      {
        "name": "LoopBackRespTime",
        "type": "int",
        "description": "Sets the loopback response time for the session.",
        "default": "1",
        "range_or_options": "1-10"
      },
      {
        "name": "EnableLinkFault",
        "type": "bool",
        "description": "Enables or disables Link Fault signaling.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableDyingGasp",
        "type": "bool",
        "description": "Enables or disables Dying Gasp signaling.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCriticalEvent",
        "type": "bool",
        "description": "Enables or disables Critical Event signaling.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLoopBackResp",
        "type": "bool",
        "description": "Enables or disables Loopback Response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableVarResp",
        "type": "bool",
        "description": "Enables or disables Variable Response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "VarReqPeriod",
        "type": "int",
        "description": "Sets the period for Variable Request messages.",
        "default": "1",
        "range_or_options": "0-10"
      }
    ],
    "description": "Modifies the settings of one or more IEEE 802.1AS session objects by updating their specified attributes. This function ensures only existing attributes on each session are updated and silently skips any invalid attribute names. It wraps around an internal `_set_attr` method in the backend RenixAPI class to apply changes.",
    "example": ".. code:: RobotFramework\n\n    | Create Ieee801as | Port=${Port} | MaxPduSize=1300 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.wait_ieee8021as_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired states within the timeout period. Returns False if the timeout is reached and not all sessions have reached the expected state.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "The IEEE 802.1AS session object(s) to monitor. It can be a single session object or an iterable (list, set, tuple) of session objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list, optional",
        "description": "One or more acceptable values for the attribute being monitored. If None, defaults to 'RUNNING'. Supported states include RUNNING, DISABLED, IDLE, and COMPLETED.",
        "default": "None (defaults to 'RUNNING')",
        "range_or_options": "RUNNING DISABLED IDLE COMPLETED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of the session state.",
        "default": "1",
        "range_or_options": "positive integer"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired states before returning False.",
        "default": "60",
        "range_or_options": "positive integer"
      }
    ],
    "kwargs": [],
    "description": "Waits until the provided IEEE 802.1AS session(s) reach a specified state. The function checks whether the session(s) have reached the desired state by polling at regular intervals. If the session type is Ieee8021asProtocolConfig, it waits on the 'SessionState' attribute; otherwise, it waits on the default 'State' attribute via the _wait_state method.",
    "example": "| Wait Ieee8021as State | Sessions=${Sessions} | State=RUNNING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.wait_ieee8021as_clock_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the expected clock states within the timeout period; otherwise, it raises a Failure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list",
        "description": "A single IEEE 802.1AS session object or a list of such objects whose 'ClockState' will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list of str",
        "description": "The target clock state(s) to wait for. If None, defaults to ['MASTER', 'SLAVE']. Comparison is case-insensitive.",
        "default": "['MASTER', 'SLAVE']",
        "range_or_options": "MASTER SLAVE DISABLED IDLE"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time in seconds between successive checks of the clock state for each session.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the expected clock states.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'ClockState' attribute of IEEE 802.1AS sessions reaches one of the specified target states. It polls each session at a given interval and checks whether its 'ClockState' attribute has reached any of the expected states. If all sessions reach an expected state within the timeout period, it returns True. Otherwise, it raises a Failure exception.",
    "example": "| Wait Ieee8021as Clock State | Sessions=${Sessions} | State=MASTER | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_clock_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary of statistical item names and their values if a single matching row is found, a pandas DataFrame if multiple rows match the criteria, or False if no matching rows are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list",
        "description": "Ieee802.1as session object or a collection of session objects whose statistics are to be retrieved. If a collection is passed, the `.Name` attribute of each session object is extracted to form session IDs. If None, no specific session filter is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list",
        "description": "Specifies which statistical properties (columns) to retrieve. If None, all available properties are fetched. Valid options include 'State', 'LocalMultiplexerAction'.",
        "default": "not_found",
        "range_or_options": "'State' 'LocalMultiplexerAction'"
      }
    ],
    "kwargs": [],
    "description": "Retrieves IEEE 802.1AS clock statistics based on the provided session(s) and statistical items. This function acts as a wrapper around `_get_statictis`, specifically tailored for fetching 'Ieee8021asClockStatistic' type data. It prepares the session identifiers from the provided `Session` input, then delegates to the internal method for retrieving and filtering the actual statistic values.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Ieee802.1asSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ieee802.1as Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_clock_sync_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "统计结果返回类型取决于匹配结果的行数。如果恰好一行匹配，则返回一个包含 StaItems 对应键值的字典；如果多行匹配，则返回一个 pandas DataFrame；如果没有找到匹配项，则返回 False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "表示 IEEE 802.1AS 会话对象或会话对象的集合。每个对象必须具有 `Name` 属性，该属性表示会话句柄。如果不提供，则不进行会话过滤。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "需要获取的统计项（列名）。如果为 None，则返回所有可用属性；如果是字符串，则将其转换为列表。必须是 IEEE 802.1AS 时钟同步相关统计项的子集。",
        "default": "None",
        "range_or_options": "例如 ['ClockOffset', 'FrequencyOffset', 'TxOrgSpecPduCounter', 'RxOrgSpecPduCounter'] 等有效统计项"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取指定 IEEE 802.1AS 会话的时钟同步统计信息。它封装了底层 `_get_statictis` 方法，并根据传入的会话和统计项进行过滤和查询。",
    "example": ">>> api = RenixAPI()\n>>> session = api.get_session('session1')\n>>> stats = api.get_ieee8021as_clock_sync_statistic(Session=session, StaItems=['ClockOffset', 'FrequencyOffset'])\n>>> print(stats)"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_message_rate_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if one matching row is found, a pandas DataFrame for multiple matches, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "A session object or collection of session objects. If None, no session filtering is applied. The `Name` attribute of each session object is used for filtering.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a single-element list. Items must be valid properties of 'Ieee8021asMessageRateStatistic'.",
        "default": "None",
        "range_or_options": "Supported items include: State, LocalMultiplexerAction"
      }
    ],
    "kwargs": [],
    "description": "Retrieves IEEE 802.1AS message rate statistics for specified session(s). This function wraps a call to `_get_statictis` and is specifically tailored to fetch statistics related to IEEE 802.1AS message rates. It supports filtering by session and allows specification of which statistical items to return.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Ieee802.1asSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ieee802.1as Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_parent_clock_info_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical items for a single matching session, a DataFrame if multiple sessions match, or False if no matches are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "The IEEE 802.1AS session(s) to query statistics for. If None, all sessions are considered. Each session object must have a `.Name` attribute used as the session handle.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from 'Ieee8021asParentClockInfoStatistic'. If None, all available columns are retrieved. If a string is provided, it's converted into a single-element list.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves IEEE 802.1AS parent clock information statistics for specified session(s). This function wraps around an internal method to fetch statistical data related to IEEE 802.1AS parent clock info, supporting filtering based on session handles and selection of specific statistical items.",
    "example": "| @{StaItems} | Create List | AdjacencyState | TxUpdate |\n| Subscribe Result | Types=Ieee802.1asSessionStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Ieee802.1as Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_state_summary_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for IEEE 802.1AS state summary. If exactly one row matches the filters, returns a dictionary with keys corresponding to `StaItems`. If multiple rows match, returns a pandas DataFrame. If no matching result is found, returns False.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A port object or collection of port objects for which to retrieve statistics. Each port object must have a 'Name' attribute used as an identifier. If None, statistics are retrieved without filtering by port.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a list. Must be a subset of the available statistical properties.",
        "default": "None",
        "range_or_options": "['State', 'LocalMultiplexerAction']"
      }
    ],
    "kwargs": [],
    "description": "Retrieves IEEE 802.1AS state summary statistics for specified port(s). This function is a wrapper around `_get_statictis` that specifically fetches the 'Ieee8021asStateSummaryStatistic' type of statistics. It allows filtering by port and selecting specific statistical items to retrieve.",
    "example": "| @{StaItems} | Create List | State | LocalMultiplexerAction |\n| Subscribe Result | Types=Ieee802.1asSessionStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Ieee802.1as Session Statistic | Port=${Port} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ieee8021as.get_ieee8021as_time_properties_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回IEEE 802.1AS时间属性的统计结果。如果找到唯一匹配的结果，返回一个字典；如果有多个匹配项，返回一个pandas DataFrame；如果没有找到匹配项，则返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or None",
        "description": "指定要查询的Ieee802.1as会话对象或对象列表。若为None，则不应用过滤器，全局查询。每个对象需包含`.Name`属性，用于标识对应的会话名称。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的统计项目（列名），支持子集选择。若为None，则返回所有可用属性；若为字符串，则自动转换为单元素列表。",
        "default": "None",
        "range_or_options": "支持的统计项包括: State LocalMultiplexerAction 及其他IEEE 802.1AS时间相关属性"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取IEEE 802.1AS协议中时间属性相关的统计信息。它是一个封装接口，底层调用`_get_statictis`并预设了统计类型为'Ieee8021asTimePropertiesStatistic'。支持按会话和统计项进行过滤，并根据匹配结果数量返回字典或DataFrame。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Ieee802.1asSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ieee802.1as Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.create_igmp",
    "return_type": "Igmp",
    "return": "IGMP协议会话对象, 类型：object",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "IGMP协会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能ICMP协议会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "版本",
        "default": "IGMPV2",
        "range_or_options": "IGMPV1 IGMPV2 IGMPV3"
      },
      {
        "name": "PackReports",
        "type": "bool",
        "description": "合并报告报文",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InitialJoin",
        "type": "bool",
        "description": "单个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustJoin",
        "type": "bool",
        "description": "多个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Robust值",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "UnsolicitedReportInterval",
        "type": "int",
        "description": "发送初始报文的时间间隔 (秒)",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "ForceLeave",
        "type": "bool",
        "description": "强制发送Leave报文",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouterPresentTimeout",
        "type": "int",
        "description": "IGMPv1路由器存在的超时时间 (秒)",
        "default": "400",
        "range_or_options": "0-65535"
      },
      {
        "name": "NotFragment",
        "type": "bool",
        "description": "设置IP头报文分片标志位",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TosValue",
        "type": "Hex or int",
        "description": "设置IP头TOS值 (十进制或者十六进制)",
        "default": "0xc0",
        "range_or_options": "0x00-0xFF"
      }
    ],
    "description": "该函数用于在指定的端口上创建并配置一个新的IGMP协议会话实例。它允许用户通过关键字参数对IGMP会话进行详细配置，包括版本控制、报告行为、QoS设置等。所创建的IGMP实例会被注册到全局映射中，以便后续引用和管理。",
    "example": "| Create Igmp | Port=${Port} | Version=IGMPV3 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.edit_igmp",
    "return_type": "bool",
    "return": "True if the IGMP session attributes were successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "The IGMP session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the IGMP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the IGMP protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "Specifies the IGMP version for the session.",
        "default": "IGMPV2",
        "range_or_options": "IGMPV1 IGMPV2 IGMPV3"
      },
      {
        "name": "PackReports",
        "type": "bool",
        "description": "Enables merging of report messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InitialJoin",
        "type": "bool",
        "description": "Sends a single initial join message when joining a group.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustJoin",
        "type": "bool",
        "description": "Sends multiple initial join messages when joining a group.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Sets the robustness variable used in IGMP operations.",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "UnsolicitedReportInterval",
        "type": "int",
        "description": "Time interval (in seconds) between unsolicited report transmissions.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "ForceLeave",
        "type": "bool",
        "description": "Forces sending of Leave messages when leaving groups.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouterPresentTimeout",
        "type": "int",
        "description": "Timeout (in seconds) for detecting presence of an IGMPv1 router.",
        "default": "400",
        "range_or_options": "0-65535"
      },
      {
        "name": "NotFragment",
        "type": "bool",
        "description": "Controls the IP fragmentation flag in the IP header.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TosValue",
        "type": "bool",
        "description": "Controls the TOS field value in the IP header (Hex format).",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This function updates the attributes of an existing IGMP session object with the provided values. It supports modifying various IGMP-related settings such as protocol version, behavior during join/leave operations, and IP header properties. The function returns True upon successful update, otherwise False.",
    "example": "| Edit Igmp | Session=my_igmp_session | Version=IGMPV1 | RouterPresentTimeout=500 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.select_source_interface",
    "return_type": "bool",
    "return": "布尔值，表示源接口选择是否成功（True 表示成功，False 表示失败）",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "IGMP/MLD协议会话对象，用于标识当前的组播测试会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Memberships",
        "type": "object",
        "description": "组播成员关系配置对象，描述了组播组与设备之间的映射关系。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Interface",
        "type": "object",
        "description": "测试仪表接口对象，指定要绑定为源地址的接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "将 IGMP/MLD 协议会话的组播组过滤源地址绑定到指定的接口。该函数封装了底层 `Session.select_source_interface` 方法，并在执行前后加入异常检查逻辑，确保操作的稳定性。此功能通常用于网络测试中动态控制流量来源。",
    "example": ".. code:: RobotFramework\n\n    | ${Interface} | create_interface | Port=${Port} |\n    | ${Group} | Create Multicast Group | Version=IPV4 | Start=225.0.1.1 | Number=20 |\n    | ${Session} | Create Igmp | Port=${Port} | Version=IGMPV3 |\n    | ${Memberships} | Create Memberships | Session=${Session} | Start=225.0.1.1 | DeviceGroupMapping=ONETOONE |\n    | binding_multicast_group | Session=${Session} | Memberships=${Memberships} | MulticastGroup=${Group} |\n    | Select Source Interface | Session=${Session} | Memberships=${Memberships} | Interface=${Interface} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.wait_igmp_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired IGMP states within the timeout period. Otherwise, raises a Failure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`Igmp`)",
        "description": "A list of Igmp protocol session objects whose IGMP state will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target IGMP state that each session is expected to reach.",
        "default": "'MEMBER'",
        "range_or_options": "NONMEMBER JOINING MEMBER LEAVING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between successive checks of the IGMP state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired IGMP state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the IGMP state of each session reaches a specified target state. This function polls the provided session objects at regular intervals and checks their current IGMP state. If all sessions reach the desired state within the timeout period, it returns True. Otherwise, a Failure exception is raised when the timeout is reached.",
    "example": "| Wait Igmp State | Sessions=${Sessions} | State=MEMBER | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.igmp_send_report",
    "return_type": "bool",
    "return": "True if the IGMP report is sent successfully for all sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable containing session objects. Each session must have a `send_report()` method to be executed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends an IGMP report for each session in the provided Sessions collection. The function supports both a single session and multiple sessions in an iterable. If a single session is provided, it is automatically wrapped into a list. The function then iterates over all sessions and calls the `send_report()` method on each session object. If any session does not have the `send_report()` method, a TypeError is raised.",
    "example": ".. code:: RobotFramework\n\n    | Igmp Send Report | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.igmp_send_leave",
    "return_type": "bool",
    "return": "布尔值，表示 IGMP Leave 消息是否成功发送。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`Igmp`)",
        "description": "IGMP 会话对象或其集合（列表、集合或元组），用于发送 IGMP Leave 消息。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于向指定的 IGMP 会话发送 IGMP Leave 消息，以结束组播组成员身份。支持传入单个会话对象或多个会话对象的集合。如果操作失败，将抛出 `ContinuableFailure` 异常；否则返回 True。",
    "example": ".. code:: RobotFramework\n\n    | Igmp Send Leave | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.igmp_resend_report",
    "return_type": "bool",
    "return": "True if all sessions successfully resend their IGMP reports, False if any session fails.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`Igmp`)",
        "description": "A list of IGMP session objects. Each object must have a `resend_report()` method defined.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Re-sends IGMP reports for the specified session(s). This function ensures that each provided IGMP session retransmits its report. If a single session is provided instead of a list, it will be converted into a list to maintain consistency in processing. Each session's `resend_report()` method is called in turn.",
    "example": "| Igmp Resend Report | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.get_igmp_host_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "If one matching session is found, returns a dictionary with requested statistical items as keys and their values. If multiple sessions match, returns a pandas DataFrame of the results. If no matches are found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the IGMP host session(s) to retrieve statistics for. If None, applies no session filter. Each session object must have a `.Name` attribute used as 'IgmpHostBlockId' in index dict. Collections of sessions are supported.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to fetch from 'IgmpHostResults'. If None, retrieves all available properties. If string, it's converted into a single-element list. Must be subset of valid IGMP host result properties.",
        "default": "None",
        "range_or_options": "IgmpTxFrames IgmpRxFrames IgmpRxUnknownTypes IgmpRxChecksumErrors IgmpRxLengthErrors"
      }
    ],
    "kwargs": [],
    "description": "Retrieves IGMP host-related statistics for specified session(s). Internally wraps `_get_statictis` function and uses 'IgmpHostResults' type to fetch data. Builds an index dictionary using session identifiers derived from `Session`. Optionally filters by specific statistical items provided via `StaItems`.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | IgmpTxFrames | IgmpRxFrames |\n    | Subscribe Result | Types=IgmpHostResults |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Igmp Host Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.get_igmp_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "If one matching row is found, returns a dictionary with statistic items as keys and values; if multiple rows are found, returns a pandas DataFrame; if no match is found, returns False.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple of objects, optional",
        "description": "A single port object or collection of port objects for which IGMP statistics are to be retrieved. Each port object must have a `Name` attribute. If None (default), no specific port filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies the statistical items (columns) to retrieve. If None (default), all available properties are queried. Must be a subset of the available properties for 'IgmpPortAggregatedResults'. Supported items include IgmpTxFrames, IgmpRxFrames, IgmpTxV1Reports, IgmpTxV2Reports, IgmpTxLeaveGroups, IgmpTxV3Reports, IgmpTxV3ModeInclude, IgmpTxV3ModeExclude, IgmpTxV3ModeChangeToInclude, IgmpTxV3ModeChangeToExclude, IgmpTxV3ModeAllowNewSources, IgmpTxV3ModeBlockOldSources, IgmpRxV1Queries, IgmpRxV2Queries, IgmpRxV3Queries, IgmpRxGeneralQueries, IgmpRxGroupSpecificQueries, IgmpRxGroupAndSourceSpecificQueries, IgmpRxUnknownTypes, IgmpRxChecksumErrors, IgmpRxLengthErrors.",
        "default": "None",
        "range_or_options": "IgmpTxFrames IgmpRxFrames IgmpTxV1Reports IgmpTxV2Reports IgmpTxLeaveGroups IgmpTxV3Reports IgmpTxV3ModeInclude IgmpTxV3ModeExclude IgmpTxV3ModeChangeToInclude IgmpTxV3ModeChangeToExclude IgmpTxV3ModeAllowNewSources IgmpTxV3ModeBlockOldSources IgmpRxV1Queries IgmpRxV2Queries IgmpRxV3Queries IgmpRxGeneralQueries IgmpRxGroupSpecificQueries IgmpRxGroupAndSourceSpecificQueries IgmpRxUnknownTypes IgmpRxChecksumErrors IgmpRxLengthErrors"
      }
    ],
    "description": "Retrieves IGMP port-level aggregated statistics for specified ports. This function wraps the `_get_statictis` method to fetch IGMP-related statistics from one or more ports. It prepares the port identifiers and delegates the actual statistic retrieval logic to the internal `_get_statictis` method.",
    "example": "| @{StaItems} | Create List | IgmpTxFrames | IgmpRxFrames |\n| Subscribe Result | Types=IgmpPortAggregatedResults |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Igmp Port Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.create_igmp_querier",
    "return_type": "IgmpQuerier",
    "return": "IGMP协议会话对象，用于后续操作和查询。",
    "description": "该函数用于创建并配置一个绑定到指定端口的IGMP Querier实例。它支持通过关键字参数对IGMP Querier进行详细配置，并在创建后将其注册到全局协议对象映射中以便后续引用。",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，表示该IGMP Querier将绑定到的物理或逻辑端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "IGMP Querier会话名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用IGMP Querier协议会话。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "指定IGMP版本。",
        "default": "IGMPV2",
        "range_or_options": "IGMPV1 IGMPV2 IGMPV3"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "健壮系数，用于控制IGMP查询机制的容错能力。",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "查询时间间隔（单位：秒）。",
        "default": "125",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "QueryResponseInterval",
        "type": "int",
        "description": "查询响应时间间隔（单位：毫秒）。",
        "default": "10000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "StartupQueryCount",
        "type": "int",
        "description": "初始查询报文发送个数。",
        "default": "2",
        "range_or_options": "1-255"
      },
      {
        "name": "LastMemberQueryInterval",
        "type": "int",
        "description": "最后成员查询时间间隔（单位：毫秒）。",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LastMemberQueryCount",
        "type": "int",
        "description": "最后成员查询次数。",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "IPv4DoNotFragment",
        "type": "bool",
        "description": "设置IP头中的不分片标志位。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IPv4TosValue",
        "type": "hex",
        "description": "设置IPv4头部的TOS值。",
        "default": "0xc0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "example": "| Create Igmp Querier | Port=${Port} | Version=IGMPV3 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.edit_igmp_querier",
    "return_type": "bool",
    "return": "True if the IGMP querier session attributes were successfully updated; False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "IgmpQuerier",
        "description": "The IGMP Querier session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the IGMP Querier session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the IGMP Querier session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "Specifies the IGMP version used for the session.",
        "default": "IGMPV2",
        "range_or_options": "IGMPV1 IGMPV2 IGMPV3"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Sets the robustness variable used in IGMP querier operations.",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Sets the query interval (in seconds) between IGMP queries sent by the querier.",
        "default": "125",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ResponseInterval",
        "type": "int",
        "description": "Sets the maximum time (in milliseconds) a host waits before sending a response to an IGMP query.",
        "default": "10000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "StartupQueryCount",
        "type": "int",
        "description": "Sets the number of queries sent at startup to discover multicast group members.",
        "default": "2",
        "range_or_options": "1-255"
      },
      {
        "name": "LastMemberQueryInterval",
        "type": "int",
        "description": "Sets the interval (in milliseconds) between last member queries.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LastMemberQueryCount",
        "type": "int",
        "description": "Sets the number of queries sent to confirm whether a host is the last member of a group.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "IPv4DoNotFragment",
        "type": "bool",
        "description": "Sets the Don't Fragment (DF) bit in the IP header of IGMP packets.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IPv4TosValue",
        "type": "hex",
        "description": "Sets the Type of Service (ToS) field in the IP header of IGMP packets.",
        "default": "0xc0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "description": "This function edits an existing IGMP Querier session by updating its configuration attributes. It allows users to dynamically modify various protocol-specific parameters such as version, intervals, and IP header options. The function internally calls the backend API to update the provided `Session` object with the specified key-value pairs. If the operation fails, a ContinuableFailure exception is raised.",
    "example": "| Edit Igmp Querier | Session=my_igmp_session | Version=IGMPV3 | IPv4TosValue=0xff |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.apply_igmp_querier",
    "description": "Applies the IGMP querier configuration to one or more session objects. This function accepts a single session object or an iterable (list, set, tuple) of session objects and invokes the `apply()` method on each session to configure the IGMP querier settings.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable containing multiple session objects. Each session must have an `apply()` method that handles the actual configuration logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "return_type": "bool",
    "return": "Always returns True if the IGMP querier configuration is successfully applied to all provided sessions. If any session does not have an `apply()` method or if input type is invalid, exceptions will be raised instead.",
    "example": ".. code:: RobotFramework\n\n    | Apply Igmp Querier |",
    "raises": [
      {
        "exception": "AttributeError",
        "description": "If any of the provided session objects does not have an `apply()` method."
      },
      {
        "exception": "TypeError",
        "description": "If the `Sessions` argument is not a valid session object nor an iterable of session objects."
      },
      {
        "exception": "ContinuableFailure",
        "description": "If the underlying backend call returns False, indicating a failure in applying IGMP querier configuration."
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.wait_igmp_querier_state",
    "return_type": "bool",
    "return": "Returns True if all IGMP querier sessions reach one of the expected states within the timeout period.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`IgmpQuerier`)",
        "description": "A list of IgmpQuerier session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "list or str",
        "description": "One or more acceptable target states that the IGMP querier sessions are expected to reach.",
        "default": "['UP']",
        "range_or_options": "NOTSTARTED UP"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between successive checks of the IGMP querier state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to transition into one of the expected states.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the IGMP querier state of each session in 'Sessions' reaches one of the specified target states. This function polls the sessions at regular intervals and checks whether the current state matches any of the desired states. If all sessions reach one of the target states within the timeout period, the function returns True. Otherwise, it raises a TesterException when the timeout is exceeded.",
    "example": "| Wait Igmp Querier State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.get_igmp_querier_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for IGMP querier sessions based on the provided session filters and statistical items. If exactly one matching result is found, returns a dictionary with requested statistics; if multiple results match, returns a pandas DataFrame; if no match is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the session(s) to query. If None, all available IGMP querier statistics are considered. If an object with a 'Name' attribute is passed, its name is used as the session ID. If a collection of session objects is passed, their 'Name' attributes are extracted to form a list of session IDs.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, defaults to querying all available properties dynamically. If a string is provided, it is converted into a single-item list. Must be a subset of the available statistical properties.",
        "default": "None",
        "range_or_options": "QuerierTxFrames QuerierRxFrames QuerierRxUnknownTypes QuerierRxChecksumErrors QuerierRxLengthErrors"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves IGMP querier statistics based on the specified session identifiers and statistical items. It internally calls the `_get_statictis` method with appropriate parameters to fetch IGMP querier-related results. The function supports filtering by session and selecting specific statistic fields. It may raise exceptions during command execution or database access errors.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | QuerierTxFrames | QuerierRxFrames |\n    | Subscribe Result | Types=IgmpQuerierResults |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Igmp Querier Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.igmp.edit_igmp_port_config",
    "return_type": "bool",
    "return": "布尔值，表示IGMP端口配置是否修改成功（True/False）",
    "parameters": [
      {
        "name": "Ports",
        "type": "object / list",
        "description": "测试仪表端口对象，用于指定需要修改IGMP配置的端口。可以是一个单独的对象或一个端口对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "IgmpMaximumOutputRate",
        "type": "int",
        "description": "设置IGMP端口的最大发包速率（单位：包/秒）。",
        "default": "100",
        "range_or_options": "1-1000000000"
      }
    ],
    "description": "该函数用于修改一个或多个测试仪表端口上的IGMP端口配置，例如最大发包速率。它调用Renix后端API来执行实际的配置修改操作。如果配置修改失败，则抛出异常；如果成功，则返回True。",
    "example": "| Edit Igmp Port Config | Ports=${Ports} | IgmpMaximumOutputRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis",
    "return_type": "IsisRouter",
    "return": "The created ISIS protocol session object representing the configuration.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent port object to which this ISIS protocol instance belongs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the ISIS session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the ISIS protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version used for the ISIS protocol.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6 IPV4IPV6"
      },
      {
        "name": "Level",
        "type": "str",
        "description": "ISIS level type (L1, L2, or both).",
        "default": "L2",
        "range_or_options": "L1 L2 L1L2"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Network type for the ISIS interface.",
        "default": "BROADCAST",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "SystemId",
        "type": "str",
        "description": "System ID represented as a MAC address.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "MAC address format"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Priority value for the router selection.",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "AuthMethod",
        "type": "str",
        "description": "Authentication method for ISIS packets.",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Password used in authentication.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthSendOnly",
        "type": "bool",
        "description": "If True, sends authentication information without checking received ones.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CircuitId",
        "type": "int",
        "description": "Circuit identifier for the interface.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Area1",
        "type": "str",
        "description": "First area ID in hexadecimal format.",
        "default": "0x10",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "Area2",
        "type": "str",
        "description": "Second area ID in hexadecimal format.",
        "default": "",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "Area3",
        "type": "str",
        "description": "Third area ID in hexadecimal format.",
        "default": "",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "MetricMode",
        "type": "str",
        "description": "Metric mode for route calculation.",
        "default": "NARROWWIDE",
        "range_or_options": "NARROW WIDE NARROWWIDE"
      },
      {
        "name": "TeRouterId",
        "type": "str",
        "description": "Traffic Engineering Router ID (IPv4 address).",
        "default": "192.168.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "TeRouterIdIpv6",
        "type": "str",
        "description": "Traffic Engineering Router ID for IPv6.",
        "default": "3000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Interval between Hello PDUs in seconds.",
        "default": "10",
        "range_or_options": "1-300"
      },
      {
        "name": "HelloMultiplier",
        "type": "int",
        "description": "Multiplier for hello intervals to determine neighbor timeout.",
        "default": "3",
        "range_or_options": "1-100"
      },
      {
        "name": "PsnInterval",
        "type": "int",
        "description": "PSNP interval in seconds.",
        "default": "2",
        "range_or_options": "1-20"
      },
      {
        "name": "LspRefreshTime",
        "type": "int",
        "description": "Time in seconds after which an LSP is refreshed.",
        "default": "900",
        "range_or_options": "1-65535"
      },
      {
        "name": "RetransInterval",
        "type": "int",
        "description": "Time in seconds between retransmissions of LSPs.",
        "default": "5",
        "range_or_options": "1-100"
      },
      {
        "name": "HelloPadding",
        "type": "bool",
        "description": "Whether to pad Hello messages to maximum frame size.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LspSize",
        "type": "int",
        "description": "Maximum size of generated LSPs.",
        "default": "1492",
        "range_or_options": "100-1492"
      },
      {
        "name": "ValidateIpAddr",
        "type": "bool",
        "description": "Enables IP address validation on the interface.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables graceful restart capability.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables viewing of learned routes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableBFD",
        "type": "bool",
        "description": "Enables Bidirectional Forwarding Detection.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MtParams",
        "type": "int",
        "description": "Number of multi-topology parameters configured.",
        "default": "0",
        "range_or_options": "0-2"
      },
      {
        "name": "PerPduAuthentication",
        "type": "int",
        "description": "Number of per-PDU authentications configured.",
        "default": "0",
        "range_or_options": "0-4"
      },
      {
        "name": "ReportLabel",
        "type": "bool",
        "description": "Enables label reporting if True.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LearnRoute",
        "type": "bool",
        "description": "Enables route learning if True.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RecordLspNextSequenceNum",
        "type": "bool",
        "description": "Enables tracking of next sequence number for LSPs.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "L1NarrowMetric",
        "type": "int",
        "description": "Narrow metric for Level 1 routing.",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "L1WideMetric",
        "type": "int",
        "description": "Wide metric for Level 1 routing.",
        "default": "1",
        "range_or_options": "0-16777214"
      },
      {
        "name": "L2NarrowMetric",
        "type": "int",
        "description": "Narrow metric for Level 2 routing.",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "L2WideMetric",
        "type": "int",
        "description": "Wide metric for Level 2 routing.",
        "default": "1",
        "range_or_options": "0-16777214"
      },
      {
        "name": "FloodLsp",
        "type": "bool",
        "description": "Controls whether LSPs are flooded once neighbors are established.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "Hostname associated with the ISIS router.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and initializes an ISIS protocol configuration on the specified port. This function instantiates an IsisRouter object with the provided Port as its parent/upper layer, and any additional keyword arguments used to configure attributes of the ISIS protocol. It also maps the created protocol object in a global protocol-object mapping using its handle.",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${MtId} | Create List | IPV4 | IPV6 |\n| ${{MtFlags} | Create List | ABIT | OBIT |\n| Edit Isis | Session=${Session} | EnableViewRoutes=True | MtParams=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.edit_isis",
    "return_type": "bool",
    "return": "True if the attributes of the Session object were successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "IsisRouter",
        "description": "The ISIS protocol session object whose attributes are to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the ISIS session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the ISIS protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version used for the session.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6 IPV4IPV6"
      },
      {
        "name": "Level",
        "type": "str",
        "description": "Routing level of the ISIS session.",
        "default": "L2",
        "range_or_options": "L1 L2 L1L2"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Type of network the session operates on.",
        "default": "BROADCAST",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "SystemId",
        "type": "str",
        "description": "System ID of the router in MAC address format.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "MAC address format"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Router priority for DIS election.",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "AuthMethod",
        "type": "str",
        "description": "Authentication method used for the session.",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password used for the session.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "CircuitId",
        "type": "int",
        "description": "Circuit ID assigned to the session.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Area1",
        "type": "str",
        "description": "First area ID in hexadecimal format.",
        "default": "0x10",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "Area2",
        "type": "str",
        "description": "Second area ID in hexadecimal format.",
        "default": "",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "Area3",
        "type": "str",
        "description": "Third area ID in hexadecimal format.",
        "default": "",
        "range_or_options": "0x0-0xff"
      },
      {
        "name": "MetricMode",
        "type": "str",
        "description": "Metric mode used for route calculation.",
        "default": "NARROWWIDE",
        "range_or_options": "NARROW WIDE NARROWWIDE"
      },
      {
        "name": "TeRouterId",
        "type": "str",
        "description": "TE Router ID (IPv4 address).",
        "default": "192.168.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "TeRouterIdIpv6",
        "type": "str",
        "description": "TE Router ID (IPv6 address).",
        "default": "3000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval (in seconds) between Hello PDUs.",
        "default": "10",
        "range_or_options": "1-300"
      },
      {
        "name": "HelloMultiplier",
        "type": "int",
        "description": "Multiplier for Hello intervals to determine neighbor timeout.",
        "default": "3",
        "range_or_options": "1-100"
      },
      {
        "name": "PsnInterval",
        "type": "int",
        "description": "Interval (in seconds) between PSNP PDUs.",
        "default": "2",
        "range_or_options": "1-20"
      },
      {
        "name": "LspRefreshTime",
        "type": "int",
        "description": "Time interval (in seconds) after which an LSP is refreshed.",
        "default": "900",
        "range_or_options": "1-65535"
      },
      {
        "name": "RetransInterval",
        "type": "int",
        "description": "Time interval (in seconds) between LSP retransmissions.",
        "default": "5",
        "range_or_options": "1-100"
      },
      {
        "name": "HelloPadding",
        "type": "bool",
        "description": "Enables/disables padding in Hello PDUs.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LspSize",
        "type": "int",
        "description": "Maximum size of LSPs sent by the router.",
        "default": "1492",
        "range_or_options": "100-1492"
      },
      {
        "name": "ValidateIpAddr",
        "type": "bool",
        "description": "Enables/disables IP address validation on the interface.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables/disables graceful restart capability.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables/disables viewing of routes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableBFD",
        "type": "bool",
        "description": "Enables/disables Bidirectional Forwarding Detection (BFD).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MtParams",
        "type": "int",
        "description": "Number of Multi-Topology parameters to configure.",
        "default": "0",
        "range_or_options": "0-2"
      },
      {
        "name": "PerPduAuthentication",
        "type": "int",
        "description": "Number of Per-PDU authentication blocks to use.",
        "default": "0",
        "range_or_options": "0-4"
      },
      {
        "name": "ReportLabel",
        "type": "bool",
        "description": "Enables/disables label reporting capability.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LearnRoute",
        "type": "bool",
        "description": "Enables/disables route learning functionality.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RecordLspNextSequenceNum",
        "type": "bool",
        "description": "Enables/disables recording of next LSP sequence number.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "L1NarrowMetric",
        "type": "int",
        "description": "L1 narrow metric value.",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "L1WideMetric",
        "type": "int",
        "description": "L1 wide metric value.",
        "default": "1",
        "range_or_options": "0-16777214"
      },
      {
        "name": "L2NarrowMetric",
        "type": "int",
        "description": "L2 narrow metric value.",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "L2WideMetric",
        "type": "int",
        "description": "L2 wide metric value.",
        "default": "not_found",
        "range_or_options": "0-16777214"
      },
      {
        "name": "FloodLsp",
        "type": "bool",
        "description": "Enables/disables flooding of LSPs after neighbor adjacency.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AuthSendOnly",
        "type": "bool",
        "description": "If True, sends authentication information without checking received packets.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Updates the attributes of a given ISIS session object with provided key-value pairs in keyword arguments. Only existing attributes of the session object will be modified. Returns True upon successful update.",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| Edit Isis | Session=${Session} | EnableViewRoutes=True | MtParams=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.edit_isis_global_options",
    "return_type": "bool",
    "return": "True if the ISIS global options were successfully edited; False otherwise (if an error occurs, it may raise an exception depending on internal handling).",
    "parameters": [],
    "kwargs": [
      {
        "name": "SRMSPerfType",
        "type": "int",
        "description": "Specifies SRMS Preference sub-TLV type for ISIS protocol configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRv6CapabilityType",
        "type": "int",
        "description": "Specifies SRv6 Capabilities sub-TLV type in ISIS TLVs.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRv6LocatorType",
        "type": "int",
        "description": "Specifies SRv6 Locator TLV type in ISIS TLVs.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRv6EndType",
        "type": "int",
        "description": "Specifies SRv6 End SID sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRv6EndXType",
        "type": "int",
        "description": "Specifies SRv6 End.X SID sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRv6LanEndXType",
        "type": "int",
        "description": "Specifies SRv6 LAN End.X SID sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRNodeMSDType",
        "type": "int",
        "description": "Specifies SR Node MSD sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRLinkMSDType",
        "type": "int",
        "description": "Specifies SR Link MSD sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SRFAPM",
        "type": "int",
        "description": "Specifies Flex-Algo Prefix Metric sub-TLV type.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ScalabilityMode",
        "type": "str",
        "description": "Defines the scalability mode of the system. Valid values are 'NORMAL' and 'DISCARD'.",
        "default": "not_found",
        "range_or_options": "'NORMAL' 'DISCARD'"
      }
    ],
    "description": "This function edits the global ISIS (Intermediate System to Intermediate System) protocol options within the system configuration. It allows customization of various SR (Segment Routing), SRv6, and scalability-related parameters used by the ISIS routing protocol. The function internally applies these changes using the `renix.edit_isis_global_options` method and raises a failure exception upon unsuccessful execution.",
    "example": "| edit_isis_global_options | SRMSPerfType=3 | ScalabilityMode=NORMAL |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.edit_isis_per_pdu",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the operation. Returns False if the backend call fails, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable of objects (e.g., list, tuple, set)",
        "description": "The ISIS protocol session object or a collection-like structure containing session objects. If a collection is provided, the first item will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Specifies the index of the PDU entry to edit within the session.",
        "default": "0",
        "range_or_options": "0-1"
      }
    ],
    "kwargs": [
      {
        "name": "PdusType",
        "type": "str",
        "description": "The type of PDU for which authentication needs to be configured.",
        "default": "L1_HELLO",
        "range_or_options": "L1_HELLO L2_HELLO L1_AREA_PDUS L2_DOMAIN_PDUS"
      },
      {
        "name": "AuthMethod",
        "type": "str",
        "description": "The type of authentication method to apply for the PDU.",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password string to be used with the selected authentication method.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthSendOnly",
        "type": "bool",
        "description": "When set to True, sends authentication information only without checking incoming packets.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Edits the ISIS per-PDU authentication settings for a given session. This function ensures that a single valid session object is used (taking the first element if a list-like structure is passed). It then calls the internal `edit_per_pdu_authentication` method on the session object with the provided arguments to configure the authentication parameters.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | Edit Isis Per Pdu | Session=${Session} | PdusType=L2_HELLO | AuthMethod=SIMPLE | Password=Test |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.get_isis_per_pdu",
    "return_type": "dict or raises ContinuableFailure",
    "return": "Returns a dictionary containing the ISIS protocol session's Per PDU Authentication parameters, such as 'PdusType', 'AuthMethod', and 'Password'. If the backend call fails (returns False), a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (e.g., list, set, tuple)",
        "description": "The ISIS protocol session object (or an iterable of such objects). If an iterable is provided, the first element will be used for the operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index specifying which Per PDU Authentication entry to retrieve. This is typically used to select one of multiple authentication configurations.",
        "default": "0",
        "range_or_options": "0-4"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves ISIS protocol session's Per PDU Authentication information. It supports passing either a single session object or an iterable of session objects, using the first one if an iterable is passed. The function internally calls the `get_per_pdu_authentication` method on the session object with the given index. If the internal Renix API returns False, it raises a ContinuableFailure exception; otherwise, it returns the retrieved configuration in a dictionary format.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | Edit Isis | Session=${Session} | EnableViewRoutes=True | PerPduAuthentication=1 |\n    | Edit Isis Per Pdu Authentication | Session=${Session} | PdusType=L2_HELLO | AuthMethod=SIMPLE | Password=Test |\n    | Get Isis Per Pdu Authentication | Session=${Session} | Index=0 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.edit_isis_mt_params",
    "return_type": "bool",
    "return": "Returns True if the operation was successful, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable",
        "description": "An ISIS session object or a collection of session objects. If it's a collection, only the first item will be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the MT parameter set to edit within the session.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "MtId",
        "type": "str",
        "description": "The Multi-Topology Identifier to set. This identifies which topology is being configured.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "MtFlags",
        "type": "list",
        "description": "The Multi-Topology flags to configure. These define behaviors for the given topology.",
        "default": "NOSHOW",
        "range_or_options": "NOSHOW ABIT OBIT"
      }
    ],
    "kwargs": [],
    "description": "Edits the MT (Multi-Topology) parameters for an ISIS session at the specified index. This function allows modifying the Multi-Topology ID and flags in an ISIS session. If the provided Session is a list, set, or tuple, only the first element will be used for editing.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${{MtFlags} | Create List | ABIT | OBIT |\n    | Edit Isis | Session=${Session} | EnableViewRoutes=True | MtParams=1 |\n    | Edit Isis Mt Params | Session=${Session} | MtId=IPV6 | MtFlags=${{MtFlags} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.get_isis_mt_params",
    "return_type": "dict",
    "return": "A dictionary containing the MT (Metric Type) parameters for the specified ISIS session and index. Example keys include 'MtId' and 'MtFlags'.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or collection",
        "description": "An ISIS protocol session object or a collection (e.g., list, set, tuple) containing such an object. If a collection is provided, the first element will be used as the session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index specifying which MT parameter set to retrieve from the Session. Typically used to select between multiple configurations.",
        "default": "0",
        "range_or_options": "0-1"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the MT (Metric Type) parameters for an ISIS session at the specified index. This function serves as a wrapper that abstracts away complexities in accessing the underlying session's MT parameters. It ensures robust access by extracting the session object from a possible collection and retrieving the correct parameter set based on the given index.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${{MtFlags} | Create List | ABIT | OBIT |\n    | Edit Isis | Session=${Session} | EnableViewRoutes=True | MtParams=2 |\n    | Get Isis Mt Params | Session=${Session} | Index=0 |\n    | Get Isis Mt Params | Session=${Session} | Index=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_lsp",
    "return_type": "IsisLspConfig",
    "return": "ISIS LSP对象，表示创建的链路状态协议数据单元。",
    "parameters": [
      {
        "name": "Session",
        "type": "IsisRouter",
        "description": "ISIS协议会话对象列表，用于管理通信上下文。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "ISIS LSP对象名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能ISIS LSP",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SystemId",
        "type": "str",
        "description": "系统ID，取值范围为MAC地址格式",
        "default": "00:00:00:00:00:01",
        "range_or_options": "MAC地址"
      },
      {
        "name": "Level",
        "type": "str",
        "description": "区域类型，支持L1和L2",
        "default": "L2",
        "range_or_options": "L1 L2"
      },
      {
        "name": "PseudonodeId",
        "type": "int",
        "description": "伪节点ID，取值范围1-100",
        "default": "0",
        "range_or_options": "1-100"
      },
      {
        "name": "TeRouterId",
        "type": "str",
        "description": "TE路由器ID，取值范围为IPv4地址",
        "default": "192.168.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "TeRouterIdIpv6",
        "type": "str",
        "description": "IPv6 TE路由器ID，取值范围为IPv6地址",
        "default": "3000::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "序列号，取值范围1-300",
        "default": "10",
        "range_or_options": "1-300"
      },
      {
        "name": "RemainingLifeTime",
        "type": "int",
        "description": "剩余生存时间，取值范围1-100",
        "default": "3",
        "range_or_options": "1-100"
      },
      {
        "name": "Checksum",
        "type": "int",
        "description": "校验和设置，取值范围1-20",
        "default": "2",
        "range_or_options": "1-20"
      },
      {
        "name": "AttachedBit",
        "type": "int",
        "description": "区域关联位，取值范围1-65535",
        "default": "900",
        "range_or_options": "1-65535"
      },
      {
        "name": "OverloadBit",
        "type": "int",
        "description": "过载位，取值范围1-100",
        "default": "5",
        "range_or_options": "1-100"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "主机名称",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于创建一个ISIS LSP（链路状态协议数据单元）对象。它通过传入的Session对象调用底层`create_lsp`方法，并接受一系列可选参数来配置LSP的行为。该功能简化了在特定会话上下文中创建ISIS LSP的过程，并允许灵活配置。",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_ipv4_tlv",
    "return_type": "IsisIpv4TlvConfig",
    "return": "An instance of `IsisIpv4TlvConfig` representing the configured ISIS IPv4 TLV object.",
    "parameters": [
      {
        "name": "Lsp",
        "type": "IsisLspConfig",
        "description": "The ISIS LSP (Link State PDU) object to which this IPv4 TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name for the ISIS IPv4 TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the ISIS IPv4 TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteType",
        "type": "str",
        "description": "Specifies the route type for the IPv4 TLV.",
        "default": "INTERNAL",
        "range_or_options": "INTERNAL EXTERNAL"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes to be advertised by the TLV.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Step size for incrementing IP prefixes.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "Type of metric used for routing decisions.",
        "default": "INTERNAL",
        "range_or_options": "INTERNAL EXTERNAL"
      },
      {
        "name": "WideMetric",
        "type": "int",
        "description": "Extended metric value used in IS-IS routing.",
        "default": "10",
        "range_or_options": "0-16777214"
      },
      {
        "name": "UpDownBit",
        "type": "bool",
        "description": "Indicates whether the Up/Down bit is set for route leaking.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StartIpv4Prefix",
        "type": "str",
        "description": "Starting IPv4 prefix for generating routes.",
        "default": "192.168.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv4 prefix (subnet mask).",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "NarrowMetric",
        "type": "int",
        "description": "Default metric value used in narrow metrics mode.",
        "default": "10",
        "range_or_options": "0-63"
      }
    ],
    "description": "This function creates and configures an ISIS IPv4 TLV (Type-Length-Value) object associated with a given LSP (Link State PDU). It allows optional keyword arguments to configure various aspects of the TLV such as route parameters, metrics, and prefixes. The resulting `IsisIpv4TlvConfig` object can be further manipulated or used to apply configuration in the IS-IS protocol stack.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Ipv4 Tlv | Lsp=${LSP} | RouteType=EXTERNAL | RouteCount=5 | StartIpv4Prefix=10.0.0.1 | PrefixLength=24 | WideMetric=100"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_ipv6_tlv",
    "return_type": "IsisIpv6TlvConfig",
    "return": "A configured IsisIpv6TlvConfig object representing the created IPv6 TLV entry.",
    "parameters": [
      {
        "name": "Lsp",
        "type": "IsisLspConfig",
        "description": "An LSP (Link State PDU) object that serves as the upper layer/context for the IPv6 TLV configuration. It is used to associate the TLV with a specific IS-IS link state advertisement.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the ISIS IPv6 TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the ISIS IPv6 TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteType",
        "type": "str",
        "description": "Specifies the route type for the TLV.",
        "default": "INTERNAL",
        "range_or_options": "INTERNAL EXTERNAL"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "Number of routes to be advertised via this TLV.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Step increment value for generating multiple routes.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "Type of metric used for route calculation.",
        "default": "INTERNAL",
        "range_or_options": "INTERNAL EXTERNAL"
      },
      {
        "name": "WideMetric",
        "type": "int",
        "description": "Extended metric value for route cost.",
        "default": "10",
        "range_or_options": "0-16777214"
      },
      {
        "name": "UpDownBit",
        "type": "bool",
        "description": "Up/Down bit flag indicating whether the route is downlevel in hierarchy.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StartIpv6Prefix",
        "type": "str",
        "description": "Starting IPv6 prefix for route generation.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Prefix length for generated IPv6 routes.",
        "default": "24",
        "range_or_options": "1-32"
      }
    ],
    "description": "Creates and configures an IPv6 TLV (Type-Length-Value) object for an IS-IS router. This function wraps the IsisRouter.create_ipv6_tlv method to create an IPv6 TLV configuration bound to a specific LSP in the context of IS-IS routing. Optional keyword arguments can be provided to configure the TLV during its creation, enabling flexible and dynamic setup of TLVs during IS-IS protocol operations.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Ipv6 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.get_isis_router_from_tlv",
    "return_type": "list(:obj:`IsisIpv4Router`)",
    "return": "A list of ISIS router objects associated with the provided TLV configuration(s). Each entry corresponds to the 'GenerateLsp' source-relative object related to the input configuration.",
    "parameters": [
      {
        "name": "Configs",
        "type": "object or iterable (list, set, tuple) of :obj:`IsisIpv4TlvConfig`, `IsisIpv6TlvConfig`",
        "description": "A single configuration object or an iterable containing multiple TLV configuration objects. These objects must support the `get_relatives` method internally used to locate the associated ISIS routers.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves the associated ISIS router objects from the given TLV configuration objects. It processes a single object or a collection of such objects and finds their related 'GenerateLsp' object in the source direction, which represents the ISIS router bound to the TLV configuration. If a non-iterable is passed, it will be automatically wrapped into a list for processing.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${TLV} | Create Isis Ipv4 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Get Isis Router From Tlv | Configs=${TLV} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.wait_isis_state",
    "return_type": "bool",
    "return": "Returns True if all provided ISIS sessions reach the specified target state within the timeout period; otherwise, it raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`IsisRouter`)",
        "description": "A list of ISIS protocol session objects to monitor for a specific state change.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list(str), optional",
        "description": "The desired state(s) to wait for. If not provided, defaults to 'UP'. Case-insensitive comparison is used for matching states.",
        "default": "'UP'",
        "range_or_options": "'NOTSTART' 'IDLE' 'INIT' 'UP' 'GR' 'GRHELPER' 'DISABLE'"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Time in seconds between consecutive checks for the desired state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits until the provided ISIS protocol session(s) reach the specified target state(s). It polls the state of the sessions at regular intervals and returns successfully only when all sessions are in the desired state within the given timeout period. If the session type is `IsisProtocolConfig`, it monitors the 'RouterState' attribute; otherwise, it uses the generic 'State' attribute. The function raises a Failure exception if the timeout is reached before the desired state is achieved.",
    "example": "| Wait Isis State | Sessions=${Sessions} | State=GR | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.wait_isis_three_way_p2p_adj_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach the desired 'ThreeWayP2pAdjState' within the timeout period; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`IsisRouter`)",
        "description": "A list of ISIS protocol session objects (IsisRouter) to monitor for their 'ThreeWayP2pAdjState'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list(str)",
        "description": "The target state(s) that the function waits for each session's 'ThreeWayP2pAdjState' attribute to reach. If not specified, defaults to 'UP'.",
        "default": "'UP'",
        "range_or_options": "UP INIT DOWN NOTSTART NA"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of the session's 'ThreeWayP2pAdjState'.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired 'ThreeWayP2pAdjState' before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'ThreeWayP2pAdjState' attribute of each ISIS P2P adjacency session in 'Sessions' reaches the specified state. This function polls the sessions at regular intervals and returns successfully if all sessions reach the desired state within the timeout period; otherwise, it raises a Failure exception. The comparison is case-insensitive and supports multiple states as input.",
    "example": "| Wait Isis Three Way P2p Adj State | Sessions=${Sessions} | State=INIT | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.wait_isis_l1_broadcast_adj_state",
    "return_type": "bool",
    "return": "Returns True if all ISIS L1 broadcast adjacency states reach one of the expected states within the timeout period; otherwise, it raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`IsisRouter`)",
        "description": "A list of ISIS protocol session objects whose 'L1BroadcastAdjState' attribute will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list(str), optional",
        "description": "One or more acceptable values for the 'L1BroadcastAdjState' attribute. If None, defaults to ['DISOTHER', 'DIS']. All values are compared case-insensitively.",
        "default": "['DISOTHER', 'DIS']",
        "range_or_options": "NOTSTART IDLE INIT DISOTHER DIS GR GRHELPER NA"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Polling interval in seconds between consecutive checks of the 'L1BroadcastAdjState' on the sessions.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired states before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'L1BroadcastAdjState' attribute of each session in 'Sessions' reaches one of the specified target states. This function is specifically designed to monitor ISIS L1 broadcast adjacency states. It polls the sessions at a defined interval and checks whether the 'L1BroadcastAdjState' attribute for all given sessions matches one of the desired states. If all sessions reach one of the expected states within the timeout period, the function returns True. Otherwise, it raises an exception if the timeout is exceeded.",
    "example": "| Wait Isis L1 Broadcast Adj State | Sessions=${Sessions} | State=DIS | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.wait_isis_l2_broadcast_adj_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the expected 'L1BroadcastAdjState' values within the timeout period. Otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`IsisRouter`)",
        "description": "A list of ISIS protocol session objects to monitor for state changes in their L1 broadcast adjacency states.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list(str), optional",
        "description": "One or more acceptable values for the 'L1BroadcastAdjState'. If None, defaults to ['DISOTHER', 'DIS']. Comparison is case-insensitive.",
        "default": "['DISOTHER', 'DIS']",
        "range_or_options": "NOTSTART IDLE INIT DISOTHER DIS GR GRHELPER NA"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Polling interval in seconds between consecutive checks of the 'L1BroadcastAdjState' on the sessions.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired states before raising a TesterException.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'L1BroadcastAdjState' attribute of each session in 'Sessions' reaches one of the specified target states. This function is specifically designed to monitor ISIS L1 broadcast adjacency states. It polls the sessions at a defined interval and checks whether the 'L1BroadcastAdjState' attribute for all given sessions matches one of the desired states. If all sessions reach one of the expected states within the timeout period, the function returns True. Otherwise, it raises an exception if the timeout is exceeded.",
    "example": "| Wait Isis L2 Broadcast Adj State | Sessions=${Sessions} | State=RUNNING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_tlv",
    "return_type": "IsisNeighborConfig",
    "return": "An instance of the IsisNeighborConfig class representing the created ISIS neighbor TLV configuration.",
    "parameters": [
      {
        "name": "Lsp",
        "type": "IsisLspConfig",
        "description": "ISIS LSP对象，表示与该邻居TLV关联的链路状态协议数据单元。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SystemId",
        "type": "str",
        "description": "邻居系统ID，必须是有效的MAC地址格式。",
        "default": "00:00:00:00:00:01",
        "range_or_options": "有效的MAC地址格式（例如：00:00:00:00:00:01）"
      },
      {
        "name": "PseudonodeSystemId",
        "type": "int",
        "description": "伪节点ID，用于标识伪节点。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NarrowMetric",
        "type": "int",
        "description": "默认度量值，用于IS-IS路由计算。",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "WideMetric",
        "type": "int",
        "description": "扩展度量值，支持更大的度量范围。",
        "default": "10",
        "range_or_options": "0-16777214"
      }
    ],
    "description": "创建一个ISIS邻居TLV（Type-Length-Value）配置对象，并将其与给定的LSP（Link State PDU）相关联。该函数是对底层API的封装，允许通过关键字参数对邻居TLV进行自定义配置。",
    "example": "示例代码使用RobotFramework语法：\n\n| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_te_config",
    "return_type": "IsisTEConfig",
    "return": "The IsisTEConfig object associated with the provided Neighbor. If any keyword arguments (configurations) are given, they will be applied to update the retrieved configuration before returning.",
    "parameters": [
      {
        "name": "Neighbor",
        "type": "IsisNeighborConfig",
        "description": "An ISIS neighbor TLV object which must contain a child IsisTEConfig object. This is used to associate or retrieve its TE configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableInterfaceIp",
        "type": "bool",
        "description": "Whether to include the local IPv4 address in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIp",
        "type": "str",
        "description": "The local IPv4 address to use if EnableInterfaceIp is True.",
        "default": "'0.0.0.0'",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableNeighborIp",
        "type": "bool",
        "description": "Whether to include the neighbor's IPv4 address in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIp",
        "type": "int",
        "description": "The neighbor's IPv4 address value if EnableNeighborIp is True.",
        "default": "10",
        "range_or_options": "valid IPv4 address represented as integer"
      },
      {
        "name": "EnableInterfaceIpv6",
        "type": "bool",
        "description": "Whether to include the local IPv6 address in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIpv6",
        "type": "str",
        "description": "The local IPv6 address to use if EnableInterfaceIpv6 is True.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableNeighborIpv6",
        "type": "bool",
        "description": "Whether to include the neighbor's IPv6 address in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIpv6",
        "type": "str",
        "description": "The neighbor's IPv6 address to use if EnableNeighborIpv6 is True.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableTeGroup",
        "type": "bool",
        "description": "Whether to include the TE group in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TeGroup",
        "type": "int",
        "description": "The TE group ID if EnableTeGroup is True.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMaxBandwidth",
        "type": "bool",
        "description": "Whether to include the maximum bandwidth value in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximunLink",
        "type": "int",
        "description": "Maximum link bandwidth (in bytes per second) if EnableMaxBandwidth is True.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableResBandwidth",
        "type": "bool",
        "description": "Whether to include the maximum reservable bandwidth in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximumReservableLink",
        "type": "int",
        "description": "Maximum reservable bandwidth (in bytes per second) if EnableResBandwidth is True.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableUnresBandwidth",
        "type": "bool",
        "description": "Whether to include the unreserved bandwidth values for different priorities in the TE configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 0 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 1 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 2 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 3 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 4 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 5 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 6 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Unreserved bandwidth value for priority 7 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function creates or retrieves the Traffic Engineering (TE) configuration for a given ISIS neighbor and optionally updates it with provided parameters. It wraps around the backend Renix method and applies optional configurations based on the keyword arguments passed.",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n| Create Isis Neighbor Te Config | Neighbor=${Neighbor} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_sr_adj_sid_sub_tlv",
    "return_type": ":obj:`IsisSrAdjSidSubTlv`",
    "return": "The created Isis Neighbor Sr Adj Sid Sub Tlv object, representing the Segment Routing Adjacency SID sub-TLV associated with the ISIS neighbor.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`IsisRouter`",
        "description": "ISIS protocol session object used to manage the connection and interactions with the test equipment. Must contain a method for creating SR Adjacency SID sub-TLVs.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Neighbor",
        "type": ":obj:`IsisNeighborConfig`",
        "description": "ISIS Neighbor TLV object to which this SR Adjacency SID sub-TLV will be associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "Select one or more flags to be included in the TLV. These flags influence the behavior or representation of the SR Adjacency SID.",
        "default": "['NOSHOW', 'VALUE', 'LOCAL']",
        "range_or_options": "NOSHOW ADDRESS BACKUP VALUE LOCAL SET PERSISTENT"
      },
      {
        "name": "Sid",
        "type": "int",
        "description": "Specifies the label value when Flags include L.Local and V.Value; otherwise, specifies the label offset within the SID/Label range when Value/Index is not included in Flags.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Specifies the weight for the Adj-SID, used for load balancing across multiple paths.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function creates an ISIS neighbor Segment Routing (SR) Adjacency SID sub-TLV using the provided session and neighbor context. It serves as a wrapper that delegates the creation process to the underlying session object while allowing additional configuration through keyword arguments. This simplifies the interaction with the test equipment's API by abstracting low-level implementation details and providing a clean interface for configuring SR-related properties for ISIS neighbors.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Neighbor Sr Adj Sid Sub Tlv | Neighbor=${Neighbor} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_sr_lan_adj_sid_sub_tlv",
    "return_type": "IsisSrAdjSidSubTlv",
    "return": "The created ISIS Neighbor Segment Routing LAN Adjacency SID Sub-TLV object.",
    "parameters": [
      {
        "name": "Session",
        "type": "IsisRouter",
        "description": "An ISIS protocol session object used to interact with the system or API.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Neighbor",
        "type": "IsisNeighborConfig",
        "description": "An ISIS neighbor configuration object representing the specific neighbor for which the SR LAN Adjacency SID Sub-TLV is being configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "One or more flags included in the TLV to control behavior of the Segment Routing Adjacency SID.",
        "default": "['NOSHOW', 'VALUE', 'LOCAL']",
        "range_or_options": "NOSHOW ADDRESS BACKUP VALUE LOCAL SET PERSISTENT"
      },
      {
        "name": "Sid",
        "type": "int",
        "description": "Specifies the label value when Flags include L.Local and V.Value. When Value/Index not included, specifies the label offset within the SID/Label range.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Specifies the weight of the Adj-SID, used for load balancing.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SystemId",
        "type": "str",
        "description": "Specifies the system ID of the neighbor on the LAN.",
        "default": "\"00:00:00:00:00:01\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates an ISIS Neighbor Segment Routing LAN Adjacency SID Sub-TLV object using the provided session and neighbor context. It wraps the backend method that performs the actual creation and passes along additional configuration parameters via keyword arguments.",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n| Create Isis Neighbor Sr Lan Adj Sid Sub Tlv | Neighbor=${Neighbor} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_srv6_endx_sid_sub_tlv",
    "return_type": ":obj:`IsisSrv6EndXSidSubTlv`",
    "return": "返回创建的Isis Neighbor Srv6 EndX Sid Sub Tlv对象。",
    "description": "该函数用于为指定的ISIS邻居创建一个SRv6 End.X SID子TLV（Type-Length-Value）对象。SRv6是基于IPv6的段路由协议，该函数通过Session会话对象调用底层API来完成配置，并封装了异常检查以确保执行稳定性。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`IsisRouter`",
        "description": "ISIS协议会话对象，用于与底层系统或API通信并管理上下文。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Neighbor",
        "type": ":obj:`IsisNeighborConfig`",
        "description": "ISIS邻居配置对象，表示要为其创建SRv6 End.X SID子TLV的邻居。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "选择一个或多个包含在TLV中的标志位。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN BACKUP SET PERSISTENT UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "指定SID关联的算法编号。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "指定End.X SID的权重，用于负载均衡。",
        "default": "100",
        "range_or_options": "0-255"
      },
      {
        "name": "EndpointFunc",
        "type": "str",
        "description": "定义端点行为类型。",
        "default": "END_NO",
        "range_or_options": "END_NO END_PSP END_USP END_PSP_USP END_X_NO END_X_PSP END_X_USP END_X_PSP_USP END_T_NO END_T_PSP END_T_USP END_T_PSPS_USP END_B6 END_B6_ENCAPS END_BM END_DX6 END_DX4 EDN_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DX2U END_DX2M END_S END_B6_RED END_B6_ENCAPS_RED END_WITH_USD END_PSP_USD END_USP_USD END_PSP_USP_USD END_X_USD END_X_PSP_USD END_X_USP_USD END_X_PSP_USP_USD END_T_USD END_T_PSP_USD END_T_USP_USD END_T_PSP_USP_USD"
      },
      {
        "name": "EnableCustom",
        "type": "bool",
        "description": "是否启用自定义端点行为。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomFunc",
        "type": "int",
        "description": "自定义端点行为的标识值。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SID",
        "type": "str",
        "description": "指定通告的SRv6 SID地址。",
        "default": "::1",
        "range_or_options": "有效IPv6地址"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Neighbor Srv6 EndX Sid Sub Tlv | Neighbor=${Neighbor} | SID=\"2001:db8::1\" | Flags=[BACKUP, SET] | Weight=200"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_srv6_lan_endx_sid_sub_tlv",
    "return_type": ":obj:`IsisSrv6LanEndXSidSubTlv`",
    "return": "The newly created SRv6 LAN End.X SID sub-TLV object associated with the specified ISIS neighbor.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`IsisRouter`",
        "description": "ISIS protocol session object used to create the SRv6 LAN End.X SID sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Neighbor",
        "type": ":obj:`IsisNeighborConfig`",
        "description": "ISIS Neighbor TLV object for which the SRv6 LAN End.X SID sub-TLV will be created and associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SystemIdLan",
        "type": "str",
        "description": "LAN system identifier (MAC-like format) used in the SRv6 LAN context.",
        "default": "\"00:10:96:00:00:01\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "One or more flags included in the SRv6 sub-TLV, indicating various behaviors or states.",
        "default": "[\"UNKNOWN\"]",
        "range_or_options": "UNKNOWN BACKUP SET PERSISTENT UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Specifies the algorithm associated with the SRv6 SID.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Weight assigned to the End.X SID, used for load balancing purposes.",
        "default": "100",
        "range_or_options": "0-255"
      },
      {
        "name": "EndpointFunc",
        "type": "list",
        "description": "Behavior of the endpoint when processing packets with this SID.",
        "default": "[\"END_NO\"]",
        "range_or_options": "END_NO END_PSP END_USP END_PSP_USP END_X_NO END_X_PSP END_X_USP END_X_PSP_USP END_T_N END_T_PSP END_T_USP END_T_PSPS_USP END_B6 END_B6_ENCAPS END_BM END_DX6 END_DX4 EDN_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DX2U END_DX2M END_S END_B6_RED END_B6_ENCAPS_RED END_WITH_USD END_PSP_USD END_USP_USD END_PSP_USP_USD END_X_USD END_X_PSP_USD END_X_USP_USD END_X_PSP_USP_USD END_T_USD END_T_PSP_USD END_T_USP_USD END_T_PSP_USP_USD"
      },
      {
        "name": "EnableCustom",
        "type": "bool",
        "description": "Enables custom endpoint behavior if set to True.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomFunc",
        "type": "int",
        "description": "Custom endpoint behavior value, used only if EnableCustom is True.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SID",
        "type": "str",
        "description": "IPv6 address representing the SRv6 SID to be advertised.",
        "default": "\"::1\"",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Creates an SRv6 LAN End.X SID sub-TLV for a specified ISIS neighbor within the given session. This function facilitates the setup of SRv6 capabilities for ISIS neighbors in a LAN environment, allowing test or control frameworks to inject SRv6-related TLVs into the ISIS protocol data for testing or validating SRv6 forwarding behaviors.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Neighbor Srv6 Lan EndX Sid Sub Tlv | Neighbor=${Neighbor} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_sr_link_msd_sub_tlv",
    "return_type": "object",
    "return": "The created ISIS neighbor SR link MSD sub-TLV object of type `IsisSrLinkMsdSubTlv`.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "ISIS protocol session object used to interact with the API. Must be an instance of `IsisRouter`.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Neighbor",
        "type": "object",
        "description": "ISIS neighbor configuration object for which the SR link MSD sub-TLV will be configured. Must be an instance of `IsisNeighborConfig`.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "One or more flags included in the TLV to indicate which MSD parameters are present.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN MAX_SEG_LELT MAX_END_POP MAX_T_INSERT MAX_T_ENCAPS MAX_END_D"
      },
      {
        "name": "MaxSegmentLeft",
        "type": "int",
        "description": "Maximum value of the Segment Left (SL) field in the SRH before applying the SRv6 Endpoint Function instruction associated with the SID.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "Specifies the maximum number of SIDs at the top of the SRH stack that can be processed by End.POP behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxInsert",
        "type": "int",
        "description": "Specifies the maximum number of SIDs that can be inserted when performing T.Insert behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEncap",
        "type": "int",
        "description": "Specifies the maximum number of SIDs that can be encapsulated when performing T.Encap behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "Specifies the maximum number of SIDs in the SRH when executing End.DX6 and End.DT6 functions.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "Creates an ISIS neighbor Segment Routing (SR) link MSD (Maximum Stack Depth) sub-TLV for the specified session and neighbor. This function is typically used in network testing or automation scenarios involving ISIS and Segment Routing configurations, where it allows defining constraints on the SRH (Segment Routing Header) processing capabilities of a node.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Neighbor Sr Link Msd Sid Sub Tlv | Neighbor=${Neighbor} | MaxSegmentLeft=10 | Flags=[MAX_SEG_LELT, MAX_END_POP]"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_neighbor_custom_sub_tlv",
    "return_type": "IsisCustomMsdSubTlv",
    "return": "An instance of IsisCustomMsdSubTlv representing the created custom MSD sub-TLV configured with optional properties provided in kwargs.",
    "parameters": [
      {
        "name": "SubTlv",
        "type": "object",
        "description": "The parent ISIS Neighbor Sr Link MSD SID Sub TLV object to which the new custom MSD sub-TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SubType",
        "type": "int",
        "description": "Specifies the Type field value for the custom sub-TLV. This identifies the type of the sub-TLV being created.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SubValue",
        "type": "int",
        "description": "Specifies the Value field of the sub-TLV as a hexadecimal value. This defines the data content of the sub-TLV.",
        "default": "8",
        "range_or_options": "Hexadecimal values (e.g., 0x00 - 0xFF)"
      }
    ],
    "description": "This function creates and configures a custom ISIS MSD (Maximum Stack Depth) sub-TLV object for an ISIS neighbor configuration. It attaches the newly created custom MSD sub-TLV to the provided parent SubTLV structure, allowing optional configuration through keyword arguments. This is typically used in advanced ISIS protocol testing scenarios where custom TLVs are needed to extend or modify routing behavior.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Neighbor} | Create Isis Neighbor Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | ${Msd} | Create Isis Neighbor Sr Link Msd Sid Sub Tlv | Neighbor=${Neighbor} |\n    | Isis Neighbor Custom Sub Tlv | SubTlv=${Msd} | SubType=10 | SubValue=0A |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_prefix_sid_sub_tlv",
    "return_type": ":obj:`IsisSrPrefixSidSubTlv`",
    "return": "新创建的ISIS Prefix SID Sub TLV对象，可用于进一步配置或引用在后续操作中。",
    "description": "该函数用于在现有的ISIS TLV对象内创建一个Prefix SID子TLV。通常用于自动化测试场景中设置IS-IS协议的源路由（Segment Routing）功能。它允许通过关键字参数对Prefix SID子TLV进行详细配置。",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "提供上下文的会话对象，必须已经初始化并关联到有效的测试端口或上下文。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Tlv",
        "type": ":obj:`IsisIpv4TlvConfig`",
        "description": "要在其内部创建Prefix SID子TLV的父TLV对象，必须是一个已存在的支持子TLV的TLV实例。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "选择一个或多个包含在TLV中的标志位。",
        "default": "['NOSHOW', 'NOPHP']",
        "range_or_options": "NOSHOW ADVERTISEMENT NODESID NOPHP EXPLICIT VALUE LOCAL"
      },
      {
        "name": "Sid",
        "type": "int",
        "description": "SID/Label值，用于标识特定的段路由节点或前缀。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "指定计算到其他节点/前缀的可达信息的算法，以及SID所关联的算法。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "PrefixSidStep",
        "type": "int",
        "description": "定义Prefix SID的步长值，用于自动分配时递增SID。",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv4} | Create Isis Ipv4 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Prefix Sid Sub Tlv | Tlv=${Ipv4} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_flex_algorithm_prefix_metric_sub_tlv",
    "return_type": "IsisFlexAlgoPrefixMetricSubTlv",
    "return": "A configured instance of IsisFlexAlgoPrefixMetricSubTlv associated with the given parent TLV. If any kwargs are provided, the returned instance will have been customized accordingly.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "IsisIpv4TlvConfig",
        "description": "The parent TLV object that will contain the newly created Flex Algorithm Prefix Metric Sub-TLV. This serves as the upper-level container in the TLV hierarchy.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Locator关联算法 (Locator association algorithm).",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "度量值 (Metric value) used for route preference or path cost.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "创建ISIS Tlv Flex Algorithm Prefix Metric Sid Sub Tlv对象。该函数用于在给定的父TLV对象下创建并配置一个ISIS Flex Algorithm Prefix Metric Sub-TLV实例，可用于扩展IS-IS协议中前缀SID的灵活路径计算功能。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv4} | Create Isis Ipv4 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Flex Algorithm Prefix Metric Sub Tlv | Tlv=${Ipv4} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_bier_sub_tlv",
    "return_type": "IsisBierSubTlv",
    "return": "An instance of the IsisBierSubTlv class representing the newly created and optionally configured BIER sub-TLV, attached to the provided parent TLV.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "IsisIpv4TlvConfig",
        "description": "The parent ISIS TLV object to which the BIER sub-TLV will be attached. Must be a valid ISIS TLV that supports BIER extensions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "BFRId",
        "type": "int",
        "description": "Specifies the Bit Forwarding Router (BFR) ID used in BIER forwarding. This uniquely identifies a router within a BIER domain.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "SubDomainId",
        "type": "int",
        "description": "Specifies the BIER sub-domain ID. Sub-domains allow partitioning of the BIER domain into logical segments.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "IgpAlgorithm",
        "type": "int",
        "description": "Specifies the IGP algorithm used for path computation within the domain.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "BierAlgorithm",
        "type": "int",
        "description": "Specifies the BIER-specific algorithm used for replication and forwarding.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Creates and configures an ISIS BIER (Bit Index Explicit Replication) sub-TLV object associated with the given parent TLV. This function is typically used when building or modifying ISIS TLVs for advanced multicast scenarios where BIER-based forwarding is required. The function allows optional configuration through keyword arguments which are applied directly to the newly created IsisBierSubTlv object.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv4} | Create Isis Ipv4 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Bier Sub Tlv | Tlv=${Ipv4} | BFRId=100 | SubDomainId=5 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_bier_Mpls_sub_sub_tlv",
    "return_type": "IsisBierMplsSubTlv",
    "return": "An instance of IsisBierMplsSubTlv representing the configured BIER MPLS sub-sub TLV object.",
    "description": "This method creates and configures an ISIS BIER MPLS sub-sub TLV object through the RenixAPI interface. It is typically used to define or modify BIER/MPLS configurations within the ISIS routing protocol. The method wraps the corresponding class method from the IsisRouter module, allowing for optional keyword arguments to further customize the created TLV object.",
    "parameters": [
      {
        "name": "Bier",
        "type": "IsisBierSubTlv",
        "description": "The parent ISIS Bierv6 Sub TLV object under which this BIER MPLS sub-sub TLV will be created. This serves as a context for the BIER configuration in the ISIS stack.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MaxSI",
        "type": "int",
        "description": "Specifies the maximum Set Identifier (Set ID) allowed in the BIER configuration. Used to identify subsets of bit positions in the BIER header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "LabelorBiftId",
        "type": "int",
        "description": "Specifies either the starting label value in a label range or the Bit Index Forwarding Table (BIFT) identifier, depending on the BIER implementation.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BSLength",
        "type": "int",
        "description": "Specifies the length of the local bitstring in bits, indicating how many bits are used for forwarding decisions in the BIER domain.",
        "default": "1",
        "range_or_options": "0-15"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv6} | Create Isis Ipv6 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Bier Sub Tlv | Tlv=${Ipv6} |\n    | Create Isis Tlv Bier Mpls Sub Sub Tlv | Bier=${Ipv6} | MaxSI=3 | LabelorBiftId=200 | BSLength=8 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_bierv6_sub_sub_tlv",
    "return_type": "IsisBierMplsSubTlv",
    "return": "An instance of IsisBierMplsSubTlv configured with the provided parameters, representing a BIERv6 MPLS sub-sub TLV as part of the ISIS routing protocol's extension for multicast forwarding using BIER.",
    "parameters": [
      {
        "name": "Bier",
        "type": "object",
        "description": "The upper layer or parent object to which this BIERv6 MPLS sub-sub TLV belongs. This typically represents the BIERv6 configuration context in the ISIS protocol stack.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MaxSI",
        "type": "int",
        "description": "Specifies the maximum Set Identifier (SI) used in the BIERv6 sub-sub TLV. SI helps identify different sets of BIER information in a network.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "LabelorBiftId",
        "type": "int",
        "description": "Specifies the starting label value within the label range or the BIFT (Bit Index Forwarding Table) ID associated with this sub-sub TLV.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BSLength",
        "type": "int",
        "description": "Specifies the length of the local bitstring used in BIERv6 operations. This determines how many bits are used in the bitstring for multicast forwarding decisions.",
        "default": "1",
        "range_or_options": "0-15"
      }
    ],
    "description": "This function creates and configures an ISIS BIERv6 MPLS sub-sub TLV object. It provides a wrapper for creating the TLV by calling the underlying API method. The BIERv6 sub-sub TLV is used within the ISIS routing protocol to support efficient multicast packet forwarding using BIERv6 technology.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv6} | Create Isis Ipv6 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Bier Sub Tlv | Tlv=${Ipv6} |\n    | Create Isis Tlv Bierv6 Sub Sub Tlv | Bier=${Ipv6} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_end_bier_sub_tlv",
    "return_type": "IsisEndBierSubTlv",
    "return": "An instance of the IsisEndBierSubTlv class representing the newly created and configured ISIS END BIER sub-TLV object.",
    "parameters": [
      {
        "name": "Bier",
        "type": "IsisIpv6TlvConfig",
        "description": "The parent ISIS TLV object (typically an IPv6 configuration) to which this END BIER sub-TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the Type field value for the END BIER sub-TLV.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "EndBierAddr",
        "type": "str",
        "description": "Specifies the End.BIER SID (Segment Identifier) used in Segment Routing for multicast forwarding.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Creates and configures an ISIS END BIER sub-TLV object, which is used in Segment Routing for efficient multicast packet replication and forwarding. The sub-TLV is associated with a provided parent ISIS TLV object (e.g., IPv6 TLV). Optional keyword arguments can be used to configure specific properties like Type and End.BIER SID. This method wraps the backend Renix API call and handles failure cases by raising an exception on failure.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv6} | Create Isis Ipv6 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv End Bier Sub Tlv | Tlv=${Ipv6} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_tlv_bierv6_bift_id_sub_tlv",
    "return_type": "IsisBierBiftIdSubTlv",
    "return": "A configured instance of the `IsisBierBiftIdSubTlv` class representing the BIERv6 BIFT-ID sub-TLV.",
    "parameters": [
      {
        "name": "Bier",
        "type": "IsisIpv6TlvConfig",
        "description": "An upper-layer object that this TLV is associated with. Typically represents a BIER-related configuration or container TLV under which the new sub-TLV will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the Type field value for the TLV.",
        "default": "7",
        "range_or_options": "0-255"
      },
      {
        "name": "MPRA",
        "type": "str",
        "description": "Specifies the MPRA (Multi-Path Replication Anchor) IPv6 address.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Creates and configures an ISIS TLV (Type-Length-Value) object representing a BIERv6 BIFT-ID sub-TLV. This function acts as a wrapper around the internal method `renix.create_isis_tlv_bierv6_bift_id_sub_tlv`, delegating the creation and configuration to the underlying framework. The resulting TLV can be used in further protocol configurations or attached to other TLVs as needed.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Ipv6} | Create Isis Ipv6 Tlv | Lsp=${LSP} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Tlv Bierv6 Bift Id Sub Tlv | Tlv=${Ipv6} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_tlv",
    "return_type": "object",
    "return": "The created ISIS capability TLV object, typically of type `IsisCapabilityTlv`. Returns status indicator if creation fails.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "ISIS protocol session object used to manage interactions and create the capability TLV. Must be an instance of `IsisRouter`.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsp",
        "type": "object",
        "description": "Link State Packet (LSP) configuration object to which the capability TLV will be attached. Must be an instance of `IsisLspConfig`.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Option",
        "type": "list",
        "description": "List of option flags for the capability TLV. These flags control behavior or metadata related to the TLV.",
        "default": "['NOSHOW', 'SBIT']",
        "range_or_options": "NOSHOW SBIT DBIT"
      },
      {
        "name": "RouterId",
        "type": "str",
        "description": "IPv4 address representing the router ID to be included in the capability TLV.",
        "default": "'192.0.0.1'",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "description": "创建ISIS Capability TLV对象并将其附加到指定的LSP（链路状态数据包）。该函数封装了TLV创建逻辑，通过会话对象进行实际的TLV生成，并支持通过关键字参数进行灵活配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Capability Tlv | Session=${Session} | Lsp=${LSP} | RouterId=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_sr_capability_sub_tlv",
    "return_type": "IsisSrCapabilitySubTlv",
    "return": "返回一个ISIS SR Capability Sub TLV对象，用于在ISIS协议中通告Segment Routing能力。",
    "parameters": [
      {
        "name": "Session",
        "type": "IsisRouter",
        "description": "ISIS协议会话对象列表，提供与测试设备或系统的上下文和连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Capability",
        "type": "IsisCapabilityTlv",
        "description": "要编码到子TLV中的SR能力信息，通常包括支持的SRGB范围、标志位或其他SR特定参数。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "选择一个或多个包含在TLV中的标志位，用于指示SR功能的支持情况。",
        "default": "['NOSHOW', 'IPv4_CAPABLE']",
        "range_or_options": "NOSHOW IPv4_CAPABLE IPv6_CAPABLE"
      },
      {
        "name": "ValueType",
        "type": "str",
        "description": "选择标识符类型（SID或标签），用于定义使用的是20位还是32位SID/标签。",
        "default": "BIT32",
        "range_or_options": "BIT20 BIT32"
      }
    ],
    "description": "该函数用于创建一个ISIS SR (Segment Routing) Capability子TLV对象。此TLV用于在网络中通过ISIS协议通告Segment Routing能力。函数封装了底层会话方法，允许用户自定义TLV的标志位和标识符类型。",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n| Create Isis Capability Sr Capability Sub Tlv | Session={Session} | Capability=${Capability} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_sr_algorithm_sub_tlv",
    "return_type": "IsisSrAlgorithmSubTlv",
    "return": "An instance of IsisSrAlgorithmSubTlv configured with the provided parameters and linked to the given Capability object.",
    "parameters": [
      {
        "name": "Capability",
        "type": "IsisCapabilityTlv",
        "description": "An ISIS TLV object representing the capability that this SR Algorithm Sub-TLV will be associated with. This is typically another TLV or capability object in the ISIS protocol hierarchy.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Algorithm",
        "type": "list",
        "description": "A list of integer values representing the routing algorithms supported for Segment Routing (SR). These values are advertised via the SR Algorithm Sub-TLV.",
        "default": "0",
        "range_or_options": "int"
      }
    ],
    "description": "This function creates and configures an ISIS Segment Routing (SR) Algorithm Sub-TLV object, which is used to advertise support for specific routing algorithms within the ISIS protocol capabilities. The Sub-TLV is associated with a given capability object and can be further customized using optional keyword arguments. It wraps the underlying `renix.create_isis_capability_sr_algorithm_sub_tlv` method and raises an exception if the operation fails.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n    | Create Isis Capability Sr Algorithm Sub Tlv | Capability=${Capability} | Algorithm=[0,1] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_srv6_capability_sub_tlv",
    "return_type": "object",
    "return": "The created ISIS SRv6 capability sub-TLV object of type `IsisSrv6CapabilitySubTlv`.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "An ISIS protocol session object (typically of type `IsisRouter`) used to manage the creation context for the SRv6 capability sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Capability",
        "type": "object",
        "description": "An ISIS Capability TLV object (of type `IsisCapabilityTlv`) that serves as the base capability information for the SRv6 sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "A list of one or more flag values to be included in the SRv6 capability sub-TLV. These flags define optional capabilities or behaviors.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN UNUSED0 O_BIT UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7 UNUSED8 UNUSED9 UNUSED10 UNUSED11 UNUSED12 UNUSED13 UNUSED14 UNUSED15"
      }
    ],
    "description": "This function creates an ISIS SRv6 (Segment Routing over IPv6) capability sub-TLV object using the provided session and capability objects, along with optional keyword arguments such as Flags. It wraps a backend call to the session's internal method for creating the sub-TLV. If the operation fails, it raises a `ContinuableFailure`, otherwise it returns the newly created sub-TLV object.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n    | Create Isis Capability Srv6 Capability Sub Tlv | Session=${Session} | Capability=${Capability} | Flags=[O_BIT] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_sr_node_msd_sub_tlv",
    "return_type": ":obj:`IsisSrMsdSubTlv`",
    "return": "ISIS Capability Sr Node Msd Sub TLV对象，表示创建的SR Node MSD子TLV配置。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`IsisRouter`",
        "description": "ISIS协议会话对象列表，用于与底层系统交互并调用相关方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Capability",
        "type": ":obj:`IsisCapabilityTlv`",
        "description": "定义要配置的SR节点MSD（Maximum Stack Depth）能力的Capability TLV对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "选择一个或多个包含在TLV中的标志位。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN MAX_SEG_LELT MAX_END_POP MAX_T_INSERT MAX_T_ENCAPS MAX_END_D"
      },
      {
        "name": "MaxSegmentLeft",
        "type": "int",
        "description": "指定接收报文的SRH中SL（Segment Left）字段的最大值，在应用SID关联的SRv6 Endpoint Function指令之前使用。",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "指定SRH栈顶端SRH中SID的最大数量。",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxInsert",
        "type": "int",
        "description": "指定执行T.Insert行为时可包含SID的最大数量。",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEncap",
        "type": "int",
        "description": "指定执行T.Encap行为时可包含SID的最大数量。",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "指定执行End.DX6和End.DT6功能时，SRH中SID的最大数量。",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "该函数用于扩展ISIS能力，创建与Segment Routing Node MSD相关的子TLV（Type-Length-Value）元素。它作为对底层会话级方法的封装，允许通过关键字参数传递额外配置选项以增强灵活性。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n    | Create Isis Capability Sr Node Msd Sub Tlv | Capability=${Capability} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_sr_fad_sub_tlv",
    "return_type": "object",
    "return": "返回一个ISIS Capability Sr Fad Sub TLV对象，类型为 `IsisFelxAlgoDefinitionSubTlv`。",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "ISIS协议会话对象，通常通过Create Isis关键字创建。用于与底层系统交互。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Capability",
        "type": "object",
        "description": "已有的ISIS Capability TLV对象，通常通过Create Isis Capability Tlv关键字创建。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "FlexAlgo",
        "type": "int",
        "description": "灵活算法ID，用于标识特定的SR Flex Algorithm。",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "指定路径计算使用的度量类型。",
        "default": "IGP_METRIC",
        "range_or_options": "IGP_METRIC MIN_LINK_DELAY TE_METRIC"
      },
      {
        "name": "CalType",
        "type": "int",
        "description": "指定特定IGP算法的计算类型。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "指定该Sub TLV的优先级，数值越小优先级越高。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "FlexAlgoSubTlv",
        "type": "list",
        "description": "选择灵活算法路径计算要遵循的约束条件。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN EXCLUDE_ADMIN INCLUDE__ANY_ADMIN INCLUDE_ALL_ADMIN DEFINITION_FLAGS EXCLUDE_SRLG"
      },
      {
        "name": "ExcludeAdmin",
        "type": "int",
        "description": "设置排除的管理组值（Admin Group）。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAnyAdmin",
        "type": "int",
        "description": "设置包含任意管理组值的条件。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAllAdmin",
        "type": "int",
        "description": "设置必须包含所有指定管理组值的条件。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DefinitionFlags",
        "type": "list",
        "description": "定义该Flex算法的标志位，以十六进制表示。",
        "default": "0x80",
        "range_or_options": "0-FF"
      },
      {
        "name": "ExcludeSRLG",
        "type": "list",
        "description": "设置需要排除的SRLG（Shared Risk Link Group）值列表。",
        "default": "0x10020000",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "该函数用于创建一个ISIS协议中Segment Routing Flexible Algorithm Definition (FAD)类型的Sub TLV对象。它封装了底层Session对象的方法调用，允许用户通过参数和关键字参数配置FAD Sub TLV的属性。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n    | Create Isis Capability Sr Fad Sub Tlv | Session=${Session} | Capability=${Capability} | FlexAlgo=130 | MetricType=TE_METRIC | Priority=1 | FlexAlgoSubTlv=['INCLUDE_ANY_ADMIN', 'EXCLUDE_SRLG'] | ExcludeAdmin=10 | IncludeAnyAdmin=20 | DefinitionFlags=[0x80, 0xC0] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_capability_srms_preference_sub_tlv",
    "return_type": "IsisSrSRMSPrefSubTlv",
    "return": "返回一个ISIS Capability Srms Preference Sub TLV对象，可用于进一步操作或查询其属性。",
    "parameters": [
      {
        "name": "Capability",
        "type": "IsisCapabilityTlv",
        "description": "要关联此SRMS Preference Sub TLV的上层ISIS Capability对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Preference",
        "type": "int",
        "description": "指定本节点作为SR Mapping Server的优先级。",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "创建并配置一个ISIS Capability Srms Preference Sub TLV对象，并将其与给定的Capability对象关联。该函数是对底层API方法的封装，支持通过关键字参数对生成的对象进行初始配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | ${Capability} | Create Isis Capability Tlv | Lsp=${LSP} | SystemId=1.1.1.1 |\n    | Create Isis Capability Srms Preference Sub Tlv | Capability=${Capability} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_sr_binding_tlv",
    "return_type": "IsisSrBindingTlv",
    "return": "Returns an ISIS Segment Routing (SR) Binding TLV object configured with the provided parameters.",
    "parameters": [
      {
        "name": "Session",
        "type": "IsisRouter",
        "description": "ISIS protocol session object used to manage and configure the test environment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsp",
        "type": "IsisLspConfig",
        "description": "ISIS LSP (Label Switched Path) configuration object for which the SR Binding TLV will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableMt",
        "type": "bool",
        "description": "Enables multi-topology support for the SR Binding TLV.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MtId",
        "type": "str",
        "description": "Specifies the multi-topology ID when multi-topology is enabled.",
        "default": "STANDARD",
        "range_or_options": "STANDARD IPV6_ROUTING"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "List of flags associated with the SR Binding TLV.",
        "default": "['NOSHOW']",
        "range_or_options": "NOSHOW FBIT MBIT SBIT DBIT ABIT"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Specifies the weight assigned to the binding entry.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Range",
        "type": "int",
        "description": "Specifies the range of the binding entry.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4Version",
        "type": "bool",
        "description": "Specifies whether IPv4 version is enabled for the binding entry.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv4Prefix",
        "type": "str",
        "description": "IPv4 prefix associated with the binding entry.",
        "default": "192.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "Length of the IPv4 prefix in CIDR notation.",
        "default": "1",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv6Prefix",
        "type": "str",
        "description": "IPv6 prefix associated with the binding entry.",
        "default": "2000::1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix in CIDR notation.",
        "default": "64",
        "range_or_options": "1-128"
      }
    ],
    "description": "This function creates an ISIS Segment Routing (SR) Binding TLV for a specified LSP within the given session. It allows configuring various SR-related properties such as multi-topology settings, binding flags, weight, range, and IP prefixes for both IPv4 and IPv6. This TLV is typically used to define SR policies within an ISIS network during network testing scenarios.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Binding Tlv | Session=${Session} | Lsp=${LSP} | Ipv4Version=False |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_binding_sr_sid_sub_tlv",
    "return_type": "IsisSrSRMSPrefSubTlv",
    "return": "ISIS Capability Srms Preference Sub TLV对象，表示配置好的SR SID子TLV。",
    "parameters": [
      {
        "name": "Binding",
        "type": "IsisSrBindingTlv",
        "description": "要绑定SR SID子TLV的父级TLV对象，通常是一个已经创建的Binding TLV实例。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ValueType",
        "type": "str",
        "description": "指定SID的值类型，可以是20位（BIT20）或32位（BIT32），用于标识使用的是标签还是SID。",
        "default": "BIT32",
        "range_or_options": "BIT20 BIT32"
      },
      {
        "name": "Sid",
        "type": "int",
        "description": "当ValueType为BIT20时，表示起始标签；当为BIT32时，表示起始SID。",
        "default": "12000",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于在ISIS协议中创建并配置一个Segment Routing (SR) SID子TLV，并将其绑定到给定的Binding TLV对象上。这个子TLV通常用于定义SRMS（Segment Routing Mapping Server）偏好信息，支持网络中的段路由功能。",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| ${Binding} | Create Isis Binding Tlv | Lsp=${LSP} | Ipv4Version=False |\n| Create Isis Binding Sr sid Sub Tlv | Binding=${Binding} | ValueType=BIT20 | Sid=5000"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_srv6_location_tlv",
    "return_type": ":obj:`IsisSrv6LocatorTlv`",
    "return": "ISIS SRv6 Locator TLV对象，表示创建成功的TLV结构。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`IsisRouter`",
        "description": "表示ISIS协议会话的对象，用于上下文管理和调用底层方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsp",
        "type": ":obj:`IsisLspConfig`",
        "description": "表示ISIS LSP（链路状态PDU）配置的对象，TLV将与该LSP相关联。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MtId",
        "type": "str",
        "description": "多拓扑标识符，用于指定多拓扑环境中的拓扑ID。",
        "default": "STANDARD",
        "range_or_options": "not_found"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "度量值，用于路径选择的开销值。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "标签列表，用于控制SRv6 Locator的行为。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN D_BIT A_BIT UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "关联定位器所使用的算法编号。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumLocator",
        "type": "int",
        "description": "要生成的Locator数量。",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LocatorSize",
        "type": "int",
        "description": "每个Locator的大小（以位为单位）。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Locator",
        "type": "str",
        "description": "IPv6地址形式的Locator前缀。",
        "default": "aaaa:1:1:1::",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "LocatorStep",
        "type": "int",
        "description": "Locator递增步长，用于批量生成多个Locator。",
        "default": "1",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于在ISIS协议中创建SRv6 Locator TLV对象。该TLV用于在Segment Routing over IPv6 (SRv6)环境中携带Locator信息。函数通过调用底层Session对象的方法来实际执行创建操作，并支持多种可选参数进行详细配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Isis | Port=${Port} |\n    | ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n    | Create Isis Srv6 Location Tlv | Session={Session} | Lsp=${LSP} | Algorithm=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.create_isis_srv6_end_sid_sub_tlv",
    "return_type": ":obj:`IsisSrv6EndSidSubTlv`",
    "return": "ISIS Capability Srms Preference Sub TLV对象，表示创建的SRv6 End SID子TLV实例。",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "会话对象，用于管理与测试平台或API的连接和交互。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Location",
        "type": ":obj:`IsisSrv6LocatorTlv`",
        "description": "指定在哪个ISIS Locator TLV下创建该SID Sub-TLV。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "list",
        "description": "包含在TLV中的标志位列表。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN UNUSED0 UNUSED1 UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "EndpointFunc",
        "type": "str",
        "description": "端点行为定义，决定SID的功能类型。",
        "default": "END_NO",
        "range_or_options": "END_NO END_PSP END_USP END_PSP_USP END_X_NO END_X_PSP END_X_USP END_X_PSP_USP END_T_NO END_T_PSP END_T_USP END_T_PSPS_USP END_B6 END_B6_ENCAPS END_BM END_DX6 END_DX4 EDN_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DX2U END_DX2M END_S END_B6_RED END_B6_ENCAPS_RED END_WITH_USD END_PSP_USD END_USP_USD END_PSP_USP_USD END_X_USD END_X_PSP_USD END_X_USP_USD END_X_PSP_USP_USD END_T_USD END_T_PSP_USD END_T_USP_USD END_T_PSP_USP_USD"
      },
      {
        "name": "EnableCustom",
        "type": "bool",
        "description": "是否启用自定义端点行为。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomFunc",
        "type": "int",
        "description": "当启用自定义端点行为时使用的功能代码。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SID",
        "type": "str",
        "description": "要通告的SRv6 SID地址。",
        "default": "::1",
        "range_or_options": "IPv6地址"
      }
    ],
    "description": "该函数用于在网络测试框架中创建一个ISIS协议下的SRv6 End SID子TLV对象。它封装了会话管理逻辑，并将参数转发给底层会话对象的实际创建方法。",
    "example": "| ${Session} | Create Isis | Port=${Port} |\n| ${LSP} | Create Isis Lsp | Session=${Session} | SystemId=00:00:00:00:00:02 |\n| ${Location} | Create Isis Srv6 Location Tlv | Lsp=${LSP} | Algorithm=1 |\n| Create Isis Srv6 End Sid Sub Tlv | Session={Session} | Location=${Location} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.advertise_isis",
    "return_type": "bool",
    "return": "True if the advertisement of IS-IS LSPs is successful; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Lsps",
        "type": "list of IsisLspConfig",
        "description": "List of ISIS LSP objects to be advertised. Each object must have a valid 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Advertises the specified IS-IS Link State Packets (LSPs) using the underlying Renix API. This function wraps around the `IsisRouter.advertise` method and is typically used in IS-IS routing simulation or testing scenarios. If the operation fails, a ContinuableFailure exception is raised.",
    "example": "| Advertise Isis | Lsp=${Lsp} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.withdraw_isis",
    "return_type": "bool",
    "return": "Returns True if the withdrawal of ISIS LSPs is successful; otherwise, returns False and raises a ContinuableFailure.",
    "parameters": [
      {
        "name": "Lsps",
        "type": "Union[object, list, set, tuple]",
        "description": "A single LSP object or an iterable (list, set, or tuple) of LSP objects to be withdrawn. Each LSP object must have a 'handle' attribute that uniquely identifies it for the withdrawal command.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "kwargs",
        "type": "dict",
        "description": "Optional keyword arguments that can be passed to customize or extend the behavior of the withdrawal command in the underlying implementation.",
        "default": "{}",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function withdraws one or more specified ISIS Link State Packets (LSPs) using the ISIS routing protocol. It acts as a wrapper around the `IsisRouter.withdraw` method by calling `RenixAPI.withdraw_isis`. The function supports both single and multiple LSP withdrawals and allows additional configuration via optional keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | Withdraw Isis | Lsp=${Lsp} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.graceful_restart_isis",
    "return_type": "bool",
    "return": "布尔值，表示平滑重启IS-IS协议会话是否成功启动。始终返回True表示操作已成功发起。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, List[object], Set[object], Tuple[object]]",
        "description": "一个IS-IS会话对象或包含多个会话对象的可迭代结构（如列表、集合或元组），用于执行平滑重启操作。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于对提供的IS-IS会话执行平滑重启操作。若提供了单个会话对象，则会被自动转换为包含该对象的列表。函数随后遍历所有会话并调用其`graceful_restart()`方法。如果任何会话对象不支持`graceful_restart()`方法，将抛出TypeError异常。",
    "example": ".. code:: RobotFramework\n\n    | Graceful Restart Isis | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.get_isis_session_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回一个字典、pandas DataFrame 或者布尔值。若找到唯一匹配的会话，则返回统计项对应的字典；若找到多个会话，则返回包含统计信息的DataFrame；若无匹配会话则返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Isis协议会话对象或其集合，用于指定需要查询的会话。若为None，则查询所有会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的统计项列表。支持的统计项包括: TxP2pHello, RxP2pHello, TxLanL1Hello, RxLanL1Hello, TxLanL2Hello, RxLanL2Hello, TxL1Lsp, RxL1Lsp, TxL2Lsp, RxL2Lsp, TxL1Csnp, RxL1Csnp, TxL2Csnp, RxL2Csnp, TxL1Psnp, RxL1Psnp, TxL2Psnp, RxL2Psnp。",
        "default": "not_found",
        "range_or_options": "TxP2pHello RxP2pHello TxLanL1Hello RxLanL1Hello TxLanL2Hello RxLanL2Hello TxL1Lsp RxL1Lsp TxL2Lsp RxL2Lsp TxL1Csnp RxL1Csnp TxL2Csnp RxL2Csnp TxL1Psnp RxL1Psnp TxL2Psnp RxL2Psnp"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取ISIS会话的统计信息。它支持按提供的会话对象过滤，并可选择性地获取特定统计项。该函数封装了底层方法_get_statictis，并处理了输入参数的不同类型（如列表、元组等）。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxL1Lsp | RxL1Lsp |\n    | Subscribe Result | Types=IsisSessionStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Isis Session Stats | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.get_isis_tlv_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical items and their values if one row matches, a pandas DataFrame for multiple rows, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "Specifies the ISIS session(s) to filter statistics by. If None, no session filter is applied. If an object, must be an `IsisRouter` with a `Name` attribute. If a collection, all elements must be valid session objects.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items to retrieve. Valid options include: TxPrefixSid, RxPrefixSid, TxAdjSid, RxAdjSid, TxLanAdjSid, RxLanAdjSid, TxSidBinding, RxSidBinding, TxSrv6Loc, RxSrv6Loc, TxSrv6EndX, RxSrv6EndX, TxSrv6LanEndX, RxSrv6LanEndX. If None, all available items are retrieved.",
        "default": "None",
        "range_or_options": "TxPrefixSid RxPrefixSid TxAdjSid RxAdjSid TxLanAdjSid RxLanAdjSid TxSidBinding RxSidBinding TxSrv6Loc RxSrv6Loc TxSrv6EndX RxSrv6EndX TxSrv6LanEndX RxSrv6LanEndX"
      }
    ],
    "description": "Retrieves ISIS TLV (Type-Length-Value) statistics for specified session(s). This function gathers statistics by calling an internal method `_get_statictis` with 'IsisTlvStats' as the statistic type. It allows filtering based on session identifiers and selecting specific statistical items to retrieve.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=IsisTlvStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Isis Tlv Stats | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.isis.edit_isis_port_config",
    "return_type": "bool or list of modified configurations",
    "return": "Returns True if the configuration was successfully updated; otherwise, returns False. If multiple ports are processed, it may return a list of modified configuration objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list of Port",
        "description": "The test instrument port object(s) for which the ISIS port configuration should be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "UpdateRoutesTransmitRate",
        "type": "int",
        "description": "Sets the IS-IS Tx Hello Rate in messages per second.",
        "default": "1000",
        "range_or_options": "1-10000"
      }
    ],
    "description": "Edits the ISIS port configuration for one or more specified ports by modifying the IsisPortRateConfig child object with the provided parameters. This function ensures that configuration changes are applied to each port and collects the modified configuration objects into a result list.",
    "example": "| Edit Isis Port Config | Ports=${Ports} | UpdateRoutesTransmitRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.create_l2tp",
    "return_type": "L2tp",
    "return": "The newly created and configured L2TP protocol instance.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper layer object (typically a port object) that this L2TP instance will be associated with. Must have a valid `handle` attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "L2TP session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable the L2TP protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "L2TP role: LAC (L2TP Access Concentrator) or LNS (L2TP Network Server).",
        "default": "LAC",
        "range_or_options": "LAC LNS"
      },
      {
        "name": "TunnelCountPerNode",
        "type": "int",
        "description": "Number of tunnels per LAC/LNS.",
        "default": "1",
        "range_or_options": "1-32768"
      },
      {
        "name": "SessionCountPerTunnel",
        "type": "int",
        "description": "Number of sessions per tunnel.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TunnelStartingId",
        "type": "int",
        "description": "Starting ID for tunnels.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "SessionStartingId",
        "type": "int",
        "description": "Starting ID for sessions.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "UdpSourcePort",
        "type": "int",
        "description": "UDP source port used for L2TP communication.",
        "default": "1701",
        "range_or_options": "1-65535"
      },
      {
        "name": "UdpChecksumEnabled",
        "type": "bool",
        "description": "Enable UDP checksum.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RetryTunnelCreationEnabled",
        "type": "bool",
        "description": "Enable retrying tunnel creation if it fails.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TunnelCreationTimeout",
        "type": "int",
        "description": "Timeout in seconds for tunnel creation.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "MaxTunnelCreationTimes",
        "type": "int",
        "description": "Maximum number of tunnel creation attempts.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "Hostname used during tunnel negotiation.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "EnableAuthentication",
        "type": "bool",
        "description": "Enable authentication for tunnel establishment.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IncomingTunnelPassword",
        "type": "str",
        "description": "Password used for incoming tunnels.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "OutgoingTunnelPassword",
        "type": "str",
        "description": "Password used for outgoing tunnels.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "HelloEnabled",
        "type": "bool",
        "description": "Enable sending of Hello messages to maintain tunnel connectivity.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Interval between Hello messages in seconds.",
        "default": "60",
        "range_or_options": "1-255"
      },
      {
        "name": "TxBitRate",
        "type": "int",
        "description": "Transmission bit rate in bits/sec.",
        "default": "56000",
        "range_or_options": "1-65535"
      },
      {
        "name": "BearerCapabilities",
        "type": "str",
        "description": "Bearer capabilities indicating supported media types.",
        "default": "ANALOG",
        "range_or_options": "DIGITAL ANALOG BOTH"
      },
      {
        "name": "BearerType",
        "type": "str",
        "description": "Bearer type indicating the media type used.",
        "default": "ANALOG",
        "range_or_options": "DIGITAL ANALOG"
      },
      {
        "name": "FrameCapabilities",
        "type": "str",
        "description": "Supported frame types (synchronous, asynchronous, or both).",
        "default": "SYNC",
        "range_or_options": "SYNC ASYNC BOTH"
      },
      {
        "name": "FrameType",
        "type": "str",
        "description": "Default frame type used.",
        "default": "SYNC",
        "range_or_options": "SYNC ASYNC"
      },
      {
        "name": "CallingNumberEnabled",
        "type": "bool",
        "description": "Enable use of calling number in tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CallingNumber",
        "type": "str",
        "description": "Calling number used in tunnel negotiation.",
        "default": "xinertel",
        "range_or_options": "string"
      },
      {
        "name": "RxWindowSize",
        "type": "int",
        "description": "Receiver window size for data acknowledgment.",
        "default": "4",
        "range_or_options": "1-65535"
      },
      {
        "name": "UseGatewayAsRemoteIp",
        "type": "bool",
        "description": "Use gateway IP address as the remote IP address.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RemoteIpv4Address",
        "type": "str",
        "description": "IPv4 address of the remote endpoint.",
        "default": "2.1.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RemoteIpv4AddressStep",
        "type": "str",
        "description": "Increment step for IPv4 addresses when multiple sessions are created.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RemoteIpv6Address",
        "type": "str",
        "description": "IPv6 address of the remote endpoint.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "RemoteIpv6AddressStep",
        "type": "str",
        "description": "Increment step for IPv6 addresses when multiple sessions are created.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "LcpProxyMode",
        "type": "str",
        "description": "LCP proxy mode behavior.",
        "default": "NONE",
        "range_or_options": "NONE LCP LCP_AUTH"
      },
      {
        "name": "ForceLcpRenegotiation",
        "type": "bool",
        "description": "Force renegotiation of LCP parameters.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv4TosValue",
        "type": "hex int",
        "description": "IPv4 Type of Service value.",
        "default": "0xc0",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv6TrafficClassValue",
        "type": "hex int",
        "description": "IPv6 traffic class value.",
        "default": "0x0",
        "range_or_options": "1-65535"
      },
      {
        "name": "HideFramingCapabilities",
        "type": "bool",
        "description": "Hide framing capabilities during tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideBearerCapabilities",
        "type": "bool",
        "description": "Hide bearer capabilities during tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideAssignedTunnelId",
        "type": "bool",
        "description": "Hide assigned tunnel ID during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideChallenge",
        "type": "bool",
        "description": "Hide challenge message during tunnel authentication.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideChallengeResponse",
        "type": "bool",
        "description": "Hide response to challenge message.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideAssignedSessionId",
        "type": "bool",
        "description": "Hide assigned session ID during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideCallSerialNumber",
        "type": "bool",
        "description": "Hide call serial number during tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideFramingType",
        "type": "bool",
        "description": "Hide framing type during tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideCallingNumber",
        "type": "bool",
        "description": "Hide calling number during tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideTxConnectSpeed",
        "type": "bool",
        "description": "Hide transmit connection speed information.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideLastSentLcpConfReq",
        "type": "bool",
        "description": "Hide last sent LCP configure request.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideLastReceivedLcpConfReq",
        "type": "bool",
        "description": "Hide last received LCP configure request.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenType",
        "type": "bool",
        "description": "Hide proxy authentication type.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenName",
        "type": "bool",
        "description": "Hide proxy authentication name.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenChallenge",
        "type": "bool",
        "description": "Hide proxy authentication challenge.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenId",
        "type": "bool",
        "description": "Hide proxy authentication ID.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenResponse",
        "type": "bool",
        "description": "Hide proxy authentication response.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates and configures a new L2TP protocol instance associated with the specified port. The function initializes an L2TP session object with the provided configuration options and associates it with a test port. After creation, the instance is registered globally by its handle so that it can be referenced later.",
    "example": "| Create L2tp | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.edit_l2tp",
    "return_type": "bool",
    "return": "Returns True if the attributes of the L2TP session were successfully updated, False otherwise. Note that this function does not validate whether the update had a successful effect on the actual session behavior, only that no errors occurred during attribute assignment.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`L2tpProtocolConfig`",
        "description": "The L2TP protocol session object to be modified. This must be an existing session configuration object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the L2TP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the L2TP session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "Specifies the role of the L2TP session: LAC (L2TP Access Concentrator) or LNS (L2TP Network Server).",
        "default": "LAC",
        "range_or_options": "LAC LNS"
      },
      {
        "name": "TunnelCountPerNode",
        "type": "int",
        "description": "Number of tunnels per LAC/LNS node.",
        "default": "1",
        "range_or_options": "1-32768"
      },
      {
        "name": "SessionCountPerTunnel",
        "type": "int",
        "description": "Number of sessions per tunnel.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TunnelStartingId",
        "type": "int",
        "description": "Starting ID for tunnels.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "SessionStartingId",
        "type": "int",
        "description": "Starting ID for sessions.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "UdpSourcePort",
        "type": "int",
        "description": "UDP source port used for L2TP communication.",
        "default": "1701",
        "range_or_options": "1-65535"
      },
      {
        "name": "UdpChecksumEnabled",
        "type": "bool",
        "description": "Enables UDP checksums.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RetryTunnelCreationEnabled",
        "type": "bool",
        "description": "Enables retrying tunnel creation upon failure.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TunnelCreationTimeout",
        "type": "int",
        "description": "Timeout in seconds for tunnel creation.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "MaxTunnelCreationTimes",
        "type": "int",
        "description": "Maximum number of attempts to create a tunnel.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "HostName",
        "type": "str",
        "description": "Host name used in L2TP negotiation.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "EnableAuthentication",
        "type": "bool",
        "description": "Enables authentication for the tunnel.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IncomingTunnelPassword",
        "type": "str",
        "description": "Password for incoming tunnel connections.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "OutgoingTunnelPassword",
        "type": "str",
        "description": "Password for outgoing tunnel connections.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "HelloEnabled",
        "type": "bool",
        "description": "Enables periodic Hello messages to maintain tunnel liveness.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Interval between Hello messages in seconds.",
        "default": "60",
        "range_or_options": "1-255"
      },
      {
        "name": "TxBitRate",
        "type": "int",
        "description": "Transmit bit rate in bits per second.",
        "default": "56000",
        "range_or_options": "1-65535"
      },
      {
        "name": "BearerCapabilities",
        "type": "str",
        "description": "Specifies bearer capabilities (digital, analog, or both).",
        "default": "ANALOG",
        "range_or_options": "DIGITAL ANALOG BOTH"
      },
      {
        "name": "BearerType",
        "type": "str",
        "description": "Specifies the bearer type (digital or analog).",
        "default": "ANALOG",
        "range_or_options": "DIGITAL ANALOG"
      },
      {
        "name": "FrameCapabilities",
        "type": "str",
        "description": "Specifies frame capabilities (synchronous, asynchronous, or both).",
        "default": "SYNC",
        "range_or_options": "SYNC ASYNC BOTH"
      },
      {
        "name": "FrameType",
        "type": "str",
        "description": "Specifies the frame type (synchronous or asynchronous).",
        "default": "SYNC",
        "range_or_options": "SYNC ASYNC"
      },
      {
        "name": "CallingNumberEnabled",
        "type": "bool",
        "description": "Enables use of Calling Number in tunnel negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CallingNumber",
        "type": "str",
        "description": "Calling number used in tunnel negotiation.",
        "default": "xinertel",
        "range_or_options": "string length [1,255]"
      },
      {
        "name": "RxWindowSize",
        "type": "int",
        "description": "Receiver window size for flow control.",
        "default": "4",
        "range_or_options": "1-65535"
      },
      {
        "name": "UseGatewayAsRemoteIp",
        "type": "bool",
        "description": "Uses gateway IP as remote IP address.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RemoteIpv4Address",
        "type": "str",
        "description": "Remote IPv4 address for tunnel endpoint.",
        "default": "2.1.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RemoteIpv4AddressStep",
        "type": "str",
        "description": "IPv4 address increment step for multiple sessions.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RemoteIpv6Address",
        "type": "str",
        "description": "Remote IPv6 address for tunnel endpoint.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "RemoteIpv6AddressStep",
        "type": "str",
        "description": "IPv6 address increment step for multiple sessions.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "LcpProxyMode",
        "type": "str",
        "description": "LCP proxy mode (none, LCP, or LCP with authentication).",
        "default": "NONE",
        "range_or_options": "NONE LCP LCP_AUTH"
      },
      {
        "name": "ForceLcpRenegotiation",
        "type": "bool",
        "description": "Forces renegotiation of LCP parameters.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv4TosValue",
        "type": "hex int",
        "description": "IPv4 Type of Service value (in hexadecimal).",
        "default": "0xc0",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv6TrafficClassValue",
        "type": "hex int",
        "description": "IPv6 traffic class value (in hexadecimal).",
        "default": "0x0",
        "range_or_options": "1-65535"
      },
      {
        "name": "HideFramingCapabilities",
        "type": "bool",
        "description": "Hides framing capabilities during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideBearerCapabilities",
        "type": "bool",
        "description": "Hides bearer capabilities during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideAssignedTunnelId",
        "type": "bool",
        "description": "Hides assigned tunnel ID during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideChallenge",
        "type": "bool",
        "description": "Hides challenge during authentication.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideChallengeResponse",
        "type": "bool",
        "description": "Hides challenge response during authentication.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideAssignedSessionId",
        "type": "bool",
        "description": "Hides assigned session ID during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideCallSerialNumber",
        "type": "bool",
        "description": "Hides call serial number during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideFramingType",
        "type": "bool",
        "description": "Hides framing type during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideCallingNumber",
        "type": "bool",
        "description": "Hides calling number during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideTxConnectSpeed",
        "type": "bool",
        "description": "Hides transmit connection speed during negotiation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideLastSentLcpConfReq",
        "type": "bool",
        "description": "Hides last sent LCP configure request.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideLastReceivedLcpConfReq",
        "type": "bool",
        "description": "Hides last received LCP configure request.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenType",
        "type": "bool",
        "description": "Hides proxy authentication type.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenName",
        "type": "bool",
        "description": "Hides proxy authentication name.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenChallenge",
        "type": "bool",
        "description": "Hides proxy authentication challenge.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenId",
        "type": "bool",
        "description": "Hides proxy authentication ID.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HideProxyAuthenResponse",
        "type": "bool",
        "description": "Hides proxy authentication response.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Modifies the attributes of an existing L2TP protocol session object using provided keyword arguments. This function updates session configuration dynamically and is typically used during test setup or reconfiguration.",
    "example": "| Edit L2tp | Session=${Session} | Enable=True | TunnelCountPerNode=2 | SessionCountPerTunnel=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.edit_l2tp_port_config",
    "description": "Edits the L2TP protocol configuration for one or more specified ports. This function supports both single and multiple port configurations, allowing various keyword arguments to customize the L2TP settings.",
    "return_type": "object / list of objects",
    "return": "If a single port is edited, returns the modified `L2tpProtocolConfig` object directly. If multiple ports are edited, returns a list of all modified `L2tpProtocolConfig` objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object / list",
        "description": "A test instrument port object or a list of port objects for which the L2TP configuration needs to be edited. Each port object must support the `get_children` method to retrieve associated protocol configurations.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TunnelConnectRate",
        "type": "int",
        "description": "Specifies the tunnel connection rate in sessions per second.",
        "default": "100",
        "range_or_options": "1-1000"
      }
    ],
    "example": "| Edit L2tp Port Config | Ports=${Port} | TunnelConnectRate=500 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.connect_l2tp",
    "return_type": "bool",
    "return": "Returns True if all L2TP sessions are connected successfully. If any session fails, an exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "L2tp or list of L2tp",
        "description": "One or more L2TP session objects to connect. Can be a single session or a list of sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Establishes an L2TP connection for one or more provided session objects. This function wraps the underlying session `connect()` method and provides a uniform interface for connecting either a single session or multiple sessions. It returns True only if all sessions are processed and connected successfully. If any session fails to connect, an error is propagated.",
    "example": "| Connect L2tp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.disconnect_l2tp",
    "return_type": "bool",
    "return": "Returns True if all provided sessions were successfully disconnected, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "A single session object or an iterable (list, set, or tuple) of L2TP session objects to be disconnected.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function disconnects one or multiple L2TP protocol sessions. It accepts a single session object or a collection of session objects (list, set, or tuple). Internally, if the input is not an iterable, it is wrapped into a list. The function then iterates over each session and calls its `disconnect()` method. It returns True only if all provided sessions are successfully disconnected.",
    "example": "| Disconnect L2tp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.abort_l2tp",
    "return_type": "bool",
    "return": "True if all provided L2TP sessions are successfully aborted; otherwise, raises an exception on failure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list/set/tuple of objects",
        "description": "A single session object or a collection (list, set, tuple) of session objects representing the L2TP sessions to be aborted. Each session must support the `abort()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Aborts one or more L2TP sessions. If a single session is provided, it will be converted into a list for uniform processing. The function calls the `abort()` method on each session to terminate it. If any session does not have an `abort()` method, an AttributeError may be raised during execution.",
    "example": "| Abort L2tp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.wait_l2tp_state",
    "return_type": "bool",
    "return": "Returns True if all L2TP sessions reach the specified state within the timeout; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) of L2TP session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str, optional",
        "description": "The target state the L2TP sessions are expected to reach. If None, it may wait for a default state depending on implementation.",
        "default": "CONNECTED",
        "range_or_options": "NONE IDLE CONNECTING CONNECTED DISCONNECTING"
      },
      {
        "name": "Interval",
        "type": "int or float, optional",
        "description": "Time interval (in seconds) between each check of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or float, optional",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more L2TP sessions to reach a specified state (e.g., CONNECTED). The function periodically checks the state of each session until either all sessions reach the desired state or the timeout is exceeded. If the timeout occurs before reaching the desired state, an exception may be raised by the underlying method. This function returns True upon success and may raise ContinuableFailure if the result is False.",
    "example": "| Wait L2tp State | Sessions=${Sessions} | State=CONNECTED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.get_l2tp_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistics for a single port, a pandas DataFrame if multiple ports are queried, or False if no data is found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple or None",
        "description": "The test instrument port object(s) to query. If None, retrieves statistics across all available ports. Each port object must have a 'Name' property.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "List of statistical items to retrieve (e.g., TunnelUp, SessionDown). Valid options include: LacCount, LnsCount, TunnelCount, SessionCount, TunnelUp, TunnelDown, SessionUp, SessionDown. If None, returns all available properties. A string will be converted into a single-element list.",
        "default": "None",
        "range_or_options": "LacCount LnsCount TunnelCount SessionCount TunnelUp TunnelDown SessionUp SessionDown"
      }
    ],
    "kwargs": [],
    "description": "Retrieves L2TP port statistics based on the provided port(s) and statistical items. This function is a wrapper around `_get_statictis` that specifically fetches 'L2tpPortStatistic' type statistics. It supports querying for one or more ports, either by passing a single port object, a list/set/tuple of port objects, or None to retrieve statistics across all ports. The desired statistical properties can be specified via `StaItems`.",
    "example": "| @{StaItems} | Create List | TunnelUp | SessionDown |\n| Subscribe Result | Types=L2tpPortStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get L2tp Port Statistic | Port=${port_obj} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.get_l2tp_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if exactly one result is found, a pandas DataFrame if multiple results are found, or False if no matching data is retrieved.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "The L2TP session object(s) for which to retrieve statistics. If None, general statistics without session filtering are returned.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeIndexInBlock",
        "type": "int",
        "description": "Index of the node within the L2TP block for finer granularity in statistics. Used as part of the filter dictionary passed to the backend function.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. Supported values include: LocalTunnelId, RemoteTunnelId, LocalSessionId, RemoteSessionId, SessionState, LocalTunnelIpAddress, RemoteTunnelIpAddress, LocalTunnelIpv6Address, RemoteTunnelIpv6Address, TxIcrq, RxIcrq, TxIcrp, RxIcrp, TxIccn, RxIccn, TxCdn, RxCdn, ResultCode, ErrorCode, ErrorMessage.",
        "default": "None",
        "range_or_options": "LocalTunnelId RemoteTunnelId LocalSessionId RemoteSessionId SessionState LocalTunnelIpAddress RemoteTunnelIpAddress LocalTunnelIpv6Address RemoteTunnelIpv6Address TxIcrq RxIcrq TxIcrp RxIcrp TxIccn RxIccn TxCdn RxCdn ResultCode ErrorCode ErrorMessage"
      }
    ],
    "kwargs": [],
    "description": "Retrieves L2TP session statistics for specified session(s) and node index. This function wraps `_get_statictis` and is specifically tailored to fetch 'L2tpSessionStatistic' data. It allows filtering by one or more sessions, a specific node index in the block, and custom statistical items.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxIcrq | RxIcrq |\n    | Subscribe Result | Types=L2tpSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get L2tp Session Statistic | Session=${Session} | NodeIndexInBlock=1 | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.get_l2tp_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical data for specified L2TP session block(s). If a single session matches, returns a dictionary with requested statistics. If multiple sessions match, returns a pandas DataFrame with rows representing each session and columns the requested statistics. If no session matches, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the L2TP session(s) to retrieve statistics for. If None, retrieves global or default session data. If an object with 'Name' attribute is provided, its name is used as the session ID. If a list/set/tuple of such objects is provided, all session IDs are extracted from their 'Name' attributes.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a single-element list. Must be a subset of supported statistical properties related to L2TP session blocks.",
        "default": "None",
        "range_or_options": "TunnelCount SessionCount TunnelUp TunnelDown SessionUp SessionDown TunnelSetupRate SessionSetupRate AverageTunnelSetupTime MaxTunnelSetupTime MinTunnelSetupTime AverageSessionSetupTime MaxSessionSetupTime MinSessionSetupTime TxPackets RxPackets TxSccrq RxSccrq TxSccrp RxSccrp TxScccn RxScccn TxIcrq RxIcrq TxIcrp RxIcrp TxIccn RxIccn TxSli RxSli TxStopCcn RxStopCcn TxWen RxWen TxHello RxHello TxCdn RxCdn TxZlb RxZlb"
      }
    ],
    "kwargs": [],
    "description": "Retrieves L2TP session block statistics for the specified session(s). Internally calls `_get_statictis` to gather statistical data. Handles various input types for the `Session` parameter and supports filtering by specific statistical items. May internally refresh data, navigate paginated results using commands like GotoResultPageCommand, and use time.sleep(3) in some modes to ensure data consistency. Logs resulting DataFrame in tabulated format for debugging purposes.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=L2tpBlockStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get L2tp Block Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.l2tp.get_l2tp_tunnel_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary containing requested statistical items if one matching tunnel is found, a pandas DataFrame if multiple matches are found, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/tuple/set of objects or None",
        "description": "L2TP protocol session object(s) used to filter the statistics query. If None, no session filter is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeIndexInBlock",
        "type": "int",
        "description": "Index of the node within the block to fetch statistics for (used to locate specific tunnel instances).",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items to retrieve from L2TP tunnel data. If None, all available items are queried. Valid values include: LocalTunnelId, RemoteTunnelId, TunnelState, UdpSourcePort, UdpDestinationPort, LocalIpAddress, RemoteIpAddress, LocalIpv6Address, RemoteIpv6Address, SessionCount, SessionUp, SessionDown, TxPackets, RxPackets, TxSccrq, RxSccrq, TxSccrp, RxSccrp, TxScccn, RxScccn, TxSli, RxSli, TxStopCcn, RxStopCcn, TxWen, RxWen, TxHello, RxHello.",
        "default": "None",
        "range_or_options": "LocalTunnelId RemoteTunnelId TunnelState UdpSourcePort UdpDestinationPort LocalIpAddress RemoteIpAddress LocalIpv6Address RemoteIpv6Address SessionCount SessionUp SessionDown TxPackets RxPackets TxSccrq RxSccrq TxSccrp RxSccrp TxScccn RxScccn TxSli RxSli TxStopCcn RxStopCcn TxWen RxWen TxHello RxHello"
      }
    ],
    "kwargs": [],
    "description": "Retrieves L2TP tunnel statistics based on provided session and node index. This function acts as a wrapper around `_get_statictis` and specifically queries statistics for an L2TP tunnel. It supports filtering by session(s), node index in block, and specific statistical items. The result is returned as a dictionary, DataFrame, or boolean depending on the number of matches found.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=L2tpTunnelStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get L2tp Tunnel Statistic | Session=${Session} | NodeIndexInBlock=1 | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.create_lacp",
    "return_type": "Lacp",
    "return": "The created Lacp session object representing the LAG (Link Aggregation Group), which provides access to the LACP session and its associated functionality.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[port.Port, List[port.Port]]",
        "description": "A single port object or a list of port objects to be aggregated into a Link Aggregation Group (LAG). Each port must be a valid port object recognized by the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Create a LACP (Link Aggregation Control Protocol) session for the specified port(s). This function initializes a LACP session by creating a Lacp object with the provided port(s), which are aggregated into a Link Aggregation Group (LAG). The created Lacp session is then mapped in a global protocol object map using its handle for future reference. If the provided ports are invalid or if there is an internal failure during the creation of the LAG or LACP session, an exception will be raised.",
    "example": "| Create Lacp | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.lacp_add_members",
    "return_type": "bool",
    "return": "Indicates whether the operation to add member ports to the LACP session was successful.",
    "parameters": [
      {
        "name": "Lacp",
        "type": "object",
        "description": "The LACP protocol session object to which port members will be added.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ports",
        "type": "list",
        "description": "A list of port objects representing physical ports on the test instrument that should be added as members to the LACP group.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function adds the specified physical port objects as members to a given LACP (Link Aggregation Control Protocol) session. It wraps the underlying implementation of `renix.lacp_add_members` and raises an exception if the operation fails, otherwise it returns a boolean indicating success. The function includes abnormal behavior checks via the `@abnormal_check()` decorator to handle unexpected conditions.",
    "example": "| Lacp Add Members | Lacp=${Lacp} | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.edit_lacp_aggregation_group",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True / False）",
    "parameters": [
      {
        "name": "Lacp",
        "type": "object",
        "description": "lacp协议会话对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "L2HashOption",
        "type": "list",
        "description": "L2 Hash Option",
        "default": "['ETHERNET_SOURCE_MAC', 'ETHERNET_DESTINATION_MAC', 'VLAN', 'MPLS']",
        "range_or_options": "ETHERNET_SOURCE_MAC ETHERNET_DESTINATION_MAC VLAN MPLS"
      },
      {
        "name": "L3HashOption",
        "type": "list",
        "description": "L3 Hash Option",
        "default": "['IPV4_SOURCE', 'IPV4_DESTINATION', 'UDP']",
        "range_or_options": "ETHERNET_SOURCE_MAC ETHERNET_DESTINATION_MAC VLAN MPLS IPV4_SOURCE IPV4_DESTINATION IPV6_SOURCE IPV6_DESTINATION TCP UDP"
      },
      {
        "name": "ActorSystemId",
        "type": "str",
        "description": "Actor System ID",
        "default": "00:00:00:00:00:01",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "ActorSystemPriority",
        "type": "int",
        "description": "Actor System Priority",
        "default": "32768",
        "range_or_options": "0-65535"
      },
      {
        "name": "MaxActiveNumber",
        "type": "int",
        "description": "Max Active Number",
        "default": "8",
        "range_or_options": "0-65535"
      },
      {
        "name": "MinActiveNumber",
        "type": "int",
        "description": "Min Active Number",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TransmitAlgorithm",
        "type": "str",
        "description": "Transmit algorithm",
        "default": "HASHING",
        "range_or_options": "HASHING"
      },
      {
        "name": "Preempt",
        "type": "bool",
        "description": "Preempt Enable",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PreemtDelay",
        "type": "int",
        "description": "Preemt Delay Time (seconds)",
        "default": "30",
        "range_or_options": "0-65535"
      },
      {
        "name": "AggregationMode",
        "type": "str",
        "description": "Aggregation Mode",
        "default": "LACP",
        "range_or_options": "LACP STATIC"
      },
      {
        "name": "LocalPreference",
        "type": "bool",
        "description": "Tx Local Preference",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "修改 LACP 协议会话对象的 Aggregation Group 配置。该函数将配置参数通过 `**kwargs` 传递给底层 LACP 对象的 `edit_aggregation_group` 方法进行实际配置更新。",
    "example": "| Edit Lacp Aggregation Group | Lacp=${Lacp} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.lacp_delete_members",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Lacp",
        "type": "object",
        "description": "lacp协议会话对象，必须具有 delete_members 方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ports",
        "type": "list",
        "description": "测试仪表端口对象列表，表示要从 LACP 组中删除的端口成员。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "为 lacp 协议会话对象删除指定的端口成员对象。该函数封装了底层 `renix.lacp_delete_members` 的调用，并根据返回值决定是否抛出异常。",
    "example": "| Lacp Delete Members | Lacp=${Lacp} | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.edit_lacp_members_port_config",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "要修改LACP配置的一个或多个端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ActorKey",
        "type": "int",
        "description": "Actor Key 值",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "ActorPortId",
        "type": "int",
        "description": "Actor Port ID",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "ActorPortPriority",
        "type": "int",
        "description": "Actor Port Priority",
        "default": "32768",
        "range_or_options": "0-65535"
      },
      {
        "name": "LacpTimeout",
        "type": "str",
        "description": "LACP 超时时间设置",
        "default": "LONG",
        "range_or_options": "LONG SHORT"
      },
      {
        "name": "LacpActivity",
        "type": "str",
        "description": "LACP 活动状态",
        "default": "ACTIVE",
        "range_or_options": "PASSIVE ACTIVE"
      },
      {
        "name": "ActorSystemId",
        "type": "str",
        "description": "Actor System ID（MAC地址格式）",
        "default": "00:00:00:00:00:01",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "ActorSystemPriority",
        "type": "int",
        "description": "Actor System Priority",
        "default": "32768",
        "range_or_options": "0-65535"
      },
      {
        "name": "PortMacAddress",
        "type": "str",
        "description": "端口的MAC地址（MAC地址格式）",
        "default": "00:00:20:20:20:01",
        "range_or_options": "有效的mac地址"
      }
    ],
    "description": "该函数用于修改一个或多个测试仪表端口的LACP（链路聚合控制协议）端口配置。它接受端口对象以及任意数量的关键字参数，这些关键字参数对应于LACP端口配置对象的属性，并将这些属性更新为指定的新值。",
    "example": "| Edit Lacp Member Port Config | Ports=${Ports} | ActorKey=2 | ActorPortId=100 | LacpTimeout=SHORT | LacpActivity=PASSIVE"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.pause_send_lacp_pdus",
    "return_type": "bool",
    "return": "Returns True if the command to pause sending LACP PDUs was executed successfully, otherwise False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "A single port object or a list of port objects on which to pause sending LACP PDUs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Pauses the transmission of LACP PDUs (Protocol Data Units) on the specified port(s). This function acts as a wrapper for the RenixLibrary.protocol.lacp.Lacp.pause_send_lacp_pdus method. It is used to temporarily stop sending LACP PDUs on one or more given ports by delegating the operation to the LACP protocol implementation. Internally, it retrieves the LACP port configurations for the provided ports and executes the appropriate command to pause transmission.",
    "example": "| Pause Send Lacp Pdus | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.resume_send_lacp_pdus",
    "return_type": "bool",
    "return": "Returns True if the command to resume sending LACP PDUs was executed successfully, otherwise returns False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "A single port object or a list of port objects on which to resume sending LACP PDUs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes sending LACP PDUs (Link Aggregation Control Protocol Data Units) on the specified port(s). This function acts as a wrapper that calls the corresponding class method in the Lacp class to resume LACP PDU transmission. It enables periodic transmission of LACP control packets on one or more link aggregation member ports by sending a resume command to the associated LACP port handles.",
    "example": "| Resume Send Lacp Pdus | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.send_in_sync_pdus",
    "return_type": "bool",
    "return": "Returns True if In-Sync PDUs were successfully sent; otherwise False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "A single port object or a list of port objects for which to send In-Sync PDUs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends LACP In-Sync PDUs on the specified port(s) to ensure proper synchronization between partner devices in a LACP-enabled link aggregation group (LAG). This function wraps around the Lacp.send_in_sync_pdus method and ensures correct context handling via the RenixAPI instance.",
    "example": "| Send In Sync Pdus | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.send_out_of_sync_pdus",
    "return_type": "bool",
    "return": "Returns True if the command to send 'Out of Sync' LACP PDUs was executed successfully. Returns False if the operation failed.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "A single port object or a list of port objects on which to send the 'Out of Sync' LACP PDUs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends 'Out of Sync' LACP PDUs on the specified ports to notify the peer device of a configuration or state change that requires synchronization. This function is typically used after modifying LACP settings to ensure that the link partner becomes aware of the new state and initiates resynchronization. Internally, it calls the `Lacp.send_out_of_sync_pdus` method with the provided ports and raises an exception if the operation fails.",
    "example": "| Send Out of Sync Pdus | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.start_lacp_port",
    "return_type": "bool",
    "return": "Returns True to indicate that the LACP start command was executed successfully.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list[Port]",
        "description": "A single port object or a list of port objects on which to start LACP.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts the LACP protocol on one or more provided ports. This function internally retrieves the LACP port configurations for the given ports, constructs a StartLacpPortCommand with handles from the retrieved configurations, and executes the command to initiate LACP on those ports. The return value indicates whether the LACP start command was executed successfully, but does not confirm if LACP negotiation succeeded on the physical ports.",
    "example": "| Start Lacp Port | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.stop_lacp_port",
    "return_type": "bool",
    "return": "Returns True if the LACP protocol was successfully stopped on all provided ports; otherwise False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list[:class:`Port`]",
        "description": "A list of test instrument port objects on which to stop the LACP (Link Aggregation Control Protocol).",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the LACP (Link Aggregation Control Protocol) operation on one or more specified port objects. This function acts as a wrapper around the `RenixLibrary.protocol.lacp.Lacp.stop_lacp_port` static method and is used to terminate LACP sessions on the given ports. It first retrieves associated LACP port configurations for the provided ports, then constructs and executes a command to stop LACP using the handles from those configurations.",
    "example": "| Stop Lacp Port | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.get_lacp_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "A dictionary, DataFrame, or boolean depending on the result. Returns a dict for a single port's stats, a DataFrame for multiple ports, or False if no data is found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple",
        "description": "The test instrument port object(s) for which LACP statistics are to be retrieved. Each port object must have a 'Name' attribute that uniquely identifies it.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list",
        "description": "List of statistical items to retrieve. Supported items include ActorState, PartnerState, LacpState, and various LACP PDU counters.",
        "default": "None",
        "range_or_options": "ActorState PartnerState LacpState ActorOperationalKey ActorSystemId ActorSystemPriority ActorPortId ActorPortPriority PartnerOperationalKey PartnerSystemId PartnerSystemPriority PartnerPortId PartnerPortPriority PartnerCollectorMaxDelay LacpPdusSent LacpPdusReceived MarkerPdusSent MarkerPdusReceived MarkerResponsePdusSent MarkerResponsePdusReceived"
      }
    ],
    "kwargs": [],
    "description": "Retrieves LACP (Link Aggregation Control Protocol) port-level statistics for specified ports and statistical items. This function wraps an internal method `_get_statictis()` to fetch the data. It handles different types of input for the `Port` parameter and prepares necessary identifiers before delegating the actual statistic retrieval.",
    "example": "| Get Lacp Port Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lacp.get_lag_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical data for LAG ports. If one row matches, returns a dictionary of statistics; if multiple rows match, returns a pandas DataFrame; if no match is found, returns False.",
    "parameters": [
      {
        "name": "Lacp",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the LACP object(s) whose port statistics are to be retrieved. If None, no filtering by LACP handle is applied. Each element (if it's an object) must have a `session.Name` attribute used as an identifier for filtering.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from the LagPortStats table. If None, all properties are queried. If a string is provided, it will be converted into a single-element list. Must be a subset of valid statistic item names.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for LAG (Link Aggregation Group) ports based on the provided LACP configuration and desired statistics. This function wraps around `_get_statictis` to fetch LagPortStats-type statistics. It processes the input `Lacp_` to extract session names, which are used as identifiers for filtering statistics.",
    "example": ">>> api.get_lag_port_statistic(Lacp_=lacp_obj, StaItems=['Tx Frames', 'Rx Frames'])\n{'Tx Frames': 12345, 'Rx Frames': 67890}"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.create_ldp",
    "return_type": "Ldp",
    "return": "The newly created and configured LDP protocol session object.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "Test instrument port object. Represents the parent layer (e.g., a physical or logical port) to which this LDP instance is associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the LDP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the LDP session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "HelloType",
        "type": "str",
        "description": "Specifies the type of Hello message used by the LDP session.",
        "default": "DIRECT",
        "range_or_options": "DIRECT TARGETED DIRECT_TARGETED"
      },
      {
        "name": "LabelAdvertType",
        "type": "str",
        "description": "Specifies the label advertisement method used by the LDP session.",
        "default": "DU",
        "range_or_options": "DU DOD"
      },
      {
        "name": "TransportMode",
        "type": "str",
        "description": "Specifies the mode for Transport Address TLV handling in the LDP session.",
        "default": "TESTER_IP",
        "range_or_options": "TESTER_IP ROUTER_ID NONE"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "IPv4 address of the Device Under Test (DUT).",
        "default": "2.1.1.1",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "DirectHelloInterval",
        "type": "int",
        "description": "Interval (in seconds) for sending direct Hello messages.",
        "default": "5",
        "range_or_options": "1-21845"
      },
      {
        "name": "TargetedHelloInterval",
        "type": "int",
        "description": "Interval (in seconds) for sending targeted Hello messages.",
        "default": "15",
        "range_or_options": "1-21845"
      },
      {
        "name": "KeepAliveInterval",
        "type": "int",
        "description": "Interval (in seconds) for keepalive messages.",
        "default": "60",
        "range_or_options": "1-21845"
      },
      {
        "name": "LabelReqRetryCount",
        "type": "int",
        "description": "Number of retries for a label request before giving up.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LabelReqRetryInterval",
        "type": "int",
        "description": "Time interval (in seconds) between label request retries.",
        "default": "60",
        "range_or_options": "1-65535"
      },
      {
        "name": "Authentication",
        "type": "str",
        "description": "Authentication type for securing the LDP session.",
        "default": "NONE",
        "range_or_options": "NONE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Password used for authentication if enabled.",
        "default": "xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "EgressLabel",
        "type": "str",
        "description": "Specifies how egress labels are assigned.",
        "default": "NEXT_AVAILABLE",
        "range_or_options": "NEXT_AVAILABLE IMPLICIT EXPLICIT"
      },
      {
        "name": "MinLabel",
        "type": "int",
        "description": "Minimum value for label allocation.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "EnableLspResult",
        "type": "bool",
        "description": "Enables collection of statistics for LSPs.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnablePseudowireLspResult",
        "type": "bool",
        "description": "Enables collection of statistics for pseudowire LSPs.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LspBindMode",
        "type": "str",
        "description": "Binding mode for LSPs in terms of transmit and receive behavior.",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      },
      {
        "name": "VcLspBindMode",
        "type": "str",
        "description": "Binding mode for virtual circuit LSPs.",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      },
      {
        "name": "GeneralizedLspBindMode",
        "type": "str",
        "description": "Binding mode for generalized pseudowire LSPs.",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      }
    ],
    "description": "Creates and configures an LDP (Label Distribution Protocol) session object associated with the specified test port. The function supports extensive configuration options for fine-tuning LDP behavior such as hello intervals, label distribution, transport settings, authentication, and LSP binding modes.",
    "example": ".. code:: RobotFramework\n\n    | Create Ldp | Port=${Port} | Enable=True | HelloType=TARGETED | DutIpv4Address=192.168.1.1"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.edit_ldp",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True / False）",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "LDP协议会话对象，用于编辑其属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "LDP会话名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用LDP协议会话。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "HelloType",
        "type": "str",
        "description": "Hello类型。",
        "default": "DIRECT",
        "range_or_options": "DIRECT TARGETED DIRECT_TARGETED"
      },
      {
        "name": "LabelAdvertType",
        "type": "str",
        "description": "标签分配方式。",
        "default": "DU",
        "range_or_options": "DU DOD"
      },
      {
        "name": "TransportMode",
        "type": "str",
        "description": "Transport Address TLV模式。",
        "default": "TESTER_IP",
        "range_or_options": "TESTER_IP ROUTER_ID NONE"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "DUT IPv4地址。",
        "default": "2.1.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "DirectHelloInterval",
        "type": "int",
        "description": "直连Hello发送间隔(sec)。",
        "default": "5",
        "range_or_options": "1-21845"
      },
      {
        "name": "TargetedHelloInterval",
        "type": "int",
        "description": "远端Hello发送间隔(sec)。",
        "default": "15",
        "range_or_options": "1-21845"
      },
      {
        "name": "KeepAliveInterval",
        "type": "int",
        "description": "保活间隔(sec)。",
        "default": "60",
        "range_or_options": "1-21845"
      },
      {
        "name": "LabelReqRetryCount",
        "type": "int",
        "description": "标签请求重试次数。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LabelReqRetryInterval",
        "type": "int",
        "description": "标签请求间隔(sec)。",
        "default": "60",
        "range_or_options": "1-65535"
      },
      {
        "name": "Authentication",
        "type": "str",
        "description": "鉴权类型。",
        "default": "NONE",
        "range_or_options": "NONE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "密码。",
        "default": "xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "EgressLabel",
        "type": "str",
        "description": "出标签方式。",
        "default": "NEXT_AVAILABLE",
        "range_or_options": "NEXT_AVAILABLE IMPLICIT EXPLICIT"
      },
      {
        "name": "MinLabel",
        "type": "int",
        "description": "最小标签值。",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "EnableLspResult",
        "type": "bool",
        "description": "是否启用LSP统计。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnablePseudowireLspResult",
        "type": "bool",
        "description": "是否启用伪线LSP统计。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LspBindMode",
        "type": "str",
        "description": "LSP绑定模式。",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      },
      {
        "name": "VcLspBindMode",
        "type": "str",
        "description": "虚拟电路LSP绑定模式。",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      },
      {
        "name": "GeneralizedLspBindMode",
        "type": "str",
        "description": "通用伪线LSP绑定模式。",
        "default": "TX_RX",
        "range_or_options": "TX_RX TX RX NONE"
      }
    ],
    "description": "该函数用于动态更新提供的LDP会话对象(Session)的属性。通过关键字参数(**kwargs)，可以灵活地设置Session对象的各个属性值。如果更新失败，则抛出ContinuableFailure异常；否则返回True。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ldp | Port=${Port} |\n    | Edit Ldp | Session=${Session} | HelloType=DIRECT_TARGETED |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.create_ldp_ipv4_egress",
    "return_type": "list of :obj:`LdpIpv4EgressLspConfig`",
    "return": "返回创建的 LDP IPv4 Egress 对象列表。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable (list, set, tuple)",
        "description": "LDP 协议会话对象。如果传入的是可迭代对象（如 list、set 或 tuple），则使用第一个元素作为实际的会话对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "LDP IPv4 Egress 对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用 LDP IPv4 Egress。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "FecType",
        "type": "str",
        "description": "FEC 类型，用于指定前缀或主机 FEC。",
        "default": "PREFIX_FEC",
        "range_or_options": "PREFIX_FEC HOST_FEC"
      },
      {
        "name": "LspCount",
        "type": "int",
        "description": "LSP 的数量。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartIpv4Prefix",
        "type": "str",
        "description": "LSP IPv4 前缀地址的起始值。",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "LSP IPv4 前缀长度。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "PrefixStep",
        "type": "int",
        "description": "LSP IPv4 前缀长度跳变步长。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv4PrefixStep",
        "type": "str",
        "description": "LSP IPv4 前缀地址跳变步长。",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      }
    ],
    "description": "该函数用于为 LDP 会话创建一个 IPv4 Egress 配置。它封装了底层会话对象的 `create_ipv4_egress` 方法，并简化了配置流程。支持处理可迭代输入的 Session 参数，并将所有其他配置参数通过关键字参数传递到底层方法。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ldp | Port=${Port} |\n    | Edit Ldp | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Ldp Ipv4 Egress | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.create_ldp_ipv4_ingress",
    "return_type": "list of :obj:`LdpIpv4IngressLspConfig`",
    "return": "A list containing the created LDP IPv4 Ingress LSP configuration objects.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`Ldp` or iterable of :obj:`Ldp`",
        "description": "An LDP protocol session object, or an iterable (e.g., list, tuple) of session objects. Only the first session in the iterable will be used to create the ingress.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the created LDP IPv4 Ingress object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the LDP IPv4 Ingress object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "FecType",
        "type": "str",
        "description": "The FEC (Forwarding Equivalence Class) type for the LDP Ingress.",
        "default": "PREFIX_FEC",
        "range_or_options": "PREFIX_FEC HOST_FEC"
      },
      {
        "name": "LspCount",
        "type": "int",
        "description": "Number of LSPs (Label Switched Paths) to create for this ingress.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartIpv4Prefix",
        "type": "str",
        "description": "Starting IPv4 prefix address for the LSPs.",
        "default": "192.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv4 prefix for each LSP.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "PrefixStep",
        "type": "int",
        "description": "Increment step between consecutive IPv4 prefixes.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv4PrefixStep",
        "type": "str",
        "description": "IPv4 address increment step between consecutive prefixes.",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      }
    ],
    "description": "This function creates an LDP IPv4 Ingress object on a provided LDP session. It configures various properties such as the number of LSPs, their starting IP prefix, prefix length, and increment steps. This is typically used in network testing scenarios where LDP-based MPLS traffic needs to be simulated from an ingress point.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ldp | Port=${Port} |\n    | Edit Ldp | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Ingress} | Create Ldp Ipv4 Ingress | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.create_ldp_fec_128",
    "return_type": "object",
    "return": "The result of the `create_fec_128` method called on the Session object, which typically represents the created LDP FEC 128 entity.",
    "parameters": [
      {
        "name": "Session",
        "type": "Union[object, list, set, tuple]",
        "description": "A session object that has a method `create_fec_128`. If a list, set, or tuple is passed, the first element will be selected for use.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "LDP FEC 128 object name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables LDP FEC 128.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "ControlWordEnable",
        "type": "bool",
        "description": "Enables control word for LDP FEC 128.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Encapsulation",
        "type": "str",
        "description": "Encapsulation type (hex).",
        "default": "PREFIX_FEC",
        "range_or_options": "ETHERNET_TAGGED_MODE ETHERNET CEM"
      },
      {
        "name": "GroupId",
        "type": "int",
        "description": "Group ID.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "InterfaceMtu",
        "type": "int",
        "description": "Interface MTU size.",
        "default": "1500",
        "range_or_options": "1-65535"
      },
      {
        "name": "IncludePwStatusTlv",
        "type": "bool",
        "description": "Enables pseudo-wire status TLV.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PwStatusCode",
        "type": "list",
        "description": "List of pseudo-wire status codes.",
        "default": "PW_NOT_FORWARDING",
        "range_or_options": "PW_NOT_FORWARDING LOCAL_AC_RX_FAULT LOCAL_AC_TX_FAULT LOCAL_PSN_PW_RX_FAULT LOCAL_PSN_PW_TX_FAULT"
      },
      {
        "name": "UseCustomPwStatusTlv",
        "type": "bool",
        "description": "Enables custom pseudo-wire status TLV.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomPwStatusCode",
        "type": "int",
        "description": "Custom pseudo-wire status code.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "VcCount",
        "type": "int",
        "description": "Number of VCs.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "StartVcId",
        "type": "int",
        "description": "Starting VC ID.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "VcIdStep",
        "type": "int",
        "description": "VC ID step increment.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function facilitates the creation of an LDP FEC (Forwarding Equivalence Class) with type 128. It abstracts away handling of session input types and forwards all additional parameters to the underlying session's `create_fec_128` method. The function wraps a call to `Session.create_fec_128(**kwargs)` and ensures robustness by handling collection inputs such as lists, sets, or tuples for the session parameter.",
    "example": ".. code:: RobotFramework\n\n        | ${Session} | Create Ldp | Port=${Port} |\n        | Edit Ldp | Session=${Session} | HelloType=DIRECT_TARGETED |\n        | ${Ingress} | Create Ldp Fec 128 | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.create_ldp_fec_129",
    "return_type": "object or list",
    "return": "The created LDP FEC 129 object or a list of such objects, typically representing the configuration of the pseudowire (PW) in an LDP session.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects",
        "description": "A single LDP session object or a collection of session objects. If a collection is provided, only the first session is used to create the LDP FEC 129 object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the LDP FEC 129 object for identification purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the LDP FEC 129 object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "ControlWordEnable",
        "type": "bool",
        "description": "Determines whether the control word is enabled for this pseudowire (PW).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Encapsulation",
        "type": "str",
        "description": "Specifies the encapsulation type for the pseudowire traffic.",
        "default": "PREFIX_FEC",
        "range_or_options": "ETHERNET_TAGGED_MODE ETHERNET CEM"
      },
      {
        "name": "GroupId",
        "type": "int",
        "description": "The group identifier for grouping related pseudowires together.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "InterfaceMtu",
        "type": "int",
        "description": "The maximum transmission unit (MTU) size for the interface.",
        "default": "1500",
        "range_or_options": "1-65535"
      },
      {
        "name": "IncludePwStatusTlv",
        "type": "bool",
        "description": "Determines whether to include PW status TLV in signaling messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PwStatusCode",
        "type": "list",
        "description": "List of predefined pseudowire status codes indicating current state or fault conditions.",
        "default": "['PW_NOT_FORWARDING']",
        "range_or_options": "PW_NOT_FORWARDING LOCAL_AC_RX_FAULT LOCAL_AC_TX_FAULT LOCAL_PSN_PW_RX_FAULT LOCAL_PSN_PW_TX_FAULT"
      },
      {
        "name": "UseCustomPwStatusTlv",
        "type": "bool",
        "description": "Indicates whether to use a custom pseudowire status code instead of standard ones.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomPwStatusCode",
        "type": "int",
        "description": "A custom numeric pseudowire status code when `UseCustomPwStatusTlv` is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PwCount",
        "type": "int",
        "description": "Number of pseudowires to be created under this FEC configuration.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Agi",
        "type": "str",
        "description": "Starting value for Agi (Attachment Group Identifier), formatted as IPv6 address.",
        "default": "100:1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "AgiStep",
        "type": "str",
        "description": "Increment step for Agi values across multiple pseudowires, formatted as IPv6 address.",
        "default": "0:1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "Saii",
        "type": "str",
        "description": "Starting value for Saii (Source Attachment Individual Identifier), formatted as IPv4 address.",
        "default": "10.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "SaiiStep",
        "type": "str",
        "description": "Increment step for Saii values, formatted as IPv4 address.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "Taii",
        "type": "str",
        "description": "Starting value for Taii (Target Attachment Individual Identifier), formatted as IPv4 address.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "TaiiStep",
        "type": "str",
        "description": "Increment step for Taii values, formatted as IPv4 address.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      }
    ],
    "description": "This function creates an LDP FEC 129 object using the provided session or the first session in a collection. It wraps the session-level method `create_fec_129`, passing along any keyword arguments. The LDP FEC 129 is commonly used to configure pseudowires (PWs) within an LDP-based network environment.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ldp | Port=${Port} |\n    | Edit Ldp | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Ingress} | Create Ldp Fec 129 | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.get_ldp_point_from_lsp",
    "return_type": "list",
    "return": "A list of LDP point objects associated with the provided LSP configurations. Each object represents a binding stream source or destination endpoint related to an LDP LSP configuration.",
    "parameters": [
      {
        "name": "Configs",
        "type": "object or iterable",
        "description": "A single configuration object or an iterable (e.g., list, set, tuple) of configuration objects representing LSPs for which the corresponding LDP points are to be retrieved.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the associated LDP (Label Distribution Protocol) points for the provided LSP (Label Switched Path) configurations. If a single configuration is provided, it is converted into a list for uniform processing. For each configuration in the list, the function retrieves the source-relative 'GenerateLdpLsp' object, representing the LDP point associated with the given LSP configuration.",
    "example": "| Get Ldp Point From Lsp | Configs=${IPv4EgressLsp} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.wait_ldp_state",
    "return_type": "bool",
    "return": "Returns True if all LDP sessions reach the specified state within the timeout period. If not, returns False and raises a ContinuableFailure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of LDP session objects whose 'State' attribute will be monitored until it reaches the target state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that each session's 'State' attribute must reach. If None or not provided, defaults to 'OPERATIONAL'.",
        "default": "'OPERATIONAL'",
        "range_or_options": "DISABLED NOT_STARTED NON_EXISTENT INITIAL OPEN_SENT OPEN_REC OPERATIONAL RESTARTING HELPING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the target state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'State' attribute of each LDP session in the provided list reaches the specified target state. This function monitors session states at regular intervals and raises an exception if the timeout is reached before all sessions reach the desired state. It is primarily used for testing or validation purposes in network test automation scenarios.",
    "example": "| Wait Ldp State | Sessions=${Sessions} | State=RESTARTING | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.establish_ldp",
    "description": "Establishes the LDP (Label Distribution Protocol) session(s) provided. This function accepts a single session object or an iterable of session objects and invokes the `establish()` method on each one to ensure all sessions are properly initialized.",
    "return_type": "bool",
    "return": "Always returns True to indicate successful establishment of all provided sessions. If any session fails to establish, it raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (e.g., list, set, tuple)",
        "description": "A single session object or an iterable containing multiple session objects. Each session object is expected to have an `establish()` method that will be invoked internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Establish Ldp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.stop_ldp_hello",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session object or iterable of Session objects (e.g., list, set, tuple)",
        "description": "A single session object or an iterable containing one or more session objects that support the `stop_hello()` method. If a single session is provided, it will be internally converted into a list for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function gracefully stops LDP hello session(s) by calling the `stop_hello()` method on each session object provided. It supports both individual session objects and iterables (lists, sets, tuples) of session objects for flexibility in usage. Internally, if a single session is passed, it is converted into a list to ensure consistent handling with multiple sessions.",
    "example": ".. code:: RobotFramework\n\n    | Stop Ldp Hello | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.stop_ldp_keepalive",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session or list or set or tuple",
        "description": "A single session object or an iterable (list, set, tuple) of session objects for which the LDP keepalive should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the LDP keepalive mechanism for one or more session objects. This function iterates through each session in the provided `Sessions` parameter and calls the `stop_keepalive()` method on it. If a single session is provided, it is converted into a list internally to ensure uniform processing. The function ensures that the LDP keepalive is properly stopped for all specified sessions.",
    "example": ".. code:: RobotFramework\n\n    | Stop Ldp Keepalive | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.resume_ldp_hello",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the operation. Returns False if an error occurs during the backend process.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or an iterable containing multiple session objects for which the LDP hello process should be resumed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the LDP hello process for one or more session objects. This method ensures that the input is in an iterable format (if not already), then iterates over each session and resumes the LDP hello message sending process by calling the `resume_hello()` method on each session object. The function is decorated with `@abnormal_check()`, which may perform additional checks or logging around abnormal conditions during execution.",
    "example": ".. code:: RobotFramework\n\n    | Resume Ldp Hello | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.resume_ldp_keepalive",
    "return_type": "bool",
    "return": "Returns True if the LDP keepalive mechanism was successfully resumed for all provided sessions, otherwise False (which will raise a ContinuableFailure in this implementation).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or an iterable collection of session objects that support the `resume_keepalive()` method. If a single non-iterable object is passed, it will be automatically wrapped in a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the LDP keepalive mechanism for one or more session objects. This function internally calls the `resume_keepalive()` method on each session object provided. If any session does not implement the required method or if called in an invalid context, exceptions may be raised by the backend function.",
    "example": ".. code:: RobotFramework\n\n    | Resume Ldp Keepalive | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.restart_ldp",
    "return_type": "bool",
    "return": "布尔值，表示LDP协议会话是否成功重启。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "LDP协议会话对象列表。每个对象应实现`restart()`方法以支持重启操作。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于重启一个或多个LDP（Label Distribution Protocol）会话。它接受一个会话对象的列表作为输入，并对每个会话调用`restart()`方法来执行重启操作。如果所有会话都成功重启，则返回True；否则抛出异常。",
    "example": ".. code:: RobotFramework\n\n    | Restart Ldp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.request_ldp_label",
    "return_type": "bool",
    "return": "Returns True if the LDP label request was successfully executed, otherwise False.",
    "parameters": [
      {
        "name": "Configs",
        "type": "Union[object, list, set, tuple]",
        "description": "A single LSP configuration object or an iterable (list, set, tuple) of LSP configuration objects. Each configuration must have a 'handle' attribute that uniquely identifies the LSP.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Sends an LDP label request for the specified LSP configurations. The function ensures that the input is properly formatted and compatible with the underlying implementation by converting single configuration objects into a list internally. It wraps the core LDP label request functionality and includes abnormal behavior checking via the `@abnormal_check()` decorator to handle or report errors during execution. If the result of the operation is False, a `ContinuableFailure` exception is raised to signal failure in a test framework context.",
    "example": ".. code:: RobotFramework\n\n    | Request Ldp Label | Configs=${Configs} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.abort_request_ldp_label",
    "return_type": "bool",
    "return": "Returns True if the abort command was successfully executed. If there is an error during execution, it may raise an exception or return False.",
    "description": "Abort a label request for one or more LDP configurations. This function wraps around the underlying `Ldp.abort_request_label` method and ensures that the input is properly formatted as a list before invoking the protocol engine. It raises a ContinuableFailure exception if the result is False to indicate failure while allowing continuation of test execution.",
    "example": "| Abort Request Ldp Label | Configs=${Configs} |",
    "parameters": [
      {
        "name": "Configs",
        "type": "Union[object, list, set, tuple]",
        "description": "A single LDP configuration object or an iterable (list, set, or tuple) of LDP configuration objects for which the label request should be aborted. Each configuration object must have a 'handle' attribute that uniquely identifies the LDP LSP configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": []
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.withdraw_ldb_label",
    "return_type": "bool",
    "return": "True if the label withdrawal operation was successfully initiated, False otherwise.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list or LdpLspConfig",
        "description": "A single LdpLspConfig object or an iterable (list, set, tuple) of LdpLspConfig objects representing the LDP LSPs for which label bindings should be withdrawn.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Withdraws one or more Label Distribution Binding (LDB) labels associated with specified LDP Label Switched Paths (LSPs). This function wraps around `Ldp.withdraw_lsp` and ensures that the input is always treated as a list of configurations. Each configuration must have a 'handle' attribute identifying the specific LSP. The function sends a command to the underlying protocol stack to remove the corresponding label bindings.",
    "example": "| Withdraw Ldp Label | Configs=${Configs} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.advertise_ldp_label",
    "return_type": "bool",
    "return": "布尔值，表示LDP标签通告操作是否成功执行。始终返回True，除非底层调用失败并抛出异常。",
    "parameters": [
      {
        "name": "Configs",
        "type": "list",
        "description": "LDP LSP配置对象的列表。每个对象必须包含一个唯一标识LSP的'handle'属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于通告LDP（Label Distribution Protocol）标签，基于提供的LSP配置发起或重新发起LDP标签分发过程。它封装了底层`Ldp.advertise_lsp`方法，并确保输入参数被正确转换为列表格式以兼容内部API。",
    "example": ".. code:: RobotFramework\n\n    | Advertise Ldp Label | Configs=${Configs} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.start_ldp",
    "return_type": "bool",
    "return": "True if LDP was successfully started for all provided sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of session objects for which the LDP protocol should be started. Each session must have a valid `start_ldp()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts the Label Distribution Protocol (LDP) on one or more session objects. If any session fails to start LDP, an exception is raised. This function internally calls the backend API to initiate the LDP protocol and returns a boolean indicating success or failure.",
    "example": ".. code:: RobotFramework\n\n    | Start Ldp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.stop_ldp",
    "return_type": "bool",
    "return": "True if the LDP session(s) are successfully stopped, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of LDP session objects to be stopped. Each object represents an active LDP session that will be terminated by this function.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function stops one or more Label Distribution Protocol (LDP) sessions provided in the 'Sessions' list. It internally calls a backend API method to perform the actual stopping operation and returns a boolean indicating the success of the operation. If the operation fails, it raises a ContinuableFailure exception.",
    "example": ".. code:: RobotFramework\n\n    | Stop Ldp | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.get_ldp_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回一个字典、DataFrame 或布尔值，表示LDP会话的统计信息。若仅匹配到一个会话，则返回键为统计项、值为对应数值的字典；若匹配多个会话，返回DataFrame；若无匹配结果则返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "一个或多个LDP会话对象，用于查询对应的统计信息。每个对象必须包含'Name'属性作为会话ID。若为None，则不进行会话过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "指定要获取的统计项列表。支持的统计项包括：TxAddressWithdraw, RxAddressWithdraw, TxAddress, RxAddress, TxDirectHello, RxDirectHello, TxInitialization, RxInitialization, TxKeepAlive, RxKeepAlive, TxLabelAbort, RxLabelAbort, TxLabelMapping, RxLabelMapping, TxLabelRelease, RxLabelRelease, TxLabelRequest, RxLabelRequest, TxLabelWithdraw, RxLabelWithdraw, TxNotification, RxNotification, TxTargetHello, RxTargetHello, TxIPv6DirectHello, RxIPv6DirectHello, TxIPv6TargetHello, RxIPv6TargetHello。",
        "default": "not_found",
        "range_or_options": "TxAddressWithdraw RxAddressWithdraw TxAddress RxAddress TxDirectHello RxDirectHello TxInitialization RxInitialization TxKeepAlive RxKeepAlive TxLabelAbort RxLabelAbort TxLabelMapping RxLabelMapping TxLabelRelease RxLabelRelease TxLabelRequest RxLabelRequest TxLabelWithdraw RxLabelWithdraw TxNotification RxNotification TxTargetHello RxTargetHello TxIPv6DirectHello RxIPv6DirectHello TxIPv6TargetHello RxIPv6TargetHello"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取LDP（Label Distribution Protocol）会话的统计信息。它封装了底层 `_get_statictis` 方法，并根据传入的会话对象和指定的统计项来检索数据。支持单个或多个会话查询，结果形式依据匹配数量自动判断并返回字典、DataFrame 或 False。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=LdpSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ldp Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.get_ldp_lsp_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary if one matching LDP LSP statistic row is found, a pandas DataFrame if multiple rows are found, or False if no data matches the criteria.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "Specifies the LDP session(s) to retrieve statistics for. Each session object is expected to have a `Name` attribute used as the index ('LdpSessionId'). If None, no session filter is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical items (columns) to retrieve from the 'LdpLspStatistic' data. Must be a subset of available properties such as FECInfo, FECType, LabelValue, LspMode, LspState, and LspType.",
        "default": "None",
        "range_or_options": "FECInfo FECType LabelValue LspMode LspState LspType"
      }
    ],
    "kwargs": [],
    "description": "Retrieves LDP LSP (Label Switched Path) statistical information for one or more LDP sessions. This function wraps the internal `_get_statictis` method to fetch statistics of type 'LdpLspStatistic', filtering by session identifiers and selecting specific statistical items if provided.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=LdpLspStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ldp Lsp Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ldp.edit_ldp_port_config",
    "return_type": "object or list",
    "return": "If a single port is passed, returns the modified LdpPortConfig object. If multiple ports are passed, returns a list of all modified LdpPortConfig objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list]",
        "description": "A single port object or a list of port objects whose LDP port configuration needs to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EstablishRate",
        "type": "int",
        "description": "LDP发送速率(messages/sec)",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "AdvertiseRate",
        "type": "int",
        "description": "会话建立速率(sessions/sec)",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "ReleaseRate",
        "type": "int",
        "description": "会话释放速率(sessions/sec)",
        "default": "100",
        "range_or_options": "1-10000"
      },
      {
        "name": "FecPerLdpMsg",
        "type": "int",
        "description": "Number of FECs per LDP message",
        "default": "65535",
        "range_or_options": "1-65535"
      }
    ],
    "description": "Edits the LDP (Label Distribution Protocol) port configuration for one or more specified ports. The function retrieves the 'LdpPortConfig' child object(s) associated with the provided port(s) and applies the given configuration changes using keyword arguments. If a single port is provided, it returns the updated configuration object directly; otherwise, it returns a list of all updated configuration objects. The function raises an exception if any port does not have an associated 'LdpPortConfig' child object or if invalid values are provided.",
    "example": "| Edit LDP Port Config | Ports=${Port} | TcpServerPort=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping",
    "return_type": "LspPing",
    "return": "The newly created and configured LspPing instance associated with the provided Port.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The port or upper layer object that this LspPing instance is associated with. This typically represents a network interface or communication endpoint.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Lsp Ping session name, used to identify the session for logging or reference purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the Lsp Ping session upon creation. If not specified, it defaults to True.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates and configures an LspPing instance associated with the specified port. This function initializes an LspPing configuration object using the provided Port as the upper layer reference. It also accepts optional keyword arguments to set additional configuration attributes on the LspPing instance. After creating and configuring the object, it is registered in the global protocol object map using its handle for future reference.",
    "example": "| Create Lsp Ping | Port=${Port} | Name=my_lsp_ping | Enable=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_echo_request",
    "return_type": "LspPingEchoRequestConfig or list of LspPingEchoRequestConfig",
    "return": "返回一个或多个Lsp Ping Echo Request配置对象，取决于输入的Session数量。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "LspPing or iterable of LspPing",
        "description": "要在其上发送LSP Ping Echo Request的一个或多个Lsp Ping会话对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OperationMode",
        "type": "list",
        "description": "操作模式，可以是PING和TRACE中的一种或多种。",
        "default": "['PING']",
        "range_or_options": "PING TRACE"
      },
      {
        "name": "ReplyMode",
        "type": "str",
        "description": "Echo Reply响应模式。",
        "default": "REPLYVIAUDP",
        "range_or_options": "NOTREPLY REPLYVIAUDP"
      },
      {
        "name": "PingInterval",
        "type": "int",
        "description": "Ping请求之间的时间间隔（单位：秒）。",
        "default": "4",
        "range_or_options": "1-65535"
      },
      {
        "name": "PingTimeOut",
        "type": "int",
        "description": "Ping请求超时时间（单位：秒）。",
        "default": "2",
        "range_or_options": "1-60"
      },
      {
        "name": "TraceInterval",
        "type": "int",
        "description": "Trace请求之间的时间间隔（单位：秒）。",
        "default": "120",
        "range_or_options": "1-65535"
      },
      {
        "name": "TraceTimeOut",
        "type": "int",
        "description": "Trace请求超时时间（单位：秒）。",
        "default": "2",
        "range_or_options": "1-60"
      },
      {
        "name": "InnerLabel",
        "type": "str",
        "description": "内层标签类型。",
        "default": "NONE",
        "range_or_options": "NONE LDPIPv4 VPNIPv4 SEGMENT_ROUTING"
      },
      {
        "name": "OuterLabel",
        "type": "str",
        "description": "外层标签类型。",
        "default": "NONE",
        "range_or_options": "NONE LDPIPv4 VPNIPv4 SEGMENT_ROUTING"
      },
      {
        "name": "TimeToLive",
        "type": "int",
        "description": "数据包生存时间（TTL值）。",
        "default": "255",
        "range_or_options": "1-255"
      },
      {
        "name": "ExpBits",
        "type": "int",
        "description": "实验比特位值，用于QoS标记。",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "PadMode",
        "type": "str",
        "description": "填充模式，控制如何处理填充字段。",
        "default": "WITHOUT_PAD",
        "range_or_options": "WITHOUT_PAD DROP_PAD COPY_PAD"
      },
      {
        "name": "Data",
        "type": "int",
        "description": "填充数据，范围0-255。",
        "default": "",
        "range_or_options": "0-255"
      },
      {
        "name": "DesIpv4Addr",
        "type": "str",
        "description": "目标IPv4地址。",
        "default": "\"127.0.0.1\"",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "ValidateFecStack",
        "type": "bool",
        "description": "是否校验FEC Stack。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DownstreamMappingTlvType",
        "type": "str",
        "description": "下游映射TLV类型。",
        "default": "DOWNSTREAM_DETAILED_MAPPING_TLV",
        "range_or_options": "DOWNSTREAM_MAPPING_TLV DOWNSTREAM_DETAILED_MAPPING_TLV"
      }
    ],
    "description": "该函数用于创建并发送LSP Ping Echo Request请求。它封装了底层每个会话对象的`echo_request`方法，并调用其来发送请求。如果提供的是单个会话，则直接返回结果；如果是多个会话，则返回包含每个会话结果的列表。此功能通常用于检测LSP路径连通性。",
    "example": "| ${LspPing} | Create Lsp Ping | Port=${Port} |\n| Create Lsp Ping Echo Request | Sessions=${LspPing} | OperationMode=['PING'] | ReplyMode=REPLYVIAUDP"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_fec_ldp_ipv4",
    "return_type": "LspPingFecLdpIpv4PrefixConfig or list of LspPingFecLdpIpv4PrefixConfig",
    "return": "A single configured LSP Ping FEC object for LDP IPv4 if one EchoRequest is provided, or a list of such objects in the same order as the input EchoRequests.",
    "parameters": [
      {
        "name": "EchoRequests",
        "type": "LspPingEchoRequestConfig or iterable of LspPingEchoRequestConfig",
        "description": "One or more EchoRequest objects to which the LDP IPv4 FEC configuration will be applied. If a single object is passed, it will be internally wrapped in a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Count",
        "type": "int",
        "description": "Number of FEC entries to create.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartAddr",
        "type": "str",
        "description": "Starting IPv4 address for the prefix range.",
        "default": "172.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Prefix length (subnet mask) for the IPv4 address.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "Increment step for generating subsequent IPv4 addresses in the range.",
        "default": "1",
        "range_or_options": "1-255"
      }
    ],
    "description": "This function creates and configures one or more LSP Ping FEC (Forwarding Equivalence Class) objects for LDP IPv4 based on the provided EchoRequest(s). For each EchoRequest, it sets the InnerLabel property to EnumFECLabel.LDPIPv4, associates the FEC with the EchoRequest, and applies additional configurations via keyword arguments. It wraps the LspPing.fec_ldp_ipv4 static method for simplified batch configuration.",
    "example": ".. code:: RobotFramework\n\n    | ${LspPing} | Create Lsp Ping | Port=${Port} |\n    | ${EchoRequest} | Create Lsp Ping Echo Request | Sessions=${LspPing} |\n    | Create Lsp Ping Fec Ldp Ipv4 | EchoRequests=${EchoRequest} | Count=5 | StartAddr=192.168.1.1 | PrefixLength=24 | Step=1"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_fec_vpn_ipv4",
    "return_type": "LspPingFecVPNIpv4PrefixConfig or list of LspPingFecVPNIpv4PrefixConfig",
    "return": "A single configuration object if one EchoRequest is provided, or a list of configuration objects if multiple EchoRequests are provided. Each object represents the FEC configuration for its associated EchoRequest.",
    "parameters": [
      {
        "name": "EchoRequests",
        "type": "object or iterable of objects",
        "description": "One or more EchoRequest objects to associate with the FEC configuration. Each EchoRequest typically represents an LSP Ping echo request control packet.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Count",
        "type": "int",
        "description": "数量 (Number of prefixes to create).",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartAddr",
        "type": "str",
        "description": "IPv4地址 (Starting IPv4 address for the prefix generation).",
        "default": "\"172.0.0.1\"",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "前缀长度 (Subnet prefix length).",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "步长 (Increment step between generated addresses in network byte order).",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "RouteDistinguisher",
        "type": "str",
        "description": "路由标识 (RD value for the VPN route in standard format).",
        "default": "\"100:1\"",
        "range_or_options": "uint16:uint32 | ipv4:uint16 | uint32:uint16 | uint16.uint16:uint16"
      }
    ],
    "description": "创建并配置LSP Ping FEC（转发等价类）对象，用于表示VPN IPv4前缀。该函数接受一个或多个EchoRequest对象，并使用提供的可选关键字参数为每个EchoRequest配置FEC类型为VPN IPv4前缀。如果传递了多个EchoRequest，则返回相应的FEC配置对象列表；如果只传递了一个，则直接返回单个配置对象。",
    "example": "| ${LspPing} | Create Lsp Ping | Port=${Port} |\n| ${EchoRequest} | Create Lsp Ping Echo Request | Sessions=${LspPing} |\n| Create Lsp Ping Fec Vpn Ipv4 | EchoRequests=${EchoRequest} | Count=10 | StartAddr=192.168.1.1 | PrefixLength=24 | Step=1 | RouteDistinguisher=200:1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_fec_segment_routing",
    "return_type": "LspPingFecSrConfig or list of LspPingFecSrConfig",
    "return": "返回一个或多个Lsp Ping Fec Segment Routing配置对象，用于Segment Routing FEC的测试与验证。",
    "parameters": [
      {
        "name": "EchoRequests",
        "type": "LspPingEchoRequestConfig or iterable of LspPingEchoRequestConfig",
        "description": "一个或多个Echo Request对象，用于绑定Segment Routing FEC配置。每个对象必须支持`set_relatives`和`edit`方法，并且应关联有效的协议结构。",
        "default": "not_found",
        "range_or_options": "object / list"
      }
    ],
    "kwargs": [
      {
        "name": "IgpProtocol",
        "type": "str",
        "description": "指定FEC校验使用的IGP协议类型。",
        "default": "ISIS",
        "range_or_options": "OSPF ISIS"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "指定前缀数量，用于Segment Routing FEC中地址段的数量定义。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "PrefixAddrIncrement",
        "type": "int",
        "description": "指定地址步长，用于在生成多个前缀时按步长递增地址。",
        "default": "1",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "创建一个或多个Segment Routing Forwarding Equivalence Class (FEC)配置对象，绑定到提供的LSP Ping Echo Request实例上。该函数封装了底层的`LspPing.fec_segment_routing`方法，允许用户通过关键字参数自定义FEC行为。",
    "example": ".. code:: RobotFramework\n\n    | ${LspPing} | Create Lsp Ping | Port=${Port} |\n    | ${EchoRequest} | Create Lsp Ping Echo Request | Sessions=${LspPing} |\n    | Create Lsp Ping Fec Segment Routing | EchoRequests=${EchoRequest} | IgpProtocol=OSPF | PrefixCount=5 | PrefixAddrIncrement=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_fec_sr_prefix",
    "return_type": "LspPingFecSrDetailConfig or list of LspPingFecSrDetailConfig",
    "return": "If a single SR object is provided, returns the corresponding SR prefix FEC configuration object. If multiple SR objects are provided, returns a list of SR prefix FEC configuration objects in the same order as the input.",
    "parameters": [
      {
        "name": "Srs",
        "type": "object or list/tuple/set of objects",
        "description": "A single SR context object or an iterable (list, tuple, or set) of SR context objects for which SR prefix FEC configurations are to be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Prefix",
        "type": "str",
        "description": "The prefix address used in the SR prefix FEC configuration.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The length of the prefix address.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "The algorithm value used for routing decisions.",
        "default": "0",
        "range_or_options": "uint8"
      }
    ],
    "description": "This function creates and returns one or more SR prefix FEC (Forwarding Equivalence Class) configuration objects for LSP (Label Switched Path) Ping in the context of Segment Routing (SR). It wraps the static method `LspPing.fec_sr_prefix` and allows it to be used with either a single SR object or an iterable (list, tuple, or set) of SR objects. Each SR object passed will result in a corresponding SR prefix FEC configuration being created using the provided keyword arguments. The additional configuration parameters provided via `**kwargs` are directly forwarded to the `edit` method of each configuration object, allowing for dynamic customization of the SR prefix FEC settings.",
    "example": ".. code:: RobotFramework\n\n    | ${LspPing} | Create Lsp Ping | Port=${Port} |\n    | ${EchoRequest} | Create Lsp Ping Echo Request | Sessions=${LspPing} |\n    | ${Sr} | Create Lsp Ping Fec Segment Routing | EchoRequests=${EchoRequest} |\n    | Create Lsp Ping Fec Sr Prefix | Srs=${Sr} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.create_lsp_ping_fec_sr_adjacency",
    "return_type": "LspPingFecSrDetailConfig or list of LspPingFecSrDetailConfig",
    "return": "If a single SR object is provided, returns a single configured `LspPingFecSrDetailConfig` object. If multiple SR objects are provided, returns a list of corresponding configured `LspPingFecSrDetailConfig` objects.",
    "parameters": [
      {
        "name": "Srs",
        "type": "object or iterable of objects",
        "description": "A single SR object or an iterable (list, tuple, set) of SR objects to which the SR adjacency FEC configuration will be applied. Each SR object typically represents a Segment Routing context or configuration block.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "IsisSystemId",
        "type": "str",
        "description": "ISIS系统ID",
        "default": "00:00:94:00:00:01",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "IsisLanSystemId",
        "type": "str",
        "description": "ISIS LAN系统ID",
        "default": "00:00:00:00:00:00",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "IsisNeighborId",
        "type": "str",
        "description": "ISIS邻居ID",
        "default": "00:00:94:00:00:01",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "IsisNodeId",
        "type": "int",
        "description": "ISIS节点ID",
        "default": "0",
        "range_or_options": "uint8"
      },
      {
        "name": "OspfLinkType",
        "type": "str",
        "description": "OSPF链路类型",
        "default": "P2P",
        "range_or_options": "P2P TRANSITNETWORK STUBNETWORK VIRTUALLINK"
      },
      {
        "name": "OspfLinkId",
        "type": "str",
        "description": "OSPF链路ID",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "OspfLinkData",
        "type": "str",
        "description": "OSPF链路数据",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "LocalRouterId",
        "type": "str",
        "description": "本地路由器ID",
        "default": "192.168.1.1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "RemoteRouterId",
        "type": "str",
        "description": "远端路由器ID",
        "default": "192.168.1.1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "LocalInterfaceId",
        "type": "str",
        "description": "本地接口ID",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "RemoteInterfaceId",
        "type": "str",
        "description": "远端接口ID",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      }
    ],
    "description": "创建并配置用于LSP Ping操作的一个或多个SR（Segment Routing）邻接FEC（Forwarding Equivalence Class）配置。该函数是对`LspPing.fec_sr_adjacency`方法的封装，允许处理单个或多个SR对象的一致性配置。",
    "example": "| ${LspPing} | Create Lsp Ping | Port=${Port} |\n| ${EchoRequest} | Create Lsp Ping Echo Request | Sessions=${LspPing} |\n| ${Sr} | Create Lsp Ping Fec Segment Routing | EchoRequests=${EchoRequest} |\n| Create Lsp Ping Fec Sr Ajacency | Srs=${Sr} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.edit_lsp_ping_port_config",
    "return_type": "object or list of objects",
    "return": "If a single port is provided, returns the updated LspPingPortConfig object for that port. If multiple ports are provided, returns a list of all updated LspPingPortConfig objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list of objects",
        "description": "A single port object or a list of port objects for which the LSP Ping configuration needs to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "UpdateTransmitRate",
        "type": "int",
        "description": "The transmit rate used for testing, in units per second.",
        "default": "1000",
        "range_or_options": "1-10000"
      },
      {
        "name": "FrequencyPing",
        "type": "int",
        "description": "Time interval (in seconds) between consecutive Ping tests.",
        "default": "60",
        "range_or_options": "1-2147483647"
      },
      {
        "name": "FrequencyTrace",
        "type": "int",
        "description": "Time interval (in seconds) between consecutive Trace tests.",
        "default": "60",
        "range_or_options": "60-2147483647"
      }
    ],
    "description": "Edits the LSP Ping port configuration for one or more specified ports. This function retrieves the 'LspPingPortConfig' child object associated with each provided port and updates its attributes using the keyword arguments supplied. If a single port is provided, it returns the updated configuration directly; otherwise, it returns a list of all updated configurations.",
    "example": "| Edit Lsp Ping Port Config | Ports=${Port} | FrequencyTrace=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.start_lsp_ping",
    "return_type": "bool",
    "return": "Returns True if LSP Ping is successfully initiated on all provided sessions, otherwise returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "LspPing or list or tuple or set",
        "description": "A single session object or an iterable (list, tuple, or set) of LspPing session objects on which to start the LSP ping operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the Label Switched Path (LSP) Ping operation on one or more provided session objects. It wraps the `start_lsp_ping()` method of individual session objects and applies it uniformly across all provided sessions. If a single session is provided, it will be converted into a list internally for uniform processing. The function ensures that the LSP Ping is started on each session and returns True only if all operations are successful; otherwise, it returns False.",
    "example": "| Start Lsp Ping | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.stop_lsp_ping",
    "return_type": "bool",
    "return": "布尔值，表示LSP Ping停止操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, tuple, set)",
        "description": "要停止的LSP Ping会话对象或会话对象的集合。可以是单个会话对象、列表、元组或集合。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于停止一个或多个LSP (Label Switched Path) Ping会话的操作。它接受一个会话对象或多个会话对象的集合，并统一处理以停止所有提供的会话中的LSP Ping消息发送。如果任何会话调用失败，将抛出ContinuableFailure异常；若全部成功，则返回True。",
    "example": "| Stop Lsp Ping | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.pause_lsp_ping",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution. Returns False if the backend operation fails, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session or list/tuple/set of Session",
        "description": "One or more session objects for which the LSP (Label Switched Path) ping should be paused.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Pauses the LSP (Label Switched Path) ping operation for the specified session(s). This function accepts a single session or a collection of sessions (list, tuple, or set). If a single session is provided, it is internally converted into a list. The function then iterates over the sessions and calls `pause_lsp_ping()` on each one. If the operation fails at the backend, it raises a `ContinuableFailure` exception with an appropriate error message.",
    "example": "| Pause Lsp Ping | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.resume_lsp_ping",
    "return_type": "bool",
    "return": "Returns True if the LSP ping is successfully resumed for all provided sessions, otherwise False (which raises an exception in the wrapper).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list/tuple/set)",
        "description": "A single session object or a collection of session objects for which the LSP ping should be resumed. Each session must support the `resume_lsp_ping` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the LSP (Label Switched Path) ping operation for one or more specified session(s). This function ensures uniform processing by wrapping a single session into an iterable if necessary and calls the backend's `resume_lsp_ping` method on each session. If any session fails to resume the ping, the backend returns False, which triggers an exception in the wrapper code.",
    "example": "| Resume Lsp Ping | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.pause_lsp_trace",
    "return_type": "bool",
    "return": "A boolean value indicating the success of the operation. Returns True if the LSP trace was paused successfully, and raises an exception otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session or iterable of Sessions (list, tuple, set)",
        "description": "The Session object(s) for which the LSP trace needs to be paused. Can be a single session or multiple sessions in an iterable.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Pauses the LSP (Label Switched Path) trace for the given session(s). This function accepts a single session or a collection of sessions (such as list, tuple, or set). If a single session is provided, it is converted into a list for uniform processing. The function then iterates over each session and calls the `pause_lsp_trace` method on it. If the backend operation returns False, a ContinuableFailure exception is raised; otherwise, it returns True.",
    "example": "| Pause Lsp Trace | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.resume_lsp_trace",
    "return_type": "bool",
    "return": "Returns True after successfully resuming the LSP trace for all provided sessions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, tuple, set)",
        "description": "A single session object or an iterable containing session objects for which the LSP trace should be resumed. Each session is expected to have a `resume_lsp_trace()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the LSP (Label Switched Path) trace for the given session(s). This function supports both a single session and multiple sessions passed as a list, tuple, or set. If a single session is provided, it is internally converted into a list for uniform processing. The function then iterates through each session and invokes its `resume_lsp_trace()` method. It returns True upon successful execution across all provided sessions.",
    "example": "| Resume Lsp Trace | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.wait_lsp_state",
    "return_type": "bool",
    "return": "Returns True if all LSP sessions reach the specified state within the timeout; otherwise, it may raise an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "The LSP Ping session object(s) to monitor. This can be a single session or a list/set/tuple of sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or None",
        "description": "The target state that the LSP Ping session(s) should reach. If not provided, it defaults to 'UP'. Valid states are: DISABLE, NOTSTART, UP, DOWN.",
        "default": "UP",
        "range_or_options": "DISABLE NOTSTART UP DOWN"
      },
      {
        "name": "Interval",
        "type": "int or float",
        "description": "Polling interval (in seconds) for checking session state updates.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or float",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more LSP Ping session(s) to reach a specified state (e.g., UP, DOWN). The function polls each session at regular intervals until either all sessions reach the desired state or the timeout is reached. If the timeout occurs before reaching the expected state, the function may raise an exception depending on internal implementation logic.",
    "example": "| Wait Lsp State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.wait_lsp_ping_state",
    "return_type": "bool",
    "return": "Returns True if all LSP ping sessions reach the target state within the timeout. If any session fails to reach the desired state, or if an error occurs, it raises a Failure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "One or more LSP Ping session objects to monitor for reaching the specified state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the LSP ping sessions are expected to reach. If None, may wait for a default final state depending on implementation.",
        "default": "PAUSE_SEND",
        "range_or_options": "IDLE PAUSE_SEND RESUME_SEND"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval (in seconds) between consecutive checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more LSP (Label Switched Path) ping sessions to reach a specified state. The function polls each session at regular intervals until all sessions reach the desired state or the timeout is reached. Supported states include IDLE, PAUSE_SEND, and RESUME_SEND. If any session does not reach the desired state within the timeout, a Failure exception is raised.",
    "example": "| Wait Lsp Ping State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.wait_lsp_trace_state",
    "return_type": "bool",
    "return": "Returns True if all provided LSP Ping sessions reach the specified trace state within the timeout; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "The LSP Ping session object(s) to monitor for the trace state change. If a single session is provided, it will be automatically wrapped in a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or None",
        "description": "The target state that the LSP Trace message must reach. If None, waits for a default condition defined by the backend implementation.",
        "default": "None",
        "range_or_options": "IDLE PAUSE_SEND RESUME_SEND"
      },
      {
        "name": "Interval",
        "type": "int or float",
        "description": "Polling interval in seconds to check the LSP trace state status.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or float",
        "description": "Maximum time in seconds to wait for the LSP trace state to reach the desired state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for one or more LSP (Label Switched Path) Ping sessions' trace state to reach a specified condition. It internally calls the backend method `renix.wait_lsp_trace_state` and raises an exception if the result is False. The supported states include IDLE, PAUSE_SEND, and RESUME_SEND. Polling occurs at regular intervals until the target state is reached or the timeout is exceeded.",
    "example": "| Wait Lsp Trace State | Sessions=${Sessions} | State=PAUSE_SEND | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.get_lsp_ping_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "统计结果，如果找到唯一匹配的会话则返回包含所需统计项的字典；若找到多行匹配，则返回pandas DataFrame；若无匹配结果则返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object / list / set / tuple / None",
        "description": "LSP Ping会话对象或其集合，用于指定要获取统计信息的一个或多个会话。支持多种输入类型：None表示不进行过滤，单个会话对象或其集合（列表、集合、元组）。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list / str / None",
        "description": "需要获取的统计项目列表，可选值包括TxEchoRequest, RxEchoRequest, TxEchoReply, RxEchoReply。也可以传入字符串，函数内部将其转换为单元素列表。若为None，则获取所有可用统计项。",
        "default": "not_found",
        "range_or_options": "TxEchoRequest RxEchoRequest TxEchoReply RxEchoReply"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取LSP Ping会话的统计信息，如发送和接收的Echo请求与响应数量。它根据提供的会话标识符和指定的统计项从底层系统中检索数据，并返回结构化的结果。支持灵活的输入格式，适用于自动化测试和性能监控场景。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxEchoRequest | RxEchoReply |\n    | Subscribe Result | Types=LspPingSessionStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Lsp Ping Session Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.get_lsp_ping_echo_request_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "统计结果返回类型取决于匹配的行数：\n- 如果只有一行匹配，返回一个字典，键为统计项名，值为对应的统计值；\n- 如果有多行匹配，返回一个 pandas DataFrame，列对应请求的 StaItems；\n- 如果没有匹配结果，返回 False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "用于过滤统计数据的会话对象或多个会话对象的集合。如果为 None，则不根据会话进行过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EchoRequest",
        "type": "object or list/set/tuple of objects or None",
        "description": "用于过滤统计数据的 Echo Request 对象或多个对象的集合。如果为 None，则不根据 Echo Request 进行过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "要获取的统计项目（列）。如果为 None，默认获取所有可用列。支持的统计项包括：FailCount, SuccessCount, FecInfo, MaxPingLatency, AvgPingLatency, MinPingLatency, RxReturnCode。",
        "default": "not_found",
        "range_or_options": "FailCount SuccessCount FecInfo MaxPingLatency AvgPingLatency MinPingLatency RxReturnCode"
      }
    ],
    "description": "该函数用于获取 LSP Ping Echo Request 的统计信息。它是一个封装了 `_get_statictis` 方法的接口，专门用于查询 'LspPingEchoRequestStats' 类型的统计数据。函数通过传入的 Session 和 EchoRequest 参数提取其 Name 属性，并作为索引过滤条件（Idx）来查询统计数据。可以指定需要获取的统计项 StaItems。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | FailCount | SuccessCount |\n    | Subscribe Result | Types=LspPingEchoRequestStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Lsp Ping Echo Request Statistic | Session=${Session} | EchoRequest=${EchoRequest} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.lsp_ping.get_lsp_trace_echo_request_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to the requested statistical items if exactly one matching row is found. If multiple rows match, returns a pandas DataFrame. Returns False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "A session object or collection of session objects used to filter statistics by session. If an object is provided, its `Name` attribute is used as the session ID. If a collection is passed, the `Name` attributes of all elements are used. If None, no filtering is applied based on session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EchoRequest",
        "type": "object or list/set/tuple of objects or None",
        "description": "An echo request object or collection of echo request objects used to filter statistics by group. If an object is provided, its `Name` attribute is used as the group ID. If a collection is passed, the `Name` attributes of all elements are used. If None, no filtering is applied based on group.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from the statistic data. If None, all available properties are queried automatically. If a string is provided, it is converted into a list containing that string. Must be a subset of the available statistical properties.",
        "default": "None",
        "range_or_options": "'FailCount' 'SuccessCount' 'FecInfo' 'MaxPingLatency' 'AvgPingLatency' 'MinPingLatency' 'RxReturnCode'"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data related to LSP (Label Switched Path) trace echo requests based on provided filters. This function is typically used after subscribing to relevant results and starting the protocol to gather statistics over time.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | MinPingLatency | RxReturnCode |\n    | Subscribe Result | Types=LspPingEchoRequestStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Lsp Trace Echo Request Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.create_mld",
    "return_type": "Mld",
    "return": "MLD协议会话对象, 类型为object",
    "parameters": [
      {
        "name": "Port",
        "type": "Port",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "MLD协会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能MLD协议会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "版本",
        "default": "MLDV1",
        "range_or_options": "MLDV1 MLDV2"
      },
      {
        "name": "PackReports",
        "type": "bool",
        "description": "合并报告报文",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InitialJoin",
        "type": "bool",
        "description": "单个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustJoin",
        "type": "bool",
        "description": "多个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Robust值",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "UnsolicitedReportInterval",
        "type": "int",
        "description": "发送初始报文的时间间隔 (秒)",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "ForceLeave",
        "type": "bool",
        "description": "强制发送Leave报文",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TrafficClass",
        "type": "hex int",
        "description": "IP头的Traffic Class值",
        "default": "0xc0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "description": "创建并配置一个与指定端口关联的MLD（Multicast Listener Discovery）协议实例，并注册到全局协议对象映射中。该函数初始化一个新的Mld对象，使用提供的`Port`作为其父层，并应用通过`**kwargs`传入的额外配置参数。新创建的Mld实例将被添加到一个全局字典中，用于后续引用。",
    "example": "| Create Mld | Port=${Port} | Version=MLDV2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.edit_mld",
    "return_type": "bool",
    "return": "True if the attributes of the Session object were successfully updated; False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "The MLD protocol session object whose attributes are to be updated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "MLD协议会话名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能MLD协议会话",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "版本号，支持MLDV1和MLDV2",
        "default": "MLDV1",
        "range_or_options": "MLDV1 MLDV2"
      },
      {
        "name": "PackReports",
        "type": "bool",
        "description": "是否合并报告报文",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InitialJoin",
        "type": "bool",
        "description": "是否使用单个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustJoin",
        "type": "bool",
        "description": "是否使用多个初始报文加入组",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "设置Robust值，用于控制健壮性",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "UnsolicitedReportInterval",
        "type": "int",
        "description": "发送初始报文的时间间隔（秒）",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "ForceLeave",
        "type": "bool",
        "description": "是否强制发送Leave报文",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TrafficClass",
        "type": "hex int",
        "description": "IP头的Traffic Class值",
        "default": "0xc0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "description": "该函数用于更新提供的MLD协议会话对象(Session)的属性值。通过关键字参数传入需要修改的配置项，函数内部将这些配置应用到指定的会话对象上。如果操作成功则返回True，否则返回False。",
    "example": "| Edit Mld | Port=${Port} | Version=MLDV2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.wait_mld_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the expected MLD states within the timeout period. Raises an exception if timeout occurs before reaching the desired state.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or object",
        "description": "A single session object or an iterable (e.g., list) of MLD protocol session objects whose MLD state will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list",
        "description": "One or more acceptable values for the MLD state that the sessions are expected to reach. Defaults to ['MEMBER'].",
        "default": "['MEMBER']",
        "range_or_options": "'NONMEMBER' 'JOINING' 'MEMBER' 'LEAVING'"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of the current MLD state of the sessions.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired MLD states before raising a TesterException.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the MLD (Multicast Listener Discovery) state of each session reaches one of the specified target states. This function blocks execution until all given sessions reach one of the expected states or a timeout occurs. Internally, it calls `_wait_state` with appropriate parameters and determines whether to monitor the 'MldHostState' or 'State' attribute based on the session type (`MldProtocolConfig` or not). If the session's MLD state attribute is an Enum type, its name will be used for comparison. Each session's current state is logged via logging.info if it does not match any of the expected states.",
    "example": "| Wait Mld State | Sessions=${Sessions} | State=MEMBER | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.mld_send_report",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功完成（范围：True / False）",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of :obj:`Mld` or single :obj:`Mld`",
        "description": "MLD会话对象或其集合，支持单个会话或多个会话的列表、集合或元组。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于触发一个或多个MLD会话发送报告。如果传入的是单个会话对象，则会被转换为列表进行统一处理。函数内部会对每个会话调用 `send_report()` 方法。若任何元素没有 `send_report()` 方法，将抛出 TypeError。此方法最终返回布尔值，指示操作是否成功。",
    "example": ".. code:: RobotFramework\n\n    | Mld Send Report | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.mld_send_leave",
    "return_type": "bool",
    "return": "True if all sessions successfully sent the leave message; otherwise, False (though False raises an exception in the wrapper).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(Mld) or Mld",
        "description": "A single MLD session object or a collection of MLD session objects. Each session must support the `send_leave()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends a leave message for each MLD session provided in the `Sessions` parameter. It supports both single session objects and iterable collections of sessions (like lists, sets, or tuples). Internally, it calls the `send_leave()` method on each session. If any session does not have the `send_leave()` method, a TypeError is raised. The function returns True to indicate successful execution across all sessions.",
    "example": "| Mld Send Leave | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.mld_resend_report",
    "return_type": "bool",
    "return": "True if all session objects successfully resend their reports, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (e.g., list, set, tuple)",
        "description": "A single session object or an iterable of session objects. Each session object is expected to have a `resend_report()` method that will be invoked by this function.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function re-sends the MLD report for one or more session objects by calling their internal `resend_report()` method. If a single session is provided, it is internally converted into a list to simplify iteration. The function assumes each session object has a properly implemented `resend_report()` method. If any session fails to resend its report, the function returns False and raises a `ContinuableFailure` exception.",
    "example": "| Mld Resend Report | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.get_mld_host_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for MLD host sessions. If exactly one matching row is found, returns a dictionary with keys corresponding to `StaItems`. If multiple rows match the filters, returns a pandas DataFrame. If no matching result is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A session object or collection of session objects representing MLD host blocks. Each object must have a 'Name' attribute used as the index for fetching statistics. If None, no session filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available statistics are fetched. Supported values include: MldTxFrames, MldRxFrames, MldRxUnknownTypes, MldRxChecksumErrors, MldRxLengthErrors.",
        "default": "None",
        "range_or_options": "MldTxFrames MldRxFrames MldRxUnknownTypes MldRxChecksumErrors MldRxLengthErrors"
      }
    ],
    "kwargs": [],
    "description": "Retrieves MLD host statistics based on provided session(s) and statistical items. Internally wraps `_get_statistics()` and filters results by 'MldHostBlockId'. The function may return a dictionary, DataFrame, or False depending on the number of matches found in the results.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | MldTxFrames | MldRxFrames |\n    | Subscribe Result | Types=MldHostResults |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Mld Host Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.get_mld_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回一个字典、pandas DataFrame 或布尔值 False，具体取决于匹配的统计结果数量。如果只有一行匹配，则返回包含请求统计项及其对应值的字典；如果有多个匹配，则返回一个 DataFrame；如果没有匹配结果，则返回 False。",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects or None",
        "description": "指定要查询统计信息的一个或多个测试仪表端口对象。每个端口对象必须具有 `.Name` 属性用于标识。若为 None，则不进行端口过滤。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的 MLD 端口统计项列表。支持的统计项包括：MldTxFrames, MldRxFrames, MldTxV1Reports, MldStopListenGroups, MldTxV2Reports, MldTxV2ModeInclude, MldTxV2ModeExclude, MldTxV2ModeChangeToInclude, MldTxV2ModeChangeToExclude, MldTxV2ModeAllowNewSources, MldTxV2ModeBlockOldSources, MldRxV1Queries, MldRxV2Queries, MldRxGeneralQueries, MldRxGroupSpecificQueries, MldRxGroupAndSourceSpecificQueries, MldRxUnknownTypes, MldRxChecksumErrors, MldRxLengthErrors。若为 None，则获取所有可用统计项；若为字符串，则视为单个统计项的列表。",
        "default": "None",
        "range_or_options": "MldTxFrames MldRxFrames MldTxV1Reports MldStopListenGroups MldTxV2Reports MldTxV2ModeInclude MldTxV2ModeExclude MldTxV2ModeChangeToInclude MldTxV2ModeChangeToExclude MldTxV2ModeAllowNewSources MldTxV2ModeBlockOldSources MldRxV1Queries MldRxV2Queries MldRxGeneralQueries MldRxGroupSpecificQueries MldRxGroupAndSourceSpecificQueries MldRxUnknownTypes MldRxChecksumErrors MldRxLengthErrors"
      }
    ],
    "description": "该函数用于获取 MLD（Multicast Listener Discovery）协议在指定端口上的统计信息。它是一个对 `_get_statictis()` 的封装，专门用于查询 'MldPortAggregatedResults' 类型的统计结果。可以通过指定端口和统计项来过滤数据。函数内部可能调用底层接口刷新数据、翻页并处理分页结果。若未找到匹配结果则返回 False，否则根据匹配数量返回字典或 pandas DataFrame。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | MldTxFrames | MldRxFrames |\n    | Subscribe Result | Types=MldPortAggregatedResults |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Mld Port Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.create_mld_querier",
    "return_type": "MldQuerier",
    "return": "The created and configured MldQuerier instance associated with the given port, which can be used for further configuration or control of the MLD querier behavior.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The test instrument port object to which this MLD Querier protocol session is associated. This typically represents a physical or logical interface on the testing device.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the MLD Querier session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the MLD Querier protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "Specifies the version of the MLD protocol to use for the querier.",
        "default": "MLDV1",
        "range_or_options": "MLDV1 MLDV2"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Robustness variable used to determine how many queries must be missed before assuming a multicast listener has left.",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Query interval in seconds between general queries sent by the querier.",
        "default": "125",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ResponseInterval",
        "type": "int",
        "description": "Maximum response time in milliseconds advertised in query messages that listeners should use when sending responses.",
        "default": "10000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "StartupQueryCount",
        "type": "int",
        "description": "Number of queries to send at startup to discover initial multicast listeners.",
        "default": "2",
        "range_or_options": "1-255"
      },
      {
        "name": "LastMemberQueryInterval",
        "type": "int",
        "description": "Time interval in milliseconds between group-specific queries sent to check if there are any remaining listeners for a multicast group.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LastMemberQueryCount",
        "type": "int",
        "description": "Number of queries to send to verify if there are still members present in a multicast group before concluding no one is listening.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "IPv6TrafficClassValue",
        "type": "str",
        "description": "Sets the IPv6 Traffic Class field value in the IPv6 header for packets generated by the MLD querier.",
        "default": "0x0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "description": "Creates and configures an MLD (Multicast Listener Discovery) querier protocol session associated with a given port. The function initializes the MldQuerier object, sets its parent relationship through the provided `Port`, and applies optional keyword arguments to configure various aspects of the MLD querier behavior such as protocol version, query intervals, robustness variables, etc. It returns the configured MldQuerier instance which can be further manipulated for testing or simulation purposes.",
    "example": "| Create Mld Querier | Port=${Port} | Version=MLDV2 | Interval=60 | ResponseInterval=5000 | RobustnessVariable=3 | Enable=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.edit_mld_querier",
    "return_type": "bool",
    "return": "True if the attributes of the Session object were successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "MldQuerier",
        "description": "The MLD querier session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the MLD querier session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the MLD querier session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "Specifies the version of the MLD protocol to use.",
        "default": "MLDV1",
        "range_or_options": "MLDV1 MLDV2"
      },
      {
        "name": "RobustnessVariable",
        "type": "int",
        "description": "Robustness variable used to determine reliability in multicast group management.",
        "default": "2",
        "range_or_options": "2-255"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Query interval in seconds for general queries sent by the querier.",
        "default": "125",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ResponseInterval",
        "type": "int",
        "description": "Maximum delay in milliseconds before a response is sent after receiving a query.",
        "default": "10000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "StartupQueryCount",
        "type": "int",
        "description": "Number of initial queries sent when the querier starts up.",
        "default": "2",
        "range_or_options": "1-255"
      },
      {
        "name": "LastMemberQueryInterval",
        "type": "int",
        "description": "Time interval in milliseconds between last member queries.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LastMemberQueryCount",
        "type": "int",
        "description": "Number of queries sent to check for the presence of the last member.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "IPv6TrafficClassValue",
        "type": "str",
        "description": "Sets the IPv6 Traffic Class field value for packets sent by the querier.",
        "default": "0x0",
        "range_or_options": "0x0-0xff"
      }
    ],
    "description": "Edits and updates the attributes of an existing MLD querier session object using provided keyword arguments. This function allows modification of various configuration parameters such as enabling/disabling the session, setting protocol versions, intervals, robustness values, and traffic class settings.",
    "example": "| Edit Mld Querier | Session=my_mld_session | Version=MLDV2 | IPv6TrafficClassValue=0xff | Enable=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.apply_mld_querier",
    "return_type": "bool",
    "return": "A boolean indicating whether the MLD querier configuration was successfully applied to all session(s). Always returns True if no exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "The session object or collection of session objects to which the MLD querier configuration should be applied. Each session must have an `apply()` method that configures or activates the MLD querier.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Applies the MLD (Multicast Listener Discovery) querier configuration to the specified session(s). The function accepts a single session object or a collection of session objects (list, set, or tuple), and applies the configuration by calling the `apply()` method on each session. If any session fails to apply the configuration (i.e., its `apply()` method does not support this operation), a TypeError may be raised.",
    "example": ".. code:: RobotFramework\n\n    | Apply Mld Querier |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.wait_mld_querier_state",
    "return_type": "bool",
    "return": "Returns True if all MLD Querier sessions reach one of the desired states within the timeout period. Otherwise, returns False and raises a Failure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`MldQuerier`)",
        "description": "A list of MldQuerier session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list, optional",
        "description": "The target state(s) to wait for in the MldQuerier sessions. If not specified, defaults to 'UP'. Valid options are: NOTSTARTED, UP.",
        "default": "['UP']",
        "range_or_options": "NOTSTARTED UP"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "The polling interval (in seconds) between consecutive checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time (in seconds) to wait for all sessions to reach one of the expected states before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for each MldQuerier session in the provided list to transition into any of the specified target states. It periodically polls the sessions at a defined interval until all sessions have reached a matching state or the timeout is exceeded. If any session fails to reach a desired state within the timeout, a Failure exception is raised. This function internally calls `_wait_state` to perform the state monitoring logic.",
    "example": "| Wait Mld Querier State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.get_mld_querier_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for MLD querier sessions. If a single session is matched, returns a dictionary of results. If multiple sessions are matched, returns a pandas DataFrame containing all matching rows. Returns False if no matching data is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A session object or a collection of session objects representing the MLD querier(s) for which statistics are requested. Each session object must have a `Name` attribute. If None, no session filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items to retrieve. If None (default), all available properties will be queried. If a string is provided, it is treated as a single-item list. Must be a subset of supported statistical properties.",
        "default": "None",
        "range_or_options": "QuerierTxFrames QuerierRxFrames QuerierRxUnknownTypes QuerierRxChecksumErrors QuerierRxLengthErrors"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves MLD querier protocol session statistics based on the given session and selected statistical items. It wraps `_get_statistics()` to fetch MLD-specific querier statistics. The function supports filtering by one or more sessions and selecting specific statistics to return. Internally, it may refresh data via performance-based methods and uses database queries to retrieve the results.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | QuerierTxFrames | QuerierRxFrames |\n    | Subscribe Result | Types=MldQuerierResults |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Mld Querier Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.mld.edit_mld_port_config",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "测试仪表端口对象或其列表，这些端口必须包含'MldPortRateConfig'子对象以供编辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MldMaximumOutputRate",
        "type": "int",
        "description": "最大发包速率(包/秒)",
        "default": "100",
        "range_or_options": "1-1000000000"
      }
    ],
    "description": "该函数用于修改一个或多个指定端口上的MLD端口配置。它调用Renix后端API来对每个端口的'MldPortRateConfig'对象进行配置更新。支持设置最大发包速率，并返回操作是否成功的布尔值。",
    "example": ".. code:: RobotFramework\n\n    | Edit Mld Port Config | Ports=${Ports} | MldMaximumOutputRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.multicast.create_multicast_group",
    "return_type": "MldSelectMulticastGroupCommand",
    "return": "全局组播组对象, 类型：object",
    "parameters": [
      {
        "name": "Version",
        "type": "str",
        "description": "组播组IP版本，支持ipv4和ipv6",
        "default": "IPv4",
        "range_or_options": "ipv4 ipv6"
      }
    ],
    "kwargs": [
      {
        "name": "Count",
        "type": "int",
        "description": "组播组数量",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "组播组地址模式",
        "default": "RANGE",
        "range_or_options": "RANGE LIST RFC_4814"
      },
      {
        "name": "Start",
        "type": "str",
        "description": "组播组地址起始值",
        "default": "225.0.0.1 (IPv4) 或 ff1e::1 (IPv6)",
        "range_or_options": "not_found"
      },
      {
        "name": "Number",
        "type": "int",
        "description": "组播组地址数量",
        "default": "1",
        "range_or_options": "1-268435456"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "组播组地址步长",
        "default": "1",
        "range_or_options": "1-268435456"
      },
      {
        "name": "Prefix",
        "type": "int",
        "description": "组播组地址掩码",
        "default": "32 (IPv4), 128 (IPv6)",
        "range_or_options": "IPv4: 1-32; IPv6: 1-128"
      }
    ],
    "description": "创建并返回一个配置好的组播组对象，基于指定的IP版本（IPv4或IPv6）和相关配置参数。该函数通过关键字参数提供对组播组的详细配置，包括地址范围、数量、步长等。",
    "example": "| Create Multicast Group | Version=IPV4 | Start=225.0.1.1 | Number=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.multicast.create_memberships",
    "return_type": "object",
    "return": "组播协议和组播组绑定关系对象，类型为 `MldMembershipsConfig`。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`Mld`, `Igmp`",
        "description": "IGMP/MLD协会话对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "DeviceGroupMapping",
        "type": "str",
        "description": "主机和组播组映射关系。",
        "default": "MANYTOMANY",
        "range_or_options": "MANYTOMANY ONETOONE ROUNDROBIN"
      },
      {
        "name": "SourceFilterMode",
        "type": "str",
        "description": "源地址过滤模式。",
        "default": "EXCLUDE",
        "range_or_options": "INCLUDE EXCLUDE"
      },
      {
        "name": "UserDefinedSources",
        "type": "bool",
        "description": "自定义源地址。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SpecifySourcesAsList",
        "type": "bool",
        "description": "配置离散源地址。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SourceAddressList",
        "type": "list",
        "description": "离散源地址列表。",
        "default": "not_found",
        "range_or_options": "ipv4 or ipv6 string list"
      },
      {
        "name": "NumberOfSources",
        "type": "int",
        "description": "源地址个数。",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "StartingSourceIp",
        "type": "str",
        "description": "组播组起始源地址。",
        "default": "ipv4: 192.0.1.0, ipv6: 2000::1",
        "range_or_options": "ipv4 or ipv6 string"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "组跳变位。",
        "default": "ipv4: 32, ipv6: 128",
        "range_or_options": "ipv4: 1-32, ipv6: 1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "跳变步长。",
        "default": "1",
        "range_or_options": "0-16777215"
      }
    ],
    "description": "创建一个或多个组播协议和组播组的绑定关系对象。该函数通过调用底层会话对象的 `create_memberships` 方法来实现实际功能，并将任意参数传递给后端处理。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Mld | Port=${Port} |\n    | Create Memberships | Session=${Session} | Start=225.0.1.1 | DeviceGroupMapping=ONETOONE |"
  },
  {
    "method_name": "TesterLibrary.Protocol.multicast.binding_multicast_group",
    "return_type": "bool",
    "return": "A boolean indicating whether the binding operation was successful (True) or not (False).",
    "parameters": [
      {
        "name": "Session",
        "type": "object (`Mld` or `Igmp`)",
        "description": "The IGMP or MLD session object to which the multicast group will be bound. This must be a valid and existing session.",
        "default": "not_found",
        "range_or_options": "Mld Igmp"
      },
      {
        "name": "Memberships",
        "type": "object (`MldMembershipsConfig`)",
        "description": "An object representing the membership configuration, specifying which multicast groups the session should join. Typically includes group addresses and source filters.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MulticastGroup",
        "type": "object (`MldSelectMulticastGroupCommand`)",
        "description": "The global multicast group object that needs to be bound to the session. This usually contains details like the multicast group IP address.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Binds a global multicast group to an existing IGMP/MLD session using the specified memberships. This function is typically used in network testing scenarios to simulate or verify multicast communication behavior. Internally, it calls the backend implementation of `binding_multicast_group` and raises a failure exception if the operation returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Group} | Create Multicast Group | Version=IPV4 | Start=225.0.1.1 | Number=20 |\n    | ${Session} | Create Igmp | Port=${Port} | Version=IGMPV3 |\n    | ${Memberships} | Create Memberships | Session=${Session} | Start=225.0.1.1 | DeviceGroupMapping=ONETOONE |\n    | binding_multicast_group | Session=${Session} | Memberships=${Memberships} | MulticastGroup=${Group} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_switch",
    "return_type": "OpenFlowSwitch",
    "return": "The newly created and configured OpenFlowSwitch instance. This instance is also registered in the global protocol object map under its handle.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper-layer object (typically a port object) that this OpenFlowSwitch will be associated with.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TcpPort",
        "type": "int",
        "description": "TCP Port used for the OpenFlow switch connection.",
        "default": "6633",
        "range_or_options": "1-65535"
      },
      {
        "name": "ConnectionType",
        "type": "str",
        "description": "Type of connection to establish for the OpenFlow switch.",
        "default": "TCP",
        "range_or_options": "TCP TCP_TLS"
      },
      {
        "name": "EnableEchoRequest",
        "type": "bool",
        "description": "Whether to enable periodic echo requests to monitor connection health.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EchoRequestInterval",
        "type": "int",
        "description": "Interval (in seconds) between consecutive echo requests.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "OpenFlowVersion",
        "type": "str",
        "description": "The version of the OpenFlow protocol to use.",
        "default": "v1_3",
        "range_or_options": "v1_3"
      },
      {
        "name": "DPID",
        "type": "int",
        "description": "Datapath ID of the switch, uniquely identifying it in the network.",
        "default": "0",
        "range_or_options": "0-18446744073709551615"
      },
      {
        "name": "MaxBufferedPackets",
        "type": "int",
        "description": "Maximum number of packets the switch can buffer.",
        "default": "65535",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MaxTableCount",
        "type": "int",
        "description": "Maximum number of flow tables supported by the switch.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Capabilities",
        "type": "int",
        "description": "Bitmap representing the capabilities of the switch.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Creates and configures an OpenFlowSwitch instance associated with the given port. The function initializes a new OpenFlowSwitch object with the specified `Port` as its parent object. Any additional configuration parameters provided via keyword arguments (`**kwargs`) are passed directly to the OpenFlowSwitch constructor and used to set corresponding attributes on the newly created instance, if they exist. After creation, the switch is registered in a global mapping using its handle for future access.",
    "example": "| Create Openflow Switch | Port=${Port} | TcpPort=6653 | ConnectionType=TCP_TLS | EnableEchoRequest=True | EchoRequestInterval=10 | OpenFlowVersion=v1_3 | DPID=1 | MaxBufferedPackets=10000 | MaxTableCount=200 | Capabilities=3 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_controller",
    "return_type": "OpenFlowController",
    "return": "The newly created and configured OpenFlow controller instance.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The port or upper layer object to associate the OpenFlow controller with. This typically represents a physical or logical test instrument port.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TcpPort",
        "type": "int",
        "description": "TCP Port number used for the OpenFlow connection.",
        "default": "6633",
        "range_or_options": "1-65535"
      },
      {
        "name": "ConnectionType",
        "type": "str",
        "description": "Type of transport protocol used for the OpenFlow communication.",
        "default": "TCP",
        "range_or_options": "TCP TCP_TLS"
      },
      {
        "name": "EnableEchoRequest",
        "type": "bool",
        "description": "Flag indicating whether periodic Echo Requests should be enabled.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EchoRequestInterval",
        "type": "int",
        "description": "Interval (in seconds) between consecutive Echo Requests if enabled.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "OpenFlowVersion",
        "type": "str",
        "description": "Specifies the version of the OpenFlow protocol to be used.",
        "default": "v1_3",
        "range_or_options": "v1_3"
      },
      {
        "name": "BarrierRequestTimeout",
        "type": "int",
        "description": "Maximum time (in milliseconds) to wait for a Barrier Request response.",
        "default": "10000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MaxFlowRate",
        "type": "int",
        "description": "Maximum rate at which flows can be added or modified.",
        "default": "4294967295",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Creates and configures an OpenFlow controller associated with the specified port. This function initializes an instance of the `OpenFlowController` class using the provided `Port` as the upper layer object. Additional configuration attributes can be passed via keyword arguments (`**kwargs`). The newly created OpenFlow controller is then mapped in a global dictionary using its handle for future reference.",
    "example": ".. code:: RobotFramework\n\n    | Create Openflow Controller | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.wait_openflow_switch_state",
    "return_type": "bool",
    "return": "Returns True if all provided OpenFlow switch sessions reach the specified state within the timeout; otherwise False, depending on the underlying implementation.",
    "description": "Waits for one or more OpenFlow switch protocol sessions to reach a specified state (e.g., IDLE, RUNNING, STOPPED, DISABLED) within a given timeout. This function internally calls the backend method that polls each session's state periodically until the target state is achieved or the timeout is reached.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(OpenFlowSwitch)",
        "description": "A list of OpenFlow switch session objects to monitor. If a single session is passed, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state to wait for each session to reach. If None, waits for any state change. Supported values include: IDLE, RUNNING, STOPPED, DISABLED.",
        "default": "'RUNING'",
        "range_or_options": "IDLE RUNING STOPPED DISABLED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval in seconds between successive checks for the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Wait Openflow Switch State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.wait_openflow_controller_state",
    "return_type": "bool",
    "return": "Returns True if all OpenFlow controller sessions reach the specified state within the timeout. Raises an exception if any session fails or times out.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(OpenFlowController)",
        "description": "A list of OpenFlow controller session objects to monitor. If a single session is provided, it will be internally converted into a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state to wait for each session to reach. If None, waits for a default state defined by the backend (typically RUNNING). Supported values include IDLE, RUNNING, STOPPED, and DISABLED.",
        "default": "RUNNING",
        "range_or_options": "IDLE RUNNING STOPPED DISABLED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks on session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for one or more OpenFlow controller sessions to transition into a specified state (e.g., IDLE, RUNNING, etc.). It periodically polls the sessions at a defined interval until either all sessions have reached the desired state or the timeout duration has been exceeded. This is useful for synchronization during setup, recovery, or testing phases.",
    "example": "| Wait Openflow Controller State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.edit_controller_desc",
    "return_type": "object or list",
    "return": "If a single session is provided, returns the result of the update on that session. If multiple sessions are provided, returns a list containing the results of the updates for each session in the order they were processed.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable of session objects whose controller descriptions are to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "IpAddress",
        "type": "str",
        "description": "IP Address",
        "default": "127.0.0.1",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "description": "Modifies the controller description for one or more session objects. This function accepts a single session object or a collection of session objects and updates their controller configuration using the provided keyword arguments. It ensures uniform handling of both single and multiple session inputs by converting the input to a list internally. Each session's controller configuration is updated by calling its `edit_controller_config` method with the provided arguments.",
    "example": "| Edit Controller Desc | Sessions=${Sessions} | IpAddress=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.edit_switch_desc",
    "return_type": "object or list",
    "return": "If a single session is provided, returns the result from editing its switch description configuration. If multiple sessions are provided, returns a list of results corresponding to each session's configuration update.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) of session objects for which the switch description configuration will be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "IpAddress",
        "type": "str",
        "description": "IP Address of the switch/controller session.",
        "default": "127.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "DPID",
        "type": "int",
        "description": "Datapath ID of the OpenFlow switch.",
        "default": "0",
        "range_or_options": "0-18446744073709551615"
      }
    ],
    "description": "Edits the switch description configuration for one or more session objects. This function wraps the `edit_switch_config` method of individual session objects and ensures uniform handling of both single and multiple session inputs by converting non-list session inputs into a list internally. The provided configuration changes (via keyword arguments) are applied to each session.",
    "example": "| Edit Switch Desc | Sessions=${Sessions} | IpAddress=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.openflow_start_vswitch",
    "return_type": "bool",
    "return": "Returns True if all sessions are successfully started; otherwise, False (but this triggers an exception in case of failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable containing multiple session objects. Each session must have a `start_vswitch()` method that handles the virtual switch startup logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function starts the virtual switch for one or more OpenFlow switch protocol session(s). It can accept either a single session object or a collection of sessions (such as list, set, or tuple). For each session provided, it calls the `start_vswitch()` method to initialize the virtual switch. If any session fails to start, the backend will handle the error, but the wrapper here raises a `ContinuableFailure` exception when the result is `False`. On successful execution, it returns True.",
    "example": "| Openflow Start Vswitch | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.openflow_stop_vswitch",
    "return_type": "bool",
    "return": "True if all virtual switches are stopped successfully, otherwise False (but raises exception on failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`OpenFlowSwitch`)",
        "description": "A list of OpenFlow switch session objects. Each object must have a `stop_vswitch()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the virtual switch associated with each session in the provided Sessions list. This function ensures that all given sessions are processed consistently by calling `stop_vswitch()` on each session object. If any session fails to stop the virtual switch, this function may raise an exception based on internal checks and decorators like `@abnormal_check()`.",
    "example": "| Openflow Stop Vswitch | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_action_list",
    "return_type": "OfpActionListConfig",
    "return": "An OpenFlow action list configuration object that can be used to define actions in an OpenFlow flow entry.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "Specifies whether the action list is a built-in configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "Indicates if this is a default configuration for the OpenFlow action list.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "创建openflow行动列表。该函数调用底层API来生成一个OpenFlow动作列表配置对象，可用于定义OpenFlow流条目中的操作。",
    "example": ".. code:: RobotFramework\n\n    | Create Openflow Action List |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_action",
    "return_type": "OfpActionConfig",
    "return": "The newly created and optionally configured OpenFlow action configuration object.",
    "parameters": [
      {
        "name": "ActionList",
        "type": "OfpActionListConfig",
        "description": "The parent or upper object (typically a list or container) to which the new OpenFlow action will be associated. This sets the 'upper' attribute of the OfpActionConfig.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of the OpenFlow action.",
        "default": "Output",
        "range_or_options": "Output CopyTtlOut CopyTtlIn SetMplsTtl DecMplsTtl PushVlan PopVlan PushMpls PopMpls SetQueue Group SetIPv4Ttl DecIPv4Ttl SetField PushPBB PopPBB Experimenter"
      },
      {
        "name": "PortNumber",
        "type": "int",
        "description": "Port Number for the action when applicable.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "ControllerMaxLength",
        "type": "int",
        "description": "Maximum length of data sent to controller (used with certain actions).",
        "default": "128",
        "range_or_options": "1-65535"
      },
      {
        "name": "GroupID",
        "type": "int",
        "description": "Group identifier used in group-related actions.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "QueueID",
        "type": "int",
        "description": "Queue identifier for queue-related actions.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "TTL",
        "type": "int",
        "description": "Time To Live value used in TTL-related actions.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Ethertype",
        "type": "int",
        "description": "EtherType value used in Ethernet frame processing.",
        "default": "33024",
        "range_or_options": "1-65535"
      },
      {
        "name": "FieldType",
        "type": "str",
        "description": "Specifies the field to manipulate when using SetField action.",
        "default": "InPort",
        "range_or_options": "InPort InPhyPort Metadata EthDstAddr EthSrcAddr EthType VlanID VlanPCP IpDscp IpEcn IpProtocol IPv4SrcAddr IPv4DstAddr TcpSrcPort TcpDstPort UdpSrcPort UdpDstPort SctpSrcPort SctpDstPort ICMPv4Type ICMPv4Code ArpOpcode ArpSpa ArpTpa ArpSha ArpTha IPv6SrcAddr IPv6DstAddr IPv6FlowLabel ICMPv6Type ICMPv6Code IPv6NdTarget IPv6NdSll IPv6NdTll MplsLabel MplsTc MplsBos PbbIsid TunnelID IPv6ExtHdr"
      },
      {
        "name": "FieldValue",
        "type": "list",
        "description": "Value to set for the specified field; elements must be integers between 0 and 255.",
        "default": "[]",
        "range_or_options": "List of integers in range 0-255"
      },
      {
        "name": "ExperimenterID",
        "type": "int",
        "description": "Vendor or experimenter identifier used in vendor-specific actions.",
        "default": "0",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "Creates and configures an OpenFlow action object within the RENIX API framework. This function initializes an OfpActionConfig object with the specified parent or upper object, and optionally configures its properties using additional keyword arguments.",
    "example": "| Create Openflow Action | ActionList=${actions} | Type=SetField | FieldType=EthSrcAddr | FieldValue=[0, 1, 2, 3, 4, 5] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_command_list",
    "description": "创建并配置一个OpenFlow命令列表对象，用于在RENIX API框架中管理OpenFlow测试场景。",
    "return_type": "OfpCommandListConfig",
    "return": "返回一个配置好的 OfpCommandListConfig 对象，可用于后续操作，例如添加命令或应用配置。",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "指定该命令列表是否为内建的。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "指定该命令列表是否为默认配置。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Create Openflow Command List |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_command",
    "return_type": "OfpControllerCommandConfig",
    "return": "A configured OpenFlow command object ready to be used.",
    "parameters": [
      {
        "name": "CommandList",
        "type": "OfpCommandListConfig",
        "description": "An object representing the list of commands to be configured. This serves as the upper layer for the created OfpControllerCommandConfig.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CmdType",
        "type": "str",
        "description": "Specifies the type of the OpenFlow command to be created.",
        "default": "AddFlow",
        "range_or_options": "ConfigSwitch ConfigTable AddFlow ModifyFlow DeleteFlow AddGroup ModifyGroup DeleteGroup AddMeter ModifyMeter DeleteMeter RoleRequest PacketOut Think LoopBegin LoopEnd"
      },
      {
        "name": "EnableBarrier",
        "type": "bool",
        "description": "Enables or disables the use of a barrier for the command.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StrictMatch",
        "type": "bool",
        "description": "Controls whether matching should be strict for flow modification/deletion commands.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "int",
        "description": "Additional flags for the command, if applicable.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ControllerMaxLength",
        "type": "int",
        "description": "Maximum length of data to send to the controller (e.g., for PacketOut commands).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TableID",
        "type": "int",
        "description": "The table ID associated with the command.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "OutGroup",
        "type": "int",
        "description": "Output group ID for operations that target a specific group.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "OutPort",
        "type": "int",
        "description": "Output port ID for operations that target a specific port.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DesiredRole",
        "type": "str",
        "description": "The desired role of the switch in the controller connection.",
        "default": "Equal",
        "range_or_options": "Equal Master Slave"
      },
      {
        "name": "GenerationID",
        "type": "int",
        "description": "Generation ID for ensuring consistency during role requests.",
        "default": "0",
        "range_or_options": "0-(2^64-1)"
      },
      {
        "name": "PacketData",
        "type": "hex",
        "description": "Hexadecimal representation of packet data (used primarily in PacketOut commands).",
        "default": "\"\"",
        "range_or_options": "十六进制数"
      },
      {
        "name": "LoopCount",
        "type": "int",
        "description": "Number of iterations for loop commands (e.g., LoopBegin).",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ThinkDuration",
        "type": "int",
        "description": "Duration in milliseconds for think commands to pause execution.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "FlowEntry",
        "type": "OfpFlowEntryConfig",
        "description": "Reference to an openflow flow entry object for commands that manipulate flows.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "GroupTable",
        "type": "OfpGroupTableConfig",
        "description": "Reference to an openflow group table object for commands that manipulate groups.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MeterTable",
        "type": "OfpMeterTableConfig",
        "description": "Reference to an openflow meter table object for commands that manipulate meters.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ActionList",
        "type": "OfpActionListConfig",
        "description": "Reference to an openflow action list object for commands that involve actions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and configures an OpenFlow command based on the provided parameters. It initializes an OfpControllerCommandConfig object using the given CommandList and applies additional configurations through keyword arguments. Supported keywords include both direct attributes (like CmdType, EnableBarrier) and relationships to other OpenFlow components (like FlowEntry, GroupTable, etc.). Any unsupported keyword is directly set as an attribute of the command object.",
    "example": "| Create Openflow Command | CommandList=${commands} | CmdType=AddFlow | TableID=1 | FlowEntry=${flow_entry} | EnableBarrier=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_flow_table",
    "return_type": "OfpFlowTableConfig",
    "return": "A configured instance of the OfpFlowTableConfig class representing the created OpenFlow flow table.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "Indicates whether the flow table is a built-in table.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "Indicates whether this is the default flow table.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ConfigId",
        "type": "int",
        "description": "The ID of the flow table configuration.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TableMissAction",
        "type": "str",
        "description": "Action to perform when there's no matching entry in the flow table.",
        "default": "Drop",
        "range_or_options": "Drop Continue Controller"
      }
    ],
    "description": "Creates and configures an OpenFlow flow table instance using the provided parameters. This function initializes an OfpFlowTableConfig object with the upper bound set to the system entry retrieved from the current session's cl_instance. Optional keyword arguments are used to customize the configuration, which are applied via the edit method of the OfpFlowTableConfig object. The configured flow table object is returned for further use or reference.",
    "example": "| Create Openflow Flow Table |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_flow_entry",
    "return_type": "OfpFlowEntryConfig",
    "return": "The configured OpenFlow flow entry object after applying all provided settings or False if the operation fails.",
    "parameters": [
      {
        "name": "FlowTable",
        "type": "OfpCommandListConfig",
        "description": "The upper-level flow table to associate this flow entry with. Typically an instance of a flow table configuration class.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Priority",
        "type": "int",
        "description": "The priority level of the flow entry, used for conflict resolution.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "IdleTimeout",
        "type": "int",
        "description": "The idle timeout in seconds for the flow entry, after which it will be removed if not matched.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HardTimeout",
        "type": "int",
        "description": "The hard timeout in seconds for the flow entry, after which it will be removed regardless of usage.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Cookie",
        "type": "int",
        "description": "An opaque controller-assigned identifier for the flow entry.",
        "default": "0",
        "range_or_options": "0-18446744073709551615"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "A list of flags that control behavior of the flow entry.",
        "default": "['SEND_FLOW_REM']",
        "range_or_options": "SEND_FLOW_REM CHECK_OVERLAP RESET_COUNTS NO_PKT_COUNTS NO_BYT_COUNTS"
      },
      {
        "name": "PacketInAction",
        "type": "str",
        "description": "Specifies the action to take when a packet matches this flow entry.",
        "default": "ApplyActions",
        "range_or_options": "ApplyActions AddFlow ModifyFlow"
      },
      {
        "name": "FlowStreamMatch",
        "type": "str",
        "description": "Field used for matching packets in the flow stream.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "InPort",
        "type": "int",
        "description": "The switch input port on which packets must arrive to match this flow entry.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "OutPort",
        "type": "int",
        "description": "The switch output port to which packets should be forwarded if they match this flow entry.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ActionList",
        "type": "OfpActionListConfig",
        "description": "A list of actions to be associated with this flow entry and linked via OfpGetActionList relationship.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamTemplate",
        "type": "StreamTemplate",
        "description": "Stream template to be bound to this flow entry via BoundStreamTemplate relationship.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamChannel",
        "type": "object",
        "description": "Stream channel to be bound to this flow entry via BoundStreamChannel relationship.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and configures an OpenFlow flow entry associated with the given flow table. This function initializes an OfpFlowEntryConfig object linked to the specified FlowTable and configures it using the provided keyword arguments. Special handling is applied for certain parameters such as 'ActionList', 'StreamTemplate', 'StreamChannel', and 'Flags', which are processed differently from standard attribute assignments. Uses `set_relatives` method to establish relationships for special components like action lists and stream bindings. Flag values are converted from string enum names to their numeric values and combined via bitwise OR (sum).",
    "example": "| Create Openflow Flow Entry | FlowTable=${flowtable} | Priority=100 | IdleTimeout=200 | HardTimeout=300 | Cookie=123456 | Flags=['CHECK_OVERLAP', 'RESET_COUNTS'] | PacketInAction=AddFlow | InPort=2 | OutPort=3 | ActionList=${action_list} | StreamTemplate=${stream_template} | StreamChannel=${stream_channel}"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_instruction",
    "return_type": "OfpInstructionConfig",
    "return": "A configured OpenFlow instruction object associated with the given flow entry and customized based on the provided keyword arguments.",
    "parameters": [
      {
        "name": "FlowEntry",
        "type": "OfpFlowEntryConfig",
        "description": "The flow entry to which this instruction belongs. It serves as the upper-level object in the configuration hierarchy.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of the instruction.",
        "default": "ApplyActions",
        "range_or_options": "GotoTable WriteMetadata WriteActions ApplyActions ClearActions ApplyMeter Experimenter"
      },
      {
        "name": "FlowTableID",
        "type": "int",
        "description": "The ID of the flow table for GotoTable instruction type.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Metadata",
        "type": "int",
        "description": "Metadata value for WriteMetadata instruction type.",
        "default": "0",
        "range_or_options": "0-(2^64-1)"
      },
      {
        "name": "MetadataMask",
        "type": "int",
        "description": "Metadata mask used in conjunction with Metadata for WriteMetadata instruction type.",
        "default": "0",
        "range_or_options": "0-(2^64-1)"
      },
      {
        "name": "MeterID",
        "type": "int",
        "description": "Meter ID for ApplyMeter instruction type.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ExperimenterID",
        "type": "int",
        "description": "Vendor or experimenter ID for Experimenter instruction type.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ActionList",
        "type": "OfpActionListConfig",
        "description": "An action list object associated with the instruction if applicable (e.g., WriteActions, ApplyActions).",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and configures an OpenFlow instruction associated with a given flow entry. The function initializes an OfpInstructionConfig object linked to the provided FlowEntry. Additional configuration parameters are passed via keyword arguments (kwargs). If 'ActionList' is provided in kwargs, it sets the relationship between the instruction and the action list. All other keyword arguments are directly set as attributes of the instruction configuration.",
    "example": "| Create Openflow Instruction | FlowEntry=${flowentry} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_match_field",
    "return_type": "OfpMatchFieldConfig",
    "return": "An instance of OfpMatchFieldConfig representing the created and optionally configured OpenFlow match field.",
    "parameters": [
      {
        "name": "FlowEntry",
        "type": "OfpFlowEntryConfig",
        "description": "The OpenFlow flow entry to which the match field will be attached. This serves as the parent context for the match field.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of the OpenFlow match field.",
        "default": "InPort",
        "range_or_options": "InPort InPhyPort Metadata EthDstAddr EthSrcAddr EthType VlanID VlanPCP IpDscp IpEcn IpProtocol IPv4SrcAddr IPv4DstAddr TcpSrcPort TcpDstPort UdpSrcPort UdpDstPort SctpSrcPort SctpDstPort ICMPv4Type ICMPv4Code ArpOpcode ArpSpa ArpTpa ArpSha ArpTha IPv6SrcAddr IPv6DstAddr IPv6FlowLabel ICMPv6Type ICMPv6Code IPv6NdTarget IPv6NdSll IPv6NdTll MplsLabel MplsTc MplsBos PbbIsid TunnelID IPv6ExtHdr"
      },
      {
        "name": "Value",
        "type": "list",
        "description": "A list of decimal integers (0-255) representing the value of the match field.",
        "default": "[]",
        "range_or_options": "0-255"
      },
      {
        "name": "Mask",
        "type": "list",
        "description": "A list of decimal integers (0-255) used as a bitmask for the match field value.",
        "default": "[]",
        "range_or_options": "0-255"
      },
      {
        "name": "ModifierType",
        "type": "str",
        "description": "Specifies the modifier behavior for generating multiple flows using this match field.",
        "default": "NONE",
        "range_or_options": "NONE Intra Inter"
      },
      {
        "name": "ModifierStep",
        "type": "list",
        "description": "A list of decimal integers (0-255) specifying how much to increment the field when generating multiple flows.",
        "default": "[]",
        "range_or_options": "0-255"
      },
      {
        "name": "ModifierCount",
        "type": "int",
        "description": "The number of times to apply the modifier, allowing generation of multiple values for this field.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "创建openflow流表匹配域对象。该函数为指定的OpenFlow流表项(FlowEntry)创建一个匹配域配置对象(OfpMatchFieldConfig)，并根据提供的关键字参数进行可选配置。此功能允许用户定义数据包头字段，用于流表规则的匹配条件。",
    "example": "| Create Openflow Match Field | FlowEntry=${flowentry} | Type=EthDstAddr | Value=[0x00, 0x11, 0x22, 0x33, 0x44, 0x55] | Mask=[0xff, 0xff, 0xff, 0xff, 0xff, 0xff] | ModifierType=Inter | ModifierStep=[0x01] | ModifierCount=10"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_group_table",
    "return_type": "OfpGroupTableConfig",
    "return": "The configured OfpGroupTableConfig object representing the created OpenFlow group table entry.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "Whether the group table is built-in or not.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "Whether the group table is marked as default.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ConfigId",
        "type": "int",
        "description": "Configuration ID for the group table, unique identifier.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "Type of the OpenFlow group table. Default is 'All'.",
        "default": "All",
        "range_or_options": "All Select Indirect FastFailover"
      }
    ],
    "description": "Creates and configures an OpenFlow group table entry in the system. This function initializes an OfpGroupTableConfig object linked to the system entry retrieved from the current RenixAPI instance. If additional configuration parameters are provided via keyword arguments, they are applied using the edit() method of the OfpGroupTableConfig object. The function returns the configured OfpGroupTableConfig object, allowing further inspection or manipulation.",
    "example": "| Create Openflow Group Table |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_action_bucket",
    "return_type": "OfpActionBucketConfig",
    "return": "配置好的OpenFlow组表行动桶对象。",
    "parameters": [
      {
        "name": "GroupTable",
        "type": "OfpGroupTableConfig",
        "description": "用于创建或配置OpenFlow组表行动桶的组表对象。该对象必须支持get_children方法以检索'OfpActionBucketConfig'类型的子对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Weight",
        "type": "int",
        "description": "设置行动桶的权重值，通常用于选择性转发场景中的优先级控制。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "WatchGroup",
        "type": "int",
        "description": "监控组ID，用于故障转移场景中指定备用组。",
        "default": "4294967295",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "WatchPort",
        "type": "int",
        "description": "监控端口ID，用于故障转移场景中指定备用端口。",
        "default": "4294967295",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ActionList",
        "type": "OfpActionListConfig",
        "description": "与该行动桶关联的OpenFlow行动列表对象。如果提供，则通过'OfpGetActionList'关系建立连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于创建或配置一个OpenFlow组表行动桶（action bucket）对象，并将其与提供的组表（GroupTable）相关联。它从组表中检索第一个'OfpActionBucketConfig'类型的子对象，并根据传入的关键字参数对其进行配置。若提供了ActionList，则会为该行动桶配置相应的行动列表。",
    "example": "| Create Openflow Action Bucket | GroupTable=${grouptable} | Weight=100 | WatchPort=1 | ActionList=${action_list}"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_meter_table",
    "return_type": "OfpMeterTableConfig",
    "return": "A configured instance of the OfpMeterTableConfig class representing the created OpenFlow meter table.",
    "description": "Creates and configures an OpenFlow meter table instance. This function initializes an OfpMeterTableConfig object with default values and allows optional configuration through keyword arguments.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "Indicates whether the meter table is built-in or user-defined.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "Specifies if the meter table is a default configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ConfigId",
        "type": "int",
        "description": "The ID assigned to the meter table configuration.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BandUnit",
        "type": "str",
        "description": "Determines the unit used for band rates, either kilobits (kb) or packets per second (pkt).",
        "default": "kb",
        "range_or_options": "kb pkt"
      },
      {
        "name": "EnableBurstSize",
        "type": "bool",
        "description": "Enables or disables burst size support in the meter table.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableStatistics",
        "type": "bool",
        "description": "Enables or disables statistics collection for the meter table.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Create Openflow Meter Table | Builtin=True | ConfigId=100 | BandUnit=kB | EnableBurstSize=True"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_meter_band",
    "return_type": "object",
    "return": "The configured OfpMeterBandConfig object after applying the provided settings.",
    "description": "创建openflow计量带宽对象。该函数用于在指定的MeterTable中获取或配置一个OpenFlow meter band，并根据提供的关键字参数更新其配置。",
    "parameters": [
      {
        "name": "MeterTable",
        "type": "object",
        "description": "openflow计量表，类型：object，必须支持get_children方法以检索关联的meter bands。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "Type of the meter band.",
        "default": "Drop",
        "range_or_options": "Drop DscpRemark Experimenter"
      },
      {
        "name": "Rate",
        "type": "int",
        "description": "Rate (per second) for the meter band.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BurstSize",
        "type": "int",
        "description": "Burst Size for the meter band.",
        "default": "10",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrecLevel",
        "type": "int",
        "description": "Drop Precedence Level for the meter band.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "ExperimenterID",
        "type": "int",
        "description": "Experimenter ID for the meter band when Type is Experimenter.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "example": "| Create Openflow Meter Band | MeterTable=${MeterTable} |",
    "note": "This function internally calls `renix.create_openflow_meter_band` to perform the actual configuration. If the operation fails, it raises a ContinuableFailure exception."
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_queue",
    "return_type": "OfpQueueConfig",
    "return": "A configured instance of the OfpQueueConfig class representing the created OpenFlow queue.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Builtin",
        "type": "bool",
        "description": "Whether the queue is built-in or user-defined.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IsDefault",
        "type": "bool",
        "description": "Whether the queue is a default queue.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ConfigId",
        "type": "int",
        "description": "The ID for the queue configuration.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Creates and configures an OpenFlow queue object within the RENIX API framework. This function initializes an OfpQueueConfig instance with session-specific data and optionally applies user-defined settings through keyword arguments. It serves as a factory method for generating queues used in traffic control scenarios during network testing.",
    "example": "| Create Openflow Queue |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.create_openflow_queue_property",
    "return_type": "OfpQueuePropertyConfig",
    "return": "An instance of OfpQueuePropertyConfig representing the configured OpenFlow queue property.",
    "parameters": [
      {
        "name": "Queue",
        "type": "OfpQueueConfig",
        "description": "The parent OpenFlow queue object to which this property will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of queue property. Determines how the queue is managed.",
        "default": "MinRate",
        "range_or_options": "MinRate MaxRate Experimenter"
      },
      {
        "name": "Rate",
        "type": "int",
        "description": "The rate value (in 1/1000) for the queue property, used with MinRate or MaxRate types.",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExperimenterID",
        "type": "int",
        "description": "The experimenter ID when Type is set to Experimenter.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExperimenterData",
        "type": "list",
        "description": "A list of bytes (0-255) providing additional data specific to the experimenter.",
        "default": "[]",
        "range_or_options": "List elements in range 0-255"
      }
    ],
    "description": "Creates and configures an OpenFlow queue property associated with a given OpenFlow queue object. This function initializes a new OfpQueuePropertyConfig instance linked to the provided Queue and allows optional configuration parameters via keyword arguments. The resulting configured queue property is returned.",
    "example": "| Create Openflow Queue Property | Queue=${Queue} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.get_openflow_controller_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回一个字典、pandas DataFrame 或布尔值 False。如果找到一行匹配的统计结果，则返回键为请求的统计项、值为对应统计值的字典；如果有多个匹配行，则返回包含所有匹配行的DataFrame；如果没有匹配结果，则返回 False。",
    "parameters": [
      {
        "name": "Controller",
        "type": "object or list/tuple/set of objects, optional",
        "description": "要查询其统计信息的一个控制器对象或一组控制器对象。每个对象必须具有 'Name' 属性。若为 None，则不在此阶段按控制器过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "指定要检索的统计项（列名）。如果为 None，则动态查询所有可用属性。如果传入字符串，则将其转换为包含该字符串的列表。必须是 OfpControllerStats 支持的统计属性的子集。",
        "default": "not_found",
        "range_or_options": "Duration ConnectedSwitchCount BarrierRequestCount BarrierReplyCount BarrierRequestTimeoutCount BarrierRemainingCount LastBarrierResponseTime MissPacketInCount MatchPacketInCount TotalPacketOutCount AddFlowCount ModifyFlowCount DeleteFlowCount FlowModErrorCount FlowRemovedCount AddGroupCount ModifyGroupCount DeleteGroupCount GroupModErrorCount AddMeterCount ModifyMeterCount DeleteMeterCount MeterModErrorCount RoleRequestCount RoleReplyCount"
      }
    ],
    "description": "根据指定的控制器和统计项获取 OpenFlow 控制器的统计信息。此函数调用内部方法 `_get_statictis` 来获取数据，支持查询特定的统计指标，并能根据提供的控制器进行过滤。输入的 Controller 参数会被转换为对应的控制器名称列表或单个名称。",
    "example": ".. code:: RobotFramework\n\n    | Get Openflow Controller Statistic | Controller=${Controller} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.openflow.get_openflow_switch_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for the specified OpenFlow switches. If a single switch matches, returns a dictionary with requested statistical items as keys. If multiple switches match, returns a pandas DataFrame. If no matching switch is found, returns False.",
    "parameters": [
      {
        "name": "Switch",
        "type": "object or list or set or tuple or None",
        "description": "The OpenFlow switch or switches to retrieve statistics for. If it's an object with a `Name` attribute, that name is used. If it's a collection of such objects, their names are extracted into a list. If None, no specific switch is targeted (may return all).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a list containing that string. Must be a subset of available properties.",
        "default": "None",
        "range_or_options": "Duration DPID ControllerRole CurrentGenerationID BarrierRequestCount BarrierReplyCount BarrierRequestTimeoutCount BarrierRemainingCount LastBarrierResponseTime MissPacketInCount MatchPacketInCount TotalPacketOutCount AddFlowCount AddFlowRate ModifyFlowCount ModifyFlowRate DeleteFlowCount DeleteFlowRate FlowModErrorCount FlowRemovedCount AddFlowSetupTime AddGroupCount AddGroupRate ModifyGroupCount ModifyGroupRate DeleteGroupCount DeleteGroupRate GroupModErrorCount AddMeterCount AddMeterRate ModifyMeterCount ModifyMeterRate DeleteMeterCount DeleteMeterRate MeterModErrorCount RoleRequestCount RoleReplyCount"
      }
    ],
    "kwargs": [],
    "description": "Retrieves OpenFlow switch statistics for specified switches and statistical items. This function gathers data related to OpenFlow switches by calling internal methods and supports retrieving statistics for one or more switches. It can automatically extract switch names from objects or collections. If no specific statistical items are given, all properties will be fetched. The result format depends on the number of matching switches: a dictionary for one, a DataFrame for multiple, and False if none are found.",
    "example": ".. code:: RobotFramework\n\n    | Get Openflow Switch Statistic | Switch=${Switch} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf",
    "return_type": "OspfRouter",
    "return": "The created OspfRouter instance representing the OSPFv2 protocol configuration.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent port or layer to which the OSPFv2 protocol will be attached. This typically represents the interface or port where the protocol will run.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "OSPFv2 session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the OSPFv2 protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AreaId",
        "type": "str",
        "description": "Area ID for the OSPFv2 session.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables or disables BFD (Bidirectional Forwarding Detection).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Specifies the network type for the OSPFv2 interface.",
        "default": "Broadcast",
        "range_or_options": "Broadcast P2P"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Sets the router priority used in DR/BDR elections.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Cost",
        "type": "int",
        "description": "Interface cost value used in route calculations.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "Authentication method for OSPF packets.",
        "default": "None",
        "range_or_options": "None Simple MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password when using Simple authentication.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5KeyId",
        "type": "int",
        "description": "MD5 key identifier for message authentication.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of optional flags that affect the operation of the OSPFv2 protocol.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "EnableOspfv2Mtu",
        "type": "bool",
        "description": "Enables or disables OSPF MTU negotiation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables or disables graceful restart functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GracefulRestartReason",
        "type": "str",
        "description": "Reason for initiating a graceful restart.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN SOFTWARE RELOADORUPGRADE SWITCH"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables or disables viewing of learned routes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval between Hello packets sent on the interface.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterDeadInterval",
        "type": "int",
        "description": "Time interval after which a neighbor is considered dead if no Hello packets are received.",
        "default": "40",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRetransInterval",
        "type": "int",
        "description": "Time interval for retransmitting unacknowledged LSA packets.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRefreshTime",
        "type": "int",
        "description": "Time interval after which an LSA is refreshed.",
        "default": "1800",
        "range_or_options": "1-1800"
      },
      {
        "name": "EnableSrManagement",
        "type": "bool",
        "description": "Enables or disables Segment Routing (SR) management.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates and initializes an OSPFv2 protocol configuration on the specified port. This function instantiates an OspfRouter object with the provided parent port and optional session context. It allows setting additional configuration parameters via keyword arguments. The created protocol object is then registered in a global mapping using its handle for future reference.",
    "example": "| Create Ospf | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.edit_ospf",
    "return_type": "bool",
    "return": "Returns True if the operation completes successfully, False otherwise.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or iterable",
        "description": "A single OSPFv2 session object or an iterable (list, set, tuple) of session objects to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the OSPFv2 session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the OSPFv2 protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AreaId",
        "type": "str",
        "description": "Specifies the Area ID for the OSPFv2 session.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables or disables Bidirectional Forwarding Detection (BFD) on the session.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Sets the network type for the interface.",
        "default": "Broadcast",
        "range_or_options": "Broadcast P2P"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Sets the priority value for the router in DR/BDR elections.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Cost",
        "type": "int",
        "description": "Defines the cost associated with sending packets on the interface.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "Specifies the authentication method used by the OSPFv2 session.",
        "default": "None",
        "range_or_options": "None Simple MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password used for simple authentication.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5KeyId",
        "type": "int",
        "description": "MD5 key identifier used for message authentication.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of options supported by OSPFv2.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "EnableOspfv2Mtu",
        "type": "bool",
        "description": "Enables or disables MTU negotiation for OSPFv2.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables or disables graceful restart functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GracefulRestartReason",
        "type": "str",
        "description": "Specifies the reason for initiating a graceful restart.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN SOFTWARE RELOADORUPGRADE SWITCH"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables or disables viewing of routing information.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Sets the interval at which Hello packets are sent.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterDeadInterval",
        "type": "int",
        "description": "Specifies the time interval after which a neighbor is considered down.",
        "default": "40",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRetransInterval",
        "type": "int",
        "description": "Time interval between retransmissions of LSA advertisements.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRefreshTime",
        "type": "int",
        "description": "Time interval before LSAs are refreshed.",
        "default": "1800",
        "range_or_options": "1-1800"
      },
      {
        "name": "EnableSrManagement",
        "type": "bool",
        "description": "Enables or disables Segment Routing (SR) management.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This function edits the configuration of one or more OSPFv2 protocol session objects by setting specified attributes dynamically during test execution. It supports modifying a wide range of parameters including basic enable/disable flags, network settings, authentication methods, timers, and advanced features like BFD, graceful restart, and SR.",
    "example": "| Edit Ospf | Session=${Session} | Enable=False | NetworkType=P2P | Cost=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_router_lsa",
    "return_type": "Ospfv2RouterLsaConfig",
    "return": "OSPFv2 Router LSA configuration object created by the session's `create_router_lsa` method.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "OSPFv2 protocol session object that provides context and connection to the underlying API or system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 Router LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable or disable the LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID of the router that originally advertised the LSA.",
        "default": "192.0.0.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "RouterType",
        "type": "list",
        "description": "Type of the router, which affects its role in the OSPF network.",
        "default": "['NONTBIT']",
        "range_or_options": "NONTBIT ABR ASBR VLE"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of optional capabilities supported by the router.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA age in seconds, indicating how long the LSA has been in the network.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int (hex)",
        "description": "Unique sequence number for LSA version control.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to enable checksum calculation for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv2 Router LSA (Link State Advertisement) using a provided session object and various configuration parameters. It internally calls the session’s `create_router_lsa` method with the specified arguments and returns the resulting LSA configuration object. If the operation fails, it raises a `ContinuableFailure` exception.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | Create Ospf Router Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_router_lsa_link",
    "return_type": "Ospfv2RouterLsaLinksConfig",
    "return": "The configured `Ospfv2RouterLsaLinksConfig` object representing the created router LS link.",
    "parameters": [
      {
        "name": "RouterLsa",
        "type": "Ospfv2RouterLsaConfig",
        "description": "The parent Router LSA object to which the new link will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the newly created OSPFv2 Router LSA Link.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the link is enabled or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LinkType",
        "type": "str",
        "description": "Specifies the type of the link.",
        "default": "P2P",
        "range_or_options": "P2P TRANSITNETWORK STUBNETWORK VIRTUALLINK"
      },
      {
        "name": "LinkId",
        "type": "str",
        "description": "The link state ID, an IPv4-like address string in the range 0.0.0.0 to 255.255.255.255.",
        "default": "192.0.0.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkData",
        "type": "str",
        "description": "Additional data for the link, also in the form of an IPv4-like address.",
        "default": "255.255.255.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "The cost metric associated with this link.",
        "default": "1",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Creates and configures a router link for an OSPFv2 Router LSA (Link State Advertisement). This function wraps an internal method to create and attach a new link to a given Router LSA object. It allows configuration of various properties such as link type, metric, and enable status using keyword arguments. If 'LinkType' is provided, it is transformed into an appropriate enumeration value internally. Other parameters are applied directly to the configuration object.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${RouterLsa} | Create Ospf Router Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_network_lsa",
    "return_type": "Ospfv2NetworkLsaConfig",
    "return": "OSPFv2 Network LSA对象，表示成功创建的链路状态通告配置。",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象，提供与底层网络栈交互的上下文和方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为创建的OSPFv2 Network LSA指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "控制是否启用该LSA。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "指定最初发布LSA的路由器ID。",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "DrIpAddress",
        "type": "str",
        "description": "指定DR（指定路由器）的IP地址。",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "子网掩码长度，用于定义网络前缀。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "一组可选标志位，用于控制OSPF LSA的行为。",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的生存时间（以秒为单位）。",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA的序列号，用于标识LSA更新版本。",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否启用校验和验证。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建一个OSPFv2 Network LSA（链路状态通告）对象。Network LSA描述了广播或NBMA网络段上的连接路由器集合，通常由该网络段的DR生成。此函数封装了会话对象中的`create_network_lsa`方法，提供了对LSA配置的抽象接口，并支持多种参数进行定制。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | Create Ospf Network Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_network_atch_router",
    "return_type": "Ospfv2NetworkAtchRouterConfig",
    "return": "A newly created and optionally configured OSPFv2 network-attached router configuration object linked to the provided Network LSA.",
    "description": "This function creates an OSPFv2 Network LSA Attached Router configuration object, associated with a given Network LSA. It allows optional configuration of properties such as name, enable status, and attached router IP address. This method wraps the internal API for integration into the test framework and ensures proper error handling upon failure.",
    "parameters": [
      {
        "name": "NetworkLsa",
        "type": "Ospfv2NetworkLsaConfig",
        "description": "The Network LSA (Link State Advertisement) that the network-attached router is associated with. This serves as the parent context for the new configuration object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 Network LSA Attached Router instance.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the attached router should be enabled or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AttachedRouter",
        "type": "str",
        "description": "IP address of the attached router in IPv4 format.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${NetworkLsa} | Create Ospf Network Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Network Lsa Atch Router | NetworkLsa=${NetworkLsa} | Metric=65535 |",
    "note": "Any additional keyword arguments beyond those listed will be passed directly to the underlying `edit` method of the created configuration object."
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_summary_lsa",
    "return_type": "Ospfv2SummaryLsaConfig",
    "return": "返回创建的OSPFv2 Summary LSA对象，类型为object。",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Summary LSA的名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该LSA",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "通告路由器ID，即最初发布LSA的路由器ID",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "要生成的路由数量",
        "default": "1",
        "range_or_options": "1-1000000"
      },
      {
        "name": "StartNetworkPrefix",
        "type": "str",
        "description": "起始网络前缀地址",
        "default": "192.0.1.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "子网掩码前缀长度（即网络前缀）",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "每次递增的步长值，用于批量生成路由",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "LSA度量值，表示路径开销",
        "default": "10",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "OSPF LSA选项字段，控制一些可选功能",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的老化时间，单位为秒",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA序列号，用于检测重复或旧版本LSA",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否启用校验和检查",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建一个OSPFv2 Summary LSA（链路状态广播）对象。Summary LSA在OSPF中用于在一个区域内部向其他区域传播汇总路由信息，从而减少链路状态数据库的大小并优化跨区域路由。此函数通过调用底层`renix.create_ospf_summary_lsa`方法实现，并在执行失败时抛出异常。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | Create Ospf Summary Lsa | Session=${Session} | Age=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_asbr_summary_lsa",
    "return_type": "Ospfv2AsbrSummaryLsaConfig",
    "return": "OSPFv2 Asbr Summary LSA configuration object, which contains metadata about the created LSA such as identifier, status, and associated attributes.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "An OSPFv2 protocol session object used to associate the ASBR summary LSA with a specific router session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 ASBR Summary LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the LSA is enabled or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "IP address of the router that originates this LSA (advertising router ID).",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "AsbrRouterId",
        "type": "str",
        "description": "IP address of the Autonomous System Boundary Router (ASBR) being summarized.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Cost metric associated with the summarized route.",
        "default": "10",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of OSPF LSA options flags that define additional properties of the LSA.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Time in seconds since the LSA was originated; used for aging control.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Unique sequence number to identify different instances of the same LSA.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether checksum calculation is enabled for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv2 ASBR (Autonomous System Boundary Router) Summary LSA (Link State Advertisement), which represents reachability information to an external route that is summarized at the area boundary. It allows configuring various parameters including advertising router, metric, options, and LSA header fields like age, sequence number, and checksum. The function wraps the backend method using a provided session object and supports keyword arguments for detailed configuration.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| Create Ospf Asbr Summary Lsa | Session=${Session} | Age=20 | Metric=100 | Enable=True | AdvertisingRouterId=2.2.2.2 | AsbrRouterId=3.3.3.3 | Options=['TOSBIT', 'MCBIT'] | Checksum=False |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_external_lsa",
    "return_type": ":obj:`Ospfv2ExternalLsaConfig`",
    "return": "OSPFv2 External LSA configuration object representing the created LSA.",
    "description": "创建OSPFv2 External LSA对象。该函数用于在OSPF测试会话中创建一个或多个外部LSA（Link-State Advertisement），通常用于模拟路由重分发行为。支持自定义LSA的多种属性，如类型、度量值、前缀等。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`OspfRouter`",
        "description": "OSPFv2协议会话对象列表，提供底层方法用于创建和管理LSA。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 External LSA的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能状态。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "通告路由器ID，即最初发布LSA的路由器ID。",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LsType",
        "type": "str",
        "description": "LSA类型。",
        "default": "ExtLsaLsType1",
        "range_or_options": "ExtLsaLsType1 ExtLsaLsType2"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "要生成的路由条目数量。",
        "default": "1",
        "range_or_options": "1-1000000"
      },
      {
        "name": "StartNetworkPrefix",
        "type": "str",
        "description": "起始网络前缀。",
        "default": "192.0.1.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "子网掩码长度，表示IP前缀长度。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "每次递增的步长值。",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "路由度量类型。",
        "default": "ExtLsaLsMetricType1",
        "range_or_options": "ExtLsaLsMetricType1 ExtLsaLsMetricType2"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "LSA的度量值。",
        "default": "10",
        "range_or_options": "1-16777215"
      },
      {
        "name": "ForwardingAddress",
        "type": "str",
        "description": "LSA中携带的转发地址。",
        "default": "192.0.1.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "RouterTag",
        "type": "int",
        "description": "路由标签，用于标记重分发的路由。",
        "default": "0",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "LSA选项标志位。",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的老化时间（单位：秒）。",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA的序列号，以十六进制表示。",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "LsaAutomaticConversion",
        "type": "bool",
        "description": "是否启用LSA自动转换功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否计算校验和。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| Create Ospf External Lsa | Session=${Session} | Age=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_te_lsa",
    "return_type": "Ospfv2TeLsaConfig",
    "return": "OSPFv2 TE LSA configuration object, used to reference or manipulate the created LSA in network testing scenarios.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "The OSPFv2 protocol session object used to create and manage the TE LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 TE LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the TE LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID that originally advertised the LSA.",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "TlvType",
        "type": "str",
        "description": "Type of TLV included in the LSA.",
        "default": "LsaLink",
        "range_or_options": "LsaRouter LsaLink"
      },
      {
        "name": "RouterId",
        "type": "str",
        "description": "Router ID associated with the LSA.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkId",
        "type": "str",
        "description": "Link ID for identifying the link associated with this LSA.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkType",
        "type": "str",
        "description": "Type of the link associated with this LSA.",
        "default": "LsaLink",
        "range_or_options": "LinkP2P LinkMultiaccess"
      },
      {
        "name": "Instance",
        "type": "int",
        "description": "Instance number for the LSA.",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Cost metric for the link represented by this LSA.",
        "default": "10",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of options flags for the LSA.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA's age in seconds.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int (hex)",
        "description": "LSA sequence number to detect old or duplicate LSAs.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to calculate and set the LSA checksum automatically.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv2 Traffic Engineering (TE) Link State Advertisement (LSA) configuration using the provided session and keyword arguments. It wraps the backend call to `Session.create_te_lsa`, allowing users to simulate and test various OSPF TE LSA scenarios in a network testing or simulation environment.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| Create Ospf Te Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.edit_ospf_te_lsa_link",
    "return_type": "bool",
    "return": "A boolean value indicating whether the operation was successful (True) or failed (False).",
    "parameters": [
      {
        "name": "TeLsa",
        "type": "Ospfv2TeLsaConfig",
        "description": "The OSPFv2 TE LSA object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 Te LSA Link object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the TE LSA link.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLocalIp",
        "type": "bool",
        "description": "Enables or disables the local IPv4 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LocalIp",
        "type": "str",
        "description": "Sets the local IPv4 address for the TE LSA link.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableRemoteIp",
        "type": "bool",
        "description": "Enables or disables the remote IPv4 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RemoteIp",
        "type": "str",
        "description": "Sets the remote IPv4 address for the TE LSA link.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableGroup",
        "type": "bool",
        "description": "Enables or disables the group ID configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Group",
        "type": "int",
        "description": "Sets the group ID for the TE LSA link.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMaxBandwidth",
        "type": "bool",
        "description": "Enables or disables the maximum bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximumBandwidth",
        "type": "int",
        "description": "Sets the maximum bandwidth value for the TE LSA link.",
        "default": "1000",
        "range_or_options": "0-16777215"
      },
      {
        "name": "EnableReservedBandwidth",
        "type": "bool",
        "description": "Enables or disables the reserved bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ReservableBandwidth",
        "type": "int",
        "description": "Sets the reservable bandwidth value for the TE LSA link.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableUnreservedBandwidth",
        "type": "bool",
        "description": "Enables or disables unreserved bandwidth configurations.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 0.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 1.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 2.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 3.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 4.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 5.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 6.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Sets unreserved bandwidth for priority level 7.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the Traffic Engineering (TE) link configuration of an OSPFv2 LSA (Link State Advertisement). This function modifies various parameters related to the TE LSA link, such as IP addresses, bandwidths, and enable/disable flags. It wraps around the backend method `OspfRouter.edit_te_lsa_link` and ensures that only the first LSA from a collection is used for modification.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${TeLsa} | Create Ospf Te Lsa | Session=${Session} | Age=20 |\n    | Edit Ospf Te Lsa Link | TeLsa=${TeLsa} | LocalIp=2.2.2.2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_opaque_router_info_lsa",
    "return_type": "Ospfv2OpaqueRouterInfoLsaConfig",
    "return": "OSPFv2 Opaque Router Info LSA对象，用于配置或操作该LSA实例。",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象，提供与API或设备的上下文连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Opaque Router Info LSA的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该LSA。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "指定最初发布LSA的路由器ID。",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "LSA选项标志列表。",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的生存时间（秒）。",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA的序列号。",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否计算校验和。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建一个OSPFv2 Opaque Router Info LSA对象。Opaque LSA用于扩展OSPF的功能，携带非标准定义的信息，例如流量工程、优雅重启等附加信息。",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_algorithm_tlv",
    "return_type": "Ospfv2SrAlgorithmTlvConfig",
    "return": "An instance of Ospfv2SrAlgorithmTlvConfig representing the created and configured SR Algorithm TLV associated with the provided Opaque Router Information LSA.",
    "parameters": [
      {
        "name": "OpaqueRouterInfoLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "The Opaque Router Information LSA object to which the SR Algorithm TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name for the newly created OSPFv2 SR Algorithm TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the SR Algorithm TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Algorithms",
        "type": "int",
        "description": "Specifies the algorithm type used by Segment Routing. This value is typically a numeric identifier for the algorithm.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and configures an OSPFv2 Segment Routing (SR) Algorithm TLV and associates it with the provided Opaque Router Information LSA. The SR Algorithm TLV is used in Segment Routing to specify supported algorithms for path computation within the network. It allows optional configuration through keyword arguments such as enabling/disabling the TLV, setting its name, or specifying algorithm identifiers.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| Create Ospf Sr Algorithm Tlv | OpaqueRouterInfoLsa=${Lsa} | Name=MySRAlgorithm | Enable=True | Algorithms=1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_sid_label_range_tlv",
    "return_type": "Ospfv2SidLabelRangeTlvConfig",
    "return": "OSPFv2 Sr Sid Label Range Tlv对象，表示创建的Segment Routing SID/Label范围TLV配置。",
    "parameters": [
      {
        "name": "OpaqueRouterInfoLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "提供用于配置SR SID/Label Range TLV的上下文的OSPFv2 Opaque Router Information LSA对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为新创建的OSPFv2 Sr Sid Label Range Tlv指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用或禁用该TLV。如果设置为True，则TLV生效；如果设置为False，则不生效。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SidLabelType",
        "type": "str",
        "description": "指定SID/Label的类型，可以是20位标签(Bit20)或32位SID(Bit32)。",
        "default": "Bit20",
        "range_or_options": "Bit20 Bit32"
      },
      {
        "name": "SidLabelBase",
        "type": "int",
        "description": "当使用Bit20时，表示起始标签值；当使用Bit32时，表示起始SID值。",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "SidLabelRange",
        "type": "int",
        "description": "指定要创建的SID/标签的数量。",
        "default": "0",
        "range_or_options": "1-16777215"
      }
    ],
    "description": "该函数用于在OSPFv2协议中创建一个SR（Segment Routing）SID/Label Range TLV，并将其关联到给定的Opaque Router Info LSA下。此TLV用于通告支持的SID或标签的范围。关键字参数允许进一步自定义TLV的配置。",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| Create Ospf Sr Sid Label Range Tlv | OpaqueRouterInfoLsa=${Lsa} | Name=MyTLV | Enable=True | SidLabelType=Bit32 | SidLabelBase=1000 | SidLabelRange=100"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_srms_preference_tlv",
    "return_type": "Ospfv2SrmsPreferenceTlvConfig",
    "return": "OSPFv2 Sr Srms Preference Tlv对象，用于配置Segment Routing Mapping Server的偏好值。",
    "parameters": [
      {
        "name": "OpaqueRouterInfoLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "指定该TLV将附加到的OSPFv2 Opaque Router Info LSA对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为创建的OSPFv2 Sr Srms Preference Tlv对象指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用或禁用该SRMS Preference Tlv功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Preference",
        "type": "int",
        "description": "设置路由器作为Segment Routing Mapping Server的优先级。",
        "default": "1",
        "range_or_options": "0-255"
      }
    ],
    "description": "该函数用于创建一个OSPFv2 Segment Routing SRMS (Segment Routing Mapping Server) Preference TLV配置对象。此TLV用于在OSPFv2协议中通告Segment Routing Mapping Server的优先级，以控制多个SRMS存在时的优选行为。该TLV通常用于Segment Routing网络中的映射服务器选择。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Sr Srms Preference Tlv | OpaqueRouterInfoLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_router_info_capability_tlv",
    "return_type": "Ospfv2RouterInfoCapabilityTlvConfig",
    "return": "返回一个配置好的OSPFv2 Router Info Capability TLV对象。",
    "description": "该函数用于创建并返回一个OSPFv2 Router Information Capability TLV配置对象。TLV（Type-Length-Value）结构用于OSPFv2路由信息链路状态通告（LSA）中，以描述特定的路由器能力信息。该函数会将生成的TLV与传入的Opaque Router Information LSA关联。",
    "parameters": [
      {
        "name": "OpaqueRouterInfoLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "要将TLV附加到的OSPFv2 Opaque Router Information LSA对象。这是必需参数，必须是有效的父对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "新创建的TLV对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "InfoCapability",
        "type": "int",
        "description": "指定TLV的能力值。",
        "default": "1",
        "range_or_options": "0-255"
      }
    ],
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| Create Ospf Router Info Capability Tlv | OpaqueRouterInfoLsa=${Lsa} | Enable=True | InfoCapability=5 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_fad_tlv",
    "return_type": ":obj:`Ospfv2FlexAlgoDefinitionTlvConfig`",
    "return": "OSPFv2 Sr Fad Tlv对象，用于表示创建的Segment Routing Forwarding Adjacency Descriptor TLV配置。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`OspfRouter`",
        "description": "OSPFv2协议会话对象，提供与测试设备或API后端通信的上下文和方法。必须实现create_sr_fad_tlv方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "OpaqueRouterInfoLsa",
        "type": ":obj:`Ospfv2OpaqueRouterInfoLsaConfig`",
        "description": "OSPFv2 Opaque Router Info LSA对象，通常包含来自路由器的Segment Routing能力信息。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Sr Fad Tlv的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否使能该TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "FlexAlgo",
        "type": "int",
        "description": "灵活算法ID，用于Segment Routing路径计算。",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "指定算路使用的度量类型。",
        "default": "IGP_METRIC",
        "range_or_options": "IGP_METRIC MIN_LINK_DELAY TE_METRIC"
      },
      {
        "name": "CalcType",
        "type": "int",
        "description": "指定特定IGP算法的计算类型。",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "指定该Sub-TLV的优先级。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlexAlgoSubTlv",
        "type": "list",
        "description": "选择灵活算法路径计算要遵循的约束条件。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN EXCLUDE_ADMIN INCLUDE_ANY_ADMIN INCLUDE_ALL_ADMIN DEFINITION_FLAGS EXCLUDE_SRLG"
      },
      {
        "name": "ExcludeAdmin",
        "type": "int",
        "description": "排除具有特定管理组的链路。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAnyAdmin",
        "type": "int",
        "description": "包括至少匹配一个指定管理组的链路。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAllAdmin",
        "type": "int",
        "description": "包括必须匹配所有指定管理组的链路。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DefinitionFlags",
        "type": "list",
        "description": "定义TLV标志位。",
        "default": "0x80",
        "range_or_options": "0-FF"
      },
      {
        "name": "ExcludeSRLG",
        "type": "list",
        "description": "排除具有特定SRLG（共享风险链路组）值的链路。",
        "default": "0x10020000",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "创建一个OSPF Segment Routing FAD (Forwarding Adjacency Descriptor) TLV配置，使用提供的Session和Opaque Router Info LSA来配置Segment Routing相关参数。此函数是对会话级别调用create_sr_fad_tlv的封装，传递必要的参数以配置FAD TLV。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Sr Fad Tlv | Session=${Session} | OpaqueRouterInfoLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_node_msd_tlv",
    "return_type": "Ospfv2SrNodeMsdTlvConfig",
    "return": "The created OSPFv2 SR Node MSD TLV configuration object.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "A session object representing the OSPFv2 protocol instance used for creating and managing the SR Node MSD TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "OpaqueRouterInfoLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "An Opaque Router Info LSA object to which the SR Node MSD TLV will be associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 SR Node MSD TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the SR Node MSD TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "List of flags associated with the MSD TLV, indicating supported functionalities.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN MAX_SEG_LEFT MAX_END_POP MAX_T_INSERT MAX_T_ENCAPS MAX_END_D"
      },
      {
        "name": "MaxSegmentLeft",
        "type": "int",
        "description": "Maximum value of Segment Left (SL) allowed before applying SID-related SRv6 instructions.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "Maximum number of SIDs at the top of the SRH stack that can be popped.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxInsert",
        "type": "int",
        "description": "Maximum number of SIDs that can be inserted using T.Insert behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEncap",
        "type": "int",
        "description": "Maximum number of SIDs that can be encapsulated using T.Encap behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "Maximum number of SIDs in SRH for End.DX6 and End.DT6 functions.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function creates an OSPFv2 Segment Routing (SR) Node MSD (Maximum SID Depth) TLV configuration object, associated with a given Opaque Router Info LSA. MSD TLVs are used in Segment Routing to advertise the maximum depth of the SID stack supported by a node, which influences path computation in SR-enabled networks. The function supports flexible configuration through optional keyword arguments.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| Create Ospf Sr Node Msd Tlv | Session=${Session} | OpaqueRouterInfoLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_opaque_extended_prefix_lsa",
    "return_type": ":obj:`Ospfv2OpaqueSrExtPrefixLsaConfig`",
    "return": "OSPFv2 Opaque Extended Prefix LSA对象，用于进一步配置或操作LSA的句柄。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`OspfRouter`",
        "description": "OSPFv2协议会话对象列表，用于创建LSA。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为创建的OSPFv2 Opaque Extended Prefix LSA指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用或禁用该LSA。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Scope",
        "type": "str",
        "description": "定义LSA的泛洪范围。",
        "default": "AreaLocal",
        "range_or_options": "LinkLocal AreaLocal AreaSystemWide"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "指定通告路由器的IPv4地址ID。",
        "default": "192.0.0.1",
        "range_or_options": "有效的IPv4地址格式"
      },
      {
        "name": "Instance",
        "type": "int",
        "description": "设置LSA实例编号。",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "定义LSA选项标志位。",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "设置LSA的老化时间（单位：秒）。",
        "default": "1",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "定义LSA序列号。",
        "default": "0x80000001",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "启用或禁用校验和。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "此函数用于创建一个OSPFv2 Opaque Extended Prefix LSA对象。它通过提供的OSPF会话对象调用底层方法，并支持通过关键字参数传递LSA配置信息。Opaque Extended Prefix LSA用于在OSPF网络中传播扩展前缀信息，适用于高级路由功能如Segment Routing。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | Create Ospf Opaque Extended Prefix Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_ext_prefix_range_tlv",
    "return_type": "Ospfv2ExtPrefixRangeTlvConfig",
    "return": "OSPFv2 Ext Prefix Range Tlv对象，用于进一步配置或操作该TLV。",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "OpaqueExtendedPrefixLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "与该TLV关联的OSPFv2 Opaque Extended Prefix LSA对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Ext Prefix Range Tlv的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "前缀长度，表示IPv4地址的子网掩码长度。",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "AF",
        "type": "str",
        "description": "前缀的地址族，标识地址类型。",
        "default": "IPv4Unicast",
        "range_or_options": "IPv4Unicast"
      },
      {
        "name": "ExtendedPrefixRange",
        "type": "int",
        "description": "要生成的前缀数量。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "ExtendedPrefixFlags",
        "type": "list",
        "description": "包含在TLV中的标志位。",
        "default": "NoneFlag",
        "range_or_options": "NoneFlag IAInterArea"
      },
      {
        "name": "AddressPrefix",
        "type": "str",
        "description": "起始地址前缀，用于生成连续的IPv4地址块。",
        "default": "192.0.1.0",
        "range_or_options": "有效的ipv4地址"
      }
    ],
    "description": "此函数用于创建一个OSPFv2 Extended Prefix Range TLV对象。该TLV通常用于在OSPF协议中通告一组连续的IP前缀范围，常用于网络扩展性测试和仿真场景。函数调用底层API来完成实际的创建过程，并返回一个配置对象以供后续操作。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Extended Prefix Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Ext Prefix Range Tlv | Session=${Session} | OpaqueExtendedPrefixLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_ext_prefix_tlv",
    "return_type": "Ospfv2ExtPrefixTlvConfig",
    "return": "返回一个OSPFv2 Extended Prefix TLV配置对象，用于进一步操作或查询TLV的状态。",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象列表，提供与底层测试设备的上下文和连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "OpaqueExtendedPrefixLsa",
        "type": "Ospfv2OpaqueRouterInfoLsaConfig",
        "description": "OSPFv2 Opaque Extended Prefix LSA对象，该TLV将与其关联。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Ext Prefix Range TLV的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能标志，启用或禁用该TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteType",
        "type": "str",
        "description": "路由类型，定义前缀所属的路由类别。",
        "default": "Unspecified",
        "range_or_options": "Unspecified IntraArea InterArea AsExternal NssaExternal"
      },
      {
        "name": "AddressPrefix",
        "type": "str",
        "description": "起始地址前缀，IPv4格式。",
        "default": "192.0.1.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "前缀长度，范围为0到32。",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "PrefixTlvBlockCount",
        "type": "int",
        "description": "要生成的TLV块数量。",
        "default": "1",
        "range_or_options": "0-32"
      },
      {
        "name": "AF",
        "type": "str",
        "description": "地址族（Address Family），默认为IPv4单播。",
        "default": "IPv4Unicast",
        "range_or_options": "IPv4Unicast"
      },
      {
        "name": "ExtendedPrefixFlags",
        "type": "list",
        "description": "包含在TLV中的标志位，如NoneFlag、AttachFlag、NodeFlag。",
        "default": "['NoneFlag']",
        "range_or_options": "NoneFlag AttachFlag NodeFlag"
      }
    ],
    "description": "此函数用于创建OSPFv2 Extended Prefix TLV配置对象。它通过提供的Session对象调用底层create_ext_prefix_tlv方法，并用于在测试场景中配置或操作OSPF不透明扩展前缀TLVs。该函数支持多种参数来精确控制TLV的行为和属性。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Extended Prefix Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Ext Prefix Range Tlv | Session=${Session} | OpaqueExtendedPrefixLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sid_label_binding_sub_tlv",
    "return_type": ":obj:`Ospfv2SidLabelBindingSubTlvConfig`",
    "return": "OSPFv2 Sid Label Binding Sub Tlv对象，表示创建的SID/Label绑定子TLV配置。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`OspfRouter`",
        "description": "OSPFv2协议会话对象，用于管理并应用配置。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Tlv",
        "type": ":obj:`Ospfv2ExtPrefixTlvConfig`",
        "description": "要绑定SID/Label的扩展前缀TLV对象，通常是某个LSA或TLV容器的一部分。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为新创建的Sid Label Binding Sub Tlv指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该Sid Label Binding Sub Tlv。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SidLabelBindingTlvFlags",
        "type": "list",
        "description": "TLV中包含的标志位，用于控制特定行为。",
        "default": "NoneFlag",
        "range_or_options": "NoneFlag MirroringContext"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "负载均衡时使用的权重值。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "多拓扑标识符（MT-ID）的值。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SidLabelType",
        "type": "str",
        "description": "SID/Label类型，可以是20位标签或32位SID。",
        "default": "Bit20",
        "range_or_options": "Bit20 Bit32"
      },
      {
        "name": "SidLabel",
        "type": "int",
        "description": "当使用20位标签时，代表标签值；当使用32位SID时，代表SID值。",
        "default": "16",
        "range_or_options": "0-255"
      }
    ],
    "description": "该函数用于创建一个OSPFv2协议中的SID/Label Binding Sub TLV对象。这种子TLV通常用于Segment Routing场景中，将SID（Segment ID）或Label绑定到特定的路由信息上。该函数封装了底层Renix API调用，并在失败时抛出异常，成功则返回配置对象。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n    | ${Tlv} | Create Ospf Ext Prefix Range Tlv | OpaqueRouterInfoLsa=${Lsa} |\n    | Create Ospf Sid Label Binding Sub Tlv | Session=${Session} | Tlv=${Tlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_prefix_sid_sub_tlv",
    "return_type": "Ospfv2PrefixSidSubTlvConfig",
    "return": "The created OSPFv2 Prefix SID Sub TLV configuration object.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "The OSPFv2 protocol session object used for creating the Prefix SID Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Tlv",
        "type": "Ospfv2ExtPrefixTlvConfig",
        "description": "The parent TLV (e.g., Ext Prefix Range TLV or Ext Prefix TLV) under which this Prefix SID Sub TLV will be embedded.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created Prefix SID Sub TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the Prefix SID Sub TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PrefixSidTlvFlags",
        "type": "list",
        "description": "List of flags associated with the Prefix SID TLV. These control behavior such as PHP, Mapping Server, etc.",
        "default": "['NoPhp']",
        "range_or_options": "NoPhp MappingServer ExplicitNull ValueIndex LacalGlobal"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "Specifies the Multi-Topology ID value for multi-topology routing.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Specifies the algorithm used to compute reachability to the prefix.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SidIndexLabel",
        "type": "int",
        "description": "If Value/Index flag is set, specifies the label value; otherwise, specifies the offset within the SID/Label range.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SidIndexLabelStep",
        "type": "int",
        "description": "Step increment for SidIndexLabel when multiple SIDs are being configured.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function creates an OSPFv2 Prefix SID Sub TLV object, typically used in Segment Routing (SR) environments to advertise additional information related to a specific prefix. It allows flexible configuration through keyword arguments and wraps internal API calls to create and associate the sub-TLV with the provided session and parent TLV context.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospf Ext Prefix Range Tlv | OpaqueRouterInfoLsa=${Lsa} |\n| Create Ospf Prefix Sid Sub Tlv | Session=${Session} | Tlv=${Tlv} | Enable=True | PrefixSidTlvFlags=['MappingServer', 'ExplicitNull'] | SidIndexLabel=100 | Name='MySID' |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_fapm_sub_tlv",
    "return_type": "Ospfv2SrFapmSubTlvConfig",
    "return": "A configured instance of Ospfv2SrFapmSubTlvConfig representing the SR FAPM sub-TLV configuration associated with the provided parent TLV.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "object",
        "description": "The parent TLV under which the SR FAPM sub-TLV will be created. This should be an instance of a TLV class or structure that supports containing sub-TLVs, such as OSPFv2 Ext Prefix Range Tlv / Ospfv2 Ext Prefix Tlv object.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 SR FAPM Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable or disable the SR FAPM sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Flexible algorithm ID for Segment Routing (SR) in OSPFv2.",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "Flags",
        "type": "int",
        "description": "Single-byte flags value for SR FAPM sub-TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Metric value used to represent cost or preference for the route.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This method creates and returns a configuration object for an OSPFv2 Segment Routing (SR) Forwarding Adjacency Protection Mechanism (FAPM) sub-TLV. It acts as a wrapper around the internal static method, allowing it to be used within the current API context. The method initializes a configuration object with the given parent TLV and allows further customization through optional keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n    | ${Tlv} | Create Ospf Ext Prefix Range Tlv | OpaqueRouterInfoLsa=${Lsa} |\n    | Create Ospf Sr Fapm Sub Tlv | Tlv=${Tlv} | Enable=True | Algorithm=130 | Flags=1 | Metric=100"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_bier_sub_tlv",
    "return_type": "Ospfv2BierSubTlvConfig",
    "return": "The newly created and optionally configured OSPFv2 BIER sub-TLV configuration object.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "Ospfv2TlvConfig",
        "description": "The parent TLV configuration object to which this BIER sub-TLV will be associated. This parameter is required and defines the context under which the BIER sub-TLV operates.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created OSPFv2 BIER Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the BIER sub-TLV should be enabled or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TlvType",
        "type": "int",
        "description": "The Type field value for the TLV. Used to identify the type of information contained in the TLV.",
        "default": "9",
        "range_or_options": "0-255"
      },
      {
        "name": "SubDomainId",
        "type": "int",
        "description": "BIER subdomain ID, used to distinguish different BIER domains.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MtId",
        "type": "int",
        "description": "Multi-topology identifier, used to support multiple topologies within a single routing protocol instance.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "BfrId",
        "type": "int",
        "description": "Bit Forwarding Router (BFR) ID, uniquely identifies a router in BIER multicast forwarding.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Bar",
        "type": "int",
        "description": "BIER algorithm used for path calculation.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipa",
        "type": "int",
        "description": "IGP algorithm used for IGP path selection.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function creates and configures an OSPFv2 BIER (Bit Index Explicit Replication) sub-TLV (Type-Length-Value) object. The BIER sub-TLV is used in the OSPF protocol to support efficient multicast forwarding by specifying bit positions that represent multicast distribution paths. The function accepts a parent TLV object and optional configuration parameters to customize the behavior of the BIER sub-TLV.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n    | ${Tlv} | Create Ospf Ext Prefix Range Tlv | OpaqueRouterInfoLsa=${Lsa} |\n    | Create Ospf Bier Sub Tlv | Tlv=${Tlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_bier_mpls_encap_sub_tlv",
    "return_type": "Ospfv2BierMplsEncapSubTlvConfig",
    "return": "A configured instance of the OSPFv2 BIER MPLS Encapsulation sub-TLV object.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "object",
        "description": "The parent TLV object to which this BIER MPLS Encapsulation sub-TLV will be attached. This serves as the upper context or container for the new sub-TLV configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 BIER MPLS Encapsulation sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TlvType",
        "type": "int",
        "description": "Type field value of the sub-TLV.",
        "default": "10",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxSi",
        "type": "int",
        "description": "Maximum Set Identifier (SI) allowed in the sub-TLV.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Label",
        "type": "int",
        "description": "Starting label value in the label range.",
        "default": "100",
        "range_or_options": "0-1048575"
      }
    ],
    "description": "This function creates and configures an OSPFv2 BIER MPLS Encapsulation sub-TLV by attaching it to a provided parent TLV object. It allows optional keyword arguments to customize properties such as name, enable status, type, maximum set identifier, and starting label value. If any keyword arguments are provided, they are applied during the creation process to tailor the sub-TLV configuration accordingly.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Router Info Lsa | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospf Ext Prefix Range Tlv | OpaqueRouterInfoLsa=${Lsa} |\n| ${SubTlv}| Create Ospf Bier Sub Tlv | Tlv=${Tlv} |\n| Create Ospf Bier Mpls Encap Sub Tlv | Tlv=${SubTlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_opaque_extended_link_lsa",
    "return_type": "Ospfv2OpaqueSrExtLinkLsaConfig",
    "return": "OSPFv2 Opaque Extended Link LSA configuration object that allows further manipulation or inspection of the created LSA.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "A list of OSPFv2 protocol session objects used to create the LSA. This session must support LSA creation and provide context for API operations.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the created Opaque Extended Link LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the Opaque Extended Link LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Scope",
        "type": "str",
        "description": "The scope of the TLV, determining how far the LSA is flooded within the network.",
        "default": "AreaLocal",
        "range_or_options": "LinkLocal AreaLocal AreaSystemWide"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The IP address identifying the router that advertises the LSA.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Instance",
        "type": "int",
        "description": "An identifier for multiple instances of LSAs on the same router.",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of option flags affecting the behavior of the LSA.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "The age of the LSA in seconds, used to manage its validity over time.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int (hex)",
        "description": "Uniquely identifies changes to this LSA using a hexadecimal value.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to calculate and validate checksums for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "创建OSPFv2 Opaque Extended Link LSA对象。该函数用于在指定的OSPF会话中生成一个Opaque Extended Link LSA，通常用于承载扩展信息（如Segment Routing或Traffic Engineering数据）。LSA是OSPF协议中用于链路状态传播的基本单元。Opaque LSA允许厂商或标准组织定义额外的TLVs来携带非拓扑信息。",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| Create Ospf Opaque Extended Link LSA | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_extended_link_tlv",
    "return_type": "Ospfv2ExtendedLinkTlvConfig",
    "return": "A configured instance of the Ospfv2ExtendedLinkTlvConfig object representing the created OSPFv2 Extended Link TLV.",
    "parameters": [
      {
        "name": "OpaqueExtendedLinkLsa",
        "type": "Ospfv2OpaqueSrExtLinkLsaConfig",
        "description": "The parent opaque extended link LSA to associate with this TLV, serving as the upper layer context for the TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the newly created OSPFv2 Extended Link TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the TLV is enabled or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LinkType",
        "type": "str",
        "description": "Specifies the type of the link for which the TLV is being configured.",
        "default": "P2P",
        "range_or_options": "P2P TRANSITNETWORK STUBNETWORK VIRTUALLINK"
      },
      {
        "name": "LinkId",
        "type": "str",
        "description": "IPv4 address identifying the link ID associated with the TLV.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "LinkData",
        "type": "str",
        "description": "Additional data associated with the link, represented as an IPv4 address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "description": "Creates and configures an OSPFv2 Extended Link TLV (Type-Length-Value) object. This function initializes a configuration object for the TLV, associates it with the provided parent opaque extended link LSA, and applies any additional configuration parameters passed via keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Extended Link Lsa | Session=${Session} | Age=20 |\n    | Create Ospf Extended link Tlv | OpaqueExtendedLinkLsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_adj_sid_sub_tlv",
    "return_type": "Ospfv2AdjSidSubTlvConfig",
    "return": "OSPFv2 Adjacency SID Sub-TLV configuration object used for Segment Routing in OSPFv2.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "The OSPFv2 session object representing a connection to the test device or API.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ExtendedLinkTlv",
        "type": "Ospfv2ExtendedLinkTlvConfig",
        "description": "The Extended Link TLV under which this Adjacency SID Sub-TLV will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 Adj Sid Sub Tlv instance.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the Adj Sid Sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "List of flags associated with the Adjacency SID.",
        "default": "['ValueIndexFlag', 'LocalGlobalFlag', 'NONE']",
        "range_or_options": "BackupFlag ValueIndexFlag LocalGlobalFlag GroupFlag PersistentFlag NONE"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "Multi-topology ID assigned to the Adj Sid Sub-TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Weight value for path selection when multiple paths exist.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SidLabel",
        "type": "int",
        "description": "Segment Identifier (SID) label value for segment routing.",
        "default": "1",
        "range_or_options": "1-255"
      }
    ],
    "description": "This function creates an OSPFv2 Adjacency Segment Identifier (SID) Sub-TLV configuration under a specified session and Extended Link TLV. It is typically used in OSPF Segment Routing environments to advertise adjacency-specific segment identifiers. The function supports various optional keyword arguments for fine-grained control over the configuration, including enabling/disabling the sub-TLV, setting flags, weight, multi-topology ID, and SID label.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Extended Link Lsa | Session=${Session} | Age=20 |\n    | ${Tlv} | Create Ospf Extended Link Tlv | OpaqueExtendedLinkLsa=${Lsa} |\n    | Create Ospf Adj Sid Sub Tlv | Session=${Session} | ExtendedLinkTlv=${Tlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_lan_adj_sid_sub_tlv",
    "return_type": "object",
    "return": "OSPFv2 Lan Adj Sid Sub Tlv对象，类型为：object",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "OSPFv2协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ExtendedLinkTlv",
        "type": "Ospfv2ExtendedLinkTlvConfig",
        "description": "OSPFv2 Extended Link TLV对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv2 Lan Adj Sid Sub Tlv的名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能状态",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "标志选项列表",
        "default": "['ValueIndexFlag', 'LocalGlobalFlag', 'NONE']",
        "range_or_options": "BackupFlag ValueIndexFlag LocalGlobalFlag GroupFlag PersistentFlag NONE"
      },
      {
        "name": "MultiTopologyId",
        "type": "int",
        "description": "多拓扑ID",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "权重值",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NeighborId",
        "type": "str",
        "description": "邻居标识符（IPv4地址）",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "SidLabel",
        "type": "int",
        "description": "SID或标签值",
        "default": "1",
        "range_or_options": "1-255"
      }
    ],
    "description": "该函数用于在指定的Extended Link TLV下创建一个OSPFv2 LAN Adjacency SID子TLV配置。LAN Adjacency SID子TLV用于在SR（Segment Routing）环境中标识链路的邻接SID。通过提供Session对象和ExtendedLinkTlv对象，结合可选的配置参数，可以在底层系统中生成对应的配置。",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Extended Link Lsa | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospf Extended Link Tlv | OpaqueExtendedLinkLsa=${Lsa} |\n| Create Ospf Lan Adj Sid Sub Tlv | Session=${Session} | ExtendedLinkTlv=${Tlv} | Enable=True | Flags=['BackupFlag', 'GroupFlag'] | NeighborId=192.168.1.1 | SidLabel=100"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_sr_link_msd_sub_tlv",
    "return_type": "Ospfv2SrLinkMsdSubTlvConfig",
    "return": "The created OSPFv2 SR Link MSD sub-TLV configuration object, which represents the configured Segment Routing Maximum SID Depth on a link.",
    "parameters": [
      {
        "name": "Session",
        "type": "OspfRouter",
        "description": "The OSPFv2 protocol session object used to interact with the underlying system or API.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ExtendedLinkTlv",
        "type": "Ospfv2ExtendedLinkTlvConfig",
        "description": "An existing OSPFv2 Extended Link TLV object that this MSD sub-TLV will be associated with.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the newly created OSPFv2 SR Link MSD sub-TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the MSD sub-TLV should be enabled upon creation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "List of flags included in the MSD sub-TLV to specify supported capabilities.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN MAX_SEG_LEFT MAX_END_POP MAX_T_INSERT MAX_T_ENCAPS MAX_END_D"
      },
      {
        "name": "MaxSegmentLeft",
        "type": "int",
        "description": "Maximum value for the Segment Left (SL) field in the SRH received on this link.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "Maximum number of SIDs at the top of the SRH stack that can be popped using End.POP behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxInsert",
        "type": "int",
        "description": "Maximum number of SIDs that can be inserted into the SRH when performing T.Insert behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEncap",
        "type": "int",
        "description": "Maximum number of SIDs that can be encapsulated when performing T.Encap behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "Maximum number of SIDs allowed in the SRH when executing End.DX6 or End.DT6 functions.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function creates an OSPFv2 Segment Routing (SR) Link MSD (Maximum SID Depth) sub-TLV object. MSD is used in Segment Routing to indicate the maximum depth of the SID stack that a node can process on a given link. This allows SR-capable routers to avoid exceeding the processing capability of their neighbors. The function supports setting various flags and limits related to different SR behaviors like popping, inserting, or encapsulating SIDs.",
    "example": "| ${Session} | Create Ospf | Port=${Port} |\n| ${Lsa} | Create Ospf Opaque Extended Link Lsa | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospf Extended Link Tlv | OpaqueExtendedLinkLsa=${Lsa} |\n| ${MsdSubTlv} | Create Ospf Sr Link Msd Sub Tlv | Session=${Session} | ExtendedLinkTlv=${Tlv} | MaxSegmentLeft=10 | Flags=[MAX_SEG_LEFT, MAX_END_POP] | Enable=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.create_ospf_custom_sub_tlv",
    "return_type": "Ospfv2CustomMsdSubTlvConfig",
    "return": "A configured instance of Ospfv2CustomMsdSubTlvConfig representing the custom MSD sub-TLV.",
    "parameters": [
      {
        "name": "SrLinkMsdSubTlv",
        "type": "Ospfv2SrLinkMsdSubTlvConfig",
        "description": "The parent TLV or sub-TLV object to which this custom MSD sub-TLV will be attached. Typically represents a Segment Routing Link MSD Sub-TLV in the protocol hierarchy.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv2 Custom Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable flag for the sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SubType",
        "type": "int",
        "description": "Sub-type identifier for the custom sub-TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SubValue",
        "type": "int",
        "description": "Value associated with the custom sub-TLV.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "Creates and returns a custom MSD (Maximum Stack Depth) sub-TLV configuration object for OSPFv2 by delegating to the static method `OspfRouter.create_custom_sub_tlv`. This function wraps the creation of a custom MSD sub-TLV used in Segment Routing extensions for OSPFv2. It attaches the new sub-TLV to the provided parent TLV or sub-TLV object (`SrLinkMsdSubTlv`) and allows optional configuration through keyword arguments passed via `**kwargs`.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${Lsa} | Create Ospf Opaque Extended Link Lsa | Session=${Session} | Age=20 |\n    | ${Tlv} | Create Ospf Extended link Tlv | OpaqueExtendedLinkLsa=${Lsa} |\n    | ${SubTlv} | Create Ospf Sr Link Msd Sub Tlv | SrLinkMsdSubTlv=${Tlv} |\n    | Create Ospf Custom Sub Tlv | SrLinkMsdSubTlv = ${SubTlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.get_ospf_router_from_lsa",
    "return_type": "List[object]",
    "return": "A list of OSPF routers corresponding to the input LSA(s), each representing the source router that generated the respective LSA.",
    "parameters": [
      {
        "name": "Lsa",
        "type": "Union[object, List[object]]",
        "description": "A single LSA object or a list of LSA objects. Each LSA must support the `get_relatives` method to trace back to the generating router via 'GenerateLsa' relationship.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieve the OSPF router(s) associated with the given LSA(s) by navigating the relationship graph. If a single LSA is provided, it is automatically wrapped into a list. The function then iterates over each LSA and retrieves its source router using the 'GenerateLsa' relationship in the source direction.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospf | Port=${Port} |\n    | ${RouterLsa} | Create Ospf Router Lsa | Session=${Session} | Age=20 |\n    | ${Point} | Get Ospf Router From Lsa | Lsa=${RouterLsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.establish_ospf",
    "return_type": "bool",
    "return": "Returns True if all OSPF sessions are successfully established, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`OspfRouter`)",
        "description": "A list of OSPFv2 session objects (typically of type `OspfRouter`) that need to establish OSPF sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function establishes OSPFv2 protocol sessions by invoking the internal backend method. It takes a list of session objects and ensures each one establishes its OSPF connection by calling their `establish()` method. If any session fails to establish, it returns False or raises a `ContinuableFailure` exception depending on the outcome.",
    "example": "| Establish Ospf | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.grace_restart_ospf",
    "return_type": "bool",
    "return": "True if the graceful restart operation was successfully executed on all provided sessions; False otherwise (which will raise a ContinuableFailure exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object implementing the `grace_restart()` method, or an iterable containing multiple such session objects.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Gracefully restarts the OSPFv2 protocol for one or more session objects. This function ensures that the `grace_restart()` method is called on each provided session, allowing for a smooth restart of the OSPFv2 protocol without disrupting the network unnecessarily.",
    "example": "| Grace Restart Ospf | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.advertise_ospf_lsa",
    "description": "Advertises OSPFv2 Link-State Advertisements (LSAs) using either session-based advertisement or direct LSA configuration.",
    "return_type": "bool",
    "return": "Returns True to indicate successful execution of the advertisement process; raises an exception if it fails.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(OspfRouter) or Session object or list/set/tuple of Session objects",
        "description": "The session(s) through which LSAs are to be advertised if 'Lsa' is not provided. When a list of OspfRouter objects is passed, each session in 'Sessions' will be advertised with the specified 'Type'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str or any",
        "description": "The type of advertisement to use for the sessions. Typically corresponds to the LSA type when used with 'Sessions'. Used only when 'Lsa' is None.",
        "default": "None",
        "range_or_options": "Router Network Summary AsbrSummary External"
      },
      {
        "name": "Lsa",
        "type": "Ospfv2LsaConfig object or list of Ospfv2LsaConfig objects",
        "description": "The LSA(s) to be advertised directly. If provided, this parameter takes precedence over 'Sessions' and 'Type', and the function uses the OSPFv2 advertise command with these LSA configurations.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Advertise Ospf Lsa | Sessions=${Sessions} | Type=router |\n    | Advertise Ospf Lsa | Sessions=${Sessions} | Lsa=${Lsas} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.withdraw_ospf_lsa",
    "return_type": "bool",
    "return": "Returns True if the LSA withdrawal is successful, otherwise raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(:obj:`OspfRouter`) or :obj:`OspfRouter` or None",
        "description": "OSPFv2 protocol session object(s) to use for withdrawing LSAs. If 'Lsa' is None, each session's 'withdraw' method will be called with the specified 'Type'.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str or None",
        "description": "The type of LSA to withdraw when using session-based mode (i.e., when 'Lsa' is None). Supported values: 'Router', 'Network', 'Summary', 'AsbrSummary', 'External'. Required in session-based mode.",
        "default": "None",
        "range_or_options": "'Router' 'Network' 'Summary' 'AsbrSummary' 'External'"
      },
      {
        "name": "Lsa",
        "type": "Ospfv2LsaConfig or list of Ospfv2LsaConfig or None",
        "description": "Specific LSA configuration(s) to withdraw. If provided, this overrides the session-based mode and directly triggers OSPFv2 withdraw command on the given LSA(s).",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Withdraws OSPFv2 Link-State Advertisements (LSAs) either by session or directly by LSA. This function provides two modes of operation:\n\n1. **Session-based mode**: If 'Lsa' is None, it iterates through the 'Sessions' list and calls the 'withdraw' method on each session with the specified 'Type'.\n2. **Direct LSA mode**: If 'Lsa' is provided (as a single LSA or a list), it executes an OSPFv2 withdraw command directly on those LSA configurations.\n\nExactly one of 'Type' (session-based) or 'Lsa' (direct) must be provided. If both are provided, behavior is undefined and may raise exceptions.",
    "example": ".. code:: RobotFramework\n\n    | Withdraw Ospf Lsa | Sessions=${Sessions} | Type=router |\n    | Withdraw Ospf Lsa | Sessions=${Sessions} | Lsa=${Lsas} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.wait_ospf_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired states within the timeout period; otherwise, a TesterException is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable of session objects (e.g., OspfRouter or Ospfv3Router) whose OSPF state will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list",
        "description": "One or more acceptable values for the 'State' attribute being monitored. If None, defaults to ['DR', 'BACKUP', 'DROTHER']. All values are compared case-insensitively with the actual state values.",
        "default": "['DR', 'BACKUP', 'DROTHER']",
        "range_or_options": "NOTSTART P2P WAITING DR BACKUP DROTHER DISABLE DOWN"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired states before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the OSPFv2 or OSPFv3 protocol session(s) reach one of the specified target states. This function polls each session at regular intervals and checks its 'State' attribute. If all sessions reach one of the desired states within the timeout period, it returns True. If the timeout is reached and not all sessions have reached the expected state, a TesterException is raised. Internally, this function calls `_wait_state` with `AttrName='State'`. If the session's 'State' attribute is an Enum type, its name will be used for comparison.",
    "example": "| Wait Ospf State | Sessions=${Sessions} | State=DR | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.wait_ospf_adjacency_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired adjacency states within the timeout period.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing OSPF neighbors whose adjacency status will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list(str)",
        "description": "One or more acceptable values for the 'AdjacencyStatus' attribute. If None, defaults to 'FULL'. All values are compared case-insensitively with the actual attribute values.",
        "default": "'FULL'",
        "range_or_options": "DOWN INIT EXSTART EXCHANGE LOADING FULL"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between successive checks of the adjacency status.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired adjacency states before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the OSPF adjacency status of each session in 'Sessions' reaches the specified target state. This function polls the sessions at regular intervals and checks their 'AdjacencyStatus' attribute. By default, it waits for the adjacency status to reach 'FULL', which indicates a fully established OSPF neighbor relationship. If all sessions reach the desired adjacency state within the timeout period, it returns True. If the timeout is reached and not all sessions have reached the expected state, a TesterException is raised.",
    "example": "| Wait Ospf Adjacency State | Sessions=${Sessions} | State=FULL | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.get_ospf_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary, pandas DataFrame, or boolean value depending on the number of matching results. If one match is found, returns a dictionary mapping statistical items to their values. If multiple matches are found, returns a DataFrame with all matching rows. If no match is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "OSPFv2 protocol session object(s) used to filter statistics by session handle. If None, no filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which OSPFv2 session statistics to retrieve. Can be a single statistic (as string), a list of statistics, or None to fetch all available statistics.",
        "default": "None",
        "range_or_options": "RouterState AdjacencyState TxHello RxHello TxDd RxDd TxRouterLsa RxRouterLsa TxNetworkLsa RxNetworkLsa TxSummaryLsa RxSummaryLsa TxAsbrSummaryLsa RxAsbrSummaryLsa TxAsExternalLsa RxAsExternalLsa TxNssaLsa RxNssaLsa TxTeLsa RxTeLsa TxOpaqueRouterInfoLsa RxOpaqueRouterInfoLsa TxOpaqueExtendedPrefixLsa RxOpaqueExtendedPrefixLsa TxOpaqueExtendedLinkLsa RxOpaqueExtendedLinkLsa TxRequest RxRequest TxUpdate RxAck TxAck"
      }
    ],
    "kwargs": [],
    "description": "Retrieves OSPFv2 session statistics based on provided session identifiers and statistical items. This function wraps `_get_statictis()` to specifically fetch 'Ospfv2SessionResultPropertySet' statistics. It supports filtering by session handles extracted from individual session objects or collections thereof (e.g., lists, sets, tuples). When `Session` is None, no filtering is applied. The function dynamically queries available properties if `StaItems` is None.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Ospfv2SessionResultPropertySet |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ospf Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv2.edit_ospf_port_config",
    "return_type": "object or list of objects",
    "return": "The modified Ospfv2PortConfig object(s). If a single port is processed, the return value is the corresponding configuration object. If multiple ports are processed, a list of modified Ospfv2PortConfig objects is returned.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list of objects",
        "description": "A single port object or a list of port objects for which the OSPFv2 configuration needs to be edited. Each port object must have an associated 'Ospfv2PortConfig' child.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TransmitRate",
        "type": "int",
        "description": "OSPFv2 Message Tx Rate (messages/second)",
        "default": "100",
        "range_or_options": "1-9000"
      },
      {
        "name": "SessionOutstanding",
        "type": "int",
        "description": "OSPFv2 Session Outstanding",
        "default": "20",
        "range_or_options": "1-1000"
      },
      {
        "name": "UpdateMsgTransmitRate",
        "type": "int",
        "description": "Deprecated. OSPFv2 Update Message Tx Rate (messages/second)",
        "default": "10",
        "range_or_options": "1-9000"
      },
      {
        "name": "EnableLoop",
        "type": "bool",
        "description": "Enable Loop Back",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Modifies the OSPFv2 port configuration for one or more specified ports. This function checks if the input `Ports` is a list. If not, it wraps it into a list for uniform processing. It then iterates through each port in the list, retrieves its first (and expected only) OSPFv2 port configuration child object, and applies any provided configuration changes via the `edit` method of the Ospfv2PortConfig object. All modified configuration objects are collected into a result list. If only one port was processed, that single configuration object is returned; otherwise, the list of modified configurations is returned.",
    "example": ".. code:: RobotFramework\n\n    | Edit Ospf Port Config | Ports=${Ports} | TransmitRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3",
    "return_type": "Ospfv3Router",
    "return": "The newly created and configured OSPFv3 router instance associated with the specified port.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent object in the protocol stack or configuration hierarchy to which the new OSPFv3 router belongs. This typically represents a port or interface on which OSPFv3 will run.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "OSPFv3 session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the OSPFv3 protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "InstanceId",
        "type": "int",
        "description": "Instance ID for the OSPFv3 session.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "AreaId",
        "type": "str",
        "description": "Area ID for the OSPFv3 session.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableExtendedLsa",
        "type": "bool",
        "description": "Enables extended LSA for the OSPFv3 session.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ExtendedLsaMode",
        "type": "str",
        "description": "Extended LSA mode for the OSPFv3 session.",
        "default": "Full",
        "range_or_options": "NONE MixedModeOriginateOnly MixedModeOriginateSPF Full"
      },
      {
        "name": "AreaExtendedLsaMode",
        "type": "str",
        "description": "Extended area LSA mode for the OSPFv3 session.",
        "default": "InheritGlobal",
        "range_or_options": "InheritGlobal NONE MixedModeOriginateOnly MixedModeOriginateSPF Full"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables BFD (Bidirectional Forwarding Detection) for fast failure detection.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Sets the network type for the OSPFv3 interface.",
        "default": "Broadcast",
        "range_or_options": "Broadcast P2P"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Router priority used in DR/BDR election.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "InterfaceId",
        "type": "int",
        "description": "Interface ID for the OSPFv3 interface.",
        "default": "10",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Cost",
        "type": "int",
        "description": "Interface cost used in path selection.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of options supported by the OSPFv3 implementation.",
        "default": "['NONTBIT', 'V6BIT', 'EBIT', 'RBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused17 Unused16 Unused15 Unused14 Unused13 Unused12 Unused11 Unused10 Unused9 Unused8 Unused7 Unused6 Unused5 Unused4 Unused3 Unused2 Unused1 Unused0"
      },
      {
        "name": "EnableOspfv3Mtu",
        "type": "bool",
        "description": "Enables OSPFv3 MTU negotiation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables graceful restart for OSPFv3 sessions.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GracefulRestartReason",
        "type": "str",
        "description": "Specifies the reason for initiating a graceful restart.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN SOFTWARE RELOADORUPGRADE SWITCH"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables viewing of routes learned via this OSPFv3 session.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval between Hello packets sent by the OSPFv3 interface.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterDeadInterval",
        "type": "int",
        "description": "Time interval after which a neighbor is considered dead if no Hello packets are received.",
        "default": "40",
        "range_or_options": "0-65535"
      },
      {
        "name": "LsaRetransInterval",
        "type": "int",
        "description": "Time interval between retransmissions of LSAs that have not been acknowledged.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRefreshTime",
        "type": "int",
        "description": "Time interval after which LSAs are refreshed.",
        "default": "1800",
        "range_or_options": "1-1800"
      }
    ],
    "description": "Creates and configures an OSPFv3 router instance associated with the specified parent object (typically a Port). The function initializes a new Ospfv3Router object using the provided `Port` as its parent in the protocol stack or configuration hierarchy. It also allows customization of various OSPFv3 configuration properties through keyword arguments. The newly created instance is registered in a global mapping of protocol objects via its handle for future reference.",
    "example": "| Create Ospfv3 | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.edit_ospfv3",
    "return_type": "bool",
    "return": "Always returns True if the function executes successfully, regardless of whether any attributes were actually modified. Returns False if an internal error occurs during execution.",
    "parameters": [
      {
        "name": "Session",
        "type": "list(:obj:`Ospfv3Router`)",
        "description": "A list of OSPFv3 session objects to be edited. Each object represents a single OSPFv3 router session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the OSPFv3 session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the OSPFv3 session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "InstanceId",
        "type": "int",
        "description": "The instance ID for the OSPFv3 session.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "AreaId",
        "type": "str",
        "description": "The area ID associated with the OSPFv3 session.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "EnableExtendedLsa",
        "type": "bool",
        "description": "Enables or disables extended LSA support in the session.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ExtendedLsaMode",
        "type": "str",
        "description": "Specifies the mode for extended LSA handling.",
        "default": "Full",
        "range_or_options": "NONE MixedModeOriginateOnly MixedModeOriginateSPF Full"
      },
      {
        "name": "AreaExtendedLsaMode",
        "type": "str",
        "description": "Sets the extended LSA mode at the area level.",
        "default": "InheritGlobal",
        "range_or_options": "InheritGlobal NONE MixedModeOriginateOnly MixedModeOriginateSPF Full"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables or disables Bidirectional Forwarding Detection (BFD) for the session.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "Defines the network type for the OSPFv3 interface.",
        "default": "Broadcast",
        "range_or_options": "Broadcast P2P"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Specifies the priority of the OSPFv3 router.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "InterfaceId",
        "type": "int",
        "description": "The unique identifier for the interface used by the session.",
        "default": "10",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Cost",
        "type": "int",
        "description": "The cost metric assigned to the interface.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of OSPFv3 options to enable on the interface.",
        "default": "['NONTBIT', 'V6BIT', 'EBIT', 'RBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused17 Unused16 Unused15 Unused14 Unused13 Unused12 Unused11 Unused10 Unused9 Unused8 Unused7 Unused6 Unused5 Unused4 Unused3 Unused2 Unused1 Unused0"
      },
      {
        "name": "EnableOspfv3Mtu",
        "type": "bool",
        "description": "Enables or disables MTU negotiation in OSPFv3.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables or disables graceful restart functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GracefulRestartReason",
        "type": "str",
        "description": "Specifies the reason for initiating graceful restart.",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN SOFTWARE RELOADORUPGRADE SWITCH"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Enables or disables viewing of routing information.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval (in seconds) between Hello packets sent by the router.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterDeadInterval",
        "type": "int",
        "description": "Time interval (in seconds) after which a neighbor is considered down if no Hello packet is received.",
        "default": "40",
        "range_or_options": "0-65535"
      },
      {
        "name": "LsaRetransInterval",
        "type": "int",
        "description": "Time interval (in seconds) between retransmissions of LSAs.",
        "default": "5",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaRefreshTime",
        "type": "int",
        "description": "Time interval (in seconds) after which an LSA is refreshed.",
        "default": "1800",
        "range_or_options": "1-1800"
      }
    ],
    "description": "This function modifies one or more attributes of existing OSPFv3 session objects. It allows users to edit multiple attributes in a single call by passing keyword arguments corresponding to session properties. Only existing attributes are updated; new attributes are not created.",
    "example": "| Edit Ospfv3 | Session=${Session} | Name=OSPF_Session1 | Enable=True | AreaId=1.1.1.1 | NetworkType=P2P | Cost=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_router_lsa",
    "return_type": "Ospfv3RouterLsaConfig",
    "return": "OSPFv3 Router LSA对象，表示创建的链路状态通告配置。",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "OSPFv3协议会话对象，用于提供与底层系统或API的上下文和连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 Router LSA的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用LSA。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "指定最初发布LSA的路由器ID。",
        "default": "1.0.0.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "链路状态ID。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RouterType",
        "type": "str",
        "description": "路由器类型。",
        "default": "NONTBIT",
        "range_or_options": "NONEBIT RouterTypeABR RouterTypeASBR RouterTypeVirtype"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "选项列表。",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused17 Unused16 Unused15 Unused14 Unused13 Unused12 Unused11 Unused10 Unused9 Unused8 Unused7 Unused6 Unused5 Unused4 Unused3 Unused2 Unused1 Unused0"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的老化时间（秒）。",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA的序列号。",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否计算校验和。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建一个OSPFv3 Router LSA（链路状态通告）配置。它使用提供的会话对象并传递配置参数来生成Router LSA，该LSA用于描述路由器在OSPF区域内的拓扑信息。",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_router_lsa_link",
    "return_type": "Ospfv3RouterLsaLinksConfig",
    "return": "The created and optionally configured OSPFv3 Router LSA Link object, which can be used for further manipulation or reference.",
    "parameters": [
      {
        "name": "RouterLsa",
        "type": "Ospfv3RouterLsaConfig",
        "description": "The OSPFv3 Router LSA configuration object to which the new link will be associated. This serves as the parent configuration object for the link.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created OSPFv3 Router LSA Link.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the link. True means enabled, False means disabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LinkType",
        "type": "str",
        "description": "The type of the link. Supported values are P2P, TRANSITNETWORK, and VIRTUALLINK.",
        "default": "P2P",
        "range_or_options": "P2P TRANSITNETWORK VIRTUALLINK"
      },
      {
        "name": "InterfaceId",
        "type": "int",
        "description": "The interface ID used to uniquely identify the simulated router's interface.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NeighborInterfaceId",
        "type": "int",
        "description": "The neighbor interface ID used to uniquely identify the neighbor router's interface.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NeighborRouterId",
        "type": "str",
        "description": "The ID of the neighboring router, represented in IPv4 format.",
        "default": "1.0.0.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "The metric value assigned to the link, representing the cost of using this link.",
        "default": "1",
        "range_or_options": "1-65535"
      }
    ],
    "description": "This function creates an OSPFv3 Router LSA Link object and associates it with the provided Router LSA. It allows optional configuration of various properties such as link type, interface IDs, neighbor details, and metric. The function delegates the creation and configuration to the backend API and returns the resulting link configuration object.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n| Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_endx_sid_sub_tlv",
    "return_type": "Ospfv3Srv6EndXSidSubTlvConfig",
    "return": "Returns the created OSPFv3 SRv6 End(X) SID sub-TLV configuration object that can be used for further configuration or reference.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "The session object representing an OSPFv3 protocol session, used to manage and apply configurations.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterLsaLink",
        "type": "Ospfv3RouterLsaLinksConfig",
        "description": "Reference to a router LSA link where the SRv6 End(X) SID sub-TLV will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created SRv6 End(X) SID sub-TLV configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the SRv6 End(X) SID sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EndpointBehaviorId",
        "type": "int",
        "description": "SRv6 SID endpoint behavior identifier used to define specific processing actions at the endpoint.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "List of flags included in the SRv6 End(X) SID sub-TLV.",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT Unused0 Unused1 Unused2 Unused3 Unused4 PersistentFlag SetFlag BackupFlag"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Algorithm associated with the SRv6 SID, used in path computation.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "Weight value of the End(X) SID used for load balancing purposes.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Sid",
        "type": "str",
        "description": "IPv6 address representing the SRv6 SID advertised by the router.",
        "default": "'aaaa:1:1:1::'",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "This function creates an OSPFv3 SRv6 End(X) SID sub-TLV configuration on a specified router LSA link within the provided session. It allows flexible configuration of SRv6 SIDs used in segment routing environments, including setting flags, algorithm, weight, and SID value. The function returns a configuration object that can be referenced later for modification or validation.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n    | ${LsaLink} | Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |\n    | Create Ospfv3 Srv6 Endx Sid Sub Tlv | RouterLsaLink=${LsaLink} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_lan_endx_sid_sub_tlv",
    "return_type": "Ospfv3Srv6LanEndXSidSubTlvConfig",
    "return": "OSPFv3 Srv6 Lan EndX Sid Sub Tlv对象，类型为object。",
    "description": "创建一个OSPFv3 SRv6 LAN End.X SID子TLV（Type-Length-Value）配置对象。该功能用于在OSPFv3协议中扩展支持IPv6段路由（SRv6），特别是在LAN场景中通过LSA中的子TLV广播End.X行为信息。",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "OSPFv3协议会话对象列表，提供创建配置上下文和方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterLsaLink",
        "type": "Ospfv3RouterLsaLinksConfig",
        "description": "与该SRv6 LAN End.X SID子TLV关联的路由器LSA链路对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 Srv6 Lan EndX Sid Sub Tlv的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能或禁用该SID子TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EndpointBehaviorId",
        "type": "int",
        "description": "SRv6 SID的端点行为ID。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "包含在TLV中的标志位。",
        "default": "NONEBIT",
        "range_or_options": "NONEBIT Unused0 Unused1 Unused2 Unused3 Unused4 PersistentFlag SetFlag BackupFlag"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "SID关联的算法。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Weight",
        "type": "int",
        "description": "END.X SID / LAN END.X SID的权重，用于负载分担。",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Sid",
        "type": "str",
        "description": "通告的SRv6 SID，邻居路由器ID。",
        "default": "'aaaa:1:1:1::'",
        "range_or_options": "有效的ipv6地址"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n    | ${LsaLink} | Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |\n    | Create Ospfv3 Srv6 Lan Endx Sid Sub Tlv | RouterLsaLink=${LsaLink} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_link_msd_sub_tlv",
    "return_type": "Ospfv3Srv6MsdSubTlvConfig",
    "return": "OSPFv3 Srv6 Link MSD Sub-TLV configuration object used for further manipulation or validation within the session context.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "OSPFv3 protocol session object used to manage context and state for a series of operations.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterLsaLink",
        "type": "Ospfv3RouterLsaLinksConfig",
        "description": "Reference to the router's LSA (Link State Advertisement) link where the SRv6 MSD sub-TLV will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created OSPFv3 SRv6 Link MSD Sub-TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the SRv6 MSD Sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Msds",
        "type": "list",
        "description": "List of flags included in the TLV indicating types of MSD support.",
        "default": "NONEBIT",
        "range_or_options": "NONTBIT MaxiSegmentLeft MaxiEndPop MaxiTInsert MaxiTEncaps MaxiEndD"
      },
      {
        "name": "MaximumEndDSrh",
        "type": "int",
        "description": "Maximum number of segments allowed in the SRH for End.D behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumEndPop",
        "type": "int",
        "description": "Maximum number of SIDs that can be popped from the top of an SRH stack.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumSegmentsLeft",
        "type": "int",
        "description": "Maximum number of SIDs allowed when performing T.Insert behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumTEncapSrh",
        "type": "int",
        "description": "Maximum number of SIDs allowed when performing T.Encap behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumTInsertSrh",
        "type": "int",
        "description": "Maximum number of SIDs allowed in the SRH when performing End.DX6 and End.DT6 functions.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function creates an OSPFv3 SRv6 (Segment Routing over IPv6) Link MSD (Maximum SID Depth) Sub-TLV configuration object, which is associated with a given OSPFv3 session and a router LSA link. It allows specifying various parameters related to segment routing capabilities such as enabling/disabling the feature, defining maximum SID depth limits for different behaviors, and assigning a custom name.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n    | ${LsaLink} | Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |\n    | Create Ospfv3 Srv6 Msd Sid Sub Tlv | RouterLsaLink=${LsaLink} | Enable=True | MaximumSegmentsLeft=10"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_endx_sid_structure_sub_tlv",
    "return_type": "Ospfv3Srv6SidStructureSubTlvConfig",
    "return": "A configured instance of Ospfv3Srv6SidStructureSubTlvConfig representing the newly created END(X) SID Structure Sub-TLV.",
    "parameters": [
      {
        "name": "SubTlv",
        "type": "Ospfv3Srv6EndXSidSubTlvConfig",
        "description": "Parent SubTLV object or context under which the END(X) SID Structure Sub-TLV will be created, establishing hierarchical relationship in the protocol data structure.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the OSPFv3 SRv6 Link MSD Sub TLV to be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable flag for the Sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LbLength",
        "type": "int",
        "description": "SRv6 SID Locator Block Length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "LnLength",
        "type": "int",
        "description": "SRv6 SID Locator Node Length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "FunctionLength",
        "type": "int",
        "description": "SRv6 SID Function Length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "ArgumentLength",
        "type": "int",
        "description": "SRv6 SID Argument Length.",
        "default": "32",
        "range_or_options": "0-128"
      }
    ],
    "description": "This function creates and configures an OSPFv3 END(X) SID Structure Sub-TLV object using a provided parent SubTLV context and optional configuration parameters. It ensures robustness by performing abnormal behavior checking during creation. This method acts as a wrapper around the static method `Ospfv3Router.create_endx_sid_structure_sub_tlv` within the backend.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n    | ${LsaLink} | Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |\n    | ${SubTlv} | Create Ospfv3 Srv6 Msd Sid Sub Tlv | RouterLsaLink=${LsaLink} |\n    | Create Ospfv3 Endx Sid Structure Sub Tlv | SubTlv=${SubTlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_lan_endx_sid_structure_sub_tlv",
    "return_type": "Ospfv3Srv6LanEndXSidSubTlvConfig",
    "return": "A configured instance of Ospfv3Srv6LanEndXSidSubTlvConfig representing the LAN End.X SID Structure sub-TLV.",
    "parameters": [
      {
        "name": "SubTlv",
        "type": "Ospfv3Srv6LanEndXSidSubTlvConfig",
        "description": "The parent sub-TLV object to which the newly created LAN End.X SID Structure sub-TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name for the created OSPFv3 SRv6 Link MSD Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable flag for the sub-TLV, indicating whether it is active or not.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LbLength",
        "type": "int",
        "description": "SRv6 SID Locator Block length in bits, used to define the size of the block portion of the SID.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "LnLength",
        "type": "int",
        "description": "SRv6 SID Locator Node length in bits, used to define the size of the node portion of the SID.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "FunctionLength",
        "type": "int",
        "description": "SRv6 SID Function length in bits, used to define the size of the function portion of the SID.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "ArgumentLength",
        "type": "int",
        "description": "SRv6 SID Argument length in bits, used to define the size of additional arguments within the SID.",
        "default": "32",
        "range_or_options": "0-128"
      }
    ],
    "description": "This function creates and configures an OSPFv3 LAN End.X SID Structure sub-TLV under a provided parent sub-TLV object. It is used in the context of Segment Routing over IPv6 (SRv6) to represent structured SIDs within the OSPFv3 protocol framework. The function supports optional keyword arguments to customize various aspects of the sub-TLV configuration, such as enabling/disabling the structure and specifying bit-lengths for different components of the SRv6 SID.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Router Lsa | Session=${Session} | Age=20 |\n    | ${LsaLink} | Create Ospfv3 Router Lsa Link | RouterLsa=${RouterLsa} | Metric=65535 |\n    | ${SubTlv} | Create Ospfv3 Srv6 Msd Sid Sub Tlv | RouterLsaLink=${LsaLink} |\n    | Create Ospfv3 Lan Endx Sid Structure Sub Tlv | SubTlv=${SubTlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_network_lsa",
    "return_type": "Ospfv3NetworkLsaConfig",
    "return": "The created OSPFv3 Network LSA configuration object, which represents the Network-LSA in the OSPFv3 protocol stack.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "An OSPFv3 protocol session object that provides context and connection to the underlying system for creating the Network-LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the OSPFv3 Network LSA to be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the Network LSA should be enabled upon creation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The ID of the router that is advertising this LSA (must be a valid IPv4 address format).",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "A unique identifier for the LSA within the area; must be an integer between 0 and 4294967295.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of optional flags that define specific behaviors or capabilities of the LSA.",
        "default": "['NONTBIT', 'EBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused0 Unused1 Unused2 Unused3 Unused4 Unused5 Unused6 Unused7 Unused8 Unused9 Unused10 Unused11 Unused12 Unused13 Unused14 Unused15 Unused16 Unused17"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "The age of the LSA in seconds; used to determine how long the LSA has been in the network.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "A sequence number used to identify newer or duplicate LSAs.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Enables or disables checksum computation for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv3 Network LSA (Link State Advertisement) object using the provided session and configuration parameters. It wraps the session's `create_network_lsa` method to abstract the low-level details and allows flexible configuration via keyword arguments. The Network LSA describes the set of routers connected to a transit network in the OSPFv3 routing protocol.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 Network Lsa | Session=${Session} | Age=20 | Name=MyNetworkLSA | AdvertisingRouterId=2.2.2.2 | LinkStateId=100 | Options=['V6BIT', 'MCBIT'] | SequenceNumber=0x80000002 | Checksum=False |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_network_atch_router",
    "return_type": ":obj:`Ospfv3NetworkAtchRouterConfig`",
    "return": "OSPFv3 Network LSA Atch Router对象, 类型为：object",
    "parameters": [
      {
        "name": "Lsa",
        "type": ":obj:`Ospfv3NetworkLsaConfig`",
        "description": "测试仪表OSPFv3 Network LSA对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 Network LSA Atch Router的名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AttachedRouter",
        "type": "str",
        "description": "附加路由器的IP地址",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      }
    ],
    "description": "该函数用于创建一个OSPFv3 Network LSA Atch Router配置对象，并基于提供的LSA上下文进行初始化。它封装了底层API调用，用于在网络模拟或路由协议测试中定义与OSPFv3网络关联的附加路由器。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${RouterLsa} | Create Ospfv3 Network Lsa | Session=${Session} | Age=20 |\n    | Create Ospfv3 Network Lsa Atch Router | Lsa=${RouterLsa} | Metric=65535 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_intra_area_prefix_lsa",
    "return_type": "Ospfv3IntraAreaPrefixLsaConfig",
    "return": "The created OSPFv3 Intra-Area Prefix LSA configuration object used for further manipulation or advertisement in the network.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "An active OSPFv3 protocol session object that provides access to the underlying API for creating and managing LSAs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created Intra Area Prefix LSA instance.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the LSA should be enabled upon creation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID of the originator of the LSA, must be a valid IPv4-like string.",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "The Link State ID for this LSA, which uniquely identifies it within the area.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ReferencedLsType",
        "type": "str",
        "description": "The type of referenced LSA (in hexadecimal format).",
        "default": "0x0",
        "range_or_options": "0x0-0xFFFF"
      },
      {
        "name": "ReferencedAdvertisingRouterId",
        "type": "str",
        "description": "The advertising router ID of the referenced LSA.",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "ReferencedLinkStateId",
        "type": "int",
        "description": "The link state ID of the referenced LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExtendedLsaTlvs",
        "type": "list",
        "description": "List of extended TLVs to include in the LSA.",
        "default": "Ipv6IntraAreaPrefix",
        "range_or_options": "NONE Ipv6IntraAreaPrefix"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "Number of prefixes to advertise in this LSA.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartPrefixAddress",
        "type": "str",
        "description": "Starting IPv6 prefix address to advertise.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix being advertised.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Value by which to increment each subsequent prefix if multiple are advertised.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixOptions",
        "type": "list",
        "description": "List of options associated with the prefix(es).",
        "default": "NONTBIT",
        "range_or_options": "NONTBIT NUBIT LABIT MCBIT PBIT DNBit NBit Unused1 Unused0"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Cost value associated with reaching the advertised prefix(es).",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA's age in seconds, indicating how long it has been since it was originated.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Hexadecimal sequence number used to identify newer instances of the same LSA.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to automatically calculate and apply the checksum for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv3 Intra-Area Prefix LSA, which is used to advertise IPv6 prefixes within a single area in OSPFv3 networks. It wraps the session method to configure and instantiate the LSA with various parameters such as prefix information, metrics, reference LSAs, and more. This is commonly used in test environments to simulate route advertisements or manipulate routing behavior.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | Create Ospfv3 Intra Area Prefix Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_inter_area_prefix_lsa",
    "return_type": "Ospfv3InterAreaPrefixLsaConfig",
    "return": "OSPFv3 Inter-Area-Prefix LSA configuration object representing the created LSA.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "A session object that provides context and connection for OSPFv3 operations. This object must have a method `create_inter_area_prefix_lsa` to be used internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 Inter Area Prefix LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID of the router that originally advertises the LSA.",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "Link state identifier for the LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExtendedLsaTlvs",
        "type": "list",
        "description": "List of extended LSA TLVs to be included in the LSA.",
        "default": "Ipv6InterAreaPrefix",
        "range_or_options": "NONE Ipv6InterAreaPrefix"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "Number of prefixes to generate.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartPrefixAddress",
        "type": "str",
        "description": "Starting IPv6 prefix address for prefix generation.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Step value for incrementing prefix addresses.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixOptions",
        "type": "list",
        "description": "List of options associated with each prefix.",
        "default": "NONTBIT",
        "range_or_options": "NONTBIT NUBIT LABIT MCBIT PBIT"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Cost metric for the route advertised by this LSA.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Age of the LSA, in seconds.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sequence number for the LSA (in hexadecimal format).",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Enables or disables checksum validation for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates an OSPFv3 Inter-Area-Prefix LSA (Link State Advertisement) using the provided session object and keyword arguments. This function wraps the underlying implementation from the session's `create_inter_area_prefix_lsa` method and returns the resulting configuration object. It is typically used to simulate or configure inter-area prefix advertisements in an OSPFv3 network environment.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | Create Ospfv3 Inter Area Prefix Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_inter_area_router_lsa",
    "return_type": "Ospfv3InterAreaRouterLsaConfig",
    "return": "OSPFv3 Inter Area Router LSA对象，表示创建的LSA配置。",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "OSPFv3协议会话对象列表，用于提供与底层API或系统的上下文和连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 Router LSA的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能OSPFv3 Router LSA。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "通告路由器ID，即最初发布LSA的路由器ID。",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "链路状态ID，用于标识LSA。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AsbrId",
        "type": "str",
        "description": "ASBR（自治系统边界路由器）ID。",
        "default": "0.0.0.0",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "路由度量值，表示到达目标的成本。",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "OSPFv3选项标志位。",
        "default": "['NONTBIT', 'V6BIT', 'EBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused17 Unused16 Unused15 Unused14 Unused13 Unused12 Unused11 Unused10 Unused9 Unused8 Unused7 Unused6 Unused5 Unused4 Unused3 Unused2 Unused1 Unused0"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA的老化时间（单位：秒）。",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA的序列号，用于检测重复和更新。",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "是否启用校验和。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建一个OSPFv3 Inter-Area Router LSA（链路状态广播）对象。OSPFv3 Inter-Area Router LSA用于在不同区域之间传递路由信息。此函数是一个封装器，调用Session对象的create_inter_area_router_lsa方法，并可能通过abnormal_check装饰器执行额外检查或处理。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | Create Ospfv3 Inter Area Router Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_sr_fapm_sub_tlv",
    "return_type": "Ospfv3SrFapmSubTlvConfig",
    "return": "A configuration object representing the created OSPFv3 SR FAPM (Segment Routing Flexible Algorithm Prefix Metric) sub-TLV, associated with the provided LSA.",
    "parameters": [
      {
        "name": "Lsa",
        "type": "Ospfv3InterAreaRouterLsaConfig",
        "description": "The parent Link State Advertisement (LSA) object to which this SR FAPM sub-TLV will be attached. This should be an instance of an appropriate OSPFv3 LSA configuration class.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 SR FAPM sub-TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the SR FAPM sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Flexible algorithm ID used for segment routing.",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Metric value for the prefix metric in SR FAPM sub-TLV.",
        "default": "0",
        "range_or_options": "128-255"
      }
    ],
    "description": "This function creates and configures an OSPFv3 SR FAPM (Segment Routing Flexible Algorithm Prefix Metric) sub-TLV object and associates it with a given LSA (Link State Advertisement). It wraps the backend creation logic and provides a simplified interface for use in test automation or configuration scripts. The function allows optional configuration through keyword arguments that modify the behavior of the generated SR FAPM sub-TLV.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${Lsa} | Create Ospfv3 Inter Area Prefix Lsa | Session=${Session} | Age=20 |\n    | Create Ospfv3 Sr Fapm Sub Tlv | Lsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_bier_sub_tlv",
    "return_type": "Ospfv3BierSubTlvConfig",
    "return": "A configured instance of Ospfv3BierSubTlvConfig representing the newly created and optionally customized BIER sub-TLV.",
    "parameters": [
      {
        "name": "Lsa",
        "type": "Ospfv3InterAreaRouterLsaConfig",
        "description": "The parent LSA (Link State Advertisement) object to which the new BIER sub-TLV will be attached. This defines the context and hierarchy in which the BIER sub-TLV exists within the OSPFv3 configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 Bier Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the BIER sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TlvType",
        "type": "int",
        "description": "Type field value for the TLV.",
        "default": "9",
        "range_or_options": "0-255"
      },
      {
        "name": "SubDomainId",
        "type": "int",
        "description": "BIER sub-domain ID used to identify a specific sub-domain within the network.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MtId",
        "type": "int",
        "description": "Multi-topology ID used for multi-topology routing.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "BfrId",
        "type": "int",
        "description": "BFR (Bit Forwarding Router) ID, identifying the router responsible for forwarding bits in BIER multicast.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Bar",
        "type": "int",
        "description": "BIER algorithm used for path selection.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipa",
        "type": "int",
        "description": "IGP algorithm used for route calculation.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Creates and configures an OSPFv3 BIER (Bit Index Explicit Replication) sub-TLV object under the specified LSA (Link State Advertisement). This function wraps the backend static method to provide an instance-based interface for creating and returning a configured BIER sub-TLV. It is typically used in environments where the API layer manages interactions with protocol-specific constructs. Any provided keyword arguments are passed directly into the `edit` method of the returned `Ospfv3BierSubTlvConfig` object, allowing immediate customization after creation.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Inter Area Prefix Lsa | Session=${Session} | Age=20 |\n| Create Ospfv3 Bier Sub Tlv | Lsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_bier_mpls_encap_sub_tlv",
    "return_type": "Ospfv3BierMplsEncapSubTlvConfig",
    "return": "A configured instance of Ospfv3BierMplsEncapSubTlvConfig associated with the provided parent SubTLV object.",
    "parameters": [
      {
        "name": "SubTlv",
        "type": "Ospfv3BierSubTlvConfig",
        "description": "The parent or upper-level TLV/SubTLV object that this configuration belongs to. This defines the context under which this BIER MPLS encapsulation sub-TLV will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the newly created OSPFv3 Bier Sub TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TlvType",
        "type": "int",
        "description": "Type field value for the sub-TLV.",
        "default": "10",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxSi",
        "type": "int",
        "description": "Maximum Set Identifier (SI) used in BIER encoding.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Label",
        "type": "int",
        "description": "Start label value within the label range for MPLS encapsulation.",
        "default": "100",
        "range_or_options": "0-1048575"
      },
      {
        "name": "BsLen",
        "type": "int",
        "description": "Length of the local bitstring used in BIER encoding.",
        "default": "4",
        "range_or_options": "0-15"
      }
    ],
    "description": "This method creates and configures an OSPFv3 BIER MPLS Encapsulation Sub-TLV object within the protocol stack. It acts as a wrapper around the internal static method `Ospfv3Router.create_bier_mpls_encap_sub_tlv`, integrating it into the RenixAPI instance for use in test automation scenarios involving advanced OSPFv3 BIER configurations. The method allows optional configuration through keyword arguments, which are passed directly to the edit() method of the created configuration object during initialization.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${Lsa} | Create Ospfv3 Inter Area Prefix Lsa | Session=${Session} | Age=20 |\n    | ${SubTlv} | Create Ospfv3 Bier Sub Tlv | Lsa=${Lsa} |\n    | Create Ospfv3 Bier Mpls Encap Sub Tlv | SubTlv=${SubTlv} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_as_external_lsa",
    "return_type": "Ospfv3AsExternalLsaConfig",
    "return": "OSPFv3 As External LSA configuration object representing the created LSA instance.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "The OSPFv3 protocol session object used to create the AS-external-LSA. This session must support the method `create_as_external_lsa` for this function to work properly.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 AS-external-LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the AS-external-LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID that originates the LSA, in IPv4 address format.",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "Link state identifier for the LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "Number of prefixes to be advertised.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartPrefixAddress",
        "type": "str",
        "description": "Starting IPv6 prefix address for the route advertisement.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix (subnet mask equivalent).",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Step size between consecutive prefixes.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixOptions",
        "type": "list",
        "description": "List of prefix options for the external route.",
        "default": "['NONTBIT']",
        "range_or_options": "NONTBIT NUBIT LABIT MCBIT PBIT DNBit NBit Unused1 Unused0"
      },
      {
        "name": "IsExternalMetric",
        "type": "bool",
        "description": "Whether the metric is an external type.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Cost metric associated with the external route.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "EnableForwardingAddress",
        "type": "bool",
        "description": "Whether a forwarding address should be included in the LSA.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ForwardingAddress",
        "type": "str",
        "description": "IPv6 address to which traffic should be forwarded.",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "AdminTag",
        "type": "int",
        "description": "Administrative tag value for policy-based routing or filtering.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ReferencedLsType",
        "type": "int",
        "description": "Reference link-state type if this LSA refers to another LSA.",
        "default": "0x0",
        "range_or_options": "0x0-0xFFFF"
      },
      {
        "name": "ReferencedLinkStateId",
        "type": "int",
        "description": "Reference link-state ID if this LSA refers to another LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Time in seconds since the LSA was originated.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sequence number of the LSA used for aging and synchronization.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "LsaAutomaticConversion",
        "type": "bool",
        "description": "Whether to automatically convert LSA type based on NSSA/non-NSSA context.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to calculate and include checksum in the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates an OSPFv3 AS-external-LSA configuration object using the provided session. The function wraps the internal implementation from the Renix library and handles failure cases by raising exceptions. It allows configuring various properties of the LSA such as prefixes, metrics, options, and timers.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 As External Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_nssa_external_lsa",
    "return_type": "Ospfv3NssaExternalLsaConfig",
    "return": "OSPFv3 Nssa External LSA configuration object created based on the provided session and parameters.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "OSPFv3 protocol session object used to create the LSA, typically representing a router session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 NSSA External LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable this LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The ID of the router that originates the LSA.",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "Link State ID of the LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExtendedLsaTlvs",
        "type": "list",
        "description": "List of extended LSA TLVs included in the LSA.",
        "default": "Ipv6ExternalPrefix",
        "range_or_options": "NONE Ipv6ExternalPrefix"
      },
      {
        "name": "ExtendedLsaSubTlvs",
        "type": "list",
        "description": "List of extended LSA sub-TLVs included in the LSA.",
        "default": "NONTBIT",
        "range_or_options": "NONE Ipv6ForwardingAddr Ipv4ForwardingAddr RouteTag"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "Number of IPv6 prefixes included in the LSA.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartPrefixAddress",
        "type": "str",
        "description": "Starting IPv6 prefix address for generating multiple prefixes.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Value to increment the prefix by when generating multiple prefixes.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixOptions",
        "type": "list",
        "description": "List of options applied to the prefix.",
        "default": "NONTBIT",
        "range_or_options": "NONTBIT NUBIT LABIT MCBIT PBIT DNBit NBit Unused1 Unused0"
      },
      {
        "name": "IsExternalMetric",
        "type": "bool",
        "description": "Whether the metric is an external type (Type-5 or Type-7).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Metric value associated with the route.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "EnableForwardingAddress",
        "type": "bool",
        "description": "Whether to include a forwarding address in the LSA.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ForwardingAddress",
        "type": "str",
        "description": "IPv6 address used as a forwarding address in the LSA.",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "Ipv4ForwardingAddress",
        "type": "str",
        "description": "IPv4 address used as a forwarding address in the LSA.",
        "default": "0.0.0.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "AdminTag",
        "type": "int",
        "description": "Administrative tag used for route filtering or tagging.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ReferencedLsType",
        "type": "int",
        "description": "Type of referenced LSA if this LSA is part of a reference chain.",
        "default": "0x0",
        "range_or_options": "0x0-0xFFFF (hex)"
      },
      {
        "name": "ReferencedLinkStateId",
        "type": "int",
        "description": "Link state ID of the referenced LSA if applicable.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Age of the LSA in seconds.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sequence number of the LSA used for aging and synchronization.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF (hex)"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to calculate and include checksum information in the LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LsaAutomaticConversion",
        "type": "bool",
        "description": "Whether to automatically convert between external LSA and NSSA LSA depending on the session type.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv3 Not-So-Stubby Area (NSSA) External Link State Advertisement (LSA) using the provided session and configuration parameters. It simulates network routing behavior for testing and validation purposes.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 Nssa External Lsa | Session=${Session} | Age=20"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_link_lsa",
    "return_type": "Ospfv3LinkLsaConfig",
    "return": "OSPFv3 Link LSA configuration object that represents the created LSA, which can be used for further management or inspection.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "An active OSPFv3 protocol session object used to create the Link LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the OSPFv3 Link LSA to be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the LSA should be enabled upon creation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "The router ID of the advertising router (i.e., the originator of the LSA).",
        "default": "1.1.1.1",
        "range_or_options": "0.0.0.0-255.255.255.255"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "The link state ID associated with this LSA.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ExtendedLsaTlvs",
        "type": "list",
        "description": "List of extended LSA TLVs to include in the LSA.",
        "default": "['Ipv6IntraAreaPrefix']",
        "range_or_options": "NONE Ipv6IntraAreaPrefix Ipv6LinkLocalAddr Ipv4LinkLocalAddr"
      },
      {
        "name": "PrefixCount",
        "type": "int",
        "description": "Number of IPv6 prefixes to advertise via this LSA.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StartPrefixAddress",
        "type": "str",
        "description": "Starting IPv6 prefix address to use when generating multiple prefixes.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix to advertise.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Increment",
        "type": "int",
        "description": "Step increment for generating additional prefixes beyond the first.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixOptions",
        "type": "list",
        "description": "List of options to apply to each prefix advertised by the LSA.",
        "default": "['NONTBIT']",
        "range_or_options": "NONTBIT NUBIT LABIT MCBIT PBIT DNBit NBit Unused1 Unused0"
      },
      {
        "name": "LinkLocalInterfaceAddress",
        "type": "str",
        "description": "IPv6 link-local address of the interface associated with this LSA.",
        "default": "fe80::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "Ipv4LinkLocalInterfaceAddress",
        "type": "str",
        "description": "IPv4 link-local address of the interface associated with this LSA.",
        "default": "0.0.0.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RouterPriority",
        "type": "int",
        "description": "Router priority for DR/BDR election on the link.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "List of general OSPFv3 options to configure for the LSA.",
        "default": "['NONTBIT', 'V6BIT', 'EBIT']",
        "range_or_options": "NONTBIT V6BIT EBIT MCBIT NBIT RBIT DCBIT Unused17 Unused16 Unused15 Unused14 Unused13 Unused12 Unused11 Unused10 Unused9 Unused8 Unused7 Unused6 Unused5 Unused4 Unused3 Unused2 Unused1 Unused0"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "LSA age in seconds.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA sequence number, typically represented as a hexadecimal value.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether to enable checksum calculation for the LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "Creates an OSPFv3 Link LSA (Link State Advertisement) using the provided session and configuration parameters. This function wraps a session-level method to generate a Link LSA, which is used in OSPFv3 to describe the link-local state and router information for IPv6 interfaces. The resulting object can be used to manage or inspect the LSA within the current session context.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 Link Lsa | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_opaque_router_info_lsa",
    "return_type": "Ospfv3OpaqueRouterInfoLsaConfig",
    "return": "OSPFv3 Opaque Router Info LSA configuration object, used for injecting or configuring vendor-specific or application-specific information in the OSPFv3 protocol.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "The OSPFv3 session object through which the LSA is created and managed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 Opaque Router Info LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Scope",
        "type": "str",
        "description": "Specifies the scope of the LSA propagation.",
        "default": "AreaLocal",
        "range_or_options": "LinkLocal AreaLocal AreaSystemWide"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "IP address of the advertising router.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "Identifier for the link state, must be unique within the area.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "TlvsFlag",
        "type": "list",
        "description": "List of TLV flags indicating capabilities included in the LSA.",
        "default": "['NONTBIT', 'InfoCapabilities']",
        "range_or_options": "NONEBIT InfoCapabilities FuncCapabilities"
      },
      {
        "name": "InformationalCapabilities",
        "type": "list",
        "description": "List of informational capability bits advertised in the LSA.",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT RcBit RhBit SrsBit TesBit PolBit Etbit MiBit SrhBit Unused8 ... Unused30"
      },
      {
        "name": "FunctionalCapabilities",
        "type": "list",
        "description": "List of functional capability bits advertised in the LSA.",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT Unused0 Unused1 Unused2 Unused3 Unused4 Unused5 Unused6 Unused7 Unused8 ... Unused30"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Time in seconds since the LSA was originated.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Unique sequence number to identify LSA instances.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Indicates whether the checksum should be computed automatically.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function creates an OSPFv3 opaque router information LSA (Link State Advertisement) using a provided session. It allows for injecting or configuring vendor-specific or application-specific extensions into the OSPFv3 domain by wrapping the underlying session's method. The LSA carries router-specific information that can be used for advanced routing scenarios or testing purposes.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_sr_algorithm_tlv",
    "return_type": "Ospfv3SrAlgorithmTlvConfig",
    "return": "返回一个配置对象，表示新创建的OSPFv3 SR Algorithm TLV。该对象可以进一步用于配置或应用到路由器实例中。",
    "parameters": [
      {
        "name": "Lsa",
        "type": "Ospfv3OpaqueRouterInfoLsaConfig",
        "description": "OSPFv3 Opaque Router Info LSA对象，作为SR Algorithm TLV的父容器，定义了TLV所属的LSA上下文。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 SR Algorithm TLV的名称，用于标识该TLV。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能/禁用该SR Algorithm TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Algorithms",
        "type": "int",
        "description": "指定支持的Segment Routing算法编号。",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于创建并配置一个OSPFv3 Segment Routing (SR) Algorithm TLV对象。SR Algorithm TLV用于在OSPFv3中通告路由器所支持的Segment Routing算法。该TLV被绑定在一个已有的OSPFv3 Opaque Router Info LSA上，并可通过关键字参数进行灵活配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n    | Create Ospfv3 Sr Algorithm Tlv | Lsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_sr_fad_tlv",
    "return_type": "Ospfv3SrFadTlvConfig",
    "return": "The created OSPFv3 SR FAD TLV configuration object.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "OSPFv3 protocol session object used to create the SR FAD TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsa",
        "type": "Ospfv3OpaqueRouterInfoLsaConfig",
        "description": "OSPFv3 Opaque Router Info LSA object under which the SR FAD TLV will be registered or attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 SR FAD TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable flag for the SR FAD TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "FlexAlgorithm",
        "type": "int",
        "description": "Flexible algorithm ID for path calculation.",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "Metric type used in path computation.",
        "default": "IGPMetric",
        "range_or_options": "IGPMetric MinUnidirectionalLinkDelay TEDefaultMetric"
      },
      {
        "name": "CalculationType",
        "type": "int",
        "description": "Computation type specific to IGP algorithms.",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Priority of the SR FAD TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlexAlgorithmSubTlvs",
        "type": "list",
        "description": "List of constraints that the flexible algorithm must follow during path computation.",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT ExcludeAdminGroups IncludeAnyAdminGroups IncludeAllAdminGroups DefinitionFlags ExcludeSRLG"
      },
      {
        "name": "ExcludeAdminGroups",
        "type": "int",
        "description": "Administrative groups to exclude from path computation.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAnyAdminGroups",
        "type": "int",
        "description": "Administrative groups where at least one must be included in the path.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAllAdminGroups",
        "type": "int",
        "description": "Administrative groups that all must be included in the path.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DefinitionFlags",
        "type": "int",
        "description": "Flags used for defining additional properties of the algorithm.",
        "default": "0x80",
        "range_or_options": "0-FF"
      },
      {
        "name": "ExcludeSRLG",
        "type": "int",
        "description": "Shared Risk Link Group (SRLG) to be excluded from the path.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Creates an OSPFv3 Segment Routing Forwarding Adjacency Downstream (FAD) TLV configuration object using the provided session and LSA. This function wraps the underlying API call to configure SR FAD TLVs, allowing for customization through optional keyword arguments related to algorithm settings, metric types, and constraints.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n| Create Ospfv3 Sr Fad Tlv | Lsa=${Lsa} | FlexAlgorithm=130 | MetricType=MinUnidirectionalLinkDelay |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_capabilities_tlv",
    "return_type": ":obj:`Ospfv3Srv6CapabilitiesTlvConfig`",
    "return": "返回创建的OSPFv3 SRv6 Capabilities Tlv对象，用于在网络中配置或广播SRv6能力信息。",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`Ospfv3Router`",
        "description": "OSPFv3协议会话对象，提供创建TLV所需的上下文和方法。必须包含`create_srv6_capabilities_tlv`方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsa",
        "type": ":obj:`Ospfv3OpaqueRouterInfoLsaConfig`",
        "description": "与SRv6 Capabilities TLV关联的OSPFv3 Opaque Router Info LSA对象，包含LSA类型、ID等属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为创建的OSPFv3 SRv6 Capabilities Tlv指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "控制是否启用该SRv6 Capabilities Tlv。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "定义SRv6 Capabilities相关的标志位。",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT Unused0 OFlag Unused2 Unused3 Unused4 Unused5 Unused6 Unused7 Unused8 Unused9 Unused10 Unused11 Unused12 Unused13 Unused14 Unused15"
      }
    ],
    "description": "此函数用于在OSPFv3环境中创建SRv6（基于IPv6的段路由）能力TLV（Type-Length-Value），通常用于在LSA（链路状态通告）中广播SRv6功能支持情况。它封装了底层会话对象的方法，允许通过关键字参数灵活配置SRv6相关选项。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n    | Create Ospfv3 Srv6 Capabilities Tlv | Lsa=${Lsa} | Enable=True | Flags=[OFlag] |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_node_msd_tlv",
    "return_type": "Ospfv3Srv6MsdSubTlvConfig",
    "return": "OSPFv3 Srv6 Node MSD TLV configuration object that represents the created TLV structure.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "An active OSPFv3 protocol session object used to provide context for creating the MSD TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsa",
        "type": "Ospfv3OpaqueRouterInfoLsaConfig",
        "description": "The Opaque Router Info LSA object to which the SRv6 Node MSD TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created OSPFv3 SRv6 Node MSD TLV object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Msds",
        "type": "list",
        "description": "List of flags included in the TLV, representing various segment routing capabilities.",
        "default": "NONEBIT",
        "range_or_options": "NONTBIT MaxiSegmentLeft MaxiEndPop MaxiTInsert MaxiTEncaps MaxiEndD"
      },
      {
        "name": "MaximumEndDSrh",
        "type": "int",
        "description": "Maximum value for the Segment Left (SL) field in the SRH of received packets.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumEndPop",
        "type": "int",
        "description": "Maximum number of SIDs at the top of the SRH stack when performing End.Pop behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumSegmentsLeft",
        "type": "int",
        "description": "Maximum number of SIDs that can be included when performing T.Insert behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumTEncapSrh",
        "type": "int",
        "description": "Maximum number of SIDs that can be encapsulated during T.Encap behavior.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaximumTInsertSrh",
        "type": "int",
        "description": "Maximum number of SIDs allowed in the SRH when performing End.DX6 and End.DT6 functions.",
        "default": "8",
        "range_or_options": "0-255"
      }
    ],
    "description": "Creates an OSPFv3 SRv6 Node MSD TLV (Multi-Segment Descriptor Type-Length-Value) configuration within the given session and attaches it to the specified LSA. This TLV is used to specify segment routing parameters for traffic engineering in SRv6 networks.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n| Create Ospfv3 Srv6 Node Msd Tlv | Lsa=${Lsa} | Enable=True | MaximumSegmentsLeft=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_location_lsa",
    "return_type": "Ospfv3Srv6LocatorLsaConfig",
    "return": "OSPFv3 Srv6 Location LSA configuration object representing the newly created LSA.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "An active OSPFv3 protocol session object used as the context for creating the SRv6 Location LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created SRv6 Location LSA.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable this SRv6 Location LSA.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Scope",
        "type": "str",
        "description": "The scope of the SRv6 Location LSA, which defines its flooding scope in the network.",
        "default": "AreaLocal",
        "range_or_options": "LinkLocal AreaLocal AreaSystemWide"
      },
      {
        "name": "AdvertisingRouterId",
        "type": "str",
        "description": "IPv4 address of the router advertising this LSA.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "LinkStateId",
        "type": "int",
        "description": "Link state identifier used in the LSA header; typically a unique number per LSA instance.",
        "default": "0",
        "range_or_options": "1-255"
      },
      {
        "name": "Age",
        "type": "int",
        "description": "Age of the LSA in seconds, indicating how long it has been in the network.",
        "default": "0",
        "range_or_options": "0-3600"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "LSA sequence number used to detect old or duplicate LSAs.",
        "default": "0x80000001",
        "range_or_options": "0x1-0xFFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "bool",
        "description": "Whether checksum validation should be applied to this LSA.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "创建OSPFv3 Srv6 Location LSA对象。该函数通过调用底层会话的create_srv6_location_lsa方法，用于在OSPFv3协议中配置和生成SRv6（Segment Routing over IPv6）相关的Location LSA。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | Create Ospfv3 Srv6 Location LSA | Session=${Session} | Age=20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_location_tlv",
    "return_type": "Ospfv3Srv6LocatorTlvConfig",
    "return": "OSPFv3 Srv6 Location Tlv对象，表示创建的SRv6 Locator TLV配置。",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router",
        "description": "用于与API交互的会话对象，必须是Ospfv3Router类型。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsa",
        "type": "Ospfv3Srv6LocatorLsaConfig",
        "description": "与SRv6 Location TLV关联的LSA（链路状态通告）对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的OSPFv3 Srv6 Location Tlv的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该TLV。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouterType",
        "type": "str",
        "description": "路由器类型，用于指定路由范围。",
        "default": "IntraArea",
        "range_or_options": "IntraArea InterArea ASExternal NSSAExternal"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Locator关联算法编号。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "LocatorLength",
        "type": "int",
        "description": "Locator前缀长度。",
        "default": "64",
        "range_or_options": "0-128"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "标志位列表。",
        "default": "['NONEBIT']",
        "range_or_options": "NONEBIT Unused0 Unused1 Unused2 Unused3 Unused4 Unused5 ABit NFlag"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "度量值，用于路径选择。",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "Locator",
        "type": "str",
        "description": "通告的Locator IPv6地址。",
        "default": "'aaaa:1:1:1::'",
        "range_or_options": "有效的IPv6地址"
      }
    ],
    "description": "该函数用于在给定的OSPFv3会话和LSA上下文中创建一个OSPFv3 SRv6 Location TLV对象。此TLV通常用于SRv6网络中，通告Locator信息并参与路径计算。",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n| Create Ospfv3 Srv6 Location Tlv | Lsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_end_sid_sub_tlv",
    "return_type": "Ospfv3Srv6EndSidSubTlvConfig",
    "return": "A configuration object representing the newly created SRv6 End SID sub-TLV, which can be used to inspect or modify the sub-TLV after its creation.",
    "parameters": [
      {
        "name": "Tlv",
        "type": "Ospfv3Srv6LocatorTlvConfig",
        "description": "The parent TLV object to which the newly created SRv6 End SID sub-TLV will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created OSPFv3 Srv6 End Sid Sub Tlv.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable this SRv6 End SID sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EndpointBehaviorId",
        "type": "int",
        "description": "SRv6 SID endpoint behavior ID.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Flags",
        "type": "int",
        "description": "Flags included in the SRv6 End SID sub-TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Sid",
        "type": "str",
        "description": "The advertised SRv6 SID (IPv6 address format).",
        "default": "'aaaa:1:1:1::'",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "This function creates and configures an SRv6 End SID sub-TLV for OSPFv3. It initializes a new SRv6 End SID sub-TLV associated with a given parent TLV and allows optional configuration parameters such as Enable, EndpointBehaviorId, Flags, and Sid to be set during creation.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospfv3 Srv6 Location Tlv | Lsa=${Lsa} |\n| Create OSPFv3 Srv6 End Sid Sub Tlv | Tlv=${Tlv} | Flags=255 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.create_ospfv3_srv6_sid_structure_sub_tlv",
    "return_type": "Ospfv3Srv6SidStructureSubTlvConfig",
    "return": "A configured instance of the SRv6 SID structure sub-TLV ready to be used or further manipulated.",
    "parameters": [
      {
        "name": "SubTlv",
        "type": "Ospfv3Srv6EndSidSubTlvConfig",
        "description": "The parent sub-TLV object to which this SRv6 SID structure sub-TLV will be attached. This defines the hierarchical relationship in the TLV structure used by OSPFv3 extensions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created OSPFv3 Srv6 Sid Structure Sub Tlv.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable flag for the SRv6 SID structure sub-TLV.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LbLength",
        "type": "int",
        "description": "SRv6 SID Locator Block length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "LnLength",
        "type": "int",
        "description": "SRv6 SID Locator Node length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "FunctionLength",
        "type": "int",
        "description": "SRv6 SID Function length.",
        "default": "32",
        "range_or_options": "0-128"
      },
      {
        "name": "ArgumentLength",
        "type": "int",
        "description": "SRv6 SID Argument length.",
        "default": "32",
        "range_or_options": "0-128"
      }
    ],
    "description": "Creates and configures an SRv6 SID structure sub-TLV for OSPFv3 protocol within the context of the Renix API. This function acts as a wrapper around Ospfv3Router.create_srv6_sid_structure_sub_tlv, providing integration into the RenixLibrary's API framework. It is used to generate and optionally configure an SRv6 SID structure sub-TLV object that can be associated with OSPFv3 advertisements.",
    "example": "| ${Session} | Create Ospfv3 | Port=${Port} |\n| ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n| ${Tlv} | Create Ospfv3 Srv6 Location Tlv | Lsa=${Lsa} |\n| ${SubTlv} | Create OSPFv3 Srv6 End Sid Sub Tlv | Tlv=${Tlv} | Flags=255 |\n| Create OSPFv3 Srv6 Sid Structure Sub Tlv | SubTlv=${SubTlv} | LbLength=128 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.get_ospf_router_from_lsa",
    "return_type": "List[object]",
    "return": "A list of OSPF routers corresponding to the input LSA(s). Each router object represents the source of the respective LSA.",
    "parameters": [
      {
        "name": "Lsa",
        "type": "Union[object, List[object]]",
        "description": "A single LSA object or a list of LSA objects. Each LSA object must support the `get_relatives` method to find related entities through 'GenerateLsa' relationships.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieve the OSPF router(s) associated with the given LSA(s) by navigating the relationship graph. This function checks if the provided LSA input is a list. If not, it wraps the input into a list. Then, for each LSA in the list, it retrieves the source-relative 'GenerateLsa' relationship, which typically represents the router that generated the LSA.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Ospfv3 | Port=${Port} |\n    | ${Lsa} | Create Ospfv3 Opaque Router Info LSA | Session=${Session} | Age=20 |\n    | ${Point} | Get Router From Route Pool | Lsa=${Lsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.establish_ospfv3",
    "return_type": "bool",
    "return": "Returns True if all OSPFv3 sessions are successfully established, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ospfv3Router or iterable of Ospfv3Router",
        "description": "A single session object or an iterable (list, set, tuple) of session objects representing OSPFv3 routers.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function is used to establish OSPFv3 protocol sessions by invoking the `establish()` method on each provided session object. It ensures uniform handling whether a single session or multiple sessions are passed. Internally, it converts any single session into a list for iteration and calls the `establish()` method on each session object. The function does not perform error handling itself but relies on decorators like `@abnormal_check` to manage exceptions.",
    "example": ".. code:: RobotFramework\n\n    | Establish Ospfv3 | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.grace_restart_ospfv3",
    "description": "Gracefully restarts the OSPFv3 sessions provided. This function accepts a single session or a collection of sessions (list, set, or tuple). It ensures each session is gracefully restarted by invoking the `grace_restart()` method on it. The function returns True upon successful execution.",
    "return_type": "bool",
    "return": "Returns True if all provided sessions were processed successfully.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single OSPFv3 session object or an iterable (list, set, tuple) containing multiple OSPFv3 session objects. Each session must have a `grace_restart()` method that performs the actual restart operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Grace Restart Ospfv3 | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.advertise_ospfv3_lsa",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功完成（True）或失败（False）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ospfv3Router or list of Ospfv3Router",
        "description": "OSPFv3协议会话对象或其列表。这些会话应包含一个`advertise`方法用于LSA广播。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str or None",
        "description": "指定要广播的LSA类型。支持的类型包括：'Router', 'Network', 'InterAreaPrefix', 'InterAreaRouter', 'AsExternal', 'Link'。",
        "default": "None",
        "range_or_options": "Router Network InterAreaPrefix InterAreaRouter AsExternal Link"
      },
      {
        "name": "Lsa",
        "type": "list or Lsa object or None",
        "description": "单个LSA对象或LSA对象的列表。如果提供此参数，则会忽略`Sessions`并使用LSA句柄进行广播。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于通告OSPFv3 Link-State Advertisements (LSAs)，支持两种模式：1) 使用提供的会话调用其`advertise`方法；2) 提供LSA对象列表直接构造和执行广播命令。",
    "example": ".. code:: RobotFramework\n\n    | Advertise Ospfv3 Lsa | Sessions=${Sessions} | Type=router |\n    | Advertise Ospfv3 Lsa | Sessions=${Sessions} | Lsa=${Lsas} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.withdraw_ospfv3_lsa",
    "return_type": "bool",
    "return": "Returns True if the LSA withdrawal operation is successfully executed; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ospfv3Router or list/set/tuple of Ospfv3Router",
        "description": "One or more session objects managing OSPFv3 LSA advertisements. If a single session object is provided, it will be converted into a list internally for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str or int, optional",
        "description": "The type of LSA to withdraw when operating on sessions. Valid values are specific OSPFv3 LSA types such as 'router', 'network', etc., depending on the underlying implementation and supported OSPFv3 features.",
        "default": "None",
        "range_or_options": "'router' 'network' 'InterAreaPrefix' 'InterAreaRouter' 'AsExternal'"
      },
      {
        "name": "Lsa",
        "type": "object or list of objects, optional",
        "description": "One or more LSA objects to be explicitly withdrawn. Each LSA object must have a 'handle' attribute used by the command layer to identify and withdraw the LSA. This parameter takes precedence over 'Type'.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Withdraws OSPFv3 Link-State Advertisements (LSAs) either based on session objects or directly targeting specific LSAs. The function provides two modes of operation: \n1. If no 'Lsa' is provided, it operates on one or more session objects specified in 'Sessions', withdrawing LSAs of a given type from each session.\n2. If 'Lsa' is provided, it directly withdraws the specified LSAs using a command layer instance, ignoring the 'Type' parameter.",
    "example": ".. code:: RobotFramework\n\n    | Withdraw Ospfv3 Lsa | Sessions=${Sessions} | Type=router |\n    | Withdraw Ospfv3 Lsa | Sessions=${Sessions} | Lsa=${Lsas} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.wait_ospfv3_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired states within the timeout period. If timeout occurs, a TesterException is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ospfv3Router or iterable of Ospfv3Router",
        "description": "OSPFv3 protocol session object(s) to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list of str, optional",
        "description": "Target OSPFv3 state(s) to wait for. If None, defaults to ['DR', 'BACKUP', 'DROTHER']. Comparison is case-insensitive.",
        "default": "['DR', 'BACKUP', 'DROTHER']",
        "range_or_options": "NOTSTART P2P WAITING DR BACKUP DROTHER DISABLE DOWN"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Polling interval in seconds between checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired state(s).",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the OSPFv3 state of each session in 'Sessions' reaches one of the desired states defined in 'State'. This function polls the sessions at regular intervals and checks the value of the 'State' attribute. If the state value for all given sessions matches one of the target states within the timeout period, it returns True. If the timeout is reached and not all sessions have reached the desired state, an exception is raised.",
    "example": "| Wait Ospfv3 State | Sessions=${Sessions} | State=DR | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.wait_ospfv3_adjacency_state",
    "return_type": "bool",
    "return": "Returns True if all sessions reach one of the desired adjacency states within the timeout period; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or iterable of Ospfv3Router objects",
        "description": "A list or any iterable collection of OSPFv3 session (neighbor) objects whose adjacency status will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list of str, optional",
        "description": "One or more expected adjacency states that the function waits for. If not provided, defaults to 'FULL'. The comparison is case-insensitive.",
        "default": "'FULL'",
        "range_or_options": "DOWN INIT EXSTART EXCHANGE LOADING TWOWAY FULL"
      },
      {
        "name": "Interval",
        "type": "int or convertible to int, optional",
        "description": "Polling interval in seconds between successive checks of the adjacency status.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or convertible to int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach the desired adjacency state(s).",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the OSPFv3 adjacency status of each session in 'Sessions' reaches one of the specified target states. This function polls the sessions at regular intervals and logs their current adjacency state if it does not match any of the expected states. It returns True as soon as all sessions have reached a valid expected state. If the timeout is reached before this condition is met, a TesterException is raised.",
    "example": "| Wait Ospfv3 Adjacency State | Sessions=${Sessions} | State=FULL | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.get_ospfv3_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with statistical items and their values if one matching session is found, returns a pandas DataFrame if multiple sessions match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ospfv3Router object or list or set or tuple or None",
        "description": "The OSPFv3 protocol session object(s) for which to retrieve statistics. If it's a collection of session objects, their `Name` attributes are extracted. If None, statistics may be retrieved without session filtering.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies the statistical items (columns) to retrieve from the available properties in 'Ospfv3SessionResultPropertySet'. If None, all properties are queried. If a string is provided, it will be converted into a list.",
        "default": "None",
        "range_or_options": "['RouterState', 'AdjacencyState', 'TxHello', 'RxHello', 'TxDd', 'RxDd', 'TxRouterLsa', 'RxRouterLsa', 'TxNetworkLsa', 'RxNetworkLsa', 'TxInterAreaPrefixLsa', 'RxInterAreaPrefixLsa', 'TxInterAreaRouterLsa', 'RxInterAreaRouterLsa', 'TxAsExternalLsa', 'RxAsExternalLsa', 'TxNssaLsa', 'RxNssaLsa', 'TxLinkLsa', 'RxLinkLsa', 'TxIntraAreaPrefixLsa', 'RxIntraAreaPrefixLsa', 'TxOpaqueRouterInfoLsa', 'RxOpaqueRouterInfoLsa', 'TxSrv6LocatorLsa', 'RxSrv6LocatorLsa', 'TxRequest', 'RxRequest', 'TxUpdate', 'RxUpdate', 'TxAck', 'RxAck']"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves OSPFv3 session statistics based on the given session object(s) and specified statistical items. It acts as a wrapper over an internal statistic-retrieval mechanism and handles data extraction, filtering, and formatting. The function supports retrieving either a single session’s statistics as a dictionary, multiple sessions' statistics as a DataFrame, or returns False when no match is found.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=Ospfv3SessionResultPropertySet |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Ospfv3 Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ospfv3.edit_ospfv3_port_config",
    "return_type": "bool",
    "return": "返回布尔值，表示Ospfv3端口配置是否修改成功。如果失败则抛出ContinuableFailure异常。",
    "parameters": [
      {
        "name": "Ports",
        "type": ":obj:`Port`",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TransmitRate",
        "type": "int",
        "description": "OSPFv3 Message Tx Rate (messages/second)",
        "default": "100",
        "range_or_options": "1-9000"
      },
      {
        "name": "SessionOutstanding",
        "type": "int",
        "description": "OSPFv3 Session Outstanding",
        "default": "20",
        "range_or_options": "1-1000"
      },
      {
        "name": "UpdateMsgTransmitRate",
        "type": "int",
        "description": "Deprecated. OSPFv3 Update Message Tx Rate (messages/second)",
        "default": "10",
        "range_or_options": "1-9000"
      },
      {
        "name": "EnableLoop",
        "type": "bool",
        "description": "启用环回模式",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于修改一个或多个指定端口上的OSPFv3协议端口配置。支持的配置参数包括传输速率、会话数量、更新消息速率以及是否启用环回模式等。若配置失败，则会抛出ContinuableFailure异常；若成功，则返回True。",
    "example": ".. code:: RobotFramework\n\n    | Edit Ospfv3 Port Config | Ports=${Ports} | TransmitRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.create_ovsdb",
    "return_type": "Ovsdb",
    "return": "The newly created and initialized Ovsdb instance associated with the given port. This instance is also registered in the global protocol object map using its handle as the key.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper layer object (typically a port) that the Ovsdb instance is associated with. This is passed directly to the Ovsdb constructor.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OvsdbControllerIpList",
        "type": "list",
        "description": "OVSDB Controller IP List used for configuring the OVSDB session. This is an optional keyword argument.",
        "default": "\"\"",
        "range_or_options": "valid IP addresses"
      }
    ],
    "description": "Creates and initializes an Ovsdb protocol instance associated with the given port, and updates the global protocol object mapping with this new instance. Any provided keyword arguments are forwarded to the Ovsdb constructor for further configuration. After creation, the instance is registered in the global `map_protocol_object` dictionary using its `handle` as the key, allowing it to be referenced later by that handle. This function is typically used when setting up an OVSDB protocol session on a specific test port within a test automation framework.",
    "example": "| Create Ovsdb | Port=${Port} | OvsdbControllerIpList=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.wait_ovsdb_state",
    "return_type": "bool",
    "return": "Returns True if all OVSDB sessions reach the specified state within the timeout. If any session fails to reach the target state, the function raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Ovsdb objects",
        "description": "A list containing one or more OVSDB session objects that will be monitored for reaching the specified state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state each session must reach. Valid options are 'STARTED' and 'STOPPED'. Default is 'STARTED'.",
        "default": "'STARTED'",
        "range_or_options": "STARTED STOPPED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The interval (in seconds) at which the function polls the state of each session.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time (in seconds) to wait for all sessions to reach the specified state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for one or more OVSDB protocol sessions to transition into a specified state ('STARTED' or 'STOPPED'). It internally calls the backend implementation with the provided parameters and checks session states periodically. If all sessions reach the desired state within the timeout period, it returns True; otherwise, it raises a ContinuableFailure exception.",
    "example": "| Wait Ovsdb State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.edit_ovsdb_port_config",
    "return_type": "bool or list of OvsdbPortConfig",
    "return": "如果配置修改成功返回True，否则返回False。若传入单个Port对象，则返回对应的OvsdbPortConfig对象；若传入多个Port对象，则返回OvsdbPortConfig对象的列表。",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port or list of Port",
        "description": "需要修改OVSDB端口配置的一个或多个测试仪表端口对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OvsdbConnectionType",
        "type": "str",
        "description": "指定OVSDB连接类型。",
        "default": "TCP",
        "range_or_options": "TCP TLS PASSIVE_TCP PASSIVE_TLS"
      },
      {
        "name": "PrivateKey",
        "type": "str",
        "description": "用于TLS连接的私钥文件路径。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "Certificate",
        "type": "str",
        "description": "用于TLS连接的证书文件路径。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "CaCertificate",
        "type": "str",
        "description": "用于TLS连接的CA证书文件路径。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "ConnectRate",
        "type": "int",
        "description": "每秒最大连接数（连接速率）。",
        "default": "1000",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于修改一个或多个测试仪表端口上的OVSDB协议配置。它接受端口对象和一组关键字参数作为配置项，并将这些配置更新到每个端口关联的OvsdbPortConfig对象中。如果所有配置都成功应用，则返回True；否则返回False。如果只传入一个端口，则返回更新后的OvsdbPortConfig对象；如果传入多个端口，则返回更新后的OvsdbPortConfig对象列表。",
    "example": "| Edit Ovsdb Port Config | Ports=${Ports} | OvsdbConnectionType=TLS | PrivateKey=/path/to/private.key | Certificate=/path/to/cert.pem | CaCertificate=/path/to/ca.pem | ConnectRate=2000"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.edit_ovsdb_table",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [],
    "kwargs": [
      {
        "name": "OvsdbRefreshWay",
        "type": "str",
        "description": "设置 OVSDB 表的刷新方式。",
        "default": "MANUAL",
        "range_or_options": "MANUAL PERIODIC"
      },
      {
        "name": "OvsdbTimer",
        "type": "int",
        "description": "设置 OVSDB 表的刷新定时器时间（单位：秒）。",
        "default": "30",
        "range_or_options": "1-65535"
      },
      {
        "name": "OvsdbContents",
        "type": "str",
        "description": "设置 OVSDB 表的内容数据。",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "OvsdbDatabaseType",
        "type": "str",
        "description": "设置 OVSDB 数据库类型。",
        "default": "HARDWAREVTEP",
        "range_or_options": "HARDWAREVTEP"
      },
      {
        "name": "OvsdbTableType",
        "type": "str",
        "description": "设置 OVSDB 表的类型。",
        "default": "LOCAL",
        "range_or_options": "LOCAL REMOTE"
      }
    ],
    "description": "该函数用于修改 OVSDB 表的相关配置。通过传入关键字参数，可以更新 OVSDB 的刷新方式、刷新周期、内容数据、数据库类型以及表类型等信息。此函数封装了底层 `renix.edit_ovsdb_table` 的调用，并在失败时抛出可继续执行的异常（ContinuableFailure）。",
    "example": ".. code:: RobotFramework\n\n    | Edit Ovsdb Table | OvsdbRefreshWay=PERIODIC | OvsdbTimer=60 | OvsdbContents={\"table\": \"Remote_Mappings\"} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.edit_ovsdb_export",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True / False）",
    "parameters": [],
    "kwargs": [
      {
        "name": "OvsdbDatabaseType",
        "type": "str",
        "description": "指定 OVSDB 数据库类型。",
        "default": "HARDWAREVTEP",
        "range_or_options": "HARDWAREVTEP"
      },
      {
        "name": "OvsdbTableType",
        "type": "str",
        "description": "指定 OVSDB 表类型。",
        "default": "LOCAL",
        "range_or_options": "LOCAL REMOTE"
      },
      {
        "name": "OvsdbExportFilePrefix",
        "type": "str",
        "description": "指定导出文件的前缀名。",
        "default": "OVSDB_Contents_",
        "range_or_options": "not_found"
      },
      {
        "name": "OvsdbSaveAsArchive",
        "type": "bool",
        "description": "指定是否将导出内容保存为归档文件。",
        "default": "FALSE",
        "range_or_options": "TRUE FALSE"
      },
      {
        "name": "OvsdbExportPath",
        "type": "str",
        "description": "指定导出文件的路径。",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于修改 OVSDB 导出配置。它是一个封装了底层 `Ovsdb.edit_ovsdb_export` 静态方法的接口方法，允许通过关键字参数动态更新 OVSDB 的导出设置。此方法主要用于配置 OVSDB 内容导出时的数据库类型、表类型、文件前缀、存储路径及是否以归档形式保存等选项。",
    "example": ".. code:: RobotFramework\n\n    | Edit Ovsdb Export | OvsdbSaveAsArchive=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_upload_ca_certificate",
    "return_type": "bool",
    "return": "Always returns True if the upload command is executed successfully. Returns False only if the backend operation fails.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list]",
        "description": "A single port object or a list of port objects where CA certificates will be uploaded. Each port must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LocalPath",
        "type": "str",
        "description": "The local directory path on the host machine where the CA certificate files are stored.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Files",
        "type": "Union[str, list]",
        "description": "A single filename or a list of filenames representing the CA certificate files to upload. The files must exist in the specified LocalPath directory.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function uploads one or more CA certificate files to the specified test port(s). It prepares and executes the upload operation by converting inputs into appropriate formats before calling the backend command. This is commonly used in secure communication testing scenarios where trusted certificates need to be configured on the device under test.",
    "example": "| Ovsdb Upload Ca Certificate | Ports=${Ports} | LocalPath='D:\\files\\tls' | Files=${files} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_upload_certificate",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the upload command. Returns False only if the underlying operation fails, in which case a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "The test instrument port(s) on which the certificate should be uploaded. If a single Port object is provided, it will be internally converted into a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LocalPath",
        "type": "str",
        "description": "The local file path where the certificate file(s) are located.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Files",
        "type": "list of str or str",
        "description": "The name(s) of the certificate file(s) to upload. If a single string is provided, it will be internally converted into a list.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Uploads a certificate file from the local machine to the specified port(s) using the OVSDB protocol. This function acts as a wrapper for the static method `Ovsdb.upload_certificate`, ensuring that the certificate files are properly uploaded via OVSDB communication. Internally, it ensures that both Ports and Files are treated as lists even if scalar values are passed.",
    "example": "| Ovsdb Upload Certificate | Ports=${Ports} | LocalPath='D:\\files\\tls' | Files=${files} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_upload_private_key",
    "return_type": "bool",
    "return": "Returns True if the private key upload operation is successfully initiated. Returns False only if there's a failure during execution.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "The test port(s) on which the private key should be uploaded via OVSDB protocol.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LocalPath",
        "type": "str",
        "description": "The local file system path where the private key files are located.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Files",
        "type": "str or list of str",
        "description": "Name or names of the private key file(s) to be uploaded from LocalPath.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function uploads one or more private key files from the local machine to specified test ports using the OVSDB protocol. It acts as a wrapper for the `Ovsdb.upload_private_key` static method and ensures that scalar inputs for Ports and Files are internally converted into lists for uniform handling. If the upload operation fails (returns False), a `ContinuableFailure` exception is raised with a corresponding error message.",
    "example": "| Ovsdb Upload Private Key | Ports=${Ports} | LocalPath='D:\\files\\tls' | Files=${files} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_refresh_files",
    "return_type": "bool",
    "return": "Returns True if the file refresh operation was successfully initiated. This does not guarantee that the refresh completed without errors, only that the command was executed properly.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, List[object]]",
        "description": "A single port object or a list of port objects whose files need to be refreshed. Each port object must have a `handle` attribute that uniquely identifies it within the OVSDB context.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Refreshes the files associated with the specified ports in the OVSDB protocol. This function acts as a wrapper around the underlying RenixAPI's ovsdb_refresh_files method. If only one port is provided, it is internally converted into a list to ensure consistent handling of input. If the result from the backend call is False, this function raises a ContinuableFailure exception indicating failure; otherwise, it returns the result.",
    "example": "| Ovsdb Refresh Files | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_delete_certificate",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the deletion command. Returns False only if the backend operation fails, in which case a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "The port(s) from which the certificates should be deleted.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Files",
        "type": "str or list of str",
        "description": "The name(s) of the certificate file(s) to delete.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Deletes one or more certificate files from one or more specified ports using the OVSDB protocol. This method wraps the `Ovsdb.delete_certificate` static method and ensures proper parameter handling by converting single values into lists internally for consistent processing.",
    "example": "| Ovsdb Delete Certificate | Ports=${Ports} | Files=${files} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_start_refresh_table",
    "return_type": "bool",
    "return": "A boolean indicating whether the refresh operation was successfully initiated on all provided session(s). Always returns True unless an exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ovsdb or iterable of Ovsdb objects (list, set, tuple)",
        "description": "A single OVSDB session object or a collection of OVSDB session objects whose table refresh process should be started.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts the table refresh process for one or more OVSDB session objects. This function can accept either a single session or an iterable (list, set, or tuple) of sessions. It invokes the `start_refresh_table` method on each session to initiate periodic or manual updates of table data from the associated OVSDB server. If any underlying call fails, an exception may propagate upward since this function does not catch exceptions from session methods.",
    "example": "| Ovsdb Start Refresh Table | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_stop_refresh_table",
    "description": "Stops the table refresh operation for one or more OVSDB session objects. This function is typically used to halt periodic updates or polling of database tables on a per-session basis.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single OVSDB session object or an iterable (e.g., list, tuple, set) containing multiple OVSDB session objects. Each session must have a `stop_refresh_table()` method implemented.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "return_type": "bool",
    "return": "Always returns True after successfully attempting to stop the refresh operation for all provided sessions. If any failure occurs internally, it raises a ContinuableFailure exception instead.",
    "example": "| Ovsdb Stop Refresh Table | Sessions=${Sessions} |",
    "additional_notes": "This function is decorated with @abnormal_check(), which may provide additional error handling or logging. If any session object does not implement the `stop_refresh_table()` method, a TypeError may be raised during execution."
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_query_db",
    "return_type": "bool",
    "return": "True if the query operation is successfully executed on all provided sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list/tuple/set of objects",
        "description": "A single OVSDB session object or a collection of session objects used to perform database queries. If a single session is provided, it will be internally converted into a list for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict",
        "description": "Arbitrary keyword arguments representing filtering criteria or query options passed directly to the underlying `query_db` method of each session. These may include table names, conditions, columns, etc., depending on the session implementation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function performs a query operation on the Open vSwitch Database (OVSDB) using one or more session objects. It wraps calls to the `query_db` method of each session after ensuring valid input formatting. This allows batch querying across multiple sessions in a unified manner.",
    "example": "| Ovsdb Query Db | Sessions=${Sessions} | table=Interface | where={'name': 'eth0'} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_query_db_oneshot",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the query operation. Note that this does not guarantee the success of individual queries on each session; errors during per-session queries should be handled separately by the callee.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Session object or iterable of Session objects",
        "description": "One or more Session instances on which the one-shot OVSDB database query will be executed. If a single Session is provided, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict",
        "description": "Additional keyword arguments passed directly to the underlying `query_db_oneshot` method of each Session object. These may include options like table names, filters, columns, or other query-specific parameters.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Perform a one-shot OVSDB database query on the specified session(s). This function wraps a call to `query_db_oneshot` on one or more Session objects, allowing for querying of the OVSDB in a single operation. It ensures uniform querying across multiple sessions with the same set of parameters and is typically used to retrieve data from the OVSDB without maintaining an ongoing connection or subscription.",
    "example": "| Ovsdb Query Db Oneshot | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_query_db_period",
    "return_type": "bool",
    "return": "A boolean value indicating the success of initiating the database query operation across all provided sessions. Returns True if successful, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Ovsdb",
        "description": "The OVSDB protocol session object or an iterable (e.g., list, tuple) of such session objects on which to perform the periodic database query.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function performs a periodical database query operation using the OVSDB protocol on one or more session objects. It wraps the `query_db_period` method of each provided session, allowing for repeated querying over time. If a single session is provided, it is handled appropriately; if multiple sessions are provided, the operation is applied to each individually. The function ensures consistent handling of session objects and propagates any failure by raising a ContinuableFailure exception.",
    "example": "| Ovsdb Query Db Period | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_stop_query_db_period",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful. Returns True on success, and raises a ContinuableFailure exception on failure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single OVSDB session object or a collection (list, set, tuple) of session objects for which periodic database querying should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict, optional",
        "description": "Additional keyword arguments that can be used to configure how the periodic query is stopped. These are passed directly to the `stop_query_db_period` method of each session.",
        "default": "{}",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops the periodic querying of the Open vSwitch Database (OVSDB) for one or more session objects. This function supports both single and multiple session inputs, and accepts optional keyword arguments for extended configurations. If the underlying call returns False, it raises a ContinuableFailure exception to indicate the operation failed, otherwise it returns True.",
    "example": "| Ovsdb Stop Query Db Period | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.ovsdb_export_contents",
    "return_type": "bool",
    "return": "Returns True if all session contents are exported successfully, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (list, set, tuple) containing multiple session objects. Each session object must implement the `export_contents()` method to handle the actual export logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Exports the contents of one or more session objects to the OVSDB (Open vSwitch Database). This function accepts a single session object or a collection of session objects and invokes the `export_contents()` method on each session. It returns True upon successful execution. If the input is not a list, set, or tuple, it will be converted into a list for iteration.",
    "example": ".. code:: RobotFramework\n\n    | Ovsdb Stop Query Db Period | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.ovsdb.get_ovsdb_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary, DataFrame, or boolean based on the number of matching results:\n- If one match: Returns a dictionary with keys as statistical items (e.g., 'ReadCount', 'WriteCount').\n- If multiple matches: Returns a pandas DataFrame.\n- If no matches: Returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list/set/tuple of objects",
        "description": "Session object(s) for which to retrieve statistics. Each session object must have a `Name` attribute. If None, no session filtering is applied. If a single session object is passed, its `Name` is used as the session identifier. If multiple session objects are passed, their `Name` attributes are collected.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string is provided, it is converted into a list. Must be a subset of available properties determined by the system.",
        "default": "None",
        "range_or_options": "['ReadCount', 'WriteCount']"
      }
    ],
    "kwargs": [],
    "description": "Retrieves OVSDB-related statistics for given session(s), optionally filtered to specific statistical items. This function wraps `_get_statictis()` and is specifically tailored for querying 'OvsdbResults' statistics. It processes the provided session information into appropriate identifiers and delegates the actual data retrieval and filtering to `_get_statictis()`. The result is returned in a structured format, either as a dictionary or DataFrame, depending on the number of matches found.",
    "example": "| Get Ovsdb Statistic | Sessions=${Sessions} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep",
    "return_type": "Pcep",
    "return": "The newly created PCEP protocol session object, initialized with the provided Port and configuration parameters.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent port or layer to which this PCEP instance will be associated. Typically another protocol or port object within the test framework.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable the PCEP protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Role",
        "type": "str",
        "description": "PCEP role: either PCE or PCC.",
        "default": "PCE",
        "range_or_options": "PCE PCC"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version used for the session.",
        "default": "IPv4",
        "range_or_options": "IPv4 IPv6"
      },
      {
        "name": "UseGatewayAsDutIp",
        "type": "bool",
        "description": "Use gateway IP address as DUT IP address if selected; otherwise custom DUT IP is used.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SessionIpAddress",
        "type": "str",
        "description": "Type of IP used for the PCEP connection.",
        "default": "Interface_IP",
        "range_or_options": "Interface_IP Router_ID"
      },
      {
        "name": "PeerIpv4Address",
        "type": "str",
        "description": "DUT IPv4 address when UseGatewayAsDutIp is not selected and IpVersion is IPv4.",
        "default": "192.85.1.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "PeerIpv4AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv4 address when UseGatewayAsDutIp is not selected and IpVersion is IPv4.",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "PeerIpv6Address",
        "type": "str",
        "description": "DUT IPv6 address when UseGatewayAsDutIp is not selected and IpVersion is IPv6.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "PeerIpv6AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv6 address when UseGatewayAsDutIp is not selected and IpVersion is IPv6.",
        "default": "::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "SessionInitiator",
        "type": "bool",
        "description": "If True, initiates session establishment request actively; if False, listens for incoming requests. If both sides are active, the side with higher IP wins.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Negotiation",
        "type": "bool",
        "description": "Enable negotiation for Keepalive Timer and Dead Timer values.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "KeepAlive",
        "type": "str",
        "description": "Interval (in seconds) between KEEPALIVE messages.",
        "default": "30",
        "range_or_options": "0-65535"
      },
      {
        "name": "MinKeepAlive",
        "type": "int",
        "description": "Minimum acceptable keepalive interval (in seconds).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxKeepAlive",
        "type": "int",
        "description": "Maximum acceptable keepalive interval (in seconds).",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Dead",
        "type": "str",
        "description": "Time interval (in seconds) before a session is considered dead after no message is received.",
        "default": "120",
        "range_or_options": "0-65535"
      },
      {
        "name": "MinDeadAlive",
        "type": "int",
        "description": "Minimum acceptable dead interval (in seconds).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxDeadAlive",
        "type": "int",
        "description": "Maximum acceptable dead interval (in seconds).",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "EnableStatefulCapability",
        "type": "bool",
        "description": "Include Stateful PCE Capability TLV in OPEN message if enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "StatefulCapability",
        "type": "list",
        "description": "List of stateful capabilities to include when enabled.",
        "default": "['LSP_UPDATE','LSP_INSTANTIATION']",
        "range_or_options": "LSP_UPDATE INCLUDE_DB_VERSION LSP_INSTANTIATION TRIGGERED_RESYNC DELTA_LSP_SYN TRIGGERED_INITIAL_SYNC"
      },
      {
        "name": "EnableSegmentRoutingCapability",
        "type": "list",
        "description": "Enable Segment Routing capability extensions.",
        "default": "['SR']",
        "range_or_options": "SR SRv6"
      },
      {
        "name": "PathSetupTypeList",
        "type": "list",
        "description": "Add path setup types.",
        "default": "[0,1]",
        "range_or_options": "0 1"
      },
      {
        "name": "SrCapabilityFlags",
        "type": "list",
        "description": "Select one or more SR capability flags (visible when Role is PCC and SR is enabled).",
        "default": "['NONTBIT','NFlag','XFlag']",
        "range_or_options": "NONTBIT NFlag XFlag"
      },
      {
        "name": "Srv6CapabilityFlags",
        "type": "list",
        "description": "Select one or more SRv6 capability flags (visible when Role is PCC and SRv6 is enabled).",
        "default": "['NONTBIT','NFlag','XFlag']",
        "range_or_options": "NONTBIT NFlag XFlag"
      },
      {
        "name": "MSDs",
        "type": "list",
        "description": "Select one or more MSD types (visible when SRv6 is enabled and Role is PCC).",
        "default": "['NONTBIT']",
        "range_or_options": "NONTBIT MaxiSegmentLeft MaxiEndPop MaxiHEncaps MaxiEndD"
      },
      {
        "name": "MaximumSidDepth",
        "type": "int",
        "description": "Specify maximum number of SIDs (visible when SR is enabled and Role is PCC).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxSegmentsLeft",
        "type": "int",
        "description": "Specify MSD value (visible when SRv6 is enabled, Role is PCC, and 'Maximum Segments Left' is selected).",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "Specify MSD value (visible when SRv6 is enabled, Role is PCC, and 'Maximum End Pop' is selected).",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxHencaps",
        "type": "int",
        "description": "Specify MSD value (visible when SRv6 is enabled, Role is PCC, and 'Maximum H.Encaps' is selected).",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "Specify MSD value (visible when SRv6 is enabled, Role is PCC, and 'Maximum End D' is selected).",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "EnableDbVersionTlv",
        "type": "bool",
        "description": "Configure DB Version TLV if enabled.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LspStateDbVersion",
        "type": "int",
        "description": "Initial version number of LSP state database (visible when EnableDbVersionTlv is True).",
        "default": "1",
        "range_or_options": "1-18446744073709551614"
      }
    ],
    "description": "Creates a new PCEP protocol instance and maps it in the global protocol object map. This function initializes a PCEP object with the provided parent port and any additional configuration parameters. It then registers the created PCEP instance in the global protocol object mapping using its handle, allowing for later reference and management.",
    "example": "| Create Pcep | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.edit_pcep",
    "return_type": "bool",
    "return": "Returns True if the PCEP session attributes were successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Pcep",
        "description": "The PCEP protocol session object to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the PCEP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PCEP protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Role",
        "type": "str",
        "description": "Specifies the role of the PCEP entity in the session.",
        "default": "PCE",
        "range_or_options": "PCE PCC"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "Specifies the IP version used for the session.",
        "default": "IPv4",
        "range_or_options": "IPv4 IPv6"
      },
      {
        "name": "UseGatewayAsDutIp",
        "type": "bool",
        "description": "If True, uses gateway IP as DUT IP; otherwise allows custom DUT IP.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SessionIpAddress",
        "type": "str",
        "description": "Specifies the type of IP address used for the session.",
        "default": "Interface_IP",
        "range_or_options": "Interface_IP Router_ID"
      },
      {
        "name": "PeerIpv4Address",
        "type": "str",
        "description": "Custom DUT IPv4 address when UseGatewayAsDutIp is False and IpVersion is IPv4.",
        "default": "192.85.1.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "PeerIpv4AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv4 addresses when UseGatewayAsDutIp is False and IpVersion is IPv4.",
        "default": "0.0.0.1",
        "range_or_options": "valid_ipv4_address"
      },
      {
        "name": "PeerIpv6Address",
        "type": "str",
        "description": "Custom DUT IPv6 address when UseGatewayAsDutIp is False and IpVersion is IPv6.",
        "default": "2000::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "PeerIpv6AddressStep",
        "type": "str",
        "description": "Increment step for DUT IPv6 addresses when UseGatewayAsDutIp is False and IpVersion is IPv6.",
        "default": "::1",
        "range_or_options": "valid_ipv6_address"
      },
      {
        "name": "SessionInitiator",
        "type": "bool",
        "description": "Determines whether this side initiates the session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Negotiation",
        "type": "bool",
        "description": "Enables negotiation of Keepalive and Dead timers.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "KeepAlive",
        "type": "str",
        "description": "Interval (in seconds) for sending KEEPALIVE messages.",
        "default": "30",
        "range_or_options": "0-65535"
      },
      {
        "name": "MinKeepAlive",
        "type": "int",
        "description": "Minimum acceptable KEEPALIVE interval (in seconds).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxKeepAlive",
        "type": "int",
        "description": "Maximum acceptable KEEPALIVE interval (in seconds).",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Dead",
        "type": "str",
        "description": "Time (in seconds) after which the session is considered dead if no message is received.",
        "default": "120",
        "range_or_options": "0-65535"
      },
      {
        "name": "MinDeadAlive",
        "type": "int",
        "description": "Minimum acceptable DEAD interval (in seconds).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxDeadAlive",
        "type": "int",
        "description": "Maximum acceptable DEAD interval (in seconds).",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "EnableStatefulCapability",
        "type": "bool",
        "description": "If True, includes Stateful PCE Capability TLV in OPEN messages.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "StatefulCapability",
        "type": "list",
        "description": "List of capabilities included in Stateful PCE Capability TLV.",
        "default": "['LSP_UPDATE','LSP_INSTANTIATION']",
        "range_or_options": "LSP_UPDATE INCLUDE_DB_VERSION LSP_INSTANTIATION TRIGGERED_RESYNC DELTA_LSP_SYN TRIGGERED_INITIAL_SYNC"
      },
      {
        "name": "EnableSegmentRoutingCapability",
        "type": "list",
        "description": "List of Segment Routing Capabilities enabled for the session.",
        "default": "['SR']",
        "range_or_options": "SR SRv6"
      },
      {
        "name": "PathSetupTypeList",
        "type": "list",
        "description": "List of Path Setup Types supported by the session.",
        "default": "[0,1]",
        "range_or_options": "0 1"
      },
      {
        "name": "SrCapabilityFlags",
        "type": "list",
        "description": "SR capability flags for PCEP sessions with Role=PCC and SR enabled.",
        "default": "['NONTBIT','NFlag','XFlag']",
        "range_or_options": "NONTBIT NFlag XFlag"
      },
      {
        "name": "Srv6CapabilityFlags",
        "type": "list",
        "description": "SRv6 capability flags for PCEP sessions with Role=PCC and SRv6 enabled.",
        "default": "['NONTBIT','NFlag','XFlag']",
        "range_or_options": "NONTBIT NFlag XFlag"
      },
      {
        "name": "MSDs",
        "type": "list",
        "description": "List of MSD types for SRv6 capability.",
        "default": "['NONTBIT']",
        "range_or_options": "NONTBIT MaxiSegmentLeft MaxiEndPop MaxiHEncaps MaxiEndD"
      },
      {
        "name": "MaximumSidDepth",
        "type": "int",
        "description": "Specifies the maximum number of SIDs allowed in a path when SR is enabled.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxSegmentsLeft",
        "type": "int",
        "description": "Specifies the maximum segments left value when SRv6 and 'Maximum Segments Left' MSD are selected.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndPop",
        "type": "int",
        "description": "Specifies the maximum End Pop value when SRv6 and 'Maximum End Pop' MSD are selected.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxHencaps",
        "type": "int",
        "description": "Specifies the maximum H.Encaps value when SRv6 and 'Maximum H.Encaps' MSD are selected.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxEndD",
        "type": "int",
        "description": "Specifies the maximum End D value when SRv6 and 'Maximum End D' MSD are selected.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "EnableDbVersionTlv",
        "type": "bool",
        "description": "If True, enables DB Version TLV in PCEP OPEN messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LspStateDbVersion",
        "type": "int",
        "description": "Initial version number of the LSP state database when EnableDbVersionTlv is True.",
        "default": "1",
        "range_or_options": "1-18446744073709551614"
      }
    ],
    "description": "This function modifies the attributes of a given PCEP session object based on provided keyword arguments. It supports configuration of various PCEP session parameters including session control, IP addressing, timers, capabilities, and more. The function updates only the provided parameters and leaves others unchanged.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | Role=PCC |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pcc_lsp",
    "return_type": "PccLspConfig or list of PccLspConfig",
    "return": "Returns a single `PccLspConfig` object if one session is provided, or a list of `PccLspConfig` objects for multiple sessions. These represent the created PCEP PCC LSP configurations.",
    "description": "创建PCEP PCC LSP对象。该方法用于一个或多个PCEP会话对象上创建PCC（路径计算客户端）LSP（标签交换路径）配置。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "PCEP协议会话对象列表，每个会话对象必须包含`create_pcc_lsp`方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP PCC LSP对象名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能PCEP PCC LSP。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LspCount",
        "type": "int",
        "description": "LSP数量。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "AutoGenSymbolicName",
        "type": "bool",
        "description": "系统自动生成Symbolic Name。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SymbolicName",
        "type": "str",
        "description": "设置Symbolic Name。",
        "default": "PLSP_@s",
        "range_or_options": "not_found"
      },
      {
        "name": "PathSetupType",
        "type": "str",
        "description": "建立LSP的方法。",
        "default": "SEGMENT_ROUTING",
        "range_or_options": "SEGMENT_ROUTING SRv6"
      },
      {
        "name": "SourceIpv4Address",
        "type": "str",
        "description": "起始源IPv4地址。",
        "default": "192.85.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "SourceIpv4AddressStep",
        "type": "str",
        "description": "源IPv4地址的跳变步长。",
        "default": "0.0.0.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "SourceIpv4AddressSessionOffset",
        "type": "str",
        "description": "源IPv4地址在会话之间的跳变步长。",
        "default": "0.0.1.0",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "DestinationIpv4Address",
        "type": "str",
        "description": "起始目的IPv4地址。",
        "default": "193.85.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "DestinationIpv4AddressStep",
        "type": "str",
        "description": "目的IPv4地址的跳变步长。",
        "default": "0.0.0.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "DestinationIpv4AddressSessionOffset",
        "type": "str",
        "description": "目的IPv4地址在会话之间的跳变步长。",
        "default": "0.0.1.0",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "SourceIpv6Address",
        "type": "str",
        "description": "起始源IPv6地址。",
        "default": "2000::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "SourceIpv6AddressStep",
        "type": "str",
        "description": "源IPv6地址的跳变步长。",
        "default": "::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "SourceIpv6AddressSessionOffset",
        "type": "str",
        "description": "源IPv6地址在会话之间的跳变步长。",
        "default": "::1:0",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "DestinationIpv6Address",
        "type": "str",
        "description": "起始目的IPv6地址。",
        "default": "2001::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "DestinationIpv6AddressStep",
        "type": "str",
        "description": "目的IPv6地址的跳变步长。",
        "default": "::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "DestinationIpv6AddressSessionOffset",
        "type": "str",
        "description": "目的IPv6地址在会话之间的跳变步长。",
        "default": "::1:0",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "LspInitiateMethod",
        "type": "str",
        "description": "LSP初始方式。",
        "default": "REPORT",
        "range_or_options": "REPORT PCE_INITIATE SYNCHRONIZATION REQUEST"
      },
      {
        "name": "ImmediateDelegation",
        "type": "bool",
        "description": "直接托管，会话建立后自动将LSP托管给PCE。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "DelegationInSynchronization",
        "type": "bool",
        "description": "同步中托管，仅当LSP初始方式为Synchronization Method时可用。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pce_lsp",
    "description": "创建PCEP PCE LSP对象，用于配置和管理路径计算元素（PCE）通过PCEP协议发起的标签交换路径（LSP）。该方法支持IPv4和IPv6地址配置、LSP数量控制以及Symbolic Name自动生成等高级功能。",
    "return_type": "object or list of :obj:`PceLspConfig`",
    "return": "返回一个或多个创建的PCE LSP对象。如果输入单个会话，则返回单个对象；如果输入多个会话，则返回对象列表。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object / list",
        "description": "PCEP协议会话对象列表，用于在其上创建PCE LSP。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP PCE LSP对象名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能PCEP PCE LSP",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LspCount",
        "type": "int",
        "description": "LSP数量",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "AutoGenSymbolicName",
        "type": "bool",
        "description": "系统自动生成Symbolic Name",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SymbolicName",
        "type": "str",
        "description": "设置Symbolic Name",
        "default": "PLSP_@s",
        "range_or_options": "not_found"
      },
      {
        "name": "PathSetupType",
        "type": "str",
        "description": "建立LSP的方法",
        "default": "SEGMENT_ROUTING",
        "range_or_options": "SEGMENT_ROUTING SRv6"
      },
      {
        "name": "SourceIpv4Address",
        "type": "str",
        "description": "起始源IPv4地址",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "SourceIpv4AddressStep",
        "type": "str",
        "description": "源IPv4地址跳变步长",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "SourceIpv4AddressSessionOffset",
        "type": "str",
        "description": "源IPv4地址在会话之间的跳变步长",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DestinationIpv4Address",
        "type": "str",
        "description": "起始目的IPv4地址",
        "default": "193.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DestinationIpv4AddressStep",
        "type": "str",
        "description": "目的IPv4地址跳变步长",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DestinationIpv4AddressSessionOffset",
        "type": "str",
        "description": "目的IPv4地址在会话之间的跳变步长",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "SourceIpv6Address",
        "type": "str",
        "description": "起始源IPv6地址",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "SourceIpv6AddressStep",
        "type": "str",
        "description": "源IPv6地址跳变步长",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "SourceIpv6AddressSessionOffset",
        "type": "str",
        "description": "源IPv6地址在会话之间的跳变步长",
        "default": "::1:0",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "DestinationIpv6Address",
        "type": "str",
        "description": "起始目的IPv6地址",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "DestinationIpv6AddressStep",
        "type": "str",
        "description": "目的IPv6地址跳变步长",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "DestinationIpv6AddressSessionOffset",
        "type": "str",
        "description": "目的IPv6地址在会话之间的跳变步长",
        "default": "::1:0",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "LspInitiateMethod",
        "type": "str",
        "description": "LSP初始方式",
        "default": "UPDATE",
        "range_or_options": "UPDATE PCE_INITIATE REPLY"
      },
      {
        "name": "ImmediateUpdate",
        "type": "bool",
        "description": "是否立即更新LSP",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pcc_lsp_info",
    "return_type": "PccLspInfoObjectConfig or list of PccLspInfoObjectConfig",
    "return": "A single 'PccLspInfoObjectConfig' object if one was created, or a list of such objects if multiple PcepLsps were processed.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list",
        "description": "A single PCEP LSP object or a collection (list, set, or tuple) of PCEP LSP objects for which the PCC LSP information needs to be retrieved or configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the PCEP PCC LSP INFO object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the PCEP PCC LSP INFO object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Administrator",
        "type": "bool",
        "description": "Enables Administrative control.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "State",
        "type": "str",
        "description": "Sets the initial LSP state.",
        "default": "GOING_UP",
        "range_or_options": "DOWN UP ACTIVE GOING_DOWN GOING_UP RESERVED_5 RESERVED_6 RESERVED_7"
      },
      {
        "name": "AutoGeneratedPlspId",
        "type": "bool",
        "description": "Automatically generates PLSP-ID.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PlspId",
        "type": "int",
        "description": "Specifies the starting PLSP-ID.",
        "default": "1",
        "range_or_options": "1-1048575"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "Specifies the step increment for PLSP-ID within the same session.",
        "default": "1",
        "range_or_options": "1-1048575"
      },
      {
        "name": "LspId",
        "type": "int",
        "description": "Specifies the starting LSP ID.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "LspIdStep",
        "type": "int",
        "description": "Specifies the step increment for LSP-ID within the same session.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "LspIdSessionOffset",
        "type": "int",
        "description": "Specifies the step increment for LSP-ID across sessions in a PCEP session block.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "TunnelId",
        "type": "int",
        "description": "Specifies the starting Tunnel ID.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "TunnelStep",
        "type": "int",
        "description": "Specifies the step increment for Tunnel ID within the same session.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "TunnelSessionOffset",
        "type": "int",
        "description": "Specifies the step increment for Tunnel ID across sessions in a PCEP session block.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "ExtendedTunnelIPv4Id",
        "type": "str",
        "description": "Specifies the extended tunnel IPv4 ID.",
        "default": "10.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "ExtendedTunnelIPv4IdStep",
        "type": "str",
        "description": "Specifies the step increment for the extended tunnel IPv4 ID within the same session.",
        "default": "0.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "ExtendedTunnelIPv4IdSessionOffset",
        "type": "str",
        "description": "Specifies the step increment for the extended tunnel IPv4 ID across sessions in a PCEP session block.",
        "default": "0.0.1.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "ExtendedTunnelIPv6Id",
        "type": "str",
        "description": "Specifies the extended tunnel IPv6 ID.",
        "default": "2000:1::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "ExtendedTunnelIPv6IdStep",
        "type": "str",
        "description": "Specifies the step increment for the extended tunnel IPv6 ID within the same session.",
        "default": "::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "ExtendedTunnelIPv6IdSessionOffset",
        "type": "str",
        "description": "Specifies the step increment for the extended tunnel IPv6 ID across sessions in a PCEP session block.",
        "default": "::1:0",
        "range_or_options": "IPv6 address"
      }
    ],
    "description": "Creates or retrieves PCC LSP information objects for one or more PCEP LSPs. This function wraps the internal `create_pcc_lsp_info_object` method and allows processing of a single PCEP LSP object or a collection (list, set, or tuple) of such objects. For each provided `PcepLsp`, it retrieves the associated 'PccLspInfoObjectConfig' configuration object and applies any additional configuration parameters passed via keyword arguments. If only one PccLspInfoObjectConfig is generated, it returns that object directly; if multiple objects are generated, it returns them as a list.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${LspInfo} | Create Pcep Pcc Lsp Info | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pce_lsp_info",
    "return_type": "object or list",
    "return": "PCEP PCE LSP Info对象列表，类型为 `PceLspInfoObjectConfig`。",
    "description": "创建或获取与指定的PCEP PCE LSP相关联的LSP信息对象（PceLspInfoObjectConfig），并根据提供的关键字参数配置这些对象。该函数支持单个或多个PCEP LSP的批量操作，并返回对应的配置对象。",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Info} | Create Pcep Pce Lsp Info | PcepLsp=${Egress} |",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": ":obj:`PceLspConfig`",
        "description": "PCEP PCE LSP对象或对象列表，用于创建或获取其对应的LSP Info对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP PCE LSP INFO对象名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能/禁用PCEP PCE LSP INFO对象。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Administrator",
        "type": "bool",
        "description": "启用Administrative功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "State",
        "type": "str",
        "description": "设置Initial LSP状态。",
        "default": "GOING_UP",
        "range_or_options": "DOWN UP ACTIVE GOING_DOWN GOING_UP RESERVED_5 RESERVED_6 RESERVED_7"
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pcc_auto_delegation_parameters",
    "return_type": "object or list of PcepAutoDelegationParametersConfig",
    "return": "If a single LSP is provided, returns the corresponding 'PcepAutoDelegationParametersConfig' object. If multiple LSPs are provided, returns a list of such objects after applying any updates.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single PCEP LSP object or an iterable of multiple PCEP LSP objects for which auto-delegation parameters are to be configured or retrieved.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the PCEP Auto Delegation Parameters object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Indicates whether the auto-delegation feature should be enabled or disabled for the associated LSP(s).",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function configures or retrieves the PCEP auto-delegation parameters for one or more LSP objects. It acts as a wrapper around the backend method `Pcep.pcep_auto_delegation_parameters_config`. If configuration parameters (`**kwargs`) are provided, it updates the auto-delegation settings on each specified LSP with those values. The function supports both single and multiple LSP inputs, returning either a single configuration object or a list of configuration objects accordingly. This is particularly useful in managing auto-delegation behavior across multiple LSPs within a PCEP session.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Parameter} | Create Pcep Pcc Auto Delegation Parameters | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pce_auto_initiate_parameters",
    "description": "Configures or retrieves the PCEP auto-initiate parameters for one or more LSP objects. This method allows uniform configuration of PCEP auto-initiate parameters across individual or multiple LSPs, returning the associated PcepAutoInitiateParametersConfig object(s).",
    "return_type": "object / list",
    "return": "If a single PcepLsp is provided, returns the configured or retrieved PcepAutoInitiateParametersConfig object. If multiple LSPs are provided, returns a list of all corresponding PcepAutoInitiateParametersConfig objects, each possibly updated with the provided keyword arguments.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "PceLspConfig / list / set / tuple",
        "description": "A single PCEP LSP object or a collection (list, set, or tuple) of PCEP LSP objects whose auto-initiate parameters are to be configured or retrieved.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the PCEP Auto Initiate Parameters object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the auto-initiate functionality should be enabled for the PCEP Auto Initiate Parameters object.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pce Auto Initiate Parameters | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pce_auto_reply_parameters",
    "return_type": "object or list of PcepAutoReplyParametersConfig",
    "return": "返回与提供的PCEP LSP对象关联的PcepAutoReplyParametersConfig对象或列表，类型为object / list。",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list",
        "description": "一个或多个PCEP LSP对象（PceLspConfig），用于配置或检索其对应的自动回复参数。每个对象必须支持get_children方法以查找关联的PcepAutoReplyParametersConfig子对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "设置生成的PcepAutoReplyParametersConfig对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "控制是否启用自动回复功能。如果未指定，默认为True。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建、配置或检索一个或多个PCEP LSP（Label Switched Path）对象的PCEP Auto Reply Parameters配置。它封装了底层`pcep_auto_reply_parameters_config`方法，允许对单个或多个PceLspConfig对象进行统一操作，并且支持通过关键字参数批量更新配置。特别适用于需要对多个LSP进行一致行为管理的场景，例如自动响应LSP初始化或更新请求。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pce Auto Reply Parameters | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pcc_auto_request_parameters",
    "return_type": "object or list of PcepAutoRequestParametersConfig",
    "return": "Returns the configured or retrieved PCEP auto-request parameters configuration object(s). If a single LSP is provided, returns one configuration object. If multiple LSPs are provided, returns a list of configuration objects in the same order as input.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list",
        "description": "The PCEP PCC LSP object(s) for which auto-request parameters need to be configured or retrieved.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP auto-request parameters configuration object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the auto-request feature should be enabled for this configuration.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function configures or retrieves PCEP (Path Computation Element Protocol) auto-request parameters for one or more LSPs (Label Switched Paths). It wraps around the backend method `pcep_auto_request_parameters_config` and applies the given configuration parameters (if any) to each LSP's associated 'PcepAutoRequestParametersConfig' object. If no configuration arguments are provided, it simply retrieves the current configuration for each LSP. The return value matches the number and order of provided LSPs.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pcc Auto Request Parameters | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pcc_auto_sync_parameters",
    "return_type": "object or list of PcepAutoSyncParametersConfig",
    "return": "If a single PCEP LSP is provided, returns the corresponding `PcepAutoSyncParametersConfig` object. If multiple LSPs are provided, returns a list of `PcepAutoSyncParametersConfig` objects in the same order as input. If configuration was applied via keyword arguments, the updated configurations are returned.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single PCEP LSP object or an iterable containing multiple PCEP LSP objects for which auto-sync parameters are to be configured or retrieved.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the auto-sync parameters object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Flag indicating whether auto-sync should be enabled for the PCEP LSP(s).",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "This function configures or retrieves the auto-sync parameters for one or more PCEP LSPs (Label Switched Paths) in a unified manner. It serves as a wrapper around the internal method `Pcep.pcep_auto_sync_parameters_config`. When keyword arguments (`**kwargs`) are provided, it updates the auto-sync settings on the specified LSPs with those values. If no additional arguments are passed, it simply returns the current configuration of the auto-sync parameters for the given LSP(s).",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pcc Auto Sync Parameters | PcepLsp=${Egress} | Enable=True | Name=MyAutoSyncParam"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_pce_auto_update_parameters",
    "return_type": "object or list",
    "return": "返回与提供的PCEP LSP对象关联的`PcepAutoUpdateParametersConfig`对象，或对象列表。若仅处理一个LSP，则返回单个对象；若处理多个LSP，则返回对应对象的列表。",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable (e.g., list, set, tuple)",
        "description": "一个或多个PCEP LSP（Label Switched Path）对象，用于配置或获取其关联的自动更新参数配置。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "为生成的`PcepAutoUpdateParametersConfig`对象指定名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "启用或禁用该自动更新参数配置。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "该函数用于创建或配置与一个或多个PCEP LSP相关联的`PcepAutoUpdateParametersConfig`对象。它封装了底层的`pcep_auto_update_parameters_config`方法，能够统一处理单个或多个LSP对象，并根据输入形式返回相应结构的结果。如果提供了关键字参数（kwargs），则会将这些参数应用于相应的配置属性更新。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pce Auto Update Parameters | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_lsp_auto_tx_parameters",
    "return_type": "object or list",
    "return": "配置后的PcepAutoTxParametersConfig对象或对象列表，具体取决于输入的配置对象数量。",
    "parameters": [
      {
        "name": "PcepAutoParameters",
        "type": "BgpRouter or iterable of BgpRouter",
        "description": "要配置的PCEP LSP Auto Parameters对象（或对象列表）。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP Auto Tx Parameters对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该PCEP Auto Tx Parameters对象。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "ObjectCategory",
        "type": "str",
        "description": "指定LSP自动传输所关联的对象类别。",
        "default": "LSP",
        "range_or_options": "BANDWIDTH RP NO_PATH ENDPOINT METRIC ERO RRO LSPA SRP LSP XRO"
      },
      {
        "name": "SelectObjectHandle",
        "type": "str",
        "description": "用于选择特定对象的句柄字符串。",
        "default": "",
        "range_or_options": "not_found"
      }
    ],
    "description": "此函数用于创建并配置PCEP协议中LSP的自动传输（Auto TX）参数。它封装了底层`pcep_auto_tx_parameters_config`方法，支持对单个或多个PcepAutoParametersConfig对象进行统一配置，并返回配置后的结果。该方法能够处理关键字参数中的配置覆盖，适用于自动化测试和网络性能评估场景。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Parameter} | Create Pcep Pce Auto Update Parameters | PcepLsp=${Egress} |\n    | ${LspAutoTx} | Create Pcep Lsp Auto Tx Parameters | PcepAutoParameters=${Parameter} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_bw_object",
    "return_type": "PcepBwObjectConfig or list of PcepBwObjectConfig",
    "return": "Returns a single `PcepBwObjectConfig` instance if one LSP is provided, or a list of instances if multiple LSPs are provided.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object / list",
        "description": "One or more PCEP LSP (Label Switched Path) objects to which the bandwidth object will be associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the created PCEP Bw Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PCEP Bw Object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Whether the P Flag in the PCReq message should be set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Whether the I Flag in the PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Bandwidth",
        "type": "str",
        "description": "The bandwidth value for the Bw Object. Should be a string representing an integer between 0 and 4294967295.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function creates and configures PCEP Bandwidth Objects for one or more given PCEP LSP (Label Switched Path) instances. It wraps the internal configuration method and allows setting common properties like name, enable status, flags, and bandwidth value. If a single LSP is passed, it returns the corresponding Bw Object; if multiple LSPs are passed, it returns a list of Bw Objects in the same order.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Bw Object | PcepLsps=${Egress} | Enable=True | Bandwidth=1000"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_endpoint_object",
    "return_type": "PcepEndPointObjectConfig or list of PcepEndPointObjectConfig",
    "return": "A single configured PcepEndPointObjectConfig instance if a single PcepLsp was provided, or a list of configured instances if multiple LSPs were given.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable",
        "description": "A single PCEP LSP object or an iterable (list, set, or tuple) of multiple PCEP LSP objects. Each LSP object represents a Label Switched Path in the context of PCEP communication.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name for the PCEP Endpoint Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the PCEP Endpoint Object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Whether the P Flag in PCReq message should be set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Whether the I Flag in PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Configures one or more PCEP (Path Computation Element Protocol) endpoint objects based on the provided LSP(s) (Label Switched Path). This function wraps the class-level configuration method `Pcep.pcep_endpoint_object_config` and allows both single and multiple PcepLsp objects to be processed. If a single PcepLsp is provided, it returns a single configured endpoint object. If multiple LSPs are provided (as a list, set, or tuple), it returns a list of corresponding configured endpoint objects. Any additional configuration options passed via `**kwargs` are applied to each endpoint object during its creation.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Endpoint Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_lspa_object",
    "return_type": "object or list of PcepLspaObjectConfig instances",
    "return": "If a single PCEP LSP object is provided, returns the corresponding configured `PcepLspaObjectConfig` instance. If multiple LSPs are provided (e.g., in a list), returns a list of `PcepLspaObjectConfig` objects, one for each LSP.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list",
        "description": "A single PCEP LSP object or an iterable containing multiple PCEP LSP objects to associate with the LSPA configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP LSPA object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the PCEP LSPA object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Sets the P Flag in the PCReq message.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Sets the I Flag in the PCReq message.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SetupPriority",
        "type": "int",
        "description": "Specifies the priority for preemption of TE resources during setup.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "HoldingPriority",
        "type": "int",
        "description": "Specifies the priority for holding TE resources after they have been allocated.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "LFlag",
        "type": "bool",
        "description": "Enables the L Flag in the LSPA object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Affinities",
        "type": "bool",
        "description": "When enabled, allows setting link constraints using IncludeAll, IncludeAny, and ExcludeAny attributes.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ExcludeAny",
        "type": "int",
        "description": "Excludes links that match any of the specified affinity bits when Affinities is enabled.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAny",
        "type": "int",
        "description": "Includes links that match any of the specified affinity bits when Affinities is enabled.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "IncludeAll",
        "type": "int",
        "description": "Includes links that match all of the specified affinity bits when Affinities is enabled.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function creates and configures one or more PCEP LSPA (LSP Attributes) objects based on the given parameters. It associates each LSPA object with a corresponding PCEP LSP object (or list of LSPs). The method supports both individual and bulk configuration via keyword arguments, which correspond directly to editable properties of the LSPA object. If only one LSP is provided, it returns a single `PcepLspaObjectConfig` object; if multiple LSPs are provided, it returns a list of corresponding configurations.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Lspa Object | PcepLsp=${Egress} | Enable=True | SetupPriority=3 | Affinities=True | IncludeAny=123456789 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_metric_list",
    "return_type": "PcepMetricListConfig or list of PcepMetricListConfig",
    "return": "配置好的 PcepMetricListConfig 对象或对象列表，与输入的 PcepLsp 对象顺序一致。",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object / list",
        "description": "要为其创建 Metric List 的一个或多个 PCEP LSP 对象（即 PccLspConfig 类型的对象）。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP Metric List 对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该 Metric List。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "在 PCReq 消息中是否设置 P Flag。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "在 PCReq 消息中是否设置 I Flag。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "为一个或多个提供的 PCEP LSP 对象配置并生成对应的 PcepMetricListConfig 对象。该方法封装了底层 `pcep_metric_list_config` 方法的调用，支持单个或批量处理 PcepLsp 对象，并允许通过关键字参数自定义 Metric List 配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Metric List | PcepLsp=${Egress} | Enable=True | PFlag=False"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_metric_object",
    "return_type": "PcepMetricObjectConfig or list",
    "return": "A single configured `PcepMetricObjectConfig` instance if only one metric list is provided, or a list of such instances if multiple metric lists are provided.",
    "description": "Configures one or more PCEP metric objects associated with the provided PCEP LSP metric lists. This function wraps the backend method `Pcep.pcep_metric_object_config` and allows for configuring either a single or multiple PCEP metric objects based on the input. The configuration supports several customizable parameters through keyword arguments.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Metric List | PcepLsp=${Egress} |\n| ${Subobject} | Create Pcep Metric Object | PcepMetricLists=${Object} |",
    "parameters": [
      {
        "name": "PcepMetricLists",
        "type": "object or list",
        "description": "A single PCEP LSP metric list object or an iterable (list, set, tuple) of such metric lists. Each list will have a corresponding metric object configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP Metric Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Specifies whether the PCEP Metric Object is enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "BoundFlag",
        "type": "bool",
        "description": "Indicates whether the B(Bound) bit in the METRIC Object of the PCReq message is set.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ComputedFlag",
        "type": "bool",
        "description": "Indicates whether the C(Computed Metric) bit in the METRIC Object of the PCReq message is set.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "Specifies the type of metric to be used.",
        "default": "MAX_SID_DEPTH",
        "range_or_options": "IGP_METRIC TE_METRIC HOP_COUNTS MAX_SID_DEPTH"
      },
      {
        "name": "MetricValue",
        "type": "int",
        "description": "Specifies the maximum metric value.",
        "default": "10",
        "range_or_options": "0-4294967295"
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_no_path_reason",
    "return_type": "object or list",
    "return": "PCEP No Path Object配置对象或对象列表，表示一个或多个LSP的No Path配置。",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object / iterable",
        "description": "一个或多个PCEP LSP对象（类型为PccLspConfig），用于配置或获取其对应的No Path Object信息。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP No Path Object对象名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该No Path Object",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NoPathType",
        "type": "str",
        "description": "No-Path类型",
        "default": "NOT_SATISFYING_CONSTRAINTS",
        "range_or_options": "NOT_SATISFYING_CONSTRAINTS PCE_CHAIN_BROKEN"
      },
      {
        "name": "CFlag",
        "type": "bool",
        "description": "C Flag是否置位",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NoPathReason",
        "type": "str",
        "description": "No-Path原因描述",
        "default": "NONTBIT",
        "range_or_options": "NONTBIT PCE_UNAVAILABLE UNKNOWN_DESTINATION UNKNOWN_SOURCE"
      }
    ],
    "description": "该函数用于创建、配置或获取PCEP协议中与LSP关联的'No Path'对象。支持单个或批量处理PCEP LSP对象，并允许通过关键字参数设置No Path相关的配置字段。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep No Path Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_rp_object",
    "return_type": "object or list",
    "return": "If a single PCEP LSP is provided, returns the associated RP object (of type `PcepRpObjectConfig`). If multiple PCEP LSPs are provided, returns a list of RP objects corresponding to each LSP. If keyword arguments are given, each returned RP object reflects the updated configuration.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object / list",
        "description": "A single PCEP LSP object or an iterable containing multiple PCEP LSP objects. Each must support the `get_children` method and be compatible with `Pcep.pcep_rp_object_config`.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created PCEP PCC RP Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PCEP PCC RP Object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AutoGeneratedId",
        "type": "bool",
        "description": "When True, enables auto-generation of RP-ID. When False, allows specifying a custom RP-ID via `RpId`.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RpId",
        "type": "int",
        "description": "Specifies the starting RP-ID when Auto-Generated RP-ID is disabled. Valid range: 0–4294967295.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RpIdStep",
        "type": "int",
        "description": "Specifies the step increment for RP-ID allocation across multiple LSPs. Valid range: 0–4294967295.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Specifies the request priority; higher numbers indicate higher priority. Valid range: 0–7.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Sets the P Flag in the PCReq message, indicating that the PCC will send further requests related to this LSP.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Sets the I Flag in the PCRep message, indicating that the PCE may reply asynchronously.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "BFlag",
        "type": "bool",
        "description": "Sets the B (Bi-directional) flag in the RP Object, indicating bi-directional LSP behavior.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OFlag",
        "type": "bool",
        "description": "Sets the O (strict/loose) flag in the RP Object, indicating whether the path should be strict or loose.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This function configures or retrieves the Request Parameters (RP) object(s) for one or more PCEP LSPs. It abstracts handling of both single and multiple LSP inputs and delegates actual configuration to an internal class-level method. It supports both retrieval and modification of RP object configurations in a uniform manner.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${Parameter} | Create Pcep Rp Object | PcepLsps=${Egress} | Priority=5 | BFlag=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_sr_ero_object",
    "return_type": "PcepSrEroObjectConfig or list of PcepSrEroObjectConfig",
    "return": "If a single PcepLsp is provided, returns the corresponding configured ERO object. If multiple PcepLsps are provided, returns a list of configured ERO objects in the same order as the input LSPs.",
    "description": "Configure a PCEP SR ERO (Segment Routing Explicit Route Object) for one or more LSPs (Label Switched Paths). This function wraps the internal `pcep_sr_ero_object_config` method from the `Pcep` class and allows configuration of SR ERO objects on one or more provided PcepLsp instances. Any additional configuration parameters passed via `kwargs` will be applied to each ERO configuration.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "PccLspConfig or iterable of PccLspConfig",
        "description": "One or more PCEP LSP objects to associate with an SR ERO configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP SR ERO object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the SR ERO object is enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Indicates whether the P Flag in PCReq message is set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Indicates whether the I Flag in PCReq message is set.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Sr Ero Object | PcepLsp=${Egress} | Enable=True | PFlag=False"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_sr_ero_sub_object",
    "return_type": "PcepSrEroSubObjectConfig or list of PcepSrEroSubObjectConfig",
    "return": "If a single PcepSrEroObject is passed, returns the corresponding configured sub-object. If multiple PcepSrEroObjects are passed, returns a list of configured sub-objects in the same order.",
    "parameters": [
      {
        "name": "PcepSrEroObjects",
        "type": "object or iterable of objects",
        "description": "A single PCEP SR ERO object or an iterable containing multiple PCEP SR ERO objects. These objects represent the parent context to which the sub-object configurations belong.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP Sr Ero Sub Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable or disable the PCEP Sr Ero Sub Object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteType",
        "type": "str",
        "description": "Set the P Flag in PCReq message to indicate route strictness.",
        "default": "STRICT",
        "range_or_options": "STRICT LOOSE"
      },
      {
        "name": "NaiType",
        "type": "str",
        "description": "Set the I Flag in PCReq message to indicate NAI type.",
        "default": "IPV4_NODE_ID",
        "range_or_options": "ABSENT IPV4_NODE_ID IPV6_NODE_ID IPV4_ADJACENCY IPV6_ADJACENCY_GLOBAL UNNUMBERED_ADJACENCY IPV6_ADJACENCY_LINK_LOCAL"
      },
      {
        "name": "MFlag",
        "type": "bool",
        "description": "M Flag for segment routing.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CFlag",
        "type": "bool",
        "description": "C Flag for segment routing.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SFlag",
        "type": "bool",
        "description": "S Flag for segment routing.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FFlag",
        "type": "bool",
        "description": "F Flag for segment routing.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SidLabel",
        "type": "int",
        "description": "SID Label value.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidLabelStep",
        "type": "int",
        "description": "SID Label increment step.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidLabelSessionOffset",
        "type": "int",
        "description": "SID Label session offset.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidIndex",
        "type": "int",
        "description": "SID Index (32 Bits).",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SidIndexStep",
        "type": "int",
        "description": "SID Index increment step (32 Bits).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SidIndexSessionOffset",
        "type": "int",
        "description": "SID Index session offset (32 Bits).",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidTrafficClass",
        "type": "int",
        "description": "SID Traffic Class (3 bits).",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "SidTimeToLive",
        "type": "int",
        "description": "SID Time To Live.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "SidBottomOfStack",
        "type": "bool",
        "description": "SID Bottom Of Stack Flag (1 Bit).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NaiIpv4NodeId",
        "type": "str",
        "description": "NAI IPv4 Node ID address.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiIpv6NodeId",
        "type": "str",
        "description": "NAI IPv6 Node ID address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalIpv4Address",
        "type": "str",
        "description": "NAI Local IPv4 Address.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiLocalIpv6Address",
        "type": "str",
        "description": "NAI Local IPv6 Address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiRemoteIpv4Address",
        "type": "str",
        "description": "NAI Remote IPv4 Address.",
        "default": "193.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiRemoteIpv6Address",
        "type": "str",
        "description": "NAI Remote IPv6 Address.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalNodeId",
        "type": "str",
        "description": "NAI Local Node-ID.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiLocalInterfaceId",
        "type": "int",
        "description": "NAI Local Interface ID.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NaiRemoteNodeId",
        "type": "str",
        "description": "NAI Remote Node-ID.",
        "default": "193.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiRemoteInterfaceId",
        "type": "int",
        "description": "NAI Remote Interface ID.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Configures one or more PCEP Segment Routing ERO (Explicit Route Object) sub-objects based on the provided input. This function acts as a wrapper for the `Pcep.pcep_sr_ero_sub_object_config` method. It accepts a single PCEP SR ERO object or an iterable (list, set, or tuple) of such objects, and configures each using the provided keyword arguments.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Sr Ero Object | PcepLsp=${Egress} |\n| ${Subobject} | Create Pcep Sr Ero Sub Object | PcepSrEroObjects=${Object} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_srp_info",
    "return_type": "object or list of PcepSrpObjectConfig",
    "return": "PCEP SRP object(s) associated with the provided LSP(s). If configuration parameters are provided, the SRP object(s) will be updated before being returned.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list of PccLspConfig",
        "description": "A single PCEP LSP object or an iterable (list, set, tuple) of PCEP LSP objects for which the SRP object configuration needs to be retrieved or updated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the created PCEP Srp Info object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether to enable the SRP object. Accepts boolean values True or False.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "AutoGeneratedId",
        "type": "bool",
        "description": "Whether to automatically generate the SRP-ID. Accepts boolean values True or False.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SrpId",
        "type": "int",
        "description": "Specifies the starting SRP-ID value.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SrpIdStep",
        "type": "int",
        "description": "Specifies the step increment for SRP-ID when multiple IDs are needed.",
        "default": "1",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function provides a streamlined interface to access and modify the SRP (Stateful PCE Request Parameters) object configuration of one or more PCEP LSPs (Label Switched Paths). When called with configuration parameters via keyword arguments, it updates the SRP object(s); otherwise, it simply returns the current configuration. It ensures uniform handling of both single and multiple LSP inputs by converting non-iterable inputs into a list internally.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Srp Info | PcepLsp=${Egress} | Enable=True | AutoGeneratedId=False | SrpId=100 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_sr_rro_object",
    "return_type": "PcepSrRroObjectConfig or list of PcepSrRroObjectConfig",
    "return": "A single PcepSrRroObjectConfig instance if one LSP is provided, or a list of such instances if multiple LSPs are provided.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single PCEP LSP object or an iterable containing multiple PCEP LSP objects. Each will be configured with its own PcepSrRroObjectConfig.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the PCEP SR RRO Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PCEP SR RRO Object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Whether the P Flag in the PCReq message should be set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Whether the I Flag in the PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Configures and returns one or more PCEP Segment Routing RRO (Record Route Object) configuration objects for the specified PCEP LSP(s). This function acts as a wrapper that applies the same configuration to multiple LSPs if provided.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Sr Rro Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_sr_rro_sub_object",
    "return_type": "PcepSrRroSubObjectConfig or list of PcepSrRroSubObjectConfig",
    "return": "Returns a single configured `PcepSrRroSubObjectConfig` instance or a list of such instances depending on the input. If only one RRO object is provided, returns a single object; otherwise, returns a list.",
    "parameters": [
      {
        "name": "PcepSrRroObjects",
        "type": "object or list",
        "description": "A single PCEP SR RRO (Segment Routing Return Route Record Object) object or a list of such objects to configure with sub-object settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name for the PCEP SR RRO Sub Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the sub-object configuration.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NaiType",
        "type": "str",
        "description": "Specifies the NAI type field in the sub-object.",
        "default": "IPV4_NODE_ID",
        "range_or_options": "ABSENT IPV4_NODE_ID IPV6_NODE_ID IPV4_ADJACENCY IPV6_ADJACENCY_GLOBAL UNNUMBERED_ADJACENCY IPV6_ADJACENCY_LINK_LOCAL"
      },
      {
        "name": "MFlag",
        "type": "bool",
        "description": "Sets the M Flag in the sub-object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CFlag",
        "type": "bool",
        "description": "Sets the C Flag in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SFlag",
        "type": "bool",
        "description": "Sets the S Flag in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FFlag",
        "type": "bool",
        "description": "Sets the F Flag in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SidIndex",
        "type": "int",
        "description": "Start SID index value for Segment Routing.",
        "default": "1",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidLabel",
        "type": "int",
        "description": "Start SID label value for Segment Routing.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "SidTrafficClass",
        "type": "int",
        "description": "Traffic class value for the SID.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "SidTimeToLive",
        "type": "int",
        "description": "TTL value for the SID.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "SidBottomOfStack",
        "type": "bool",
        "description": "Indicates whether the SID is at the bottom of the stack.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NaiIpv4NodeId",
        "type": "str",
        "description": "IPv4 node ID for NAI.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiIpv6NodeId",
        "type": "str",
        "description": "IPv6 node ID for NAI.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalIpv4Address",
        "type": "str",
        "description": "Local IPv4 address for NAI.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiLocalIpv6Address",
        "type": "str",
        "description": "Local IPv6 address for NAI.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiRemoteIpv4Address",
        "type": "str",
        "description": "Remote IPv4 address for NAI.",
        "default": "193.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiRemoteIpv6Address",
        "type": "str",
        "description": "Remote IPv6 address for NAI.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalNodeId",
        "type": "str",
        "description": "Remote node ID for NAI.",
        "default": "192.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiLocalInterfaceId",
        "type": "int",
        "description": "Local interface ID for NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NaiRemoteNodeId",
        "type": "str",
        "description": "Remote node ID for NAI.",
        "default": "193.85.1.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "NaiRemoteInterfaceId",
        "type": "int",
        "description": "Remote interface ID for NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures one or more PCEP Segment Routing Return RRO (Route Record Object) sub-objects by delegating the configuration to the underlying Pcep class method. It supports passing multiple parent RRO objects and applies the same configuration across all of them. The configuration includes flags, segment identifiers (SID), and NAI (Node or Adjacency Identifier) values based on the provided keyword arguments.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Sr Rro Object | PcepLsp=${Egress} |\n| ${Subobject} | Create Pcep Sr Rro Sub Object | PcepSrRroObjects=${Object} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_srv6_ero_object",
    "return_type": "PcepSrv6EroObjectConfig or list of PcepSrv6EroObjectConfig",
    "return": "If a single PcepLsp is provided, returns the corresponding configured PcepSrv6EroObjectConfig instance. If multiple PcepLsps are provided, returns a list containing the configured PcepSrv6EroObjectConfig instances in the same order as the input.",
    "description": "Configures SRv6 ERO (Explicit Route Object) for one or more PCEP LSPs (Label Switched Paths). This function wraps an internal method that allows configuring SRv6 ERO objects either for a single PcepLsp or for multiple PcepLsps passed as a list, set, or tuple. It applies the configuration to each LSP and returns the configured object(s).",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable of objects",
        "description": "A single PcepLsp object or a collection (list, set, or tuple) of PcepLsp objects to which SRv6 ERO configurations will be applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the SRv6 ERO object being created.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Specifies whether the SRv6 ERO object should be enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Indicates if the 'P Flag' in the PCReq message should be set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Indicates if the 'I Flag' in the PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Srv6 Ero Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_srv6_ero_sub_object",
    "return_type": "PcepSrv6EroSubObjectConfig or list of PcepSrv6EroSubObjectConfig",
    "return": "A single configured SRv6 ERO sub-object if a single input object was provided, otherwise a list of configured sub-objects corresponding to each input object.",
    "parameters": [
      {
        "name": "PcepSrv6EroObjects",
        "type": "object or iterable of objects",
        "description": "A single PCEP SRv6 ERO object or a collection of such objects that need to have SRv6 ERO sub-objects configured. These objects must be compatible with the expected type used by the internal configuration method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name for the created PCEP SRv6 ERO Sub Object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the SRv6 ERO Sub Object is enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteType",
        "type": "str",
        "description": "The route type used for establishing the LSP.",
        "default": "STRICT",
        "range_or_options": "STRICT LOOSE"
      },
      {
        "name": "NaiType",
        "type": "str",
        "description": "Specifies the NAI (Node or Adjacency Identifier) type for the endpoint behavior.",
        "default": "IPV6_NODE_ID",
        "range_or_options": "ABSENT IPV4_NODE_ID IPV6_NODE_ID IPV4_ADJACENCY IPV6_ADJACENCY_GLOBAL UNNUMBERED_ADJACENCY IPV6_ADJACENCY_LINK_LOCAL"
      },
      {
        "name": "SFlag",
        "type": "bool",
        "description": "Set the S Flag in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FFlag",
        "type": "bool",
        "description": "Set the F Flag in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EndpointBehavior",
        "type": "str",
        "description": "Specifies the endpoint behavior for the SRv6 SID.",
        "default": "Invalid",
        "range_or_options": "Invalid EndNoPspUsp EndPsp EndUsp EndPspUsp EndXNoPspUsp EndXPsp EndXUsp EndXPspUsp EndTNoPspUsp EndTPsp EndTUsp EndTPspUsp EndB6Encaps EndBM EndDX6 EndDX4 EndDT6 EndDT4 EndDT46 EndDX2 EndDX2V EndDT2U EndDT2M ENDB6EncapsRed EndUSD EndPSPUSD EndUSPUSD EndPSPUSPUSD EndXUSD EndXPSPUSD EndXUSPUSD EndXPSPUSPUSD EndTUSD EndTPSPUSD EndTUSPUSD EndTPSPUSPUSD"
      },
      {
        "name": "SRv6Sid",
        "type": "str",
        "description": "IPv6 address representing the SRv6 SID.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiIpv6NodeId",
        "type": "str",
        "description": "IPv6 Node ID for NAI (Node or Adjacency Identifier).",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalIpv6Address",
        "type": "str",
        "description": "Local IPv6 address for NAI.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiRemoteIpv6Address",
        "type": "str",
        "description": "Remote IPv6 address for NAI.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalInterfaceId",
        "type": "int",
        "description": "Local interface ID for adjacency-based NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NaiRemoteInterfaceId",
        "type": "int",
        "description": "Remote interface ID for adjacency-based NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures one or more PCEP SRv6 ERO (Explicit Route Object) sub-objects based on the provided input. It abstracts the handling of both individual and batch SRv6 ERO sub-object configuration, ensuring consistent behavior regardless of whether a single object or multiple objects are passed. Each configuration is performed by delegating to an underlying class method responsible for creating and editing the SRv6 ERO sub-object with the specified parameters.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep Srv6 Ero Object | PcepLsp=${Egress} |\n    | ${Subobject} | Create Pcep Srv6 Ero Sub Object | PcepSrEroObjects=${Object} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_srv6_rro_object",
    "return_type": "object or list of PcepSrv6RroObjectConfig instances",
    "return": "Returns a single `PcepSrv6RroObjectConfig` instance if one LSP is provided, or a list of instances in the same order as the input LSPs.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or list",
        "description": "A single PCEP LSP object or an iterable (list, set, tuple) of multiple PCEP LSP objects. Each LSP will have its SRv6 RRO configured using the provided options.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the PCEP Srv6 RRO object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the PCEP Srv6 RRO object should be enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Whether to set the 'P Flag' in the PCReq message.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Whether to set the 'I Flag' in the PCReq message.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Configures SRv6 RRO (Segment Routing Version 6 Record Route Object) for one or more PCEP LSPs (Label Switched Paths). This function wraps the class-level configuration method `Pcep.pcep_srv6_rro_object_config`, enabling instance-based configuration of SRv6 RRO objects on one or more PCEP LSPs. It supports passing additional configuration parameters via keyword arguments. The function ensures uniform configuration of SRv6 RRO objects across all provided LSPs by iterating through them and calling the class-level configuration method for each.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Srv6 Rro Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_srv6_rro_sub_object",
    "return_type": "PcepSrv6RroSubObjectConfig or list of PcepSrv6RroSubObjectConfig",
    "return": "A single configured instance of the PCEP SRv6 RRO sub-object if one input object is provided, otherwise a list of configured instances corresponding to the input objects.",
    "parameters": [
      {
        "name": "PcepSrv6RroObjects",
        "type": "object or iterable",
        "description": "The upper-level PCEP SRv6 RRO object(s) to which the sub-objects will be associated. Can be a single object or an iterable (list, set, tuple).",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PCEP SRv6 RRO sub-object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the sub-object should be enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NaiType",
        "type": "str",
        "description": "Value of the NT (Node/Adjacency Identifier Type) field in the sub-object.",
        "default": "IPV6_NODE_ID",
        "range_or_options": "ABSENT IPV4_NODE_ID IPV6_NODE_ID IPV4_ADJACENCY IPV6_ADJACENCY_GLOBAL UNNUMBERED_ADJACENCY IPV6_ADJACENCY_LINK_LOCAL"
      },
      {
        "name": "SFlag",
        "type": "bool",
        "description": "S Flag for segment behavior in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FFlag",
        "type": "bool",
        "description": "F Flag for forwarding behavior in the sub-object.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EndpointBehavior",
        "type": "str",
        "description": "Specifies the endpoint behavior for the SRv6 SID.",
        "default": "Invalid",
        "range_or_options": "Invalid EndNoPspUsp EndPsp EndUsp EndPspUsp EndXNoPspUsp EndXPsp EndXUsp EndXPspUsp EndTNoPspUsp EndTPsp EndTUsp EndTPspUsp EndB6Encaps EndBM EndDX6 EndDX4 EndDT6 EndDT4 EndDT46 EndDX2 EndDX2V EndDT2U EndDT2M ENDB6EncapsRed EndUSD EndPSPUSD EndUSPUSD EndPSPUSPUSD EndXUSD EndXPSPUSD EndXUSPUSD EndXPSPUSPUSD EndTUSD EndTPSPUSD EndTUSPUSD EndTPSPUSPUSD"
      },
      {
        "name": "SRv6Sid",
        "type": "str",
        "description": "Specifies the SRv6 Segment Identifier (SID), must be a valid IPv6 address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiIpv6NodeId",
        "type": "str",
        "description": "Specifies the NAI IPv6 node ID, must be a valid IPv6 address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalIpv6Address",
        "type": "str",
        "description": "Specifies the local IPv6 address for NAI, must be a valid IPv6 address.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiRemoteIpv6Address",
        "type": "str",
        "description": "Specifies the remote IPv6 address for NAI, must be a valid IPv6 address.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "NaiLocalInterfaceId",
        "type": "int",
        "description": "Specifies the local interface ID for NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NaiRemoteInterfaceId",
        "type": "int",
        "description": "Specifies the remote interface ID for NAI.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures one or more PCEP SRv6 RRO (Record Route Object) sub-objects based on the provided parameters. It acts as a wrapper that delegates configuration to the `pcep_srv6_rro_sub_object_config` method of the `Pcep` class. Each provided PcepSrv6RroObject is configured with the specified sub-object properties using keyword arguments. The function returns either a single configured sub-object or a list of them depending on the number of inputs.",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pcc Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Srv6 Rro Object | PcepLsp=${Egress} |\n| ${Subobject} | Create Pcep Srv6 Rro Sub Object | PcepSrv6RroObjects=${Object} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_xro_object",
    "return_type": "PcepXroObjectConfig or list",
    "return": "A single configured PcepXroObjectConfig instance if exactly one PcepLsp was provided, otherwise a list of configured PcepXroObjectConfig instances.",
    "parameters": [
      {
        "name": "PcepLsps",
        "type": "object or iterable (list, set, tuple)",
        "description": "One or more PcepLsp objects representing the LSPs (Label Switched Paths) to associate with the XRO configuration(s). If only a single PcepLsp is provided, it will be wrapped in a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP XRO Object对象名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the PCEP XRO object should be enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "PFlag",
        "type": "bool",
        "description": "Whether the P Flag in PCReq message should be set.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "IFlag",
        "type": "bool",
        "description": "Whether the I Flag in PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FFlag",
        "type": "bool",
        "description": "Whether the F Flag in PCReq message should be set.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This method configures one or more PCEP XRO (Exclude Route Object) configurations associated with the provided PcepLsp objects. It allows for the configuration of XRO objects in a PCEP session. If a single PcepLsp object is passed, it returns a single configured PcepXroObjectConfig instance. If multiple PcepLsp objects are provided (as a list, set, or tuple), it returns a list of corresponding configured instances. Any additional configuration parameters passed via keyword arguments (**kwargs) are applied to each XRO configuration.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pcep | Port=${Port} |\n    | Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n    | ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n    | ${Object} | Create Pcep XRO Object | PcepLsp=${Egress} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.create_pcep_xro_sub_object",
    "return_type": "object or list of PcepXroSubObjectConfig",
    "return": "配置后的PCEP XRO子对象（单个或多个）",
    "parameters": [
      {
        "name": "PcepXroObjects",
        "type": ":obj:`PcepXroObjectConfig`",
        "description": "要配置的PCEP XRO对象，可以是单个对象或包含多个对象的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PCEP XRO子对象的名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该XRO子对象",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "XFlag",
        "type": "bool",
        "description": "排除标志位，表示是否排除此路由对象",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "XRO对象的类型，决定后续字段使用哪一个地址/标识符",
        "default": "IPv4_PREFIX",
        "range_or_options": "IPv4_PREFIX IPv6_PREFIX UNNUMBERED_INTERFACE_ID AUTONOMOUS_SYS_NUM SRLG"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "IP前缀长度，用于IPv4或IPv6类型",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "Attribute",
        "type": "str",
        "description": "指定排除属性的类型",
        "default": "INTERFACE",
        "range_or_options": "INTERFACE NODE SRLG"
      },
      {
        "name": "Ipv4Address",
        "type": "str",
        "description": "IPv4地址，当类型为IPv4_PREFIX时使用",
        "default": "192.85.1.1",
        "range_or_options": "IPv4地址格式"
      },
      {
        "name": "Ipv6Address",
        "type": "str",
        "description": "IPv6地址，当类型为IPv6_PREFIX时使用",
        "default": "2000::1",
        "range_or_options": "IPv6地址格式"
      },
      {
        "name": "TeRouterId",
        "type": "str",
        "description": "流量工程路由器ID，通常为IPv4地址",
        "default": "192.85.1.1",
        "range_or_options": "IPv4地址格式"
      },
      {
        "name": "InterfaceId",
        "type": "int",
        "description": "接口ID，当类型为UNNUMBERED_INTERFACE_ID时使用",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "AsNumber",
        "type": "int",
        "description": "自治系统号，当类型为AUTONOMOUS_SYS_NUM时使用",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SrlgId",
        "type": "int",
        "description": "共享风险链路组ID，当类型为SRLG时使用",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "description": "创建并配置一个或多个PCEP XRO（Exclude Route Object）子对象。该函数是对底层方法`Pcep.pcep_xro_sub_object_config`的封装，允许一次性配置多个XRO子对象，并根据提供的参数进行初始化设置。",
    "example": "| ${Session} | Create Pcep | Port=${Port} |\n| Edit Pcep | Session=${Session} | HelloType=DIRECT_TARGETED |\n| ${Egress} | Create Pcep Pce Lsp | Sessions=${Session} |\n| ${Object} | Create Pcep Xro Object | PcepLsp=${Egress} |\n| ${Subobject} | Create Pcep Xro Sub Object | PcepXroObjects=${Object} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.wait_pcep_state",
    "return_type": "bool",
    "return": "Returns True if all specified PCEP sessions reach the desired state within the timeout period. Returns False if any session does not reach the expected state, although in this implementation, False will raise a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "The PCEP session object(s) to monitor for reaching the target state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the PCEP session(s) must reach. If None, may wait for an implicit default state.",
        "default": "None",
        "range_or_options": "DISABLED IDLE PENDING UP CLOSING"
      },
      {
        "name": "Interval",
        "type": "int or float",
        "description": "Time interval (in seconds) between successive checks of session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int or float",
        "description": "Maximum time (in seconds) to wait for the session(s) to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more PCEP sessions to reach a specified state (e.g., UP, IDLE, etc.) by periodically checking their current state until either all reach the desired state or the timeout is exceeded. Internally calls `Session.wait_session_state` on each session and is decorated with `@abnormal_check()` to detect abnormal states during execution.",
    "example": "| Wait Pcep State | Sessions=${Sessions} | State=UP | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_establish",
    "return_type": "bool",
    "return": "Returns True if all PCEP sessions were successfully initiated, otherwise False (which will raise a ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or a collection of session objects. Each session must have a `pcep_establish()` method to establish the PCEP connection.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Establishes PCEP (Path Computation Element Communication Protocol) sessions for the provided session objects. The function supports both a single session object and multiple session objects passed as an iterable. If a single session is provided, it is converted into a list for uniform processing. The function calls the `pcep_establish()` method on each session object to initiate the PCEP session. If any session fails to establish, a ContinuableFailure exception is raised. Otherwise, it returns True to indicate successful initiation of all sessions.",
    "example": "| Pcep Establish | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_stop_keep_alive",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the operation. Returns False only if the underlying backend call fails, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable of session objects for which the PCEP keep-alive should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the PCEP keep-alive mechanism for one or more session objects. This function ensures that each session's `pcep_stop_keep_alive` method is called, effectively halting the transmission of Keepalive messages for each provided session. It is typically used during session teardown or when communication with a PCE is no longer required.",
    "example": "| Pcep Stop Keep Alive | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_resume_keep_alive",
    "return_type": "bool",
    "return": "Returns True if the PCEP keep-alive mechanism was successfully resumed for all provided sessions; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable containing one or more PCEP protocol session objects for which the keep-alive mechanism should be resumed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the PCEP keep-alive mechanism for one or more specified session objects. This function is typically used after the keep-alive has been paused, to re-enable the sending of PCEP Keepalive messages on the provided sessions. The function supports both single session inputs and collections of sessions, ensuring each session resumes its keep-alive process individually.",
    "example": "| Pcep Resume Keep Alive | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_initial_sync",
    "return_type": "bool",
    "return": "布尔值，表示初始状态同步是否成功触发。返回 True 表示所有会话均成功发出同步指令；若失败则抛出异常。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Pcep",
        "description": "PCEP协议会话对象列表，用于触发PCC向PCE的初始状态同步。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of BgpRouter, optional",
        "description": "可选参数，指定参与同步的LSP（Label Switched Path）对象列表。若未提供，则默认使用每个会话的PccLsp属性。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于触发一个或多个PCC（Path Computation Client）会话的初始状态同步流程。通常在PCEP（Path Computation Element Protocol）环境中使用，用于PCC与PCE之间的初始化和状态同步过程。如果同步失败，将抛出ContinuableFailure异常；否则返回True。",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc Initial Sync | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_end_sync",
    "description": "Synchronizes the end of PCC (Path Computation Client) sessions for the provided session objects. This function wraps the `pcc_end_sync` method of individual session objects and allows synchronization either for all LSPs (Label Switched Paths) associated with each session or for a specific set of LSPs provided as input.",
    "return_type": "bool",
    "return": "Always returns True, indicating successful completion of the synchronization process across all provided sessions. If any session fails during synchronization, an exception is raised instead.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (list, set, tuple) of session objects. Each session object must have a `pcc_end_sync` method that accepts an 'lsps' parameter. If a single session is provided, it will be wrapped into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "optional, object or list of objects",
        "description": "The LSP(s) to synchronize at the end of the PCC session. If not provided (default is None), the session's default `PccLsp` attribute will be used for synchronization. If provided, it should be a single LSP object or a list of LSP objects.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc End Sync | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_delegate_lsp",
    "return_type": "bool",
    "return": "布尔值，表示托管LSP请求是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Pcep",
        "description": "PCEP协议会话对象列表，每个会话对象代表一个PCC与PCE之间的连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of BgpRouter or None",
        "description": "要委托给PCE的LSP（Label Switched Path）对象列表。如果为None，则使用每个会话对象默认的LSP（Session.PccLsp）。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于将指定的LSP管理权从PCC（Path Computation Client）委托给PCE（Path Computation Element）。可以批量对多个会话进行操作。若未提供Lsps参数，则使用各会话自身的默认LSP。该函数是对底层`pcc_delegate_lsp`方法的封装，并在失败时抛出可继续执行的异常。",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc Delegate Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_revoke_lsp",
    "return_type": "bool",
    "return": "布尔值，表示LSP撤销操作是否成功启动（True表示成功，False表示失败）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of :obj:`Pcep`",
        "description": "PCEP协议会话对象列表。每个会话代表一个PCC与PCE之间的连接。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of :obj:`BgpRouter`, optional",
        "description": "要撤销的PCEP LSP对象列表。如果未提供，则默认撤销所有与对应Session关联的LSP。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于向PCE发送请求以撤销一个或多个LSP（标签交换路径）。对于每个提供的Session，它将调用其内部的pcc_revoke_lsp方法。如果未指定具体的LSP，则会撤销该会话下的所有LSP。",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc Revoke Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_remove_delegate_lsp",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the operation. If an error occurs, a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (list, set, tuple) of session objects from which the delegated LSPs will be removed.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "object or list, optional",
        "description": "The LSP or list of LSPs to remove from each session. If None, all LSPs associated with each session will be removed.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Removes delegated LSPs (Label Switched Paths) from one or more PCC (Path Computation Client) sessions. This function iterates through the provided Sessions and invokes the `pcc_remove_delegated_lsp` method on each session object. If no specific LSPs are provided via the Lsps parameter, it removes all LSPs associated with each session (i.e., Session.PccLsp). Otherwise, it removes only the specified LSPs.",
    "example": "| Pcep Pcc Remove Delegate Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_request_lsp",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successfully initiated. Always returns True unless an exception is raised.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Pcep session objects",
        "description": "A list (or iterable) of PCEP protocol session objects for which the LSP computation request should be sent to the PCE.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of PccLspConfig objects or None",
        "description": "Optional. A list of LSP configuration objects to request path computation for. If not provided, the function will use the default LSPs associated with each session.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends a Path Computation Request from the PCC (Path Computation Client) to the PCE (Path Computation Element) for one or more LSPs (Label Switched Paths) across one or more sessions. It wraps and calls `Session.pcc_request_lsp()` for each session in the input. If no explicit LSPs are provided, it uses the default LSPs associated with each session. This function ensures that all requests are successfully initiated; otherwise, it raises a `ContinuableFailure` exception.",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc Request Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_report_lsp",
    "return_type": "bool",
    "return": "Returns True if the LSP status was successfully reported for all sessions, otherwise raises an exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of PCEP protocol session objects for which the LSP status needs to be reported.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list or None",
        "description": "An optional list of PCC LSP configuration objects to report. If not provided, all LSPs associated with each session will be reported.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function is used by a PCC (Path Computation Client) to report the status of one or more LSPs (Label Switched Paths) to the PCE (Path Computation Element) over established PCEP sessions. It wraps the backend `pcc_report_lsp` method and handles failure cases by raising a `ContinuableFailure` exception when the underlying call fails.",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pcc Report Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pcc_synchronize_lsp",
    "return_type": "bool",
    "return": "True if the synchronization is successful, False otherwise (though always returns True according to backend docstring).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "A single session object or an iterable (like list, set, tuple) of PCEP session objects for which LSP synchronization should be performed.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "object or None",
        "description": "The specific LSP(s) to synchronize. If None, all LSPs associated with each session will be synchronized.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Synchronizes the LSP information from the PCC (Path Computation Client) to the PCE (Path Computation Element) for the given sessions. If no specific LSPs are provided, it synchronizes all LSPs associated with each session. This ensures that the LSP state between the PCC and controller is up-to-date.",
    "example": "| Pcep Pcc Synchronize Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pce_return_lsp",
    "return_type": "bool",
    "return": "Returns True if the PCE successfully returns LSP control to the PCC for all specified sessions; otherwise, False (which will raise a ContinuableFailure in the user interface).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Pcep session objects",
        "description": "A list of PCEP protocol session objects on which the PCE should return LSP management rights to the PCC.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of PccLspConfig objects or None",
        "description": "An optional list of LSP configuration objects that specify which LSPs should be returned by the PCE. If not provided, the function will use the default LSPs stored in each session object.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function triggers the operation where a Stateful PCE returns control of one or more LSPs back to the PCC via the PCEP protocol. It wraps the backend `pce_return_lsp` method and ensures proper error handling by raising a `ContinuableFailure` exception if the operation fails.",
    "example": ".. code:: RobotFramework\n\n    | Pcep Pce Return Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pce_update_lsp",
    "return_type": "bool",
    "return": "True if the LSP update operation was successfully triggered on all sessions, otherwise False.",
    "description": "Sends an LSP update request from a Stateful PCE to PCC(s) using one or more PCEP session objects. This function triggers the update either for specified LSPs or for the default LSP associated with each session.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list of objects",
        "description": "A single session object or a list of session objects representing PCEP connections where the LSP update should be initiated. Each session is expected to have a `pce_update_lsp` method and optionally a `PceLsp` attribute referring to its default LSP.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "object or list of objects, optional",
        "description": "The specific LSP or list of LSPs to update. If not provided, the function will use the session's default LSP(s) stored in `Session.PceLsp`.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Pcep Pce Update Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pce_initiate_lsp",
    "return_type": "bool",
    "return": "布尔值，表示PCE初始化LSP请求是否成功发送。若返回True表示成功，False表示失败。",
    "description": "该函数用于向PCC（Path Computation Client）发送初始化LSP（Label Switched Path）的请求，由PCE（Path Computation Element）发起LSP的建立过程。可以为多个会话配置默认或自定义的LSP参数。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "一个或多个PCEP协议会话对象，表示需要进行LSP初始化的会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list, optional",
        "description": "指定用于PCE LSP初始化的LSP配置列表。如果未提供，则使用每个会话中预设的默认LSP配置。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Pcep Pce Initiate Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.pcep_pce_remove_initiated_lsp",
    "return_type": "bool",
    "return": "True if the operation is successfully executed, False if it fails (in which case an exception will be raised).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Pcep or iterable of Pcep",
        "description": "A single session object or an iterable (e.g., list, set, tuple) of session objects representing the PCE sessions from which initiated LSPs should be removed.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsps",
        "type": "list of PccLspConfig, optional",
        "description": "A list of specific LSP objects to remove. If not provided, all initiated LSPs associated with each session will be removed.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends a request from the PCE (Path Computation Element) to the PCC (Path Computation Client) to delete specified LSPs (Label Switched Paths) that were previously initiated by the PCE. It operates on one or more PCEP protocol sessions and delegates the actual removal to each session's internal method. The function returns True upon successful execution.",
    "example": "| Pcep Pce Remove Initiate Lsp | Sessions=${Sessions} | Lsps=&{Lsps} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.get_pcep_lsp_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical items if exactly one row matches the filters, a pandas DataFrame if multiple rows match, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "A session object or collection of session objects from which to extract session names. If None, no session filtering is applied in the index.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "The session index used for identifying a specific session when `Session` is not provided.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsp",
        "type": "object or list/set/tuple of objects or None",
        "description": "An LSP object or collection of LSP objects from which to extract LSP names. If None, no LSP filtering is applied in the index.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LspId",
        "type": "int",
        "description": "The LSP index used for identifying a specific LSP when `Lsp` is not provided.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve. If None, determined by querying ROM properties. If a string, it is converted into a list. Must be a subset of available properties.",
        "default": "None",
        "range_or_options": "SessionBlockId LspIdentify SessionIndex LspIndex SessionLocalIP SessionPeerIP Role SymbolicName LspSourceIP LspDestinationIP LspState PLSPId LSPId SRPId RPId"
      }
    ],
    "description": "Retrieves PCEP LSP (Label Switched Path) statistics based on provided session and LSP identifiers. This function wraps around `_get_statictis` to fetch and filter PCEP LSP-specific statistical data. It supports flexible input types for `Session` and `Lsp`, such as single objects, lists, or None, and translates them into appropriate identifiers for querying the statistics.",
    "example": "| @{StaItems} | Create List | SessionBlockId | LspIdentify |\n| Subscribe Result | Types=PcepLspStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Pcep Lsp Statistic | Session=@{Session} | SessionId=1 | Lsp=@{Lsp} | LspId=1 | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.get_pcep_lsp_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical data for PCEP LSP blocks. If a single result is found, returns a dictionary with keys as requested StaItems. If multiple results are found, returns a pandas DataFrame. If no matching result is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None, optional",
        "description": "A session object or a collection of session objects used to identify which sessions' statistics to retrieve. If provided as a collection, the `Name` attribute of each element is used to extract session identifiers.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "The index of the session if multiple sessions exist. Used primarily when Session is not provided, and helps locate the correct session in multi-session environments.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Lsp",
        "type": "object or list/set/tuple of objects or None, optional",
        "description": "An LSP object or a collection of LSP objects used to filter statistics by specific LSPs. If provided as a collection, the `Name` attribute of each element is used to extract LSP identifiers.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried. If a string, it is converted into a list containing that string. Must be a subset of available statistic properties.",
        "default": "not_found",
        "range_or_options": "SessionBlockId LspIdentify SessionIndex SessionLocalIP SessionPeerIP Role LspCount RequestedLsps RepliedLsps DelegatedLsps UpdatedLsps RevokedLsps ReturnedLsps InitiatedLsps StateDownLsps StateUpLsps StateActiveLsps StateGoingDownLsps StateGoingUpLsps StateOtherLsps"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves PCEP LSP block statistics based on session and LSP identifiers. It supports filtering by session and LSP objects or their identifiers. The function internally calls `_get_statictis` with the 'PcepLspBlockStatistic' type to gather data. If collections (like list, set, tuple) are passed for Session or Lsp, the function extracts the `Name` attribute from the elements to identify the relevant sessions or LSPs. The return value depends on the number of matches: dict for one match, DataFrame for multiple matches, and False if none are found.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=PcepLspBlockStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pcep Lsp Block Statistic | Session=@{Session} | SessionId=1 | Lsp=@{Lsp} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.get_pcep_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回值取决于查询结果的数量：如果仅匹配一行，返回包含统计项键值对的字典；如果匹配多行（例如多个端口），返回一个pandas DataFrame；如果没有找到匹配项，返回False。",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple, optional",
        "description": "需要获取统计信息的一个或多个端口对象。每个端口对象必须包含`Name`属性。如果不指定，则查询所有可用端口的PCEP统计信息。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "要获取的统计项列表。可选值包括SessionBlockCount, SessionBlockIdleCount, SessionBlockPendingCount, SessionBlockUpCount等。若为字符串则会被转换成列表；若为None，则会查询所有可用的统计项。",
        "default": "None",
        "range_or_options": "SessionBlockCount SessionBlockIdleCount SessionBlockPendingCount SessionBlockUpCount"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取与PCEP协议相关的端口统计信息。它支持针对一个或多个端口查询特定的统计项目。底层通过调用_get_statictis方法，并指定类型为'PcepPortStatistic'来实现。若未找到匹配数据，将返回False；若有多条记录（如多个端口），则返回DataFrame格式的结果；若只有一条记录，则返回字典格式的结果。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | SessionBlockCount | SessionBlockUpCount |\n    | Subscribe Result | Types=PcepPortStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pcep Port Statistic | Port=@{Port} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.get_pcep_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to requested statistical items if one session matches, a pandas DataFrame for multiple sessions, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple, optional",
        "description": "A session object or collection of session objects representing the PCEP session(s) for which statistics are requested. If provided, the session's name is used as the session handle. If None, the session handle is not specified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "The session index used as an alternative identifier when Session is not provided. This corresponds to the session's numerical identifier in the system.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are queried automatically. If a string, it is converted into a single-element list. Must be a subset of valid statistic properties for 'PcepSessionStatistic'.",
        "default": "None",
        "range_or_options": "Role LocalIP PeerIP State LspCount StateDownLsps StateUpLsps StateActiveLsps StateGoingDownLsps StateGoingUpLsps StateOtherLsps TxOpenCount RxOpenCount TxKeepaliveCount RxKeepaliveCount TxReportCount RxReportCount TxUpdateCount RxUpdateCount TxRequestCount RxRequestCount TxReplyCount RxReplyCount TxInitiateCount RxInitiateCount TxCloseCount RxCloseCount TxErrorCount RxErrorCount"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for PCEP sessions based on session identifiers and specified statistical items. This function acts as a wrapper around `_get_statictis`, specifically tailored to fetch statistics of type 'PcepSessionStatistic'. It supports filtering by session object(s) or session index and allows specification of which statistical properties to retrieve.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | Role | TxUpdateCount |\n    | Subscribe Result | Types=PcepSessionStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pcep Session Statistic | Session=@{Session} | SessionId=1 | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.get_pcep_session_block_statistic",
    "description": "获取PCEP session block统计结果。该函数用于查询一个或多个PCEP会话对象的指定统计项，返回对应的结果。",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回值取决于匹配的session block数量：\n- 如果恰好匹配一个block，则返回一个字典，键为统计项名称，值为对应的值；\n- 如果匹配多个block，则返回一个包含所有匹配结果的pandas DataFrame；\n- 如果没有找到匹配的block，则返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple, optional",
        "description": "需要查询统计信息的PCEP协议会话对象或其集合。如果未传入（默认None），则不进行会话过滤；如果是一个对象，使用其Name属性作为会话ID；如果是多个对象，将提取它们的Name属性组成会话ID列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "需要获取的统计项列表。如果未传入（默认None），则自动获取所有可用的统计项；如果传入字符串，会被转换为单元素列表。",
        "default": "not_found",
        "range_or_options": "SessionBlockId SessionCount IdleCount PendingCount UpCount LspCount StateDownLsps StateUpLsps StateActiveLsps StateGoingDownLsps StateGoingUpLsps StateOtherLsps TxOpenCount RxOpenCount TxKeepaliveCount RxKeepaliveCount TxReportCount RxReportCount TxUpdateCount RxUpdateCount TxRequestCount RxRequestCount TxReplyCount RxReplyCount TxInitiateCount RxInitiateCount TxCloseCount RxCloseCount TxErrorCount RxErrorCount"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | AdjacencyState | TxUpdate |\n    | Subscribe Result | Types=PcepSessionBlockStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pcep Session Block Statistic | Session=@{Session} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.pcep.edit_pcep_port_config",
    "return_type": "Union[object, list]",
    "return": "A single modified PcepPortConfig object if only one port is processed; otherwise, a list of modified PcepPortConfig objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list]",
        "description": "A single port object or a list of port objects for which the PCEP configuration needs to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MaxOutstanding",
        "type": "int",
        "description": "Maximum number of outstanding sessions. This value affects how many sessions can be pending at any given time.",
        "default": "100",
        "range_or_options": "1-65535"
      },
      {
        "name": "RetryCount",
        "type": "int",
        "description": "Number of times to retry establishing a session before giving up.",
        "default": "5",
        "range_or_options": "0-65535"
      },
      {
        "name": "RetryInterval",
        "type": "int",
        "description": "Time interval (in seconds) between each session establishment attempt.",
        "default": "30",
        "range_or_options": "0-65535"
      },
      {
        "name": "MaxLspPerMessage",
        "type": "int",
        "description": "Maximum number of LSPs that can be included in a single PCEP message.",
        "default": "100",
        "range_or_options": "1-2000"
      }
    ],
    "description": "This function modifies the PCEP port configuration on one or more test ports. It retrieves the PcepPortConfig child object from each provided port and applies the specified configuration changes using the edit method internally. If no configuration changes are provided, it does not make any modifications. The function returns either a single modified PcepPortConfig object or a list of such objects depending on the number of ports processed.",
    "example": ".. code:: RobotFramework\n\n    | Edit PCEP Client Port Config | Ports=${Port} | MaxOutstanding=200 | RetryCount=3 | RetryInterval=10 | MaxLspPerMessage=150"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim",
    "return_type": "PimRouter",
    "return": "The newly created and initialized PIM router object. This object can be used to further configure or interact with the PIM protocol instance.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper layer object that this PIM router belongs to. Typically represents a port on which PIM will be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PIM session name.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable the PIM protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SessionMode",
        "type": "str",
        "description": "Protocol mode of PIM session.",
        "default": "SM",
        "range_or_options": "SM SSM"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "IP version for the PIM session.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "DrPriority",
        "type": "int",
        "description": "Designated Router (DR) priority value.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "DrAddr",
        "type": "str",
        "description": "DR IPv4 address.",
        "default": "0.0.0.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DrIpv6Addr",
        "type": "str",
        "description": "DR IPv6 address.",
        "default": "'::'",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "GenIdMode",
        "type": "str",
        "description": "Generation ID mode.",
        "default": "FIXED",
        "range_or_options": "FIXED INCR RAND"
      },
      {
        "name": "RegisterEnable",
        "type": "bool",
        "description": "Enable register functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Bsrenable",
        "type": "bool",
        "description": "Enable Bootstrap Router (BSR).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "BsrPriority",
        "type": "int",
        "description": "Bootstrap Router (BSR) priority value.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "BsrInterval",
        "type": "int",
        "description": "Time interval (in seconds) between BSR messages.",
        "default": "60",
        "range_or_options": "1-3600"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval (in seconds) between Hello messages.",
        "default": "30",
        "range_or_options": "1-3600"
      },
      {
        "name": "HelloHoldTime",
        "type": "int",
        "description": "Timeout duration (in seconds) for Hello messages.",
        "default": "105",
        "range_or_options": "1-65535"
      },
      {
        "name": "JoinPruneInterval",
        "type": "int",
        "description": "Time interval (in seconds) between Join/Prune messages.",
        "default": "60",
        "range_or_options": "1-65535"
      },
      {
        "name": "JoinPruneHoldTime",
        "type": "int",
        "description": "Timeout duration (in seconds) for Join/Prune messages.",
        "default": "210",
        "range_or_options": "1-65535"
      }
    ],
    "description": "Creates and configures a new PIM (Protocol Independent Multicast) router instance. This method initializes a PimRouter object with the specified parent port and any additional configuration parameters provided via keyword arguments. The newly created PIM router is then registered in a global protocol object map using its handle for future reference.",
    "example": "| ${Session} | Create Pim | Port=${Port} |\n| ${DrAddr} | Set Variable | ${Session.DrAddr} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.edit_pim",
    "return_type": "bool",
    "return": "Returns True if the attributes of the Session object were successfully updated; otherwise, False.",
    "parameters": [
      {
        "name": "Session",
        "type": "PimRouter",
        "description": "A PIM session object whose parameters are to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the PIM session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PIM protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SessionMode",
        "type": "str",
        "description": "Specifies the PIM protocol mode.",
        "default": "SM",
        "range_or_options": "SM SSM"
      },
      {
        "name": "IpVersion",
        "type": "str",
        "description": "Specifies the IP version used by the PIM session.",
        "default": "IPV4",
        "range_or_options": "IPV4 IPV6"
      },
      {
        "name": "DrPriority",
        "type": "int",
        "description": "Designated Router (DR) priority value.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "DrAddr",
        "type": "str",
        "description": "Designated Router (DR) IPv4 address.",
        "default": "0.0.0.0",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "DrIpv6Addr",
        "type": "str",
        "description": "Designated Router (DR) IPv6 address.",
        "default": "::",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "GenIdMode",
        "type": "str",
        "description": "Specifies how GenID is generated.",
        "default": "FIXED",
        "range_or_options": "FIXED INCR RAND"
      },
      {
        "name": "RegisterEnable",
        "type": "bool",
        "description": "Enables or disables Register messages.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Bsrenable",
        "type": "bool",
        "description": "Enables or disables BSR functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "BsrPriority",
        "type": "int",
        "description": "BSR (Bootstrap Router) priority value.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "BsrInterval",
        "type": "int",
        "description": "Time interval (in seconds) for sending BSR messages.",
        "default": "60",
        "range_or_options": "1-3600"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Time interval (in seconds) for sending Hello messages.",
        "default": "30",
        "range_or_options": "1-3600"
      },
      {
        "name": "HelloHoldTime",
        "type": "int",
        "description": "Hold time (in seconds) before considering a neighbor down due to missed Hello messages.",
        "default": "105",
        "range_or_options": "1-65535"
      },
      {
        "name": "JoinPruneInterval",
        "type": "int",
        "description": "Time interval (in seconds) for sending Join/Prune messages.",
        "default": "60",
        "range_or_options": "1-65535"
      },
      {
        "name": "JoinPruneHoldTime",
        "type": "int",
        "description": "Hold time (in seconds) for Join/Prune messages.",
        "default": "210",
        "range_or_options": "1-65535"
      }
    ],
    "description": "This function edits the configuration parameters of an existing PIM session object dynamically. It allows updating only those attributes that already exist on the provided Session object with the values specified in keyword arguments. The backend ensures type consistency and validates whether each parameter is applicable to the session object before applying changes.",
    "example": "| ${Session} | Create Pim | Port=${Port} |\n| Edit Pim | Session=${Session} | HelloInterval=60 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_group",
    "return_type": "object",
    "return": "返回一个PIM Group配置对象（PimGroupConfig）",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "PIM协议会话对象，用于在底层创建组。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PIM Group对象名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否使能该PIM Group。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "GroupCheck",
        "type": "bool",
        "description": "指定协议模式（例如是否启用组校验）。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GroupType",
        "type": "str",
        "description": "指定组的类型或模式。",
        "default": "ANY_G",
        "range_or_options": "ANY_G S_G S_G_RPT ANY_RP"
      },
      {
        "name": "GroupAddr",
        "type": "str",
        "description": "组播组地址（IPv4格式）。",
        "default": "225.0.0.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "GroupCount",
        "type": "int",
        "description": "组的数量。",
        "default": "1",
        "range_or_options": "1-65535 (BigTao), 1-500000 (DarYu)"
      },
      {
        "name": "GroupModifierStep",
        "type": "int",
        "description": "组地址递增步长。",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "GroupModifierBit",
        "type": "int",
        "description": "组地址增量位数。",
        "default": "32",
        "range_or_options": "1-32"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "RP（Rendezvous Point）地址（IPv4格式）。",
        "default": "10.10.10.10",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "JoinSrc",
        "type": "str",
        "description": "Join消息中的源地址（IPv4格式）。",
        "default": "1.1.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "JoinMaskLen",
        "type": "int",
        "description": "Join源地址的掩码长度。",
        "default": "32",
        "range_or_options": "1-32"
      },
      {
        "name": "PruneSrcAddr",
        "type": "str",
        "description": "Prune消息中的源地址（IPv4格式）。",
        "default": "1.1.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "PruneMaskLen",
        "type": "int",
        "description": "Prune源地址的掩码长度。",
        "default": "32",
        "range_or_options": "1-32"
      }
    ],
    "description": "该函数用于创建并配置一个PIM组播组。它通过提供的PIM会话对象调用底层API的create_group方法，并根据传入的参数初始化该组的配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pim | Port=${Port} |\n    | Create Pim Group | Session=${Session} | GroupAddr=225.0.0.2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_ipv6_group",
    "return_type": "PimIpv6GroupConfig",
    "return": "返回一个PIM IPv6 Group配置对象，用于后续操作该组播组。",
    "description": "创建一个PIM IPv6组播组（Group）配置对象。该函数通过调用底层会话的create_ipv6_group方法实现IPv6组播组的配置，支持多种参数设置，如组地址、RP地址、Join/Prune源地址等。",
    "parameters": [
      {
        "name": "Session",
        "type": "PimRouter",
        "description": "PIM协议会话对象，表示当前的PIM路由器实例。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PIM IPv6 Group对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该PIM IPv6 Group。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "GroupCheck",
        "type": "bool",
        "description": "指定协议模式，是否启用组检查。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "GroupType",
        "type": "str",
        "description": "组播组类型，定义组播行为。",
        "default": "ANY_G",
        "range_or_options": "ANY_G S_G S_G_RPT ANY_RP"
      },
      {
        "name": "GroupAddr",
        "type": "str",
        "description": "组播组的IPv6地址。",
        "default": "ff1e::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "GroupCount",
        "type": "int",
        "description": "组播组的数量。",
        "default": "1",
        "range_or_options": "1-65535 (BigTao), 1-500000 (DarYu)"
      },
      {
        "name": "GroupModifierStep",
        "type": "int",
        "description": "组播组地址增量步进值。",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "GroupModifierBit",
        "type": "int",
        "description": "组播组地址增量位数。",
        "default": "128",
        "range_or_options": "1-128"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "RP（Rendezvous Point）的IPv6地址。",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "JoinSrc",
        "type": "str",
        "description": "Join消息的源IPv6地址。",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "JoinMaskLen",
        "type": "int",
        "description": "Join源地址的前缀掩码长度。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "PruneSrcAddr",
        "type": "str",
        "description": "Prune消息的源IPv6地址。",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "PruneMaskLen",
        "type": "int",
        "description": "Prune源地址的前缀掩码长度。",
        "default": "64",
        "range_or_options": "1-128"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pim | Port=${Port} |\n    | Create Pim IPv6 Group | Session=${Session} | GroupAddr=ff1e::2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_register_group",
    "return_type": "PimRegisterGroupConfig",
    "return": "创建的PIM IPv4 Register Group对象，用于后续对组播注册行为的配置和控制。",
    "parameters": [
      {
        "name": "Session",
        "type": "PimRouter",
        "description": "PIM协议会话对象，用于在指定的上下文中创建Register Group。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PIM IPv4 Register Group对象的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用该PIM IPv4 Register Group。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MulticastGroupToSourceDistribution",
        "type": "str",
        "description": "组播地址与源地址之间的映射方式。",
        "default": "PAIR",
        "range_or_options": "PAIR BACKBONE"
      },
      {
        "name": "RegisterTransmitMode",
        "type": "str",
        "description": "Register报文的发送模式。",
        "default": "CONTINUOUS",
        "range_or_options": "FIXED CONTINUOUS"
      },
      {
        "name": "FixedModeCount",
        "type": "int",
        "description": "在固定发送模式下，发送Register报文的次数。",
        "default": "5",
        "range_or_options": "1-1000"
      },
      {
        "name": "MulticastGroupCount",
        "type": "int",
        "description": "组播组的数量。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartMulticastGroupAddr",
        "type": "str",
        "description": "组播组起始IPv4地址。",
        "default": "225.0.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "MulticastGroupStep",
        "type": "int",
        "description": "组播组地址递增步长。",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MulticastGroupPrefixLength",
        "type": "int",
        "description": "组播组IP地址的前缀长度。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "MulticastSourceCount",
        "type": "int",
        "description": "组播源的数量。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartMulticastSourceAddr",
        "type": "str",
        "description": "组播源起始IPv4地址。",
        "default": "192.168.1.1",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "MulticastSourceStep",
        "type": "int",
        "description": "组播源地址递增步长。",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MulticastSourcePrefixLength",
        "type": "int",
        "description": "组播源IP地址的前缀长度。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "RP（Rendezvous Point）的IPv4地址。",
        "default": "10.10.10.20",
        "range_or_options": "IPv4地址"
      },
      {
        "name": "RegisterTransmitInterval",
        "type": "int",
        "description": "Register报文的发送间隔时间（秒）。",
        "default": "60",
        "range_or_options": "10-180"
      }
    ],
    "description": "该函数用于在给定的PIM会话中创建一个PIM IPv4 Register Group对象。Register Group用于模拟PIM-SM中的注册过程，将组播数据封装为Register报文并发送到RP（Rendezvous Point）。此功能常用于测试PIM协议的注册机制及RP处理能力。",
    "example": "| ${Session} | Create Pim | Port=${Port} |\n| Create Pim Register Group | Session=${Session} | RpAddr=20.10.10.20 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_ipv6_register_group",
    "return_type": "PimIpv6RegisterGroupConfig",
    "return": "The created PIM IPv6 Register Group configuration object, which can be used for further manipulation or validation.",
    "parameters": [
      {
        "name": "Session",
        "type": "PimRouter",
        "description": "A list of PIM protocol session objects used to create the IPv6 register group. This session must already be initialized and associated with a valid port or device.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PIM IPv6 Register Group object for identification purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PIM IPv6 Register Group object.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MulticastGroupToSourceDistribution",
        "type": "str",
        "description": "Specifies how multicast groups are mapped to sources.",
        "default": "PAIR",
        "range_or_options": "PAIR BACKBONE"
      },
      {
        "name": "RegisterTransmitMode",
        "type": "str",
        "description": "Defines the mode in which register messages are transmitted.",
        "default": "CONTINUOUS",
        "range_or_options": "FIXED CONTINUOUS"
      },
      {
        "name": "FixedModeCount",
        "type": "int",
        "description": "Number of times to transmit register messages if using fixed mode.",
        "default": "5",
        "range_or_options": "1-1000"
      },
      {
        "name": "MulticastGroupCount",
        "type": "int",
        "description": "Number of multicast groups to configure.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartMulticastGroupAddr",
        "type": "str",
        "description": "Starting IPv6 address for the multicast group range.",
        "default": "ff1e::2",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "MulticastGroupStep",
        "type": "int",
        "description": "Increment value for subsequent multicast group addresses.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MulticastGroupPrefixLength",
        "type": "int",
        "description": "Prefix length for the multicast group IPv6 addresses.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "MulticastSourceCount",
        "type": "int",
        "description": "Number of multicast sources to configure.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "StartMulticastSourceAddr",
        "type": "str",
        "description": "Starting IPv6 address for the multicast source range.",
        "default": "2001::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "MulticastSourceStep",
        "type": "int",
        "description": "Increment value for subsequent multicast source addresses.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "MulticastSourcePrefixLength",
        "type": "int",
        "description": "Prefix length for the multicast source IPv6 addresses.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "RP (Rendezvous Point) IPv6 address used by PIM for registering multicast traffic.",
        "default": "2000::2",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "RegisterTransmitInterval",
        "type": "int",
        "description": "Time interval (in seconds) between successive register message transmissions.",
        "default": "60",
        "range_or_options": "10-180"
      }
    ],
    "description": "Creates an IPv6 register group configuration for PIM (Protocol Independent Multicast). This function wraps the underlying Renix API call to configure a PIM IPv6 register group with customizable parameters passed through keyword arguments. It is typically used in network testing scenarios to simulate PIM register behavior.",
    "example": "| ${Session} | Create Pim | Port=${Port} |\n| Create Pim Ipv6 Register Group | Session=${Session} | RpAddr=3000::2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_rp_map",
    "return_type": "object",
    "return": "PIM RP Map configuration object, typically of type `PimIpv4RpMapConfig` or similar. This object represents the RP mapping for multicast groups in a PIM-SM environment.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "A PIM protocol session object (of type `PimRouter`) that provides the underlying method to create the RP map. It represents the context under which the RP map is created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name assigned to the PIM IPv4 RP Map object for identification purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Whether the RP Map should be enabled upon creation.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MulticastGroupAddr",
        "type": "str",
        "description": "The multicast group address associated with this RP. Typically an IPv4 address or prefix.",
        "default": "255.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "The IP address of the Rendezvous Point (RP) associated with the multicast group.",
        "default": "10.10.10.10",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "The prefix length for the multicast group address range associated with the RP.",
        "default": "32",
        "range_or_options": "0-32"
      },
      {
        "name": "RpPriority",
        "type": "int",
        "description": "RP priority value; used to select among multiple RPs for overlapping group ranges.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RpHoldTime",
        "type": "int",
        "description": "The hold time (in seconds) for the RP mapping before it times out.",
        "default": "150",
        "range_or_options": "1-65535"
      }
    ],
    "description": "This function creates and configures a PIM RP (Rendezvous Point) map object, associating a multicast group range with a specific RP address. It wraps the underlying `renix.create_pim_rp_map` method, passing along the session and keyword arguments as needed. The function is primarily used in PIM-SM environments where RP mappings are essential for proper multicast routing.",
    "example": "| ${Session} | Create Pim | Port=${Port} |\n| Create Pim IPv4 Rp Map | Session=${Session} | RpAddr=20.10.10.10 | Enable=True | MulticastGroupAddr=224.0.0.0 | PrefixLength=24 | RpPriority=10 | RpHoldTime=300"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.create_pim_ipv6_rp_map",
    "return_type": "PimIpv6RpMapConfig",
    "return": "返回创建的PIM IPv6 Rp Map对象，可用于后续对该RP映射的配置或操作。",
    "parameters": [
      {
        "name": "Session",
        "type": "PimRouter",
        "description": "PIM协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PIM IPv6 Rp Map对象名称",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否使能PIM IPv6 Rp Map对象",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "MulticastGroupAddr",
        "type": "str",
        "description": "组播地址和源地址映射方式，应为IPv6地址",
        "default": "ff1e::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "RpAddr",
        "type": "str",
        "description": "RP（Rendezvous Point）地址，应为IPv6地址",
        "default": "2000::1",
        "range_or_options": "IPv6地址"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "前缀长度，用于定义RP所服务的组播地址范围",
        "default": "128",
        "range_or_options": "0-128"
      },
      {
        "name": "RpPriority",
        "type": "int",
        "description": "RP优先级，数值越小优先级越高",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RpHoldTime",
        "type": "int",
        "description": "RP保持时间（单位：秒），接收方在该时间内未收到注册信息则认为RP失效",
        "default": "150",
        "range_or_options": "1-65535"
      }
    ],
    "description": "该函数用于创建一个PIM IPv6 RP (Rendezvous Point) 映射对象，用于PIM-SM（Sparse Mode）协议中指定特定组播组使用的RP地址。该函数封装了底层会话对象的`create_ipv6_rp_map`方法，并通过关键字参数支持多种配置选项。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Pim | Port=${Port} |\n    | Create Pim Ipv6 Rp Map | Session=${Session} | RpAddr=3000::1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.wait_pim_state",
    "return_type": "bool",
    "return": "Returns True if all PIM sessions reach one of the desired states within the timeout period. Returns False if the timeout is reached before all sessions reach the expected state.",
    "description": "Waits until the 'state' attribute of each PIM session in 'Sessions' reaches one of the expected target states. This function internally polls the session states at a given interval and waits for all sessions to achieve one of the provided desired states or defaults to 'NEIGHBOR'.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(PimRouter)",
        "description": "A list of PIM protocol session objects to be monitored. If a scalar value is passed, it will be converted into a list containing that value.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "list or str",
        "description": "One or more acceptable values representing the desired session states to wait for. If not specified, the default is ['NEIGHBOR']. All comparisons are case-insensitive.",
        "default": "['NEIGHBOR']",
        "range_or_options": "DISABLED HELLO NEIGHBOR IDLE NOTSTARTED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks of session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the expected states.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Wait Pim State | Sessions=${Sessions} | State=NEIGHBOR | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_start_boot_strap",
    "return_type": "bool",
    "return": "Returns True if the bootstrap process for all sessions was initiated successfully; otherwise, False. However, in case of failure, a ContinuableFailure exception is raised instead of returning False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or iterable of `PimRouter` objects",
        "description": "A single session object or an iterable (list, set, tuple) of PIM protocol session objects (`PimRouter`). Each session must have a `start_boot_strap()` method available to be called.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the bootstrap process for one or more PIM (Protocol Independent Multicast) protocol sessions. It accepts either a single session or an iterable of sessions and calls their respective `start_boot_strap()` methods. If any session fails to start the bootstrap process, this function raises a `ContinuableFailure` exception. Otherwise, it returns True to indicate success.",
    "example": "| Pim Start Boot Strap | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_stop_boot_strap",
    "return_type": "bool",
    "return": "Returns True if the bootstrap was successfully stopped for all provided sessions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single session object or an iterable containing multiple session objects. Each session must have a `stop_boot_strap()` method defined.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops the bootstrap process for one or more session objects. This function accepts a single session object or a collection of session objects (list, set, or tuple). It iterates through each session and invokes the `stop_boot_strap()` method on it. After processing all sessions, it returns True to indicate successful execution.",
    "example": "| Pim Stop Boot Strap | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_change_gen_id",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功启动。始终返回 True，除非操作失败并触发异常。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or iterable of PimRouter objects",
        "description": "PIM协议会话对象的列表或可迭代集合，每个会话对象必须实现 `change_gen_id` 方法以支持修改其内部的 Generation ID。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于修改一个或多个 PIM (Protocol Independent Multicast) 协议会话的 Generation ID（GenId）。Generation ID 通常用于跟踪组播组成员或源信息的变化。此函数会对提供的每个会话调用其 `change_gen_id` 方法。",
    "example": ".. code:: RobotFramework\n\n    | Pim Change Gen Id | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_join_group",
    "return_type": "bool",
    "return": "True if all sessions successfully joined the PIM multicast group, otherwise False (though in practice it always returns True or raises an exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of PimRouter objects or a single PimRouter object",
        "description": "A single session object or an iterable (list, set, or tuple) of session objects representing PIM protocol sessions. Each session is expected to have a `join_group()` method that performs the actual operation of joining the session to the multicast group.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function wraps the process of joining one or more PIM (Protocol Independent Multicast) protocol session(s) to a multicast group. It accepts either a single session object or a list of such objects and ensures all provided sessions join the group by invoking their respective `join_group()` methods. If any session fails to join, the function raises a `ContinuableFailure` exception. Otherwise, it returns True to indicate successful execution.",
    "example": "| Pim Join Group | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_leave_group",
    "return_type": "bool",
    "return": "Always returns True if the operation is completed successfully; otherwise, it raises a ContinuableFailure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of PimRouter or Session",
        "description": "A list or iterable (list, set, or tuple) of session objects representing the PIM sessions to leave the multicast group.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function sends a leave group message for each PIM session provided. It internally calls the 'leave_group()' method on each session object via the backend RenixAPI. If any session fails to leave the group, a ContinuableFailure exception is raised.",
    "example": "| Pim Leave Group | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_start_register",
    "return_type": "bool",
    "return": "Returns True if the registration process has been initiated successfully for all provided sessions. Returns False if any session fails to start registration.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or object",
        "description": "A single PIM session object or an iterable (list, set, tuple) of PIM session objects. Each session is expected to be of type `PimRouter` and must have a `start_register()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates the PIM protocol registration process by calling the `start_register()` method on each provided session object. It supports both a single session object and an iterable of session objects. If any session fails to start registration, the function returns False; otherwise, it returns True indicating successful initiation across all sessions.",
    "example": "| Pim Start Register | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.pim_stop_register",
    "description": "Stops the registration process for one or more PIM protocol session objects. This function wraps the provided session(s) in a list if they are not already an iterable and invokes `stop_register()` on each session to halt their registration.",
    "return_type": "bool",
    "return": "Always returns True to indicate that the operation has completed successfully. If any session fails during registration stop, it raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "PimRouter or iterable of PimRouter objects (list, set, tuple)",
        "description": "The session or sessions whose registration should be stopped. If a single session is provided, it will be treated as a list containing only that session. Each session's `stop_register()` method will be called.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Pim Stop Register | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.edit_pim_port_config",
    "return_type": "bool or list of objects",
    "return": "If a single port is provided, returns True/False indicating success/failure. If multiple ports are provided, returns a list of updated PimPortConfig objects.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list",
        "description": "测试仪表端口对象或其列表，表示需要配置PIM协议的端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgTransRate",
        "type": "int",
        "description": "PIM Message Transmit Rate (messages/sec)",
        "default": "500",
        "range_or_options": "1-10000"
      },
      {
        "name": "TriggerHelloDelay",
        "type": "int",
        "description": "Trigger Hello Delay in seconds",
        "default": "5",
        "range_or_options": "0-60"
      },
      {
        "name": "DisableHelloExpireTimer",
        "type": "bool",
        "description": "Disables the Hello Expire Timer for PIM protocol session",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DisableRecvHelloInNeighborState",
        "type": "bool",
        "description": "Disables receiving Hello messages while in neighbor state",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DisableNonHelloRecv",
        "type": "bool",
        "description": "Disables receiving non-Hello PIM messages",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "修改PIM协议会话的端口配置。该函数用于为一个或多个指定的测试端口编辑PIM（Protocol Independent Multicast）端口级别的配置参数。支持的关键字参数包括消息速率、Hello定时器延迟以及各种接收控制选项。",
    "example": "| Pim Port Config | Ports=${Ports} | DisableNonHelloRecv=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.get_pim_session_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for PIM sessions. If one session is queried, returns a dictionary of stats; if multiple sessions are queried, returns a pandas DataFrame; if no matching data is found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects, optional",
        "description": "A session object or a collection of session objects representing the PIM sessions for which statistics are to be retrieved. Each object must have a 'Name' attribute that uniquely identifies the session.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve for the PIM sessions. If None, all available properties are returned. Supported statistical items include: NeighborNum, TxHello, RxHello, TxJoin, RxJoin, TxAnyG, RxAnyG, TxSG, RxSG, TxRP, RxRP, TxRpt, RxRpt, TxBsr, TxRegister, RxRegisterStop.",
        "default": "None",
        "range_or_options": "NeighborNum TxHello RxHello TxJoin RxJoin TxAnyG RxAnyG TxSG RxSG TxRP RxRP TxRpt RxRpt TxBsr TxRegister RxRegisterStop"
      }
    ],
    "description": "Retrieves statistics for PIM (Protocol Independent Multicast) sessions based on the provided session identifiers and statistical items. Internally, this function calls `_get_statistics()` with the statistic type set to 'PimSessionStats'. It supports querying statistics for one or more PIM sessions by extracting session IDs from the provided Session parameter. Optionally, specific statistical items can be specified to limit the returned data.",
    "example": "| @{StaItems} | Create List | TxHello | RxHello |\n| Subscribe Result | Types=PimSessionStats |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Pim Session Stats | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pim.get_pim_group_stats",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回值根据匹配结果的不同而变化：\n- 如果恰好找到一行匹配数据，返回一个字典，键为请求的统计项(StaItems)，值为对应的统计值。\n- 如果找到多行匹配数据，返回一个pandas DataFrame，列对应请求的统计项。\n- 如果没有找到匹配数据，返回False。",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "与PIM组统计信息关联的会话对象或集合。如果为None，则不进行会话过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Group",
        "type": "object or list or set or tuple or None",
        "description": "需要获取统计信息的PIM组对象或集合。如果为None，则不进行组过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "指定要获取的统计项（列名）。如果为None，则查询所有可用属性。如果提供字符串，则转换为包含该字符串的列表。",
        "default": "not_found",
        "range_or_options": "支持的统计项包括: TxAnyG TxSG TxRP TxRpt"
      }
    ],
    "kwargs": [],
    "description": "该函数用于检索PIM（Protocol Independent Multicast）组的统计信息，基于提供的会话和组对象进行过滤。它通过调用内部方法 `_get_statictis` 获取数据，并允许用户选择性地获取特定的统计项。该函数适用于RobotFramework测试框架中，通常在协议启动后调用以获取当前状态的统计结果。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | TxHello | RxHello |\n    | Subscribe Result | Types=PimGroupStats |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pim Group Stats | Session=${Session} | Group=${Group} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.create_pppoe",
    "return_type": "object",
    "return": "The created PPPoE session object. If EmulationMode is 'CLIENT', it returns an instance of PppoeClent; if 'SERVER', it returns an instance of PppoeServer.",
    "description": "创建并配置PPPoE协议会话对象，支持客户端和服务器模式。根据指定的EmulationMode参数初始化相应的PPPoE实例，并将其与提供的端口关联。",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，通常表示网络层次结构中的端口或接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "指定PPPoE会话的仿真模式。有效值为'CLIENT'或'SERVER'。",
        "default": "'CLIENT'",
        "range_or_options": "CLIENT SERVER"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "PPPoE协议会话名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用PPPoE协议会话。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "认证方式。",
        "default": "'NO_AUTHENTICATION'",
        "range_or_options": "NO_AUTHENTICATION NEGOTIATION CHAP_MD5 PAP"
      },
      {
        "name": "Username",
        "type": "str",
        "description": "用户名，长度范围：1-126。",
        "default": "'xinertel'",
        "range_or_options": "string length in [1,126]"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "密码，长度范围：1-126。",
        "default": "'xinertel'",
        "range_or_options": "string length in [1,126]"
      },
      {
        "name": "ServiceName",
        "type": "str",
        "description": "服务名，长度范围：0-255。",
        "default": "\"\"",
        "range_or_options": "string length in [0,255]"
      },
      {
        "name": "EnableMaxPayloadTag",
        "type": "bool",
        "description": "是否启用最大净荷标签。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxPayloadBytes",
        "type": "int",
        "description": "最大净荷（字节），取值范围：1-65535。",
        "default": "1500",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpConfigReqTimeout",
        "type": "int",
        "description": "LCP Configure-Request超时时间（秒），取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpConfigReqMaxAttempts",
        "type": "int",
        "description": "LCP Configure-Request最大尝试次数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpTermReqTimeout",
        "type": "int",
        "description": "LCP Terminate-Request超时时间（秒），取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpTermReqMaxAttempts",
        "type": "int",
        "description": "LCP Terminate-Request最大尝试次数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "NcpConfigReqTimeout",
        "type": "int",
        "description": "NCP Configure-Request超时时间（秒），取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "NcpConfigReqMaxAttempts",
        "type": "int",
        "description": "NCP Configure-Request最大尝试次数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpNcpMaxNak",
        "type": "int",
        "description": "LCP/NCP最大Nak数量，取值范围：1-65535。",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableMruNegotiation",
        "type": "bool",
        "description": "是否启用MRU协商。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "MruSize",
        "type": "int",
        "description": "MRU大小（字节），取值范围：128-65535。",
        "default": "1492",
        "range_or_options": "128-65535"
      },
      {
        "name": "EnableEchoRequest",
        "type": "bool",
        "description": "是否启用Echo-Request报文。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EchoRequestInterval",
        "type": "int",
        "description": "Echo-Request间隔（秒），取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EchoRequestMaxAttempts",
        "type": "int",
        "description": "Echo-Request最大尝试次数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableMagicNumber",
        "type": "bool",
        "description": "是否启用Magic Number。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "PadiTimeout",
        "type": "int",
        "description": "PADI超时时间（秒），仅客户端参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadiMaxAttempts",
        "type": "int",
        "description": "PADI最大尝试次数，仅客户端参数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadrTimeout",
        "type": "int",
        "description": "PADR超时时间（秒），仅客户端参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadrMaxAttempts",
        "type": "int",
        "description": "PADR最大尝试次数，仅客户端参数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableRelayAgent",
        "type": "bool",
        "description": "是否启用中继代理，仅客户端参数。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentDestMac",
        "type": "str",
        "description": "中继代理MAC地址，仅客户端参数，有效MAC地址。",
        "default": "00:00:00:00:00:00",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "RelayAgentDestMacStep",
        "type": "str",
        "description": "中继代理MAC地址跳变步长，仅客户端参数，有效MAC地址。",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "UseRelayAgentPadi",
        "type": "bool",
        "description": "PADI中是否包含中继代理信息，仅客户端参数。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "UseRelayAgentPadr",
        "type": "bool",
        "description": "PADR中是否包含中继代理信息，仅客户端参数。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentType",
        "type": "str",
        "description": "中继代理类型，仅客户端参数。",
        "default": "'RFC2516'",
        "range_or_options": "RFC2516 DSL_FORUM"
      },
      {
        "name": "RelaySessionId",
        "type": "str",
        "description": "中继会话ID，仅客户端参数，长度范围：0-12。",
        "default": "\"\"",
        "range_or_options": "string length in [0,12]"
      },
      {
        "name": "CircuitId",
        "type": "str",
        "description": "环路ID，仅客户端参数，长度范围：0-63。",
        "default": "@s",
        "range_or_options": "string length in [0,63]"
      },
      {
        "name": "RemoteId",
        "type": "str",
        "description": "远程ID，仅客户端参数，长度范围：0-63。",
        "default": "@m-@p",
        "range_or_options": "string length in [0,63]"
      },
      {
        "name": "ChapChalReqTimeout",
        "type": "int",
        "description": "CHAP Challenge Request超时时间（秒），仅客户端参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapAckTimeout",
        "type": "int",
        "description": "CHAP Ack超时时间（秒），仅客户端参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapMaxReplyAttempts",
        "type": "int",
        "description": "CHAP Reply最大尝试次数，仅客户端参数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapReqTimeout",
        "type": "int",
        "description": "PAP Request超时时间（秒），仅客户端参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapReqMaxAttempts",
        "type": "int",
        "description": "PAP Request最大尝试次数，仅客户端参数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableAutoRetry",
        "type": "bool",
        "description": "是否启用自动重连功能，仅客户端参数。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoRetryCount",
        "type": "int",
        "description": "自动重连次数，仅客户端参数，取值范围：1-65535。",
        "default": "65535",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpDelay",
        "type": "int",
        "description": "LCP推迟时间（毫秒），仅客户端参数，取值范围：1-65535。",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableAutoFillIpv6",
        "type": "bool",
        "description": "是否启用获取Global IPv6地址，仅客户端参数。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AcName",
        "type": "str",
        "description": "访问集中器名称，仅服务器参数。",
        "default": "'Xinertel'",
        "range_or_options": "not_found"
      },
      {
        "name": "ChapReplyTimeout",
        "type": "int",
        "description": "CHAP Reply超时时间（秒），仅服务器参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapMaxChalAttempts",
        "type": "int",
        "description": "CHAP Challenge最大尝试次数，仅服务器参数，取值范围：1-65535。",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapPeerReqTimeout",
        "type": "int",
        "description": "等待PAP Request超时时间（秒），仅服务器参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv4Start",
        "type": "str",
        "description": "IPv4起始地址，仅服务器参数。",
        "default": "192.0.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4Step",
        "type": "str",
        "description": "IPv4地址步长，仅服务器参数。",
        "default": "0.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4Count",
        "type": "int",
        "description": "IPv4地址数量，仅服务器参数，取值范围：1-65535。",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv6InterfaceId",
        "type": "str",
        "description": "起始Interface ID，仅服务器参数。",
        "default": "::2",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6InterfaceIdStep",
        "type": "str",
        "description": "Interface ID跳变步长，仅服务器参数。",
        "default": "::1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixStart",
        "type": "str",
        "description": "IPv6起始前缀，仅服务器参数。",
        "default": "2002::",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixStep",
        "type": "str",
        "description": "IPv6前缀跳变步长，仅服务器参数。",
        "default": "0:0:0:1::",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6Count",
        "type": "int",
        "description": "IPv6前缀数量，仅服务器参数，取值范围：1-65535。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableForceConnectMode",
        "type": "bool",
        "description": "是否启用强制重连模式，仅服务器参数。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "UnconnectedSessionThreshold",
        "type": "int",
        "description": "未连接会话门限值，仅服务器参数，取值范围：1-65535。",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "MAndOFlag",
        "type": "str",
        "description": "M与O标志位，仅服务器参数。",
        "default": "'M0_O0'",
        "range_or_options": "M0_O0 M0_O1 M1"
      }
    ],
    "example": "| Create Pppoe | Port=${Port} |\n| Create Pppoe | Port=${Port} | EmulationMode=Server |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.edit_pppoe",
    "return_type": "object",
    "return": "Returns a PPPoE session object, either of type PppoeClient or PppoeServer depending on the EmulationMode.",
    "parameters": [
      {
        "name": "Session",
        "type": "Ppp",
        "description": "The PPPoE session object to be edited. This is typically obtained from a port configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the PPPoE session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the PPPoE session.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "EmulationMode",
        "type": "str",
        "description": "Role of the PPPoE session (CLIENT, SERVER, or PPPoL2TP).",
        "default": "CLIENT",
        "range_or_options": "CLIENT SERVER PPPoL2TP"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "Authentication method used for the session.",
        "default": "NO_AUTHENTICATION",
        "range_or_options": "NO_AUTHENTICATION NEGOTIATION CHAP_MD5 PAP"
      },
      {
        "name": "Username",
        "type": "str",
        "description": "Username for authentication.",
        "default": "xinertel",
        "range_or_options": "string length in [1,126]"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Password for authentication.",
        "default": "xinertel",
        "range_or_options": "string length in [1,126]"
      },
      {
        "name": "ServiceName",
        "type": "str",
        "description": "Service name used during PPPoE discovery.",
        "default": "\"\"",
        "range_or_options": "string length in [0,255]"
      },
      {
        "name": "EnableMaxPayloadTag",
        "type": "bool",
        "description": "Enables/disables Max Payload tag.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxPayloadBytes",
        "type": "int",
        "description": "Maximum payload size in bytes.",
        "default": "1500",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpConfigReqTimeout",
        "type": "int",
        "description": "LCP Configure-Request timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpConfigReqMaxAttempts",
        "type": "int",
        "description": "Maximum number of LCP Configure-Request attempts.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpTermReqTimeout",
        "type": "int",
        "description": "LCP Terminate-Request timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpTermReqMaxAttempts",
        "type": "int",
        "description": "Maximum number of LCP Terminate-Request attempts.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "NcpConfigReqTimeout",
        "type": "int",
        "description": "NCP Configure-Request timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "NcpConfigReqMaxAttempts",
        "type": "int",
        "description": "Maximum number of NCP Configure-Request attempts.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpNcpMaxNak",
        "type": "int",
        "description": "Maximum number of NAKs allowed during LCP/NCP negotiation.",
        "default": "5",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableMruNegotiation",
        "type": "bool",
        "description": "Enables/disables MRU negotiation.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "MruSize",
        "type": "int",
        "description": "MRU size in bytes.",
        "default": "1492",
        "range_or_options": "128-65535"
      },
      {
        "name": "EnableEchoRequest",
        "type": "bool",
        "description": "Enables/disables sending of Echo-Request packets.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EchoRequestInterval",
        "type": "int",
        "description": "Interval between Echo-Requests in seconds.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EchoRequestMaxAttempts",
        "type": "int",
        "description": "Maximum number of Echo-Request attempts.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableMagicNumber",
        "type": "bool",
        "description": "Enables/disables use of Magic Number in LCP.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "PadiTimeout",
        "type": "int",
        "description": "PADI packet timeout for client mode.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadiMaxAttempts",
        "type": "int",
        "description": "Maximum number of PADI attempts in client mode.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadrTimeout",
        "type": "int",
        "description": "PADR packet timeout for client mode.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PadrMaxAttempts",
        "type": "int",
        "description": "Maximum number of PADR attempts in client mode.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableRelayAgent",
        "type": "bool",
        "description": "Enables/disables Relay Agent support.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentDestMac",
        "type": "str",
        "description": "MAC address of the Relay Agent.",
        "default": "00:00:00:00:00:00",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "RelayAgentDestMacStep",
        "type": "str",
        "description": "Step value for Relay Agent MAC address increment.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "UseRelayAgentPadi",
        "type": "bool",
        "description": "Include Relay Agent info in PADI packets.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "UseRelayAgentPadr",
        "type": "bool",
        "description": "Include Relay Agent info in PADR packets.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "RelayAgentType",
        "type": "str",
        "description": "Type of Relay Agent used.",
        "default": "RFC2516",
        "range_or_options": "RFC2516 DSL_FORUM"
      },
      {
        "name": "RelaySessionId",
        "type": "str",
        "description": "Relay Session ID string.",
        "default": "\"\"",
        "range_or_options": "string length in [0,12]"
      },
      {
        "name": "CircuitId",
        "type": "str",
        "description": "Circuit ID string for client mode.",
        "default": "@s",
        "range_or_options": "string length in [0,63]"
      },
      {
        "name": "RemoteId",
        "type": "str",
        "description": "Remote ID string for client mode.",
        "default": "@m-@p",
        "range_or_options": "string length in [0,63]"
      },
      {
        "name": "ChapChalReqTimeout",
        "type": "int",
        "description": "CHAP Challenge Request timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapAckTimeout",
        "type": "int",
        "description": "CHAP Ack timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapMaxReplyAttempts",
        "type": "int",
        "description": "Maximum number of CHAP Reply attempts.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapReqTimeout",
        "type": "int",
        "description": "PAP Request timeout in seconds.",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapReqMaxAttempts",
        "type": "int",
        "description": "Maximum number of PAP Request attempts.",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableAutoRetry",
        "type": "bool",
        "description": "Enables/disables automatic retry on failure.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoRetryCount",
        "type": "int",
        "description": "Number of times to auto-retry connection.",
        "default": "65535",
        "range_or_options": "1-65535"
      },
      {
        "name": "LcpDelay",
        "type": "int",
        "description": "LCP delay time in milliseconds.",
        "default": "0",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableAutoFillIpv6",
        "type": "bool",
        "description": "Enables/disables automatic IPv6 address allocation.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AcName",
        "type": "str",
        "description": "Access Concentrator Name (server mode only).",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "ChapReplyTimeout",
        "type": "int",
        "description": "CHAP Reply timeout (server mode only).",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "ChapMaxChalAttempts",
        "type": "int",
        "description": "Maximum number of CHAP challenges (server mode).",
        "default": "10",
        "range_or_options": "1-65535"
      },
      {
        "name": "PapPeerReqTimeout",
        "type": "int",
        "description": "Wait timeout for incoming PAP request (server mode).",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv4Start",
        "type": "str",
        "description": "Starting IPv4 address (server mode).",
        "default": "192.0.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4Step",
        "type": "str",
        "description": "IPv4 step increment (server mode).",
        "default": "0.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4Count",
        "type": "int",
        "description": "Number of IPv4 addresses to allocate (server mode).",
        "default": "3",
        "range_or_options": "1-65535"
      },
      {
        "name": "Ipv6InterfaceId",
        "type": "str",
        "description": "Starting Interface ID for IPv6 (server mode).",
        "default": "::2",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6InterfaceIdStep",
        "type": "str",
        "description": "Increment step for IPv6 Interface ID.",
        "default": "::1",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixStart",
        "type": "str",
        "description": "Starting IPv6 prefix (server mode).",
        "default": "2002::",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixStep",
        "type": "str",
        "description": "Increment step for IPv6 prefix.",
        "default": "0:0:0:1::",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6Count",
        "type": "int",
        "description": "Number of IPv6 prefixes to allocate.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "EnableForceConnectMode",
        "type": "bool",
        "description": "Enables/disables force reconnect mode.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "UnconnectedSessionThreshold",
        "type": "int",
        "description": "Threshold for unconnected sessions before triggering reconnect.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "MAndOFlag",
        "type": "str",
        "description": "Flags M and O for IPv6 stateless/stateful config.",
        "default": "M0_O0",
        "range_or_options": "M0_O0 M0_O1 M1"
      }
    ],
    "description": "This function modifies attributes of an existing PPPoE session object based on provided keyword arguments. It allows detailed configuration of both client and server-side PPPoE parameters including authentication, timeouts, IP address allocation, and more.",
    "example": "| Edit Pppoe | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.connect_pppoe",
    "return_type": "bool",
    "return": "Returns True if all sessions are connected successfully; otherwise, it raises a ContinuableFailure exception on failure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "A single session object or an iterable (list, set, tuple) of session objects. Each session must have a `connect()` method that handles the actual connection logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Establishes a PPPoE connection for the provided session(s). This function accepts a single session object or a collection of session objects (list, set, or tuple). If a single session is provided, it is converted into a list for uniform processing. Each session in the collection is then connected by calling its `connect()` method. The function returns True to indicate successful execution of the connection process. If any error occurs during the connection, the function returns False and raises a ContinuableFailure exception.",
    "example": "| Connect Pppoe | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.disconnect_pppoe",
    "return_type": "bool",
    "return": "Always returns True if all sessions are successfully disconnected; otherwise, False (though in practice it raises an exception on failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of PppoeClient objects or a single PppoeClient object",
        "description": "One or more PPPoE session objects that need to be disconnected.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Disconnects one or more PPPoE sessions by calling the underlying backend function. If any session fails to disconnect, it raises a ContinuableFailure exception. This function is typically used in automated network testing scenarios where control over PPPoE client sessions is required.",
    "example": "| Disconnect Pppoe | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.abort_pppoe",
    "return_type": "bool",
    "return": "Returns True if all sessions are successfully aborted; otherwise, False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single PPPoE session object or a collection of PPPoE session objects that will be terminated. Each session must support the `abort()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Aborts one or more PPPoE protocol sessions by calling the `abort()` method on each session provided. This function supports both single session objects and multiple session collections (lists, sets, or tuples). Internally, it ensures uniform processing by converting single sessions into a list. If any session fails to abort, an exception is raised. The function returns True only if all sessions are successfully terminated.",
    "example": "| Abort Pppoe | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.create_pppoe_custom_option",
    "return_type": "bool or list of bool",
    "return": "A boolean indicating success (True) or failure (False) for creating the custom PPPoE option on a single session. If multiple sessions are provided, returns a list of booleans corresponding to each session.",
    "description": "Creates a custom PPPoE option on one or more PPPoE session objects (either client or server). This function wraps the backend call and ensures consistent handling of both single and multiple session inputs.",
    "parameters": [
      {
        "name": "Session",
        "type": "PppoeClient or PppoeServer or iterable",
        "description": "The PPPoE session object(s) on which to create the custom option. It can be a single session or an iterable (list, set, tuple) of sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "OptionValue",
        "type": "int",
        "description": "Identifier for the custom option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SubPortocolType",
        "type": "str",
        "description": "Message type that contains this option.",
        "default": "LINK_CONTROL_PROTOCOL",
        "range_or_options": "LINK_CONTROL_PROTOCOL IP_CONTROL_PROTOCOL IPV6_CONTROL_PROTOCOL PPPOE_PADI_PADR"
      },
      {
        "name": "UseWildcards",
        "type": "bool",
        "description": "Whether to use wildcards for matching the option.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "StringIsHexadecimal",
        "type": "bool",
        "description": "Whether the string data should be interpreted as hexadecimal.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionData",
        "type": "str",
        "description": "Decimal payload for the custom option.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionHexData",
        "type": "list",
        "description": "Hexadecimal payload for the custom option, represented as a list of hexadecimal numbers.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "example": "| Create Pppoe Custom Option | Sessions=${Sessions} | OptionValue=1 | SubPortocolType=LinkControlProtocol | OptionData=55"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.wait_pppoe_ipcp_state",
    "return_type": "bool",
    "return": "Returns True if the PPPoE IPCP state reaches the specified target within the timeout period; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list (:obj:`PppoeClient`)",
        "description": "A list of PPPoE client session objects for which the IPCP state should be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or None",
        "description": "The target IPCP state to wait for. If None, waits for a default state (typically CONNECTED). Supported states: NONE, IDLE, CONNECTED, CONNECTING, DISCONNECTING.",
        "default": "CONNECTED",
        "range_or_options": "NONE IDLE CONNECTED CONNECTING DISCONNECTING"
      },
      {
        "name": "Interval",
        "type": "int or float",
        "description": "Polling interval in seconds to check the IPCP state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for the IPCP state to reach the target before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for the IPCP (IP Control Protocol) state of one or more PPPoE sessions to reach the specified target state. The function polls the state at regular intervals and returns once the state is achieved or the timeout is reached. If the timeout occurs before reaching the desired state, it returns False.",
    "example": "| Wait Pppoe State | Sessions=${Sessions} | State=CONNECTED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.wait_pppoe_ipv6cp_state",
    "return_type": "bool",
    "return": "Returns True if the PPPoE IPv6CP state reaches the specified state within the timeout; otherwise returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list(PppoeClient) or list(Pppoev3Router)",
        "description": "A list of PPPoE client or Pppoev3 router session objects for which to wait for the IPv6CP state change.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target IPv6CP state to wait for. If not provided, defaults to 'CONNECTED'. Valid options are: NONE, IDLE, CONNECTED, CONNECTING, DISCONNECTING.",
        "default": "CONNECTED",
        "range_or_options": "NONE IDLE CONNECTED CONNECTING DISCONNECTING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval (in seconds) between consecutive checks of the IPv6CP state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time (in seconds) to wait for the IPv6CP state to reach the target state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits for the IPv6 Control Protocol (IPv6CP) state of one or more PPPoE or Pppoev3 sessions to reach a specified state. It continuously polls the state at a given interval until either the target state is reached or the timeout occurs. If the result is False, it raises a ContinuableFailure exception indicating the function failed.",
    "example": "| Wait Pppoe State | Sessions=${Sessions} | State=CONNECTED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.get_pppoe_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回请求的PPPoE端口统计信息。如果只有一行匹配结果，则返回一个包含所请求统计项的字典；如果有多个匹配结果（例如多个端口），则返回一个pandas DataFrame；如果没有找到匹配结果，则返回False。",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple, optional",
        "description": "用于获取统计信息的一个或多个测试仪表端口对象。每个端口对象应具有`Name`属性。如果为None，则不按端口过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "要获取的统计项列表。支持的统计项包括：SessionBlockCount, SessionCount, SessionsUp, SuccessfulConnects, FailedConnects, SucessfulDisconnects, FailedDisconnects。如果为None，将获取所有可用统计项。",
        "default": "not_found",
        "range_or_options": "SessionBlockCount SessionCount SessionsUp SuccessfulConnects FailedConnects SucessfulDisconnects FailedDisconnects"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取指定PPPoE端口的统计信息。它封装了底层 `_get_statictis()` 函数，并提供对端口级统计的支持。可以传入单个或多个端口对象以及一组特定的统计项来查询当前状态值。",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | SessionBlockCount | SessionCount |\n    | Subscribe Result | Types=PppoePortStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pppoe Port Statistic | Port=${Port} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.get_pppoe_server_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical data for PPPoE server blocks. If one matching row is found, returns a dictionary of statistics. If multiple rows match, returns a pandas DataFrame. Returns False if no results are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects, optional",
        "description": "A session object or collection of session objects representing PPPoE server blocks. Each must have a 'Name' attribute used as an identifier. If None, no session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Statistical item(s) to retrieve. Valid items include SessionCount, SessionsUp, SuccessfulConnects, FailedConnects, etc. If None, all available items are queried.",
        "default": "None",
        "range_or_options": "IpcpState Ipv6cpState SessionCount SessionsUp SuccessfulConnects FailedConnects SucessfulDisconnects FailedDisconnects MaxSetupTime MinSetupTime AverageSetupTime SuccessfulSetupRate RxPadi TxPado RxPadr TxPads TxPadt RxPadt TxLcpConfigRequest RxLcpConfigRequest TxLcpConfigAck RxLcpConfigAck TxLcpConfigNak RxLcpConfigNak TxLcpConfigReject RxLcpConfigReject TxLcpEchoRequest RxLcpEchoRequest TxLcpEchoReply RxLcpEchoReply TxLcpTerminateRequest RxLcpTerminateRequest TxLcpTerminateAck RxLcpTerminateAck TxChap RxChap TxPap RxPap TxIpcp RxIpcp TxIpv6cp RxIpv6cp TxIpv4 RxIpv4 TxIpv6 RxIpv6"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for PPPoE server blocks based on the provided session(s) and statistical items. This function wraps around internal methods to fetch performance-based statistics and filters them by session identifiers. It supports pagination and internally ensures data consistency with delays when necessary.",
    "example": "| @{StaItems} | Create List | SessionCount | SessionsUp |\n| Subscribe Result | Types=PppoeServerBlockStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Pppoe Server Block Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.get_pppoe_server_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of requested statistics if exactly one matching row is found, a pandas DataFrame if multiple rows match the criteria, or False if no result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or None",
        "description": "测试仪表端口对象 (PPPoE server session object). If None, no session identifier is used. Can also be a collection of session objects to extract names from.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "PppoeServer Block里会话的index，用于标识特定PPPoE Server实例。",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的统计项列表。如果为None，则返回所有可用属性；如果为字符串，则转换为包含该字符串的列表。",
        "default": "None",
        "range_or_options": "IpcpState Ipv6cpState MacAddress PeerMacAddress PppoeSessionId VlanId InnerVlanId Ipv4Address PeerIpv4Address Ipv6LinklocalAddress PeerIpv6LinklocalAddress SuccessfulConnects FailedConnects SucessfulDisconnects FailedDisconnects SetupTime RxPadi TxPado RxPadr TxPads TxPadt RxPadt TxLcpConfigRequest RxLcpConfigRequest TxLcpConfigAck RxLcpConfigAck TxLcpConfigNak RxLcpConfigNak TxLcpConfigReject RxLcpConfigReject TxChap RxChap TxPap RxPap TxIpcp RxIpcp TxIpv6cp RxIpv6cp TxIpv4 RxIpv4 TxIpv6 RxIpv6"
      }
    ],
    "description": "Retrieves PPPoE server statistics based on session identifiers and specified index. This function wraps the _get_statictis method to fetch and filter PPPoE server statistics. It handles different types of input for Session, constructs appropriate identifiers, and delegates the actual statistic retrieval and filtering logic to _get_statictis.",
    "example": "| @{StaItems} | Create List | SessionCount | SessionsUp |\n| Subscribe Result | Types=PppoeServerStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Pppoe Server Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.get_pppoe_client_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for PPPoE client blocks. If one matching row is found, returns a dictionary of statistic items and values. If multiple rows match, returns a pandas DataFrame. Returns False if no results are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/tuple/set of objects, optional",
        "description": "A session object or collection of session objects representing PPPoE client blocks. Each session must have a 'Name' attribute used as an index. If None, no filtering by session is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical properties (columns) to retrieve from the PPPoE client block statistic. If a string is provided, it will be converted into a list. If None, all available properties are queried.",
        "default": "None",
        "range_or_options": "IpcpState Ipv6cpState SessionCount SessionsUp SessionsRetried AttemptedConnects SuccessfulConnects FailedConnects SucessfulDisconnects FailedDisconnects MaxSetupTime MinSetupTime AverageSetupTime SuccessfulSetupRate TxPadi RxPado TxPadr RxPads TxPadt RxPadt TxLcpConfigRequest RxLcpConfigRequest TxLcpConfigAck RxLcpConfigAck TxLcpConfigNak RxLcpConfigNak TxLcpConfigReject RxLcpConfigReject TxLcpEchoRequest RxLcpEchoRequest TxLcpEchoReply RxLcpEchoReply TxLcpTerminateRequest RxLcpTerminateRequest TxLcpTerminateAck RxLcpTerminateAck TxChap RxChap TxPap RxPap TxIpcp RxIpcp TxIpv6cp RxIpv6cp TxIpv4 RxIpv4 TxIpv6 RxIpv6"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves PPPoE client block statistics based on the provided session(s) and specified statistical items. It wraps around the `_get_statictis` method and allows filtering by one or more sessions while specifying which statistical columns to return. If `Session` is not provided, it will return data for all sessions. If `StaItems` is not provided, it will query all available statistical properties.",
    "example": ".. code:: RobotFramework\n\n    | @{StaItems} | Create List | SessionCount | SessionsUp |\n    | Subscribe Result | Types=PppoeClientBlockStatistic |\n    | Start Protocol |\n    | Sleep | 60 |\n    | &{Result} | Get Pppoe Client Block Statistic | Session=${Session} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.pppoe.get_pppoe_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical values for a single matching session, a pandas DataFrame if multiple sessions match, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "A session object or collection of session objects representing the PPPoE client block(s). If None, no filtering is applied. Uses `.Name` attribute(s) to identify sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Specifies the index of the PPPoE client within the block. Used as part of the index dictionary with key 'PppoeClientId'.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Statistical items (columns) to retrieve. If None, all properties are queried. If a string, it is converted into a list containing that string. Must be a subset of available statistical properties.",
        "default": "None",
        "range_or_options": "IpcpState Ipv6cpState MacAddress PeerMacAddress PppoeSessionId VlanId InnerVlanId Ipv4Address PeerIpv4Address Ipv6LinklocalAddress PeerIpv6LinklocalAddress Ipv6GlobalAddress SessionsRetried AttemptedConnects SuccessfulConnects FailedConnects SucessfulDisconnects FailedDisconnects SetupTime TxPadi RxPado TxPadr RxPads TxPadt RxPadt TxLcpConfigRequest RxLcpConfigRequest TxLcpConfigAck RxLcpConfigAck TxLcpConfigNak RxLcpConfigNak TxLcpConfigReject RxLcpConfigReject TxLcpEchoRequest RxLcpEchoRequest TxLcpEchoReply RxLcpEchoReply TxLcpTerminateRequest RxLcpTerminateRequest TxLcpTerminateAck RxLcpTerminateAck TxChap RxChap TxPap RxPap TxIpcp RxIpcp TxIpv6cp RxIpv6cp TxIpv4 RxIpv4 TxIpv6 RxIpv6"
      }
    ],
    "kwargs": [],
    "description": "Retrieves PPPoE client statistics based on session identifiers and index. This function wraps the `_get_statictis` method to fetch and filter PPPoE client-related statistics. It supports both single and multiple session inputs by extracting session names accordingly. The `Index` parameter allows selection of a specific PPPoE client instance within the block, and `StaItems` controls which statistical properties are returned.",
    "example": "| @{StaItems} | Create List | SessionCount | SessionsUp |\n| Subscribe Result | Types=PppoeClientStatistic |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Pppoe Client Statistic | Session=${Session} | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.create_rip",
    "return_type": "RipRouter",
    "return": "RIP协议会话对象，可用于后续的配置和操作。",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，用于绑定RIP协议会话到指定的物理或逻辑端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "RIP协议会话名称，用于标识该RIP会话。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用RIP协议会话。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "RIP协议版本。当RIP版本为RIPv1/RIPv2时，DutIpv4Address可配；当RIP版本为RIPng时，DutIpv6Address可配。",
        "default": "RIPV2",
        "range_or_options": "RIPV1 RIPV2 RIPNG"
      },
      {
        "name": "UpdateType",
        "type": "str",
        "description": "RIP消息发送方式，支持广播、组播和单播。",
        "default": "MULTICAST",
        "range_or_options": "BROADCAST MULTICAST UNICAST"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "指定接收RIP消息的路由器IPv4地址，仅在RIPv1或RIPv2时有效。",
        "default": "224.0.0.9",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "DutIpv6Address",
        "type": "str",
        "description": "指定接收RIP消息的路由器IPv6地址，仅在RIPng且UpdateType为Unicast时有效。",
        "default": "ff02::9",
        "range_or_options": "IPv6 Address"
      },
      {
        "name": "AuthMethod",
        "type": "str",
        "description": "认证方法，仅在RIPv2时有效。",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "当使用Simple或MD5认证方式时输入的密码。",
        "default": "Xinetel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5KeyId",
        "type": "int",
        "description": "当使用MD5认证方式时使用的密钥ID。",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "UpdateInterval",
        "type": "int",
        "description": "发送RIP更新消息的时间间隔（单位：秒）。",
        "default": "30",
        "range_or_options": "1-65535"
      },
      {
        "name": "UpdateJitter",
        "type": "int",
        "description": "RIP更新消息发送时间的随机抖动值（单位：秒）。",
        "default": "0",
        "range_or_options": "0-5"
      },
      {
        "name": "MaxRoutePerUpdate",
        "type": "int",
        "description": "每次更新消息中携带的最大路由数量。",
        "default": "25",
        "range_or_options": "1-70"
      },
      {
        "name": "SplitHorizon",
        "type": "bool",
        "description": "是否启用水平分割功能以防止路由环路。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "是否允许查看通过RIP学习到的路由信息。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableIpAddrValidation",
        "type": "bool",
        "description": "是否验证接收到的IP地址是否与本地接口处于同一网段。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "创建一个RIP协议会话对象，并将其关联到指定的端口上。该函数用于初始化并配置RIP协议实例，支持RIPv1、RIPv2和RIPng三种协议版本。同时支持多种配置选项，如认证方式、更新间隔、最大路由数等。创建成功后，该RIP会话对象会被注册到全局协议对象映射中以便后续引用。",
    "example": "| Create Rip | Port=${Port} | EnableIpAddrValidation=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.edit_rip",
    "return_type": "bool",
    "return": "A boolean value indicating the success or failure of updating session attributes.",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "RIP protocol session object list, typically of type RipRouter.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the RIP session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the RIP protocol session.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "RIP version to be used for the session.",
        "default": "RIPV2",
        "range_or_options": "RIPV1 RIPV2 RIPNG"
      },
      {
        "name": "UpdateType",
        "type": "str",
        "description": "Communication method for sending RIP messages (BROADCAST, MULTICAST, UNICAST).",
        "default": "MULTICAST",
        "range_or_options": "BROADCAST MULTICAST UNICAST"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "IP address of the router receiving RIP messages (applicable for RIPv1/RIPv2).",
        "default": "224.0.0.9",
        "range_or_options": "not_found"
      },
      {
        "name": "DutIpv6Address",
        "type": "str",
        "description": "IPv6 address of the router receiving RIP messages (applicable for RIPng with Unicast update type).",
        "default": "ff02::9",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthMethod",
        "type": "str",
        "description": "Authentication method for the session (applicable for RIPv2).",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Authentication password if AuthMethod is SIMPLE or MD5.",
        "default": "Xinetel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5KeyId",
        "type": "int",
        "description": "MD5 key ID when using MD5 authentication.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "UpdateInterval",
        "type": "int",
        "description": "Time interval (in seconds) between RIP updates.",
        "default": "30",
        "range_or_options": "1-65535"
      },
      {
        "name": "UpdateJitter",
        "type": "int",
        "description": "Jitter time added to the update interval to simulate variability.",
        "default": "0",
        "range_or_options": "0-5"
      },
      {
        "name": "MaxRoutePerUpdate",
        "type": "int",
        "description": "Maximum number of routes included in each update message.",
        "default": "25",
        "range_or_options": "1-70"
      },
      {
        "name": "SplitHorizon",
        "type": "bool",
        "description": "Enables/disables split horizon functionality.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableViewRoutes",
        "type": "bool",
        "description": "Determines whether learned route information should be displayed.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableIpAddrValidation",
        "type": "bool",
        "description": "Validates if received IP addresses are in the same subnet as the local address.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This function updates attributes of a given Session object representing a RIP protocol session with provided key-value pairs from keyword arguments. It internally calls the backend function `renix.edit_rip` and returns True upon successful update of attributes. If the update fails, it raises a ContinuableFailure exception.",
    "example": "| Edit Rip | Session=${Session} | EnableViewRoutes=True |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.create_rip_ipv4_route",
    "return_type": "object",
    "return": "RIP IPv4路由对象 (:obj:`RipIpv4RouteConfig`)",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "RIP协议会话对象，用于创建IPv4路由。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "RIP IPv4路由名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "是否启用RIP IPv4路由。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteCount",
        "type": "str",
        "description": "路由池中包含的路由数量。",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "StartIpv4Prefix",
        "type": "str",
        "description": "起始IPv4地址。",
        "default": "192.168.1.0",
        "range_or_options": "有效的IPv4地址"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "IPv4地址前缀长度。",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "Increment",
        "type": "str",
        "description": "路由增量步长。",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "路由下一跳地址。",
        "default": "0.0.0.0",
        "range_or_options": "有效的IPv4地址"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "路由度量值，16表示不可达。",
        "default": "1",
        "range_or_options": "1-16"
      },
      {
        "name": "RouteTag",
        "type": "int",
        "description": "路由标签域的值，0表示没有标签。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于在RIP (Routing Information Protocol) 配置中创建一个IPv4路由对象。它封装了底层Session对象的create_ipv4_route方法，简化了与测试设备或系统交互的过程。通过提供会话和路由参数，用户可以定义路由的属性，如目标网络、网关、接口等（具体支持的参数依赖于底层API）。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Rip | Port=${Port} |\n    | Create Rip Ipv4 Route | Session=${Session} | Metric=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.create_rip_ipv6_route",
    "return_type": "object",
    "return": "RIP IPv6路由对象（类型为:obj:`RipIpv6RouteConfig`）",
    "parameters": [
      {
        "name": "Session",
        "type": "object",
        "description": "RIP协议会话对象列表，用于创建IPv6路由。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "RIP IPv6路由名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "使能RIP IPv6路由。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "RouteCount",
        "type": "int",
        "description": "路由池中包含的路由个数。",
        "default": "1",
        "range_or_options": "1-2147483647"
      },
      {
        "name": "StartIpv6Prefix",
        "type": "str",
        "description": "起始IPv6地址。",
        "default": "'2000::'",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "RouteStep",
        "type": "str",
        "description": "IP地址的增加步长。",
        "default": "'0:0:0:1::'",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "地址的前缀长度。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "路由下一跳。",
        "default": "'::'",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "路由度量值。",
        "default": "1",
        "range_or_options": "1-16"
      },
      {
        "name": "RouteTag",
        "type": "int",
        "description": "路由标签域的值。0表示没有tag。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于创建一个RIP IPv6路由对象。它基于提供的会话对象和参数配置来生成IPv6路由条目，并通过调用底层库函数实现实际的路由配置。此功能通常用于网络测试框架中，以模拟或配置RIP协议下的IPv6路由行为。",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Rip | Port=${Port} |\n    | Create Rip Ipv6 Route | Session=${Session} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.advertise_rip",
    "return_type": "bool",
    "return": "Returns True after successfully advertising RIP for all provided sessions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single session object or an iterable (list, set, or tuple) of session objects for which RIP advertisement should be triggered. Each session object must have an `advertise()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Advertises RIP (Routing Information Protocol) for the given session(s). This function takes one or more session objects and invokes the `advertise()` method on each of them. If the input is not a list, set, or tuple, it is converted into a list before processing. The function returns True upon successful execution.",
    "example": "| Advertise Rip | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.withdraw_rip",
    "return_type": "bool",
    "return": "True if the RIP session withdrawal process was initiated successfully, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or Session",
        "description": "A single Session object or a list of Session objects representing active RIP routing sessions. These objects must have a `withdraw()` method that handles the actual deactivation of the session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function gracefully withdraws one or more RIP (Routing Information Protocol) sessions. If a single Session is provided, it is internally converted to a list for uniform processing. The function returns True if the operation was executed successfully, though this does not guarantee that all individual session withdrawals were successful—those statuses should be checked individually from their respective objects.",
    "example": "| Withdraw Rip | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.suspend_rip",
    "return_type": "bool",
    "return": "True if all provided RIP sessions are successfully suspended, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of RIP session objects (of type `RipRouter`) that need to be suspended.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Suspends one or more RIP (Routing Information Protocol) sessions. This function accepts a list of session objects and attempts to suspend each of them via the backend API. If any session fails to suspend, it returns False, which triggers an exception in the user interface layer.",
    "example": "| Suspend Rip | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.resume_rip",
    "return_type": "bool",
    "return": "True if all provided sessions are successfully resumed; False will raise ContinuableFailure.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of RipRouter objects",
        "description": "A list containing RIP protocol session objects (of type RipRouter) to be resumed.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Resumes the execution of one or more RIP protocol session objects. This function internally calls the `resume()` method on each session provided in the input list. If any session fails to resume, a `ContinuableFailure` exception is raised with an appropriate error message.",
    "example": "| Resume Rip | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.wait_rip_state",
    "return_type": "bool",
    "return": "True if all RIP sessions reach the specified state within the timeout; False otherwise (but will raise an exception if False is returned).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of RipRouter",
        "description": "List of RIP protocol session objects to monitor for reaching the target state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The desired state to wait for in each RIP session. If not provided, defaults to 'OPEN'.",
        "default": "'OPEN'",
        "range_or_options": "DISABLED NOTSTART CLOSED OPEN SUSPENDED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Polling interval in seconds between checks for session state updates.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time in seconds to wait for all sessions to reach the target state before timing out.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more RIP (Routing Information Protocol) sessions to reach a specified operational state. The function periodically checks the state of each session at defined intervals until all sessions reach the desired state or the timeout duration is exceeded. If any session fails to reach the desired state within the timeout, the function returns False and raises a ContinuableFailure exception.",
    "example": "| Wait Rip State | Sessions=${Sessions} | State=OPEN | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.get_rip_session_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for RIP session blocks. If one matching row is found, returns a dictionary with keys as requested statistical items and values as the corresponding results. If multiple rows are found, returns a pandas DataFrame. If no rows are found, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the session(s) for which statistics are retrieved. If a single object with a `.Name` attribute is provided, its name is used as the session ID. If a list, set, or tuple of such objects is provided, their `.Name` attributes are extracted into a list of session IDs. If None, no specific session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve for the RIP session block(s). If None, available properties are queried dynamically. If a string is provided, it is converted into a list. The items must be valid properties of the 'RipSessionBlockStats' statistic type.",
        "default": "None",
        "range_or_options": "SessionBlockId SessionCount TxAdvertised RxAdvertised TxWithdrawn RxWithdrawn"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves statistical data for RIP session blocks based on the provided session(s) and requested statistical items. It wraps an internal method `_get_statictis()` to fetch statistics by preparing session identifiers and delegating the retrieval process. Internally, it may call commands like `GotoResultPageCommand` for paginated results and uses time.sleep(3) when navigating between result pages if needed. The resulting statistics are also logged in a tabulated format for debugging purposes.",
    "example": "| @{StaItems} | Create List | TxAdvertised | RxAdvertised |\n| &{Result} | Get Rip Session Block Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.get_rip_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with requested statistics if one matching row is found, a pandas DataFrame for multiple matches, or False if no match is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple, optional",
        "description": "A session object or collection of session objects. Each session object must have a `Name` attribute corresponding to the session block ID. If None, no filtering by session is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int, optional",
        "description": "The numeric session identifier used to filter results within a session block. Default is 1.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical properties (columns) to retrieve. If None, all available properties are retrieved. Supported items include: SessionBlockId, SessionId, SessionState, TxAdvertised, RxAdvertised, TxWithdrawn, RxWithdrawn.",
        "default": "None",
        "range_or_options": "SessionBlockId SessionId SessionState TxAdvertised RxAdvertised TxWithdrawn RxWithdrawn"
      }
    ],
    "description": "Retrieves RIP session statistics based on provided session identifiers and statistical items. This function wraps internal `_get_statictis` logic tailored for RIP sessions and supports flexible input types for session specification. It allows filtering by session ID and specific statistical properties. Internally modifies state by calling `_get_statictis`, potentially refreshing data or navigating paginated results.",
    "example": "| @{StaItems} | Create List | SessionState | TxAdvertised |\n| Subscribe Result | Types=RipSessionResultPropertySet |\n| Start Protocol |\n| Sleep | 60 |\n| &{Result} | Get Rip Session Statistic | Session=${Session} | SessionId=2 | StaItems=@{StaItems} |\n| Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.get_rip_router_from_route",
    "return_type": "list",
    "return": "A list of RIP router objects corresponding to the input route(s). Each entry represents the RIP router that generated the respective route.",
    "parameters": [
      {
        "name": "Route",
        "type": "object or list of objects",
        "description": "A single route object or a list of route objects for which the associated RIP router(s) need to be determined.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieve the RIP routers associated with the provided route(s). This function accepts either a single route or a list of routes and returns the corresponding RIP routers that generated those routes. It internally uses the 'get_relatives' method to find the source RIP router(s) for the given route(s), based on the 'GenerateRipRoute' relationship in the source direction.",
    "example": ".. code:: RobotFramework\n\n    | ${Session} | Create Rip | Port=${Port} |\n    | ${RouterLsa} | Create Rip Ipv4 Router | Session=${Session} | Age=20 |\n    | ${Point} | Get Rip Router From Route | Route=${RouterLsa} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.rip.edit_rip_port_config",
    "description": "Modifies the RIP port configuration for one or more specified ports, such as setting the RIP route transmit rate.",
    "example": "| Edit Rip Port Config | Ports=${Ports} | UpdateRoutesTransmitRate=100 |",
    "return_type": "object or list",
    "return": "Returns a single updated RipPortRateConfig object if one port is processed; otherwise, returns a list of updated configuration objects for all provided ports.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list or object",
        "description": "A single port object or a list of port objects for which the RIP configuration needs to be edited. If a single port is provided, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "UpdateRoutesTransmitRate",
        "type": "int",
        "description": "Sets the RIP Tx Rate in messages per second.",
        "default": "1000",
        "range_or_options": "1-1000000000"
      }
    ]
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.create_saa",
    "return_type": "Saa",
    "return": "Saa协议会话对象",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Mode",
        "type": "str",
        "description": "模式",
        "default": "RouterHost",
        "range_or_options": "RouterRA RouterHost"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "标志位",
        "default": "NONEBIT",
        "range_or_options": "NONEBIT MBIT OBIT"
      },
      {
        "name": "RouterLifetime",
        "type": "int",
        "description": "路由器生命周期",
        "default": "1800",
        "range_or_options": "0-65535"
      },
      {
        "name": "EnableDAD",
        "type": "bool",
        "description": "使能重复地址检测",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DADTransmitCount",
        "type": "int",
        "description": "重复地址检测发送次数",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "DADRetransmitDelay",
        "type": "int",
        "description": "重复地址检测重传时延",
        "default": "1000",
        "range_or_options": "1000-4294967295"
      },
      {
        "name": "RouterSolicitationRetries",
        "type": "int",
        "description": "路由Solicitation重传次数",
        "default": "2",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RouterSolicitationRetransmitDelay",
        "type": "int",
        "description": "路由Solicitation重传时延",
        "default": "3000",
        "range_or_options": "1000-4294967295"
      },
      {
        "name": "EnableEui64LinkLocal",
        "type": "bool",
        "description": "使能EUI-64 Link Local",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSendRA",
        "type": "bool",
        "description": "使能发布RA报文",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaxInterval",
        "type": "int",
        "description": "最大发布时间间隔（秒）",
        "default": "600",
        "range_or_options": "2-1350"
      },
      {
        "name": "MinInterval",
        "type": "int",
        "description": "最小发布时间间隔（秒）",
        "default": "200",
        "range_or_options": "1-1800"
      },
      {
        "name": "Ipv6EnableGatewayLearn",
        "type": "bool",
        "description": "Ipv6使能网关地址学习",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DefaultNoAdvertise",
        "type": "bool",
        "description": "不携带前缀信息",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "创建一个Saa协议配置实例，并将其注册到全局的协议对象映射中。该函数用于初始化一个新的Saa类实例，使用提供的父端口和可选的配置参数。所有的关键字参数会被设置为Saa实例的属性（如果存在对应的属性名）。",
    "example": "| Create Saa | Port=${Port} | DADTransmitCount=255 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.wait_saa_state",
    "return_type": "bool",
    "return": "Returns True if all specified SAA sessions reach the desired state within the timeout period; otherwise, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of SAA session objects whose states need to be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list",
        "description": "The target state(s) that each session must reach. If not provided, defaults to 'IDLE'. Supported states: DISABLED, IDLE, ESTABLISHING, BOUND, RUNNING.",
        "default": "'IDLE'",
        "range_or_options": "DISABLED IDLE ESTABLISHING BOUND RUNNING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval (in seconds) between successive checks for session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time (in seconds) to wait for each session to reach the specified state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more SAA (Service Access Architecture) protocol sessions to reach a specified state. This function provides a convenient way to monitor multiple sessions simultaneously and ensures consistent behavior across different session objects by calling their internal `wait_session_state` method. The function raises an exception if the sessions fail to reach the expected state within the given timeout.",
    "example": "| Wait Saa State | Sessions=${Sessions} | State=BOUND | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.edit_saa_port_config",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port",
        "description": "测试仪表端口对象，用于指定需要修改SAA端口配置的端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RequestRate",
        "type": "int",
        "description": "Request Rate (sessions/sec)，表示每秒会话请求数。",
        "default": "100",
        "range_or_options": "0-10000"
      },
      {
        "name": "MaxOutstanding",
        "type": "int",
        "description": "Max Outstanding Session，表示最大未完成会话数。",
        "default": "1000",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于修改一个或多个测试仪表端口上的SAA（Service Access Agent）端口配置。具体来说，它能够调整与SAA相关的速率控制参数，例如每秒会话请求数和最大未完成会话数。这些配置通常用于模拟特定的网络负载场景或进行性能测试。",
    "example": ".. code:: RobotFramework\n\n    | Edit Saa Port Config | Ports=${Ports} | RequestRate=1000 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.get_saa_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistical items and values for one port, a pandas DataFrame if multiple ports are queried, or False if no results found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple or None",
        "description": "The test instrument port object(s) to query statistics for. If None, all ports are considered.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "List of statistical items (columns) to retrieve. If None, retrieves all available items.",
        "default": "None",
        "range_or_options": "CurrentlyAttempting CurrentlyIdle CurrentlyBound TxNeighborSolicitation RxNeighborSolicitation TxNeighborAdvertisement RxNeighborAdvertisement TxRouterSolicitation RxRouterSolicitation TxRouterAdvertisement RxRouterAdvertisement SuccessPercentage TotalAttempted TotalBound TotalDADFailed TotalRATimeoutFailed TotalFailed"
      }
    ],
    "kwargs": [],
    "description": "Retrieves SAA port statistics for specified port(s) and statistical items. This function wraps the _get_statictis method to fetch statistics specifically of type 'SaaPortStatistics'. It supports querying for one or more ports by their names and allows specifying which statistical items (columns) to retrieve. If no port is provided, it queries statistics without filtering by port.",
    "example": "| Get Saa Port Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.get_saa_session_block_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary if one matching row is found, with keys as statistical item names and values as corresponding data. If multiple rows are found, returns a pandas DataFrame. Returns False if no matching rows are found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list/set/tuple of objects or None",
        "description": "SAA协议会话对象或对象集合，用于过滤统计结果。若为None，则不进行过滤；若为单个对象，使用其Name属性作为标识；若为集合，提取每个对象的Name属性形成标识列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的统计项，可为字符串、列表或None。若为None，默认返回ROM查询确定的统计项；若为字符串则转换为单元素列表；若为列表，需为支持的统计项子集。",
        "default": "not_found",
        "range_or_options": "BindingState BlockSessionState CurrentlyAttempting CurrentlyIdle CurrentlyBound AttemptRate BindRate TxNeighborSolicitation RxNeighborSolicitation TxNeighborAdvertisement RxNeighborAdvertisement TxRouterSolicitation RxRouterSolicitation TxRouterAdvertisement RxRouterAdvertisement TotalAttempted TotalBound TotalDADFailed TotalRATimeoutFailed TotalFailed"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取SAA协议会话块的统计信息。它封装了内部方法`_get_statictis()`，通过提供的会话标识和统计项来检索数据。函数处理输入参数并返回匹配的统计结果，支持多种返回格式（字典、DataFrame或布尔值）。",
    "example": ".. code:: RobotFramework\n\n    | Get Saa Session Block Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.saa.get_saa_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns session statistics for SAA protocol. If one matching row is found, returns a dictionary; if multiple rows match, returns a DataFrame; if no match, returns False.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple of objects or None",
        "description": "SAA session object(s) whose Name attribute identifies the session(s). If None, may return global session statistics.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "Session index used to identify specific session rows in result data.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "List of statistical items to retrieve (e.g., SessionState, MacAddress, etc.). Must be subset of available SaaSessionStatistics properties.",
        "default": "not_found",
        "range_or_options": "SessionState MacAddress VlanId InnerVlanId GlobalIpv6Address LinkLocalIpv6Address PrefixIpv6Address PrefixLength ValidLifeTime PreferredLifeTime"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves SAA (Service Assurance Agent) session statistics based on provided session identifiers, session index, and selected statistical items. It internally calls `_get_statictis` method with appropriate parameters and processes results into user-friendly output.",
    "example": "Example usage in RobotFramework:\n\n| Get Saa Session Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.create_twamp",
    "return_type": "Twamp",
    "return": "The newly created and initialized Twamp protocol session object.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent port object (typically a test instrument port) to associate the TWAMP protocol session with.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ActiveClient",
        "type": "bool",
        "description": "Enables TWAMP client or controller emulation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ActiveServer",
        "type": "bool",
        "description": "Enables TWAMP server emulation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IpLayerVersion",
        "type": "str",
        "description": "IP version for this interface.",
        "default": "IPv4",
        "range_or_options": "IPv4 IPv6"
      },
      {
        "name": "EnableLight",
        "type": "bool",
        "description": "Enables the TWAMP Light protocol.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6AddressType",
        "type": "str",
        "description": "Type of IPv6 address used for the connection.",
        "default": "GLOBAL",
        "range_or_options": "GLOBAL LINKLOCAL"
      },
      {
        "name": "ScalabilityMode",
        "type": "str",
        "description": "Controls scalability mode to reduce processor demand during large-scale testing.",
        "default": "NORMAL",
        "range_or_options": "NORMAL DISCARDSTATISTICS"
      },
      {
        "name": "PeerIpv4Address",
        "type": "str",
        "description": "IPv4 address of the peer device under test (DUT).",
        "default": "192.85.1.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "PeerIpv6Address",
        "type": "str",
        "description": "IPv6 address of the peer device under test (DUT).",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "ConnectionRetryInterval",
        "type": "int",
        "description": "Number of seconds to wait between connection attempts.",
        "default": "30",
        "range_or_options": "10-255"
      },
      {
        "name": "ConnectionRetryCount",
        "type": "int",
        "description": "Number of times to attempt a connection before timing out.",
        "default": "100",
        "range_or_options": "0-65535"
      },
      {
        "name": "WillingToParticipate",
        "type": "bool",
        "description": "Sets the 'Willing' bit in the modes field indicating willingness to participate.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Mode",
        "type": "list",
        "description": "Security mode for the TWAMP session.",
        "default": "['NONE', 'UNAUTNENTICATED']",
        "range_or_options": "NONE UNAUTNENTICATED"
      },
      {
        "name": "LocalUdpPorts",
        "type": "int",
        "description": "Port number for local UDP ports used in the TWAMP session.",
        "default": "862",
        "range_or_options": "0-65535"
      },
      {
        "name": "ServWaitTime",
        "type": "int",
        "description": "Number of seconds after which the server terminates an idle control connection.",
        "default": "900",
        "range_or_options": "0-65535"
      },
      {
        "name": "RefWaitTime",
        "type": "int",
        "description": "Number of seconds after which the Session-Reflector terminates an idle session.",
        "default": "900",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Creates and configures a new TWAMP (Two-Way Active Measurement Protocol) session associated with the specified port. This function initializes a TWAMP configuration using the provided parent port and any additional keyword arguments. The created TWAMP session is also registered in a global mapping dictionary (`map_protocol_object`) by its handle.",
    "example": "| Create Twamp | Port=${Port} | RefWaitTime=255 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.wait_twamp_state",
    "return_type": "bool",
    "return": "Returns True if all provided TWAMP session(s) have reached the desired state within the timeout period; otherwise, False (if not raising an exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Twamp session objects",
        "description": "A list of TWAMP (Two-Way Active Measurement Protocol) session objects whose states are to be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the TWAMP session(s) are expected to reach. If not specified, it defaults to 'ESTABLISHED'. Supported states: DISABLED, IDLE, CONNECT, ESTABLISHED, SESSIONREQUESTED, STARTED.",
        "default": "'ESTABLISHED'",
        "range_or_options": "DISABLED IDLE CONNECT ESTABLISHED SESSIONREQUESTED STARTED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval in seconds between successive checks of the session state.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time in seconds to wait for the session(s) to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for the specified TWAMP (Two-Way Active Measurement Protocol) session(s) to reach the desired state. This function checks the state of one or more TWAMP sessions at regular intervals until the session(s) reach the expected state or a timeout occurs. If any of the sessions do not reach the desired state within the timeout period, an error may be raised depending on the associated abnormal_check decorator.",
    "example": "| Wait Twamp State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.edit_twamp_test_session",
    "return_type": "TwampTestSessionConfig or list of TwampTestSessionConfig",
    "return": "The configuration object(s) resulting from editing the TWAMP test session(s). If a single TWAMP session was edited, returns a single configuration object. If multiple sessions were edited, returns a list of configuration objects.",
    "description": "Edits one or more TWAMP (Two-Way Active Measurement Protocol) test sessions with the provided configuration parameters. This function allows users to modify various properties of existing TWAMP test sessions such as UDP ports, duration mode, packet rate, and more. It supports both individual and batch updates by accepting either a single TWAMP session object or a list of such objects.",
    "parameters": [
      {
        "name": "Twamps",
        "type": "Twamp or list of Twamp",
        "description": "A single TWAMP session object or a list of TWAMP session objects to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SourceUdpPort",
        "type": "int",
        "description": "UDP port from which TWAMP-Test packets are sent by the Session-Sender.",
        "default": "5450",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestinationUdpPort",
        "type": "int",
        "description": "UDP port to which TWAMP-Test packets are sent by the Session-Reflector.",
        "default": "5450",
        "range_or_options": "0-65535"
      },
      {
        "name": "Timeout",
        "type": "int",
        "description": "Number of seconds that the Session-Reflector waits after receiving a Stop-Sessions message.",
        "default": "30",
        "range_or_options": "0-65535"
      },
      {
        "name": "DurationMode",
        "type": "str",
        "description": "Type of maintenance point indicating how long the test session should run.",
        "default": "SECONDS",
        "range_or_options": "SECONDS PACKETS CONTINUOUS"
      },
      {
        "name": "Duration",
        "type": "int",
        "description": "Number of seconds to run the test session if DurationMode is SECONDS.",
        "default": "60",
        "range_or_options": "0-65535"
      },
      {
        "name": "PacketCount",
        "type": "int",
        "description": "Number of packets to send if DurationMode is PACKETS.",
        "default": "100",
        "range_or_options": "0-65535"
      },
      {
        "name": "PaddingLength",
        "type": "int",
        "description": "Number of octets to be appended to the normal TWAMP-Test packet for padding.",
        "default": "128",
        "range_or_options": "27-9000"
      },
      {
        "name": "FrameRate",
        "type": "int",
        "description": "Rate at which to send TWAMP-Test packets in frames per second.",
        "default": "10",
        "range_or_options": "1-1000"
      },
      {
        "name": "Dscp",
        "type": "int",
        "description": "DiffServ code point value used for marking packets.",
        "default": "100",
        "range_or_options": "1-255"
      },
      {
        "name": "Ttl",
        "type": "int",
        "description": "Time To Live value used for each TWAMP-Test packet.",
        "default": "255",
        "range_or_options": "1-255"
      },
      {
        "name": "PaddingPattern",
        "type": "str",
        "description": "Type of data to be used for padding the TWAMP-Test packet.",
        "default": "RANDOM",
        "range_or_options": "RANDOM USERDEFINED_STRING USERDEFINED_HEX"
      },
      {
        "name": "UserDefinedString",
        "type": "str",
        "description": "User-defined string pattern to use for padding when PaddingPattern is USERDEFINED_STRING.",
        "default": "xinertel.com",
        "range_or_options": "not_found"
      },
      {
        "name": "UserDefinedHex",
        "type": "list",
        "description": "User-defined hexadecimal values to use for padding when PaddingPattern is USERDEFINED_HEX.",
        "default": "[]",
        "range_or_options": "List of integers between 0-255"
      }
    ],
    "example": "| Edit Twamp Test Session | Twamps=${Twamps} | PaddingPattern=USERDEFINED_STRING |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.wait_twamp_session_state",
    "return_type": "bool",
    "return": "Returns True if all TWAMP sessions reach one of the expected states within the timeout period; otherwise, it raises a failure exception.",
    "parameters": [
      {
        "name": "TestSessions",
        "type": "list of TwampTestSessionConfig objects",
        "description": "List of TWAMP test session configuration objects whose state will be monitored.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list of str, optional",
        "description": "One or more target session states to wait for. If not provided, defaults to ['ACCEPTED']. Supported values: IDLE, ACCEPTED, REJECTED, INPROCESS, PAUSED.",
        "default": "['ACCEPTED']",
        "range_or_options": "IDLE ACCEPTED REJECTED INPROCESS PAUSED"
      },
      {
        "name": "Interval",
        "type": "int, optional",
        "description": "Polling interval in seconds between successive checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all sessions to reach one of the desired states before raising an exception.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until the 'State' attribute of each TWAMP session in 'TestSessions' reaches one of the specified target states. The function polls the session states at regular intervals and returns successfully if all sessions reach any of the desired states within the timeout duration. If the timeout is exceeded without reaching the desired state(s), it raises a failure exception.",
    "example": "| Wait Twamp Session State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_start",
    "return_type": "bool",
    "return": "Returns True if TWAMP sessions were successfully initiated for all provided session objects, otherwise False (though in practice, it always returns True as per backend logic).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or iterable of Twamp session objects",
        "description": "A list or other iterable (e.g., set, tuple) of session objects that support the `start_twamp()` method. These objects are expected to be properly initialized before calling this function.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates TWAMP (Two-Way Active Measurement Protocol) sessions for all provided session objects. It serves as a wrapper that calls the `start_twamp()` method on each session object in the provided list or iterable. The function ensures that TWAMP measurements are started consistently across multiple sessions and provides a unified return value indicating success.",
    "example": ".. code:: RobotFramework\n\n    | Twamp Start | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_stop",
    "return_type": "bool",
    "return": "Returns True if all TWAMP sessions are successfully stopped, otherwise False (which raises a ContinuableFailure in the wrapper).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[list, set, tuple, object]",
        "description": "A single session object or a collection of session objects that support the `stop_twamp()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops TWAMP (Two-Way Active Measurement Protocol) measurements on the provided session(s). The function accepts a single session or a collection of sessions (list, set, or tuple), and iterates through each session to invoke the `stop_twamp()` method. It ensures that all sessions are properly stopped and returns True to indicate successful execution.",
    "example": "| Twamp Stop | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_start_session",
    "return_type": "bool",
    "return": "Returns True if all sessions are initiated successfully; otherwise, False (which raises a ContinuableFailure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or Twamp",
        "description": "A single session object of type `Twamp` or an iterable (e.g., list) containing multiple `Twamp` session objects. Each session must have a method `start_session` that will be called with TestSessions and any additional keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TestSessions",
        "type": "TwampTestSessionConfig",
        "description": "The test session configuration object to be passed to each session's `start_session` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ControlType",
        "type": "str",
        "description": "Specifies the operation type for controlling the TWAMP session.",
        "default": "REQUEST",
        "range_or_options": "REQUEST START STOP PAUSE RESUME STARTTWAMP STOPTWAMP"
      }
    ],
    "description": "Starts one or more TWAMP (Two-Way Active Measurement Protocol) test sessions using the provided session objects. This function ensures uniform handling of both single and multiple session objects by converting a single session into a list if needed. It then iterates over all session objects and initiates each session by calling its `start_session` method with the provided test session and additional keyword arguments. If the backend call returns False, this function raises a `ContinuableFailure` exception.",
    "example": "| Twamp Start Session | Sessions=${Sessions} | TestSessions=${TestSessions} | ControlType=STOPTWAMP |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_stop_session",
    "return_type": "bool",
    "return": "Returns True if the operation to stop sessions was successfully initiated, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "A single session object or a collection of session objects that need to be stopped. Internally, it is converted into a list for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TestSessions",
        "type": "object",
        "description": "An object passed directly to the `stop_session` method of each session. Its exact type and purpose depend on how `stop_session` is implemented in the underlying Session class, but typically it represents an active TWAMP test session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ControlType",
        "type": "str",
        "description": "The control command type used when stopping the session. This determines how the session termination is handled internally.",
        "default": "REQUEST",
        "range_or_options": "REQUEST START STOP PAUSE RESUME STARTTWAMP STOPTWAMP"
      }
    ],
    "description": "Stops one or more TWAMP (Two-Way Active Measurement Protocol) sessions by calling the `stop_session` method on each provided session object. The function supports both single session objects and collections of sessions, and forwards optional keyword arguments to the `stop_session` method of each session. It ensures proper session termination and returns a boolean indicating success or failure of the operation.",
    "example": "| Twamp Stop Session | Sessions=${Sessions} | TestSessions=${TestSessions} | ControlType=STOPTWAMP |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_request_session",
    "return_type": "bool",
    "return": "Returns True if the session request operation is successfully initiated for all provided sessions. If any error occurs during the process, it raises a ContinuableFailure and returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or object",
        "description": "A list of TWAMP session objects or a single session object for which test sessions are requested. Internally converted to a list for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TestSessions",
        "type": "TwampTestSessionConfig",
        "description": "The configuration or object defining parameters for the requested TWAMP test session.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ControlType",
        "type": "str",
        "description": "Operation type for controlling the TWAMP session. Default value is 'REQUEST'.",
        "default": "REQUEST",
        "range_or_options": "REQUEST START STOP PAUSE RESUME STARTTWAMP STOPTWAMP"
      }
    ],
    "description": "Initiates a TWAMP (Two-Way Active Measurement Protocol) session request for the provided session objects. This function ensures that each session in the 'Sessions' collection is used to request a corresponding test session using the provided 'TestSessions' parameter and any additional keyword arguments. It typically works as part of a larger framework for initiating, managing, and controlling TWAMP-based network performance tests.",
    "example": ".. code:: RobotFramework\n\n    | Twamp Request Session | Sessions=${Sessions} | TestSessions=${TestSessions} | ControlType=STOPTWAMP |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_pause_session",
    "return_type": "bool",
    "return": "Returns True if all sessions were successfully paused, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Twamp or iterable of Twamp",
        "description": "A single session object or an iterable (e.g., list, set, tuple) of TWAMP session objects to be paused.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TestSessions",
        "type": "TwampTestSessionConfig",
        "description": "The test session configuration associated with the TWAMP sessions being paused. This is used to identify or control specific test instances related to the sessions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ControlType",
        "type": "str",
        "description": "Specifies the operation type for controlling the TWAMP session. Default is 'REQUEST'.",
        "default": "REQUEST",
        "range_or_options": "REQUEST START STOP PAUSE RESUME STARTTWAMP STOPTWAMP"
      }
    ],
    "description": "Pauses one or more TWAMP (Two-Way Active Measurement Protocol) sessions by calling their respective `pause_session` method with the provided test sessions and additional keyword arguments. The function accepts a single session or a collection of sessions and ensures uniform handling by treating them as an iterable. It returns True if the pause operation was successfully initiated for all specified sessions, and raises a ContinuableFailure exception if it fails.",
    "example": "| Twamp Pause Session | Sessions=${Sessions} | TestSessions=${TestSessions} | ControlType=PAUSE |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.twamp_resume_session",
    "return_type": "bool",
    "return": "Returns True if all specified TWAMP sessions are successfully resumed, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, set, tuple]",
        "description": "A single session object or a collection of session objects that need to be resumed. Internally, it is treated as a list even if a single session is provided.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TestSessions",
        "type": "object",
        "description": "The test sessions associated with the TWAMP sessions, typically used to reference or control specific test instances during resumption.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ControlType",
        "type": "str",
        "description": "Operate type for controlling the session behavior. Used to specify the operation to perform along with resuming.",
        "default": "REQUEST",
        "range_or_options": "REQUEST START STOP PAUSE RESUME STARTTWAMP STOPTWAMP"
      }
    ],
    "description": "Resumes one or more TWAMP (Two-Way Active Measurement Protocol) sessions. This function accepts a single session or a collection of sessions and resumes each of them using the provided TestSessions and any additional keyword arguments. It ensures consistent handling of both single and multiple session inputs by converting single sessions into a list internally.",
    "example": "| Twamp Resume Session | Sessions=${Sessions} | TestSessions=${TestSessions} | ControlType=RESUME |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for TWAMP client sessions. If one session matches, returns a dictionary of requested stats; if multiple sessions match, returns a pandas DataFrame with rows per session and columns per stat item. Returns False if no data is found.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list or set or tuple or None",
        "description": "Specifies the session(s) for which to retrieve TWAMP client statistics. Each session object must have a 'Name' attribute. If None, statistics are retrieved for all available sessions.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from the 'TwampClientStats' data. Available options include: State, RxAcceptSession, RxFailedSession, RxStartAck, TxRequestSession, TxStartSession, TxStopSession.",
        "default": "None",
        "range_or_options": "State RxAcceptSession RxFailedSession RxStartAck TxRequestSession TxStartSession TxStopSession"
      }
    ],
    "kwargs": [],
    "description": "Retrieves TWAMP client statistics for specified session(s). Internally calls `_get_statictis` with statistic type 'TwampClientStats'.",
    "example": "Example usage in RobotFramework:\n| Get Twamp Client Statistic | Session=${Session} | StaItems=@{StaItems} |\nWhere ${Session} is a valid session object and @{StaItems} contains desired statistical items."
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_server_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical data for TWAMP server sessions. If exactly one matching row is found, returns a dictionary mapping statistical items to their values. If multiple rows are found, returns a pandas DataFrame containing the filtered statistics. If no matching result is found, returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or list or set or tuple or None",
        "description": "Session objects representing TWAMP server sessions. If None, no session filtering is applied. If a list, set, or tuple, it should contain session objects whose names will be used as identifiers. A single object can also be provided, and its name will be used as the identifier.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items (columns) to retrieve from 'TwampServerStats'. Valid options include: State, RxRequestSession, RxStartSession, RxStopSession, TxAcceptSession, TxFailedSession, TxStartAck. If None, all available properties are queried. If a string is provided, it will be converted into a list containing that string.",
        "default": "None",
        "range_or_options": "State RxRequestSession RxStartSession RxStopSession TxAcceptSession TxFailedSession TxStartAck"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves TWAMP (Two-Way Active Measurement Protocol) server statistics based on provided session handles and statistical items. It wraps an internal method to fetch statistics specifically for 'TwampServerStats', supporting both single and multiple session inputs by extracting their names. The function ensures data consistency through internal commands and delays during pagination navigation.",
    "example": ".. code:: RobotFramework\n\n    | Get Twamp Server Statistic | Session=${Session} | StaItems=@{StaItems} |\n\nExample usage in Python:\n>>> api = RenixAPI()\n>>> session1 = api.create_twamp_session(...)\n>>> stats = api.get_twamp_server_statistic(Sessions=[session1], StaItems=['Latency', 'Jitter'])"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_port_client_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of statistics if one matching row is found, a DataFrame for multiple rows, or False if no data matches the query.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list or set or tuple or object or None",
        "description": "The port(s) to retrieve statistics for. If None, stats may be retrieved across all ports. Port objects are converted into their 'Name' attributes (PortHandles).",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies which statistical items to retrieve. If None, all available properties are queried. If a string, it will be treated as a single-item list.",
        "default": "None",
        "range_or_options": "RxAcceptSession RxFailedSession RxStartAck TxRequestSession TxStartSession TxStopSession"
      }
    ],
    "kwargs": [],
    "description": "Retrieves TWAMP (Two-Way Active Measurement Protocol) client-side statistics for specified port(s). This function internally calls `_get_statictis` with statistic type 'TwampPortClientStats', and formats the port identifiers appropriately.",
    "example": ">>> api.get_twamp_port_client_statistic(Ports=[port1, port2], StaItems=['SentPackets', 'ReceivedPackets'])"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_port_server_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics related to TWAMP port server for specified ports and items. If one matching row is found, returns a dictionary; if multiple rows match, returns a pandas DataFrame; if no match, returns False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "object or list/set/tuple of objects (optional)",
        "description": "A single port object or collection of port objects for which TWAMP server statistics are retrieved. Each port must have a 'Name' attribute. If not provided, statistics may include all available ports.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str (optional)",
        "description": "Specifies the statistical items (columns) to retrieve from TWAMP port server statistics. Supported values include RxRequestSession, RxStartSession, RxStopSession, TxAcceptSession, TxFailedSession, TxStartAck. If None, defaults to querying all available properties.",
        "default": "None",
        "range_or_options": "RxRequestSession RxStartSession RxStopSession TxAcceptSession TxFailedSession TxStartAck"
      }
    ],
    "description": "This function retrieves TWAMP port server statistics by calling the internal `_get_statictis` method. It allows filtering by specific ports and selecting which statistical items to return. Internally, it may refresh data via `.get()` calls, execute navigation commands for paginated results, and log resulting DataFrames for debugging.",
    "example": ".. code:: RobotFramework\n\n    | Get Twamp Port Server Statistic | Ports=${Ports} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_test_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistical values for the TWAMP test sessions. If one session matches, returns a dictionary with keys as requested statistics and values as measured results. If multiple sessions match, returns a pandas DataFrame. Returns False if no matching session is found.",
    "parameters": [
      {
        "name": "Twamps",
        "type": "object or list or set or tuple of objects or None, optional",
        "description": "Specifies the TWAMP session(s) for which statistics are to be retrieved. If None, statistics may be fetched broadly. If an object, its Name attribute is used as the session identifier. If a collection, it extracts the Name attribute from each object to form a list of session IDs.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve for the TWAMP sessions. Supported items include AverageJitter, AverageLatency, AverageServerProcessingTime, MaximumJitter, MaximumLatency, MaximumServerProcessingTime, MinimumJitter, MinimumLatency, MinimumServerProcessingTime. If None, all available properties are queried. If a string, it is converted into a single-item list.",
        "default": "None",
        "range_or_options": "AverageJitter AverageLatency AverageServerProcessingTime MaximumJitter MaximumLatency MaximumServerProcessingTime MinimumJitter MinimumLatency MinimumServerProcessingTime"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for TWAMP (Two-Way Active Measurement Protocol) test sessions. This function acts as a wrapper around the internal `_get_statictis` method, specifically tailored to fetch statistics related to TWAMP test sessions. It processes the input session identifiers and delegates the actual statistic retrieval to the more general-purpose method with appropriate parameters.",
    "example": ".. code:: RobotFramework\n\n    | Get Twamp Test Session Statistic | Twamps=${Twamps} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_port_test_session_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary of TWAMP port test session statistics if one row matches, a pandas DataFrame for multiple rows, or False if no matching result is found.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list, set, tuple, or object (optional)",
        "description": "A collection of port objects or a single port object for which TWAMP session statistics should be retrieved. Each port object must have a `Name` attribute used as an identifier. If None, no specific port filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str (optional)",
        "description": "Specifies which statistical items to retrieve. If a string is provided, it is treated as a single-item list. If None, all available statistical items are retrieved.",
        "default": "not_found",
        "range_or_options": "AverageJitter AverageLatency AverageServerProcessingTime MaximumJitter MaximumLatency MaximumServerProcessingTime MinimumJitter MinimumLatency MinimumServerProcessingTime"
      }
    ],
    "kwargs": [],
    "description": "Retrieves TWAMP (Two-Way Active Measurement Protocol) port test session statistics by calling the internal `_get_statictis` method. It supports retrieving data for one or more ports and allows specifying which statistical items to include in the result. If no ports are provided, it defaults to gathering statistics without filtering by port.",
    "example": ".. code:: RobotFramework\n\n    | Get Twamp Port Test Session Statistic | Ports=${Ports} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.twamp.get_twamp_state_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary, pandas DataFrame, or boolean depending on the result of the query. If one row matches, returns a dict with keys as StaItems. If multiple rows match, returns a DataFrame. If no results are found, returns False.",
    "parameters": [
      {
        "name": "Ports",
        "type": "list/set/tuple of Port objects or a single Port object (optional)",
        "description": "Specifies the port(s) for which to retrieve TWAMP state statistics. If None, no filtering by port is applied. If a list, set, or tuple is provided, it extracts the names of the ports to use as identifiers. If a single Port object is provided, its name is used as the identifier.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None (optional)",
        "description": "Specifies which statistical items (columns) to retrieve from the 'TwampStateStats' data. If None, all available properties are queried. If a string is provided, it is treated as a single-item list. The provided items must be a subset of the available properties in the 'TwampStateStats' statistic class.",
        "default": "None",
        "range_or_options": "Connect Established Idle SessionRequested ConnectionsDown ConnectionsUp"
      }
    ],
    "description": "Retrieves TWAMP (Two-Way Active Measurement Protocol) state statistics for specified ports. This function is a wrapper around `_get_statictis` and is specifically configured to fetch 'TwampStateStats' type statistics. It supports retrieving data for one or more ports and allows filtering of the returned statistical items.",
    "example": ".. code:: RobotFramework\n\n    | Get Twamp State Statistic | Ports=${Ports} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.create_vxlan",
    "return_type": "Vxlan",
    "return": "The newly created and configured Vxlan protocol object, associated with the given port.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "The parent or upper-layer object (typically a test instrument port) to which this VXLAN instance will be associated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the VXLAN session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enable or disable the VXLAN protocol session.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoUdpSourcePort",
        "type": "bool",
        "description": "Automatically calculate the UDP source port.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "UdpSourcePort",
        "type": "int",
        "description": "Manually configure the UDP source port number.",
        "default": "1025",
        "range_or_options": "3-4095"
      },
      {
        "name": "EnableUdpChecksum",
        "type": "bool",
        "description": "Enable calculation of UDP checksum.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EvpnLearning",
        "type": "bool",
        "description": "Enable EVPN (Ethernet Virtual Private Network) learning for MAC/IP address discovery.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OvsdbLearning",
        "type": "bool",
        "description": "Enable OVSDB (Open vSwitch Database) learning for integration with SDN controllers.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MulticastType",
        "type": "str",
        "description": "Specifies the multicast protocol type used in the network.",
        "default": "IGMP",
        "range_or_options": "IGMP PIM MLD"
      },
      {
        "name": "VtepTunnelIp",
        "type": "str",
        "description": "Specifies the IP address type used by the VTEP (VXLAN Tunnel End Point).",
        "default": "INTERFACEIP",
        "range_or_options": "INTERFACEIP ROUTERID"
      },
      {
        "name": "EnableIrb",
        "type": "bool",
        "description": "Enable Integrated Routing and Bridging (IRB) functionality.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RPAddress",
        "type": "str",
        "description": "Configure the RP (Rendezvous Point) IPv4 address for PIM protocol.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RPIpv6Address",
        "type": "str",
        "description": "Configure the RP IPv6 address for PIM protocol.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "IrbMode",
        "type": "str",
        "description": "Set the IRB mode for routing and bridging behavior.",
        "default": "Symmetric",
        "range_or_options": "Symmetric"
      }
    ],
    "description": "This function creates and configures a new VXLAN protocol session associated with a specified port. It allows extensive configuration through keyword arguments, enabling users to customize tunneling, multicast behavior, UDP settings, and more. Internally, it registers the created VXLAN object in a global mapping using its handle for future reference.",
    "example": "| Create Vxlan | Port=${Port} | Name=MyVXLAN | Enable=True | UdpSourcePort=2000 | MulticastType=PIM | RPAddress=192.168.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.edit_vxlan",
    "return_type": ":obj:`Vxlan`",
    "return": "The updated Vxlan protocol session object.",
    "description": "Updates attributes of a provided VxLAN session object using the specified keyword arguments. This function allows dynamic configuration or modification of various VxLAN session parameters such as enabling/disabling the session, setting UDP source port, configuring multicast type, RP addresses, and more.",
    "parameters": [
      {
        "name": "Session",
        "type": ":obj:`Vxlan`",
        "description": "The VxLAN session object whose attributes are to be updated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "Name of the VxLAN session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables or disables the VxLAN session.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoUdpSourcePort",
        "type": "bool",
        "description": "Automatically calculates the UDP source port.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "UdpSourcePort",
        "type": "int",
        "description": "Sets the UDP source port value.",
        "default": "1025",
        "range_or_options": "3-4095"
      },
      {
        "name": "EnableUdpChecksum",
        "type": "bool",
        "description": "Enables calculation of UDP checksum.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EvpnLearning",
        "type": "bool",
        "description": "Enables EVPN (Ethernet Virtual Private Network) learning.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "OvsdbLearning",
        "type": "bool",
        "description": "Enables OVSDB (Open vSwitch Database) learning.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MulticastType",
        "type": "str",
        "description": "Specifies the multicast type for the session.",
        "default": "IGMP",
        "range_or_options": "IGMP PIM MLD"
      },
      {
        "name": "VtepTunnelIp",
        "type": "str",
        "description": "Sets the VTEP tunnel IP address selection method.",
        "default": "INTERFACEIP",
        "range_or_options": "INTERFACEIP ROUTERID"
      },
      {
        "name": "EnableIrb",
        "type": "bool",
        "description": "Enables Integrated Routing and Bridging (IRB).",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RPAddress",
        "type": "str",
        "description": "Sets the IPv4 RP (Rendezvous Point) address for PIM.",
        "default": "192.0.0.1",
        "range_or_options": "IPv4 address"
      },
      {
        "name": "RPIpv6Address",
        "type": "str",
        "description": "Sets the IPv6 RP address for PIM.",
        "default": "2000::1",
        "range_or_options": "IPv6 address"
      },
      {
        "name": "IrbMode",
        "type": "str",
        "description": "Sets the IRB mode for routing and bridging.",
        "default": "Symmetric",
        "range_or_options": "Symmetric"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Create Vxlan | Port=${Port} |",
    "note": "Only existing attributes of the Session object will be updated; new attributes cannot be added using this method."
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.create_vxlan_segment",
    "return_type": "VxlanSegmentConfig",
    "return": "A configured VXLAN segment object that can be further used or integrated into a larger configuration structure.",
    "parameters": [],
    "kwargs": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name of the VXLAN session.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable",
        "type": "bool",
        "description": "Enables the VXLAN protocol session.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "StartVni",
        "type": "int",
        "description": "Starting VNI value.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "VniCount",
        "type": "int",
        "description": "Number of VNIs to create.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "VniStep",
        "type": "int",
        "description": "Step increment for VNI assignment.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "CommunicationType",
        "type": "str",
        "description": "Learning method for the VXLAN session.",
        "default": "UNICAST",
        "range_or_options": "UNICAST MULTICAST VxlanEVPN"
      },
      {
        "name": "VniDistributionType",
        "type": "str",
        "description": "Distribution method of VNIs across VPNs.",
        "default": "ROUNDROBIN",
        "range_or_options": "ROUNDROBIN LINEAR"
      },
      {
        "name": "EnableL3Vni",
        "type": "bool",
        "description": "Enables Layer 3 VXLAN (L3VNI).",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "StartL3Vni",
        "type": "int",
        "description": "Starting L3VNI value.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "L3VniStep",
        "type": "int",
        "description": "Step increment for L3VNI assignment.",
        "default": "1",
        "range_or_options": "1-16777215"
      },
      {
        "name": "L3VniCount",
        "type": "int",
        "description": "Number of L3VNIs to create.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "VniTrafficType",
        "type": "str",
        "description": "Specifies the endpoint mode for VXLAN traffic.",
        "default": "L2VNI",
        "range_or_options": "L2VNI L3VNI L2AndL3VNI"
      },
      {
        "name": "EnableVmArp",
        "type": "bool",
        "description": "Enables VM ARP feature.",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and configures a new VXLAN segment with optional custom settings. It wraps around an internal VXLAN creation method, allowing users to define various parameters such as VNI ranges, communication type, distribution methods, and more. The created VXLAN segment is returned as a configurable object for further use.",
    "example": "| Create Vxlan Segment | Port=${Port} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.binding_vxlan_multicast_group",
    "return_type": "bool",
    "return": "布尔值，表示绑定操作是否成功（范围：True / False）",
    "parameters": [
      {
        "name": "Segments",
        "type": "VxlanSegmentConfig or list of VxlanSegmentConfig",
        "description": "要绑定的 VXLAN Segment 对象或对象列表。每个对象必须包含 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MulticastGroups",
        "type": "Ipv4MulticastGroup or list of Ipv4MulticastGroup",
        "description": "要绑定的组播组对象或对象列表。每个对象必须包含 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于将一个或多个 VXLAN Segment 绑定到指定的组播组上。它是一个封装了底层 `Vxlan.binding_multicast_group` 方法的接口，支持传入单个对象或对象列表形式的 VXLAN Segment 和组播组，并在内部统一转换为列表格式后执行绑定操作。",
    "example": ".. code:: RobotFramework\n\n    | Binding Vxlan Multicast Group | Segments=${Segments} | MulticastGroups=${MulticastGroups} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.binding_vxlan_vm",
    "return_type": "bool",
    "return": "True if the binding was executed successfully, False otherwise.",
    "parameters": [
      {
        "name": "Segments",
        "type": "object or list of objects",
        "description": "A single VXLAN segment object or a list of VXLAN segment objects. Each object must have a 'handle' attribute representing the unique identifier of the VXLAN segment.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Interfaces",
        "type": "object or list of objects",
        "description": "A single interface/VM object or a list of interface/VM objects. Each object must have a 'handle' attribute representing the unique identifier of the VM or interface.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Binds virtual machines (VMs) or interfaces to VXLAN segments by associating each interface with a corresponding VXLAN segment. This function ensures that the provided `Segments` and `Interfaces` are in list format and then delegates the actual binding operation to the backend method. It is typically used in network testing scenarios to establish VXLAN-based connectivity between VMs and specific VXLAN segments.",
    "example": "| Binding Vxlan Vm | Segments=${Segments} | Interfaces=${Interfaces} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.binding_vxlan_vtep",
    "return_type": "bool",
    "return": "Returns True if the binding operation was executed successfully, otherwise False.",
    "parameters": [
      {
        "name": "Vteps",
        "type": "list (:obj:`Vxlan`)",
        "description": "A list of Vxlan protocol session objects representing VXLAN Tunnel End Points (VTEPs). Each object must have a unique identifier (handle) for system recognition. If a single object is provided, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Interfaces",
        "type": "list (:obj:`Interface`)",
        "description": "A list of Interface objects representing VM Interfaces to which the VTEPs will be bound. Each object must have a unique identifier (handle) for system recognition. If a single object is provided, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Binds the specified VXLAN Tunnel End Points (VTEPs) to the given VXLAN interfaces. This function ensures that both inputs are in list format before delegating the binding operation to the underlying class method. It is typically used during test automation scenarios involving VXLAN protocol setup or validation. If the operation fails, a ContinuableFailure exception is raised with an appropriate message indicating failure in execution.",
    "example": "| Binding Vxlan Vtep | Vteps=${Vxlan} | Interfaces=${Interfaces} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.start_vxlan_ping",
    "return_type": "bool",
    "return": "Returns True if the ping operation was successfully initiated on all specified interfaces, otherwise returns False.",
    "parameters": [
      {
        "name": "Interfaces",
        "type": "list of Interface objects or single Interface object",
        "description": "The VXLAN interface(s) on which to start the ping operation. Each Interface object must have a 'handle' attribute that uniquely identifies the interface in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "FrameCount",
        "type": "int",
        "description": "Number of ping frames to send per interface. Used to control how many echo requests are sent during the ping operation.",
        "default": "1",
        "range_or_options": "1-1000"
      },
      {
        "name": "TimeInterval",
        "type": "int",
        "description": "Time interval (in seconds) between sending consecutive ping frames. Used to control the rate at which ping frames are transmitted.",
        "default": "1",
        "range_or_options": "1-10"
      }
    ],
    "description": "启动VXLAN Ping操作，用于在指定的VXLAN接口上发起ICMP Echo Request以测试网络连通性。该函数封装了底层 :meth:`RenixLibrary.protocol.vxlan.Vxlan.start_ping` 方法，并支持通过关键字参数配置帧数量和时间间隔。",
    "example": "| Start Vxlan Ping | Interfaces=${Interface} | FrameCount=5 | TimeInterval=2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.stop_vxlan_ping",
    "return_type": "bool",
    "return": "Returns True if the ping operation was successfully stopped on all specified interfaces. If the operation fails, it may raise an exception or return False.",
    "parameters": [
      {
        "name": "Interfaces",
        "type": "Interface or list of Interface",
        "description": "A single interface object or a list of interface objects representing the VXLAN interfaces where the ongoing ping operation should be stopped. Each interface must have a `handle` attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "FrameCount",
        "type": "int",
        "description": "Specifies the number of ping frames to send before stopping. This is passed to the underlying command constructor for customization.",
        "default": "1",
        "range_or_options": "1-1000"
      },
      {
        "name": "TimeInterval",
        "type": "int",
        "description": "The interval (in seconds) between successive ping frame transmissions. It allows tuning the behavior of the ping stop command.",
        "default": "1",
        "range_or_options": "1-10"
      }
    ],
    "description": "This function stops an ongoing VXLAN ping operation on the specified interfaces. It ensures uniform handling by converting a single interface into a list if necessary and delegates the actual stopping logic to the backend method `Vxlan.stop_ping`. The function returns True upon successful termination of the ping process across all provided interfaces, otherwise it may raise an exception or return False depending on the execution outcome.",
    "example": ".. code:: RobotFramework\n\n    | Stop Vxlan Ping | Interfaces=${Interface} | FrameCount=5 | TimeInterval=2"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.get_vxlan_vm_property",
    "return_type": "object",
    "return": "The first child of the Interface with type 'VxlanVmProperty'.",
    "parameters": [
      {
        "name": "Interface",
        "type": "object or list",
        "description": "The interface or a list containing the interface for which the VxlanVmProperty is to be retrieved. If a list is provided, only the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the VxlanVmProperty associated with the given Interface. This function checks if the provided Interface is a list. If it is, it uses the first element of the list. It then retrieves the first child object of type 'VxlanVmProperty' from the Interface and returns it.",
    "example": "| ${Vm} | Get Vxlan Vm Property | Interface=${Interface} |\n| Edit Configs | ${Vm} | OverrideAttachedVtepIp=True | AttachedVtepAddr=3.3.3.3 | AttachedIp6VtepAddr=2022::2 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.get_vxlan_vm_point",
    "return_type": "object",
    "return": "The IPv4 layer (Ipv4Layer) object associated with the VM interface connected to the given VXLAN.",
    "parameters": [
      {
        "name": "Vxlan",
        "type": "object",
        "description": "A VXLAN object for which the associated VM interface's IPv4 layer is to be retrieved. This object must have a valid session and be properly configured in the test environment.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the IPv4 layer associated with the VM interface linked to the specified VXLAN object. This function finds the VM interface related to the given VXLAN by checking its target relationships, then returns the first IPv4 layer configured on that interface.",
    "example": "| Get Vxlan Vm Point | Vxlan=${Vxlan} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.get_vxlan_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to `StaItems` if one matching row is found, a pandas DataFrame if multiple rows are found, or False if no result is found.",
    "parameters": [
      {
        "name": "Session",
        "type": "object or list or set or tuple or None",
        "description": "The session or collection of sessions for which to retrieve VXLAN statistics. Each session must have a `Name` attribute. If None, no specific session filtering is applied.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies the statistical items (columns) to retrieve. If None, all available properties are queried. If a string, it is converted into a list. Must be a subset of available properties such as VtepId, VtepState, TotalVmCount, ResolvedVmCount, UnresolvedVmCount.",
        "default": "None",
        "range_or_options": "VtepId VtepState TotalVmCount ResolvedVmCount UnresolvedVmCount"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves VXLAN binding statistics for specified session(s), optionally filtered by statistical items and mode. It wraps an internal method `_get_statictis()` to fetch 'VxlanBindingStats' type statistics. The function supports retrieving statistics for single or multiple sessions, where a session can be represented as a single object, a list, set, or tuple of objects. Internally, it extracts session identifiers and delegates statistic retrieval logic.",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start Protocol |\n    | Sleep | 10 |\n    | Stop Protocol |\n    | Sleep | 3 |\n    | ${Port} | Get Ports |\n    | ${Session} | Get Session | Ports=@{Port} | Protocols=vxlan |\n    | ${StaItems} | Create List | TotalVmCount | ResolvedVmCount |\n    | &{Result} | Get Vxlan Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.vxlan.wait_vxlan_state",
    "return_type": "bool",
    "return": "Returns True if the VXLAN sessions reach the specified state within the timeout; otherwise returns False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Vxlan objects",
        "description": "A list of VXLAN protocol session objects to monitor for state changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that the VXLAN sessions are expected to reach. Supported values are STARTED and STOPPED.",
        "default": "'STARTED'",
        "range_or_options": "STARTED STOPPED"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "The time interval in seconds between consecutive checks of the session states.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "The maximum time in seconds to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits for one or more VXLAN protocol sessions to reach a specified state (such as STARTED or STOPPED) within a given timeout period. The function periodically checks the session states at defined intervals and returns once all sessions have reached the desired state or the timeout is exceeded. If the sessions fail to reach the desired state within the timeout, the function may raise an exception depending on backend behavior.",
    "example": "| Wait Vxlan State | Sessions=${Sessions} | State=STARTED | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731",
    "return_type": "Y1731",
    "return": "The newly created and configured Y1731 protocol session object.",
    "parameters": [
      {
        "name": "Port",
        "type": "object",
        "description": "测试仪表端口对象，作为该Y1731协议会话的上层（父对象）。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NextHop",
        "type": "str",
        "description": "指定下一跳的目标。默认值为 'DUT'。",
        "default": "DUT",
        "range_or_options": "DUT Interface_X"
      },
      {
        "name": "其他可选参数",
        "type": "任意类型",
        "description": "用于配置Y1731会话对象的其他属性。仅限于Y1731对象支持的属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "创建并配置一个与指定端口关联的Y1731协议会话对象。此函数初始化一个新的Y1731协议配置对象，并使用提供的端口作为其上层（父对象）。它还允许通过关键字参数对Y1731会话进行自定义配置。创建成功后，该会话将被注册到全局协议对象映射中（map_protocol_object），以便后续引用和管理。通常用于设置涉及Y1731服务或诊断的测试场景。",
    "example": "| Create Y1731 | Port=${Port} | NextHop=Interface_1 | DADTransmitCount=255 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.wait_y1731_state",
    "return_type": "bool",
    "return": "Returns True if all Y.1731 sessions reach the expected state within the timeout period; otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731",
        "description": "A list of Y.1731 protocol session objects to monitor for reaching a specified state.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str",
        "description": "The target state that each session must reach. If not provided, defaults to 'RUNNING'. Supported states: DISABLED, IDLE, RUNNING.",
        "default": "'RUNNING'",
        "range_or_options": "DISABLED IDLE RUNNING"
      },
      {
        "name": "Interval",
        "type": "int",
        "description": "Time interval (in seconds) between consecutive checks for session state updates.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeOut",
        "type": "int",
        "description": "Maximum time (in seconds) to wait for all sessions to reach the desired state.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function waits until all provided Y.1731 protocol session objects reach the specified state or until the timeout is reached. The function polls the state of each session at regular intervals. If the timeout occurs before all sessions reach the desired state, it returns False and raises a failure exception. This function wraps an internal `_wait_state` mechanism used for polling logic.",
    "example": "| Wait Y1731 State | Sessions=${Sessions} | State=IDLE | Interval=2 | TimeOut=120 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.edit_y1731_port_config",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功应用。",
    "parameters": [
      {
        "name": "Ports",
        "type": "object",
        "description": "测试仪表端口对象。可以是单个端口对象或多个端口对象的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MulticastClass1DaMac",
        "type": "str",
        "description": "第一类组播MAC地址。",
        "default": "01:80:c2:00:00:30",
        "range_or_options": "有效的MAC地址格式（如：00:00:00:00:00:00 ~ ff:ff:ff:ff:ff:ff）"
      },
      {
        "name": "MulticastClass2DaMac",
        "type": "str",
        "description": "第二类组播MAC地址。",
        "default": "01:80:c2:00:00:38",
        "range_or_options": "有效的MAC地址格式（如：00:00:00:00:00:00 ~ ff:ff:ff:ff:ff:ff）"
      },
      {
        "name": "EncodeMdOrMeLevel",
        "type": "bool",
        "description": "是否在组播MAC地址中包含MD/ME等级信息。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "DisableCCRcv",
        "type": "bool",
        "description": "是否在该端口上忽略接收CCM消息。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TlvsInDmr",
        "type": "bool",
        "description": "是否在DMR应答消息中包含TLV选项。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "TlvsInLmr",
        "type": "bool",
        "description": "是否在LMR应答消息中包含TLV选项。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "description": "此函数用于修改一个或多个指定端口的Y.1731协议端口配置。它接受端口对象和一组可选的关键字参数来配置特定的Y.1731属性。配置通过调用底层API完成，并返回布尔值指示操作是否成功。",
    "example": ".. code:: RobotFramework\n\n    | Edit Y1731 Port Config | Ports=${Ports} | MulticastClass1DaMac=01:80:c2:00:00:31 | EncodeMdOrMeLevel=False"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.edit_y1731_global_option",
    "return_type": "bool",
    "return": "A boolean value indicating the success or failure of the operation. Returns `True` if the configuration was successfully updated, otherwise `False`.",
    "parameters": [],
    "kwargs": [
      {
        "name": "TestModeType",
        "type": "str",
        "description": "Specifies the test mode for Y.1731 protocol testing.",
        "default": "TYPE_NORMAL",
        "range_or_options": "TYPE_NORMAL TYPE_CC_SCALE_MODE TYPE_CC_SCALE_MODE_WITHOUT_RX"
      },
      {
        "name": "LmrRxFCfStart",
        "type": "int",
        "description": "Initial value of the Loss Measurement Response received frame count forwarding.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrRxFCfStep",
        "type": "int",
        "description": "Increment value for received frame count in subsequent steps in Step mode.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrTxFCbStart",
        "type": "int",
        "description": "Initial value of the Loss Measurement Response sent frame count forwarding.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrTxFCbStep",
        "type": "int",
        "description": "Increment value for sent frame count in subsequent steps in Step mode.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmmTxFCfOffset",
        "type": "int",
        "description": "TLV offset for the LMM (Loss Measurement Message) sent frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrRxFCfOffset",
        "type": "int",
        "description": "TLV offset for the LMR (Loss Measurement Response) received frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrTxFCbOffset",
        "type": "int",
        "description": "TLV offset for the LMR (Loss Measurement Response) sent frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "DmTimeUnit",
        "type": "str",
        "description": "Sets the unit of measure for delay measurement.",
        "default": "TIME_MS",
        "range_or_options": "TIME_MS TIME_NS"
      }
    ],
    "description": "This function modifies the global Y.1731 protocol configuration parameters used across the system. It allows updating a subset or all of the configurable options related to performance monitoring and measurement behaviors such as loss measurement and delay measurement units. The function internally calls the backend API which applies these changes to the first 'Y1731Option' child object found in the system configuration. If no arguments are provided, it will not make any changes but still return True.",
    "example": "| Edit Y1731 Global Option | DmTimeUnit=TIME_NS |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_meg",
    "return_type": "Y1731MegConfig",
    "return": "A configured instance of the Y1731MegConfig class representing the created MEG with applied settings.",
    "parameters": [],
    "kwargs": [
      {
        "name": "OperationMode",
        "type": "str",
        "description": "Specifies the operation mode for the Y.1731 MEG, either ITU-T or IEEE standard.",
        "default": "ITU_T",
        "range_or_options": "ITU_T IEEE"
      },
      {
        "name": "MdOrMeLevel",
        "type": "str",
        "description": "Sets the Maintenance Domain (MD) or Maintenance Entity (ME) level in the hierarchy.",
        "default": "LEVEL1",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "CcPeriod",
        "type": "str",
        "description": "Defines the period for Continuity Check Messages (CCM).",
        "default": "CCM_1S",
        "range_or_options": "CCM_3MS CCM_10MS CCM_100MS CCM_1S CCM_10S CCM_1MIN CCM_10MIN"
      },
      {
        "name": "LckPeriod",
        "type": "str",
        "description": "Specifies the Lock Alarm indication message interval.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "AisPeriod",
        "type": "str",
        "description": "Determines the interval for AIS (Alarm Indication Signal) messages.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "CcPriority",
        "type": "str",
        "description": "Priority level for Continuity Check (CC) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "LbPriority",
        "type": "str",
        "description": "Priority level for Loopback (LB) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "LtPriority",
        "type": "str",
        "description": "Priority level for Link Trace (LT) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "AisPriority",
        "type": "str",
        "description": "Priority level for Alarm Indication Signal (AIS) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "LckPriority",
        "type": "str",
        "description": "Priority level for LCK (Lock) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "DmPriority",
        "type": "str",
        "description": "Priority level for Delay Measurement (DM) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "DmmPriority",
        "type": "str",
        "description": "Priority level for Delay Measurement Message (DMM) packets.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "LmPriority",
        "type": "str",
        "description": "Priority level for Loss Measurement (LM) messages.",
        "default": "LEVEL0",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "DomainIdType",
        "type": "str",
        "description": "(IEEE Mode Only) Type of Domain ID used to identify the domain.",
        "default": "NO_DOMAIN",
        "range_or_options": "NO_DOMAIN DNS_LIKE_NAME MAC_ADDRESS_2OCTETS CHARACTER_STRING"
      },
      {
        "name": "DnsLikeName",
        "type": "str",
        "description": "(IEEE Mode & DNS_LIKE_NAME) Specifies a DNS-like name for the domain ID.",
        "default": "xinertel.com",
        "range_or_options": "string of length 1-43"
      },
      {
        "name": "MacAnd2Octets",
        "type": "str",
        "description": "(IEEE Mode & MAC_ADDRESS_2OCTETS) Defines a MAC address followed by two octets.",
        "default": "00-00-00-00-00-00:0000",
        "range_or_options": "string matching pattern ^[A-Fa-f0-9]{2}([-]?[A-Fa-f0-9]{2}){5}[:][A-Fa-f0-9]{4}$"
      },
      {
        "name": "CharacterStringDmId",
        "type": "str",
        "description": "(IEEE Mode & CHARACTER_STRING) Character string for domain ID.",
        "default": "Domain",
        "range_or_options": "string of length 1-43"
      },
      {
        "name": "MaIdType",
        "type": "str",
        "description": "(IEEE Mode) Type of Maintenance Association (MA) ID.",
        "default": "CHARACTER_STRING",
        "range_or_options": "PRIMARY_VID CHARACTER_STRING TWO_OCTET_INTEGER RFC_2685_VPN_ID"
      },
      {
        "name": "PrimaryVid",
        "type": "int",
        "description": "(IEEE Mode & PRIMARY_VID) Primary VLAN ID associated with MA.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "CharacterStringMaId",
        "type": "str",
        "description": "(IEEE Mode & CHARACTER_STRING) Character string representing MA ID.",
        "default": "MA_1",
        "range_or_options": "string of length 1-43"
      },
      {
        "name": "TwoOctet",
        "type": "str",
        "description": "(IEEE Mode & TWO_OCTET_INTEGER) Two-octet integer representation of MA ID.",
        "default": "0000",
        "range_or_options": "string matching pattern ^[A-Fa-f0-9]{4}$"
      },
      {
        "name": "Rfc2685VpnId",
        "type": "str",
        "description": "(IEEE Mode & RFC_2685_VPN_ID) RFC 2685 VPN ID format for MA ID.",
        "default": "00-00-00:00-00-00-00",
        "range_or_options": "string matching pattern ^[A-Fa-f0-9]{2}([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})[:]([A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})$"
      },
      {
        "name": "MegIdType",
        "type": "str",
        "description": "(ITU-T Mode) Type of MEG ID used in ITU-T mode.",
        "default": "CHARACTER_STRING",
        "range_or_options": "PRIMARY_VID CHARACTER_STRING TWO_OCTET_INTEGER RFC_2685_VPN_ID ICC_BASED CC_AND_ICC_BASED"
      },
      {
        "name": "IccFormatedString",
        "type": "str",
        "description": "(ITU-T Mode & ICC_BASED/CC_AND_ICC_BASED) ICC-formatted string for MEG ID.",
        "default": "MEG_1",
        "range_or_options": "string of length 1-13"
      },
      {
        "name": "CountryCode",
        "type": "str",
        "description": "(ITU-T Mode & CC_AND_ICC_BASED) Country code for MEG ID.",
        "default": "ZZ",
        "range_or_options": "string matching pattern ^[A-Z]{2}$"
      },
      {
        "name": "PrimaryVidMegId",
        "type": "int",
        "description": "(ITU-T Mode & PRIMARY_VID) Primary VLAN ID for MEG ID.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "CharacterStringMegId",
        "type": "str",
        "description": "(ITU-T Mode & CHARACTER_STRING) Character string representing MEG ID.",
        "default": "MEG_1",
        "range_or_options": "string of length 1-43"
      },
      {
        "name": "TwoOctetMegId",
        "type": "str",
        "description": "(ITU-T Mode & TWO_OCTET_INTEGER) Two-octet integer representation of MEG ID.",
        "default": "0000",
        "range_or_options": "string matching pattern ^[A-Fa-f0-9]{4}$"
      },
      {
        "name": "Rfc2685VpnIdMegId",
        "type": "str",
        "description": "(ITU-T Mode & RFC_2685_VPN_ID) RFC 2685 VPN ID format for MEG ID.",
        "default": "00-00-00:00-00-00-00",
        "range_or_options": "string matching pattern ^[A-Fa-f0-9]{2}([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})[:]([A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})([-][A-Fa-f0-9]{2})$"
      }
    ],
    "description": "Creates and configures a Y.1731 Maintenance Entity Group (MEG) object within the Renix API. This method allows customization through keyword arguments to set various configuration options for the MEG such as operation mode, priority levels, domain ID types, and MEG ID types depending on whether ITU-T or IEEE standards are being used.",
    "example": "| Create Y1731 Meg | OperationMode=IEEE |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_mp",
    "return_type": "Y1731MpConfig or list of Y1731MpConfig",
    "return": "A single Y.1731 Maintenance Point (MP) configuration object or a list of such objects depending on the input sessions.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable of objects",
        "description": "A single session object or an iterable (list, set, tuple) of session objects for which Y.1731 MPs are to be created. Each session object must have a `create_mp` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Meg",
        "type": "Y1731MegConfig",
        "description": "The Y.1731 MEG object associated with the MP.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Vid1",
        "type": "int",
        "description": "First VLAN ID assigned to the MP.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "Vid2",
        "type": "int",
        "description": "Second VLAN ID assigned to the MP.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "MpType",
        "type": "str",
        "description": "Type of Maintenance Point (MEP or MIP).",
        "default": "MEP",
        "range_or_options": "MEP MIP"
      },
      {
        "name": "MepId",
        "type": "int",
        "description": "ID of the MEP if MpType is MEP.",
        "default": "1",
        "range_or_options": "1-8191"
      },
      {
        "name": "Rdi",
        "type": "str",
        "description": "Remote Defect Indication setting.",
        "default": "AUTO",
        "range_or_options": "AUTO OFF ON"
      },
      {
        "name": "EnableAisRx",
        "type": "bool",
        "description": "Enables AIS reception.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLckRx",
        "type": "bool",
        "description": "Enables LCK reception.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLbResponse",
        "type": "bool",
        "description": "Enables Loopback response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLtResponse",
        "type": "bool",
        "description": "Enables Link Trace response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableDmResponse",
        "type": "bool",
        "description": "Enables Delay Measurement response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLmResponse",
        "type": "bool",
        "description": "Enables Loss Measurement response handling.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableOverrideCcPeriod",
        "type": "bool",
        "description": "Enables overriding of the Continuity Check message period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideCcPeriod",
        "type": "str",
        "description": "Specifies the override value for the CC message period.",
        "default": "CCM_1S",
        "range_or_options": "CCM_3MS CCM_10MS CCM_100MS CCM_1S CCM_10S CCM_1MIN CCM_10MIN"
      },
      {
        "name": "EnableOverrideAisPeriod",
        "type": "bool",
        "description": "Enables overriding of the AIS message period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideAisPeriod",
        "type": "str",
        "description": "Specifies the override value for the AIS message period.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "EnableOverrideLckPeriod",
        "type": "bool",
        "description": "Enables overriding of the LCK message period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideLckPeriod",
        "type": "str",
        "description": "Specifies the override value for the LCK message period.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "EnableOverrideMeLevel",
        "type": "bool",
        "description": "Enables overriding of the Maintenance Entity (ME) level.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideMeLevel",
        "type": "str",
        "description": "Specifies the override value for the ME level.",
        "default": "LEVEL1",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "DmmDelay",
        "type": "int",
        "description": "Sets the delay for DMM packets.",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "DmrDelay",
        "type": "int",
        "description": "Sets the delay for DMR packets.",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "LmrRxFCfStart",
        "type": "int",
        "description": "Initial value for received frame count in loss measurement response.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrRxFCfStep",
        "type": "int",
        "description": "Increment step for received frames in loss measurement response.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmrTxFCbStart",
        "type": "int",
        "description": "Initial value for sent frame count in loss measurement response.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrTxFCbStep",
        "type": "int",
        "description": "Increment step for sent frames in loss measurement response.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmmTxFCfOffset",
        "type": "int",
        "description": "TLV offset for transmitted frame count in LMM packets.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrRxFCfOffset",
        "type": "int",
        "description": "TLV offset for received frame count in LMR packets.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrTxFCbOffset",
        "type": "int",
        "description": "TLV offset for transmitted frame count in LMR packets.",
        "default": "0",
        "range_or_options": "0-32767"
      }
    ],
    "description": "This function creates one or more Y.1731 Maintenance Points (MPs) for provided session objects. It abstracts away the iteration logic and ensures uniform handling of single and multiple session inputs. The results are returned as either a single result or a list of results depending on the number of input sessions.",
    "example": ".. code:: RobotFramework\n\n    | Create Y1731 Mp | Sessions=${session} | MpType=MEP |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.edit_y1731_mp",
    "return_type": "bool",
    "return": "Returns True if all Maintenance Point (MP) objects were successfully updated; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Mps",
        "type": "object or list of objects",
        "description": "A single MP object or a list of MP objects to be edited. If a single object is provided, it will be wrapped in a list for batch processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Meg",
        "type": "Y1731MegConfig",
        "description": "The MEG object associated with the MP(s). This sets a relationship via `Mp.set_relatives()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Vid1",
        "type": "int",
        "description": "VLAN ID #1.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "Vid2",
        "type": "int",
        "description": "VLAN ID #2.",
        "default": "100",
        "range_or_options": "0-4095"
      },
      {
        "name": "MpType",
        "type": "str",
        "description": "Type of MP: MEP or MIP.",
        "default": "MEP",
        "range_or_options": "MEP MIP"
      },
      {
        "name": "MepId",
        "type": "int",
        "description": "ID of the MEP.",
        "default": "1",
        "range_or_options": "1-8191"
      },
      {
        "name": "Rdi",
        "type": "str",
        "description": "Remote Defect Indication setting.",
        "default": "AUTO",
        "range_or_options": "AUTO OFF ON"
      },
      {
        "name": "EnableAisRx",
        "type": "bool",
        "description": "Enables AIS Rx.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLckRx",
        "type": "bool",
        "description": "Enables LCK Rx.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLbResponse",
        "type": "bool",
        "description": "Enables Loopback Response.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLtResponse",
        "type": "bool",
        "description": "Enables Link Trace Response.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableDmResponse",
        "type": "bool",
        "description": "Enables Delay Measurement Response.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableLmResponse",
        "type": "bool",
        "description": "Enables Loss Measurement Response.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableOverrideCcPeriod",
        "type": "bool",
        "description": "Enables overriding of CC period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideCcPeriod",
        "type": "str",
        "description": "Specifies the overridden CC period.",
        "default": "CCM_1S",
        "range_or_options": "CCM_3MS CCM_10MS CCM_100MS CCM_1S CCM_10S CCM_1MIN CCM_10MIN"
      },
      {
        "name": "EnableOverrideAisPeriod",
        "type": "bool",
        "description": "Enables overriding of AIS period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideAisPeriod",
        "type": "str",
        "description": "Specifies the overridden AIS period.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "EnableOverrideLckPeriod",
        "type": "bool",
        "description": "Enables overriding of LCK period.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideLckPeriod",
        "type": "str",
        "description": "Specifies the overridden LCK period.",
        "default": "PERIOD_1S",
        "range_or_options": "PERIOD_1S PERIOD_1MIN"
      },
      {
        "name": "EnableOverrideMeLevel",
        "type": "bool",
        "description": "Enables overriding of ME level.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OverrideMeLevel",
        "type": "str",
        "description": "Specifies the overridden ME level.",
        "default": "LEVEL1",
        "range_or_options": "LEVEL0 LEVEL1 LEVEL2 LEVEL3 LEVEL4 LEVEL5 LEVEL6 LEVEL7"
      },
      {
        "name": "DmmDelay",
        "type": "int",
        "description": "Delay value for DMM packet transmission.",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "DmrDelay",
        "type": "int",
        "description": "Delay value for DMR response.",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "LmrRxFCfStart",
        "type": "int",
        "description": "Initial value of received frame count forwarding in LM Response.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrRxFCfStep",
        "type": "int",
        "description": "Increment step for received frame count in LM Response.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmrTxFCbStart",
        "type": "int",
        "description": "Initial value of sent frame count forwarding in LM Response.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LmrTxFCbStep",
        "type": "int",
        "description": "Increment step for sent frame count in LM Response.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LmmTxFCfOffset",
        "type": "int",
        "description": "TLV offset for LMM sent frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrRxFCfOffset",
        "type": "int",
        "description": "TLV offset for LMR received frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      },
      {
        "name": "LmrTxFCbOffset",
        "type": "int",
        "description": "TLV offset for LMR sent frame count.",
        "default": "0",
        "range_or_options": "0-32767"
      }
    ],
    "description": "Edits one or more Maintenance Point (MP) objects by updating their attributes based on provided keyword arguments. Wraps the `Y1731.edit_mp` method and allows for batch editing of multiple MP objects. If a 'Meg' key is present in kwargs, a special relationship is created between the MP and the specified MEG using `set_relatives`. For other keys, standard attribute assignment is used.",
    "example": "| Create Y1731 Mp | Mps=${mp} | MpType=MEP |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_expected_mep",
    "return_type": "Y1731ExpectedMep or list of Y1731ExpectedMep",
    "return": "A single Y1731ExpectedMep instance if one MEG is provided, otherwise a list of Y1731ExpectedMep instances associated with the respective MEGs in the input.",
    "description": "创建y1731 Expected Mep对象，用于配置和生成与一个或多个MEG关联的Y1731ExpectedMep实例。This function wraps the backend method and supports flexible creation and configuration of expected MEPs.",
    "parameters": [
      {
        "name": "Megs",
        "type": "Y1731MegConfig or iterable of Y1731MegConfig",
        "description": "A single MEG object or an iterable (list, set, tuple) containing multiple MEG objects. Each MEG serves as the parent context for the expected MEP being created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepId",
        "type": "int",
        "description": "MEP ID to assign to each created Y1731ExpectedMep instance.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "MacAddr",
        "type": "str",
        "description": "目标MAC地址，格式必须是有效的MAC地址。",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "EnableRx",
        "type": "bool",
        "description": "是否启用接收功能。",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": "| Create Y1731 Expected Mep | Megs=${meg} | EnableRx=True |",
    "additional_info": {
      "behavior": [
        "如果 `Megs` 不是一个可迭代对象，则会被包装成一个列表。",
        "对于输入中的每个MEG，都会调用Y1731.create_expected_mep()来创建对应的Y1731ExpectedMep对象。",
        "所有通过**kwargs提供的参数都会被应用到每个新创建的Y1731ExpectedMep实例上。",
        "如果只有一个MEG被提供，返回单个Y1731ExpectedMep实例；否则返回包含所有对应Y1731ExpectedMep对象的列表。"
      ],
      "failure_handling": "If the underlying call fails (returns False), a ContinuableFailure exception is raised."
    }
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_data_tlv",
    "return_type": "Y1731DataTlv or list of Y1731DataTlv",
    "return": "If a single Mp is provided, returns the configured Y1731DataTlv instance. If multiple Mps are provided, returns a list of corresponding Y1731DataTlv objects.",
    "parameters": [
      {
        "name": "Mps",
        "type": "object or iterable of objects (e.g., list, set, tuple)",
        "description": "A single maintenance point (Mp) object or an iterable of Mp objects. Each Mp represents an upper layer context to which the created Y1731DataTlv will be attached.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "Specifies the length of the Data TLV field. If not specified, default value 0 is used.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Data",
        "type": "list",
        "description": "Specifies the data content of the TLV as a list of decimal numbers. Default value is an empty list.",
        "default": "[]",
        "range_or_options": "List length: 0-255; Elements: 0-255"
      }
    ],
    "description": "Creates one or more Y1731 Data TLV (Type-Length-Value) configuration objects associated with the given maintenance point(s). This function acts as a wrapper around the `Y1731.create_data_tlv` method and allows for creation of Y1731 Data TLVs either for a single Mp or multiple Mps. It also supports optional keyword arguments to configure properties of the Data TLV during creation.",
    "example": ".. code:: RobotFramework\n\n    | Create Y1731 Data Tlv | Mps=${mp} | Length=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_ltm_egress_identifier_tlv",
    "return_type": "Y1731LtmEgressIdentifierTlv or list of Y1731LtmEgressIdentifierTlv",
    "return": "Returns a single Y.1731 LTM Egress Identifier TLV object or a list of such objects, depending on whether a single Mp or multiple Mps are provided.",
    "parameters": [
      {
        "name": "Mps",
        "type": "obj or iterable of obj",
        "description": "A single parent object (typically of type `Y1731MpConfig`) or an iterable (list, set, tuple) of such objects to which the LTM Egress Identifier TLVs will be associated. Each Mp typically represents a measurement point in the Y.1731 protocol context.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the TLV value field. If not specified, defaults to 0.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Egress Identifier - Index. Used as an identifier index for egress mapping. Defaults to 0.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MacAddress",
        "type": "str",
        "description": "Egress Identifier - MAC address. Must be a valid MAC address string. Defaults to '00:00:00:00:00:00'.",
        "default": "\"00:00:00:00:00:00\"",
        "range_or_options": "valid MAC address format (e.g., 00:11:22:33:44:55)"
      }
    ],
    "description": "This function creates and returns one or more Y.1731 LTM (Loopback Test Message) Egress Identifier TLV configuration objects. It wraps the backend method `Y1731.create_ltm_egress_identifier_tlv` and supports associating each created TLV with a corresponding parent measurement point (Mp). If a single Mp is passed, it returns a single TLV object; if multiple Mps are passed, it returns a list of corresponding TLV objects. Optional keyword arguments allow setting specific TLV fields during creation.",
    "example": ".. code:: RobotFramework\n\n    | Create Y1731 Ltm Egress Identifier Tlv | Mps=${mp} | Length=10 | Index=1 | MacAddress=00:01:02:03:04:05 |\n\n>>> api = RenixAPI()\n>>> mp1 = MeasurementPoint()  # hypothetical measurement point object\n>>> mp2 = MeasurementPoint()\n>>> tlv1 = api.create_y1731_ltm_egress_identifier_tlv(mp1, Length=10, Index=1)\n>>> tlvs = api.create_y1731_ltm_egress_identifier_tlv([mp1, mp2], Length=5, MacAddress='00:00:00:00:00:01')"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_ltr_egress_identifier_tlv",
    "return_type": "Y1731LtrEgressIdentifierTlv or list of Y1731LtrEgressIdentifierTlv",
    "return": "A configured instance or list of instances of Y1731LtrEgressIdentifierTlv linked to the provided Mp(s).",
    "parameters": [
      {
        "name": "Mps",
        "type": "object or iterable (e.g., list)",
        "description": "A single Mp object or an iterable of Mp objects representing parent context(s) for the TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "Length of TLV value field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "LastIndex",
        "type": "hex",
        "description": "Last Egress Identifier - Unique Identifier.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "LastMacAddress",
        "type": "str",
        "description": "Last Egress Identifier - MAC address.",
        "default": "\"00:00:00:00:00:00\"",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "NextIndex",
        "type": "hex",
        "description": "Next Egress Identifier - Unique Identifier.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextMacAddress",
        "type": "str",
        "description": "Next Egress Identifier - MAC address.",
        "default": "\"00:00:00:00:00:00\"",
        "range_or_options": "valid MAC address format"
      }
    ],
    "description": "Creates and returns one or more configured instances of Y1731LtrEgressIdentifierTlv for the provided Mp(s), optionally customized with keyword arguments. This method is typically used in the RenixAPI framework to associate TLVs with their hierarchical position in a protocol stack. The function supports both single and multiple Mp inputs, returning corresponding TLV instance(s). Any additional configuration options passed via keyword arguments are applied to each created TLV during initialization.",
    "example": "| Create Y1731 Ltm Egress Identifier Tlv | Mps=${mp} | Length=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_organization_specific_tlv",
    "return_type": "Y1731OrgSpecificTlv or list of Y1731OrgSpecificTlv",
    "return": "A single configured Y1731OrgSpecificTlv object if a single Mp is provided, or a list of such objects in the same order as the input Mps if multiple Mps are given.",
    "parameters": [
      {
        "name": "Mps",
        "type": "object or iterable",
        "description": "A single Mp object or an iterable (list, set, tuple) of Mp objects. Each Mp represents the upper layer context or parent structure to which the newly created TLV will belong. The TLV is hierarchically attached to this Mp.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "Length of TLV value field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OrgUniqueId",
        "type": "list",
        "description": "Unique organization ID.",
        "default": "[0, 0, 0]",
        "range_or_options": "List elements: 0-255 decimal numbers"
      },
      {
        "name": "SubType",
        "type": "int",
        "description": "Sub-type of this TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Data",
        "type": "list",
        "description": "TLV Data.",
        "default": "[]",
        "range_or_options": "List length: 0-255; Elements: 0-255 decimal numbers"
      }
    ],
    "description": "Creates one or more organization-specific TLV (Type-Length-Value) structures for the Y.1731 protocol. This method wraps the class-level method `Y1731.create_organization_specific_tlv`, enabling the creation of Y1731OrgSpecificTlv objects attached to one or more provided parent Mp objects. If multiple Mp objects are provided, a corresponding number of TLVs will be created and returned as a list. If only one Mp is provided, a single TLV object is returned directly.",
    "example": "| Create Y1731 Organization Specific Tlv | Mps=${mp} | Length=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.create_y1731_reply_ingress_tlv",
    "return_type": "Y1731ReplyIngressTlv or list of Y1731ReplyIngressTlv",
    "return": "A single `Y1731ReplyIngressTlv` object if a single MP is provided, otherwise a list of `Y1731ReplyIngressTlv` objects corresponding to each MP in the input.",
    "parameters": [
      {
        "name": "Mps",
        "type": "list of Y1731MpConfig",
        "description": "A list of Maintenance Point (MP) objects to which the Y.1731 Reply Ingress TLVs will be associated. Each MP represents a context for maintenance operations in Y.1731 protocols.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "Length of TLV value field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "IngressAction",
        "type": "str",
        "description": "Ingress Action setting.",
        "default": "ACTION_ING_OK",
        "range_or_options": "ACTION_ING_OK ACTION_ING_DOWN ACTION_ING_BLOCKED ACTION_ING_VID"
      },
      {
        "name": "IngressMacAddress",
        "type": "str",
        "description": "Ingress MAC address used in the TLV configuration.",
        "default": "\"00:00:00:00:00:00\"",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "ChassisIdLength",
        "type": "int",
        "description": "Chassis ID Length.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ChassisIdSubtype",
        "type": "int",
        "description": "Chassis ID Sub-type.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ChassisId",
        "type": "list",
        "description": "Data representing Chassis ID as a list of decimal integers.",
        "default": "[]",
        "range_or_options": "length 0-255, elements 0-255"
      }
    ],
    "description": "Creates and returns one or more Y.1731 Reply Ingress TLV (Type-Length-Value) configuration objects bound to the specified Maintenance Points (MPs). If multiple MPs are provided, a list of corresponding TLV objects is returned. If only one MP is provided, a single TLV object is returned instead of a list. This function wraps the backend implementation and ensures consistent handling whether one or multiple MPs are passed by normalizing the input into a list, creating a TLV for each MP, and returning either a single object or a list based on the number of inputs.",
    "example": "| Create Y1731 Reply Ingress Tlv | Mps=${mp} | Length=10 |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_1dm",
    "return_type": "bool",
    "return": "Returns True if the one-way delay measurement (1DM) is successfully initiated, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list or Y1731 object",
        "description": "A list of Y.1731 session objects for which the one-way delay measurement should be started. If a single session object is provided, it will be internally converted to a list.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies whether the message should be sent as unicast or multicast.",
        "default": "MULTICAST",
        "range_or_options": "UNICAST MULTICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig` or list of such objects",
        "description": "MEP handles associated with the sessions for identifying maintenance entities. If provided, their handle attributes are extracted and used in the configuration.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "Destination MAC address to which the measurement packets should be sent.",
        "default": "",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "TxType",
        "type": "str",
        "description": "Transmission type indicating how many packets to send and the sending pattern.",
        "default": "SINGLE",
        "range_or_options": "SINGLE CONTINUOUS MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "Rate at which packets are transmitted during the measurement.",
        "default": "TXRATE_1_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "TxCount",
        "type": "int",
        "description": "Number of packets to be sent when TxType is SINGLE or MULTIPLE.",
        "default": "1",
        "range_or_options": "0-65535"
      }
    ],
    "description": "This function initiates a one-way delay measurement (1DM) for the specified Y.1731 sessions using the provided configuration parameters. It prepares and executes the command to start the measurement. The function internally constructs and executes a `Y1731Start1DmCommand`, utilizing session handles and optional MEP handles and transmission settings to configure the measurement behavior.",
    "example": "| Start Y1731 1dm | Sessions=${Sessions} | MsgType=UNICAST | DestMacList=00:00:00:00:00:01 | TxType=CONTINUOUS |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_ais",
    "return_type": "bool",
    "return": "布尔值，表示AIS启动是否成功（True/False）",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, tuple, set]",
        "description": "一个或多个Y.1731协议会话对象，每个会话必须具有'handle'属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "消息类型，指定发送AIS时使用组播还是单播。",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": "Union[list, tuple, set, Y1731MpConfig]",
        "description": "指定用于发送AIS的MEP句柄。如果提供了Y1731MpConfig对象，则自动提取其'handle'属性。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "目的MAC地址，必须是有效的MAC地址格式。",
        "default": "",
        "range_or_options": "有效的MAC地址"
      }
    ],
    "description": "启动指定会话上的Y.1731 AIS（告警指示信号）。该函数在给定的一个或多个Y.1731会话上发起AIS传输，并可选择性地指定MEP（维护实体点）句柄以确定使用哪些MEP发送AIS。如果提供了MEP句柄，则从Y1731MpConfig对象中自动提取其内部句柄。",
    "example": ".. code:: RobotFramework\n\n    | Start Y1731 AIS | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_ccm",
    "return_type": "bool",
    "return": "布尔值，表示命令是否执行成功（True/False）。",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, tuple, set]",
        "description": "一个或多个 Y.1731 协议会话对象，必须包含 'handle' 属性以供系统识别。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "消息类型，用于指定发送 CCM 消息的方式。",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": "Union[list, tuple, set, Y1731MpConfig]",
        "description": "与会话关联的 MEP 句柄。若提供的是 Y1731MpConfig 对象列表，则自动提取其 handle 属性。",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "目标 MAC 地址，仅支持有效格式的 MAC 地址。",
        "default": "",
        "range_or_options": "有效的MAC地址"
      },
      {
        "name": "CcosList",
        "type": "list",
        "description": "客户 VLAN 的服务等级列表，元素取值范围为 0 到 7。",
        "default": "[]",
        "range_or_options": "0-7"
      },
      {
        "name": "ScosList",
        "type": "list",
        "description": "运营商 VLAN 的服务等级列表，元素取值范围为 0 到 7。",
        "default": "[]",
        "range_or_options": "0-7"
      }
    ],
    "description": "启动一个或多个 Y.1731 协议会话的连续性检查消息 (CCM) 发送功能。该函数负责将传入的会话对象转换为内部 API 可识别的句柄，并根据提供的关键字参数构造和执行相应的命令。",
    "example": "| Start Y1731 Ccm | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_dmm",
    "return_type": "bool",
    "return": "Returns True if the DMM command is successfully executed, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731",
        "description": "List of Y.1731 session objects for which the Delay Measurement Message (DMM) operation will be initiated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies the message transmission type: multicast or unicast.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig`",
        "description": "Optional MEP handles to use for the DMM operation. If not provided, session handles are used by default.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "Destination MAC address for unicast messages. Must be a valid MAC address format.",
        "default": "",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "TxType",
        "type": "str",
        "description": "Transmission type for the DMM message.",
        "default": "SINGLE",
        "range_or_options": "SINGLE CONTINUOUS MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "Rate at which DMM messages are transmitted.",
        "default": "TXRATE_1_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "CcosList",
        "type": "int or list of int",
        "description": "List of Class of Service values for customer VLAN (CoS).",
        "default": "",
        "range_or_options": "0-7"
      },
      {
        "name": "ScosList",
        "type": "int or list of int",
        "description": "List of Class of Service values for service-provider VLAN (CoS).",
        "default": "",
        "range_or_options": "0-7"
      }
    ],
    "description": "Starts a Y.1731 Delay Measurement Message (DMM) operation on one or more specified sessions. This function initiates delay measurement using either session handles or MEP handles, with optional configuration for transmission type, rate, destination MAC address, and CoS values for both customer and service-provider VLANs.",
    "example": "| Start Y1731 Dmm | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_lbm",
    "return_type": "bool",
    "return": "True if the LBM command is successfully initiated, False otherwise (though exceptions are raised on failure).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731 session objects",
        "description": "List of Y.1731 protocol session objects for which the Loopback Message (LBM) operation will be started.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies whether the message should be sent as a unicast or multicast packet.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig` object or list of such objects",
        "description": "Optional MEP configuration(s) to associate with this LBM operation. If provided, their handles will be used internally.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "Destination MAC address for unicast messages or a list of addresses for multicast scenarios.",
        "default": "",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "InitTransactionId",
        "type": "int",
        "description": "Initial transaction ID for identifying the sequence of LBM operations.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TxType",
        "type": "str",
        "description": "Transmission type indicating how many packets to send.",
        "default": "SINGLE",
        "range_or_options": "SINGLE CONTINUOUS MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "Rate at which packets should be transmitted.",
        "default": "TXRATE_1_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "TxCount",
        "type": "int",
        "description": "Number of packets to transmit in total when using non-continuous transmission mode.",
        "default": "1",
        "range_or_options": "0-65535"
      }
    ],
    "description": "This function initiates a Y.1731 Loopback Message (LBM) operation for one or more session objects. It configures and executes the appropriate command based on the provided session objects and optional keyword arguments. The function returns True upon successful execution, but actual success of the LBM operation must be verified separately (e.g., via polling or event notifications).",
    "example": "| Start Y1731 Lbm | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_lck",
    "return_type": "bool",
    "return": "True if the Y.1731 LCK transmission is successfully started on the specified sessions, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731 session objects",
        "description": "List of Y.1731 protocol session objects for which LCK transmission will be initiated.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies the message type for LCK transmission.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig` or list/tuple/set of :obj:`Y1731MpConfig`",
        "description": "Specifies MEP (Maintenance End Point) handles used to identify maintenance endpoints associated with the LCK command.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "Destination MAC address to be used in LCK frames when unicast messaging is selected.",
        "default": "",
        "range_or_options": "valid MAC address format (e.g., 00:11:22:33:44:55)"
      }
    ],
    "description": "Starts Y.1731 LCK (Lock Signal) transmission on the specified Y.1731 session(s). This function sends a Lock Signal message to notify the network that a fault has occurred and traffic should not be forwarded through this path. The message can be sent as either multicast or unicast, depending on the configuration provided.",
    "example": ".. code:: RobotFramework\n\n    | Start Y1731 Lck | Sessions=${Sessions} | MsgType=UNICAST | DestMacList=00:11:22:33:44:55 | MepHandles=${MepHandles}"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_lmm",
    "return_type": "bool",
    "return": "布尔值，表示Y.1731 LMM操作是否成功启动（True/False）",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731",
        "description": "y1731协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "消息类型",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig`",
        "description": "Y.1731 MEP配置对象或句柄列表",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "目标MAC地址",
        "default": "",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "TxType",
        "type": "str",
        "description": "传输类型",
        "default": "SINGLE",
        "range_or_options": "SINGLE CONTINUOUS"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "消息发送速率",
        "default": "TXRATE_1_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "TxFCfMode",
        "type": "str",
        "description": "帧发送方式：恒定速率或逐步增加",
        "default": "STEP",
        "range_or_options": "STATIC STEP"
      },
      {
        "name": "TxFCfValue",
        "type": "int",
        "description": "TxFCf计数器值（静态模式）或初始值（步进模式）",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TxFCfStep",
        "type": "int",
        "description": "每次LM消息中TcFCf计数器的步进值",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "CcosList",
        "type": "int",
        "description": "客户VLAN的CoS值列表",
        "default": "",
        "range_or_options": "0-7"
      },
      {
        "name": "ScosList",
        "type": "int",
        "description": "服务提供商VLAN的CoS值列表",
        "default": "",
        "range_or_options": "0-7"
      }
    ],
    "description": "该函数用于在指定的Y.1731会话上启动Loss Measurement Message (LMM)。支持单播和组播模式，并允许配置传输类型、速率、帧模式以及服务质量参数。可用于单个或多个会话。",
    "example": "| Start Y1731 Lmm | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.start_y1731_ltm",
    "return_type": "bool",
    "return": "Returns True if the LTM operation is successfully started, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of :obj:`Y1731`",
        "description": "A list of Y.1731 session objects on which to start the Loopback Test Message (LTM) operation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MsgType",
        "type": "str",
        "description": "Specifies whether the message should be sent as MULTICAST or UNICAST.",
        "default": "MULTICAST",
        "range_or_options": "MULTICAST UNICAST"
      },
      {
        "name": "MepHandles",
        "type": ":obj:`Y1731MpConfig`",
        "description": "Optional MEP handles used for the LTM operation. If not provided, default MEP settings will be used.",
        "default": "",
        "range_or_options": "not_found"
      },
      {
        "name": "DestMacList",
        "type": "str",
        "description": "Destination MAC address to use when sending LTM packets.",
        "default": "",
        "range_or_options": "Valid MAC address format required."
      },
      {
        "name": "InitTransactionId",
        "type": "int",
        "description": "Initial transaction ID used for identifying LTM operations.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "InitTtl",
        "type": "int",
        "description": "Initial Time-To-Live value for the LTM packet.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "TxType",
        "type": "str",
        "description": "Transmission type indicating how many times the LTM packet should be sent.",
        "default": "SINGLE",
        "range_or_options": "SINGLE CONTINUOUS MULTIPLE"
      },
      {
        "name": "TxRate",
        "type": "str",
        "description": "Rate at which LTM packets should be transmitted.",
        "default": "TXRATE_1_PER_SEC",
        "range_or_options": "TXRATE_10_PER_SEC TXRATE_1_PER_SEC TXRATE_1_PER_MIN TXRATE_1_PER_10MIN"
      },
      {
        "name": "TxCount",
        "type": "int",
        "description": "Number of LTM packets to send in case of multiple transmissions.",
        "default": "1",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Starts a Y.1731 Loopback Test Message (LTM) operation on one or more specified Y.1731 session(s). This function allows optional configuration parameters such as message type, destination MAC, TTL, and transmission behavior (single, continuous, multiple).",
    "example": "| Start Y1731 Ltm | Sessions=${Sessions} | MsgType=UNICAST |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_1dm",
    "return_type": "bool",
    "return": "布尔值Bool (范围：True / False)",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731",
        "description": "y1731协议会话对象列表",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "Y1731MpConfig",
        "description": "Y.1731 meps对象",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops a one-way delay measurement (1DM) session for the specified Y.1731 sessions. This function sends a command to stop the 1DM operation either for all provided sessions or based on additional filters like MEP handles.",
    "example": "| Stop Y1731 1dm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_ais",
    "return_type": "bool",
    "return": "True if the command to stop Y.1731 AIS transmission was successfully executed, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Y1731 or list/tuple/set of Y1731",
        "description": "A single session object or a collection of session objects for which the AIS signal should be stopped. Each session must have a valid handle.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "list/tuple/set of Y1731MpConfig or raw handles",
        "description": "Specifies the MEP handles used to identify the Maintenance End Points associated with the AIS stop command. If provided as Y1731MpConfig objects, their handles are extracted automatically.",
        "default": "",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops the Y.1731 AIS (Alarm Indication Signal) for the specified Y.1731 session(s). This function sends a command to stop the transmission of AIS packets for one or more Maintenance End Points (MEPs). If a single session is provided, it will be converted internally into a list for uniform processing.",
    "example": "| Stop Y1731 Ais | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_ccm",
    "return_type": "bool",
    "return": "Returns True if the Y.1731 CCM sessions are successfully stopped, otherwise False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731 session objects",
        "description": "A list (or collection) of Y1731 session objects for which the Continuity Check Message (CCM) transmission should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "Y1731MpConfig or list of Y1731MpConfig",
        "description": "Optional MEP handles associated with the Y.1731 sessions to stop CCM. If not provided, defaults to empty string.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops the Y.1731 Continuity Check Message (CCM) sessions for the given session objects. Optionally supports specifying MEP handles to refine the context of the stop command. Internally ensures proper formatting and extraction of raw handles from MEP objects, if provided.",
    "example": "| Stop Y1731 Ccm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_dmm",
    "description": "Stops the Y.1731 Delay Measurement Message (DMM) operation on specified Y.1731 session(s). Optionally, specific MEP handles can be provided to control which endpoints the DMM should be stopped for.",
    "return_type": "bool",
    "return": "Returns True if the DMM stop command was executed successfully; otherwise, False.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list, tuple, set, or single object",
        "description": "A session or collection of sessions for which the Y.1731 DMM should be stopped. Each session is expected to have a 'handle' attribute used in command execution.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "list, tuple, set, or single Y1731MpConfig",
        "description": "Specifies the MEP (Maintenance End Point) handles associated with the DMM stop operation. If not a list-like structure, it will be converted into one. If Y1731MpConfig objects are provided, their 'handle' attributes will be extracted and used.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "example": "| Stop Y1731 Dmm | Sessions=${Sessions} | MepHandles=${MepHandles} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_lbm",
    "return_type": "bool",
    "return": "Returns True if the LBM operation was successfully stopped, False otherwise.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "Union[object, list, tuple, set]",
        "description": "A single session object or a collection of session objects for which the Y.1731 Loopback Message (LBM) operation should be stopped. Each session object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "Union[list, tuple, set, object]",
        "description": "Optional. A single MEP handle or a collection of MEP handles. If provided, these handles are used to specify which MEPs should be considered when stopping the LBM operation. If the provided value is a `Y1731MpConfig` object or similar structure containing a handle, the handle will be extracted automatically.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops the Y.1731 Loopback Message (LBM) operation for the specified sessions or MEP handles. This function sends a command to stop ongoing LBM operations and returns a boolean indicating success. It is typically used after starting an LBM test to gracefully terminate the operation.",
    "example": "| Stop Y1731 Lbm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_lck",
    "return_type": "bool",
    "return": "布尔值Bool，表示操作是否成功 (范围：True / False)",
    "parameters": [
      {
        "name": "Sessions",
        "type": "object or iterable",
        "description": "一个或多个会话对象，用于停止Y.1731 LCK操作。每个会话对象必须具有 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "object or iterable, optional",
        "description": "单个或多个MEP（维护实体对）句柄，用于进一步指定LCK停止操作的目标。如果提供且为Y1731MpConfig实例，则会被转换为其对应的句柄。",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于停止给定会话上的Y.1731 LCK（Lock）操作。它通过构造并执行Y1731StopLckCommand来实现，使用提供的会话对象的句柄。此外，支持传入MEP句柄以更精确地控制停止目标。所有输入将被适当地转换为列表格式，并在必要时将Y1731MpConfig对象转换为它们的句柄。",
    "example": "| Stop Y1731 LCK | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_lmm",
    "description": "Stops the Y.1731 Loss Measurement (LMM) operation for the specified session(s). Optionally, it can also stop LMM for specific MEP (Maintenance End Point) handles if provided.",
    "return_type": "bool",
    "return": "Indicates that the command to stop Y.1731 LMM was executed successfully.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list, tuple, set, or single object",
        "description": "A session or collection of sessions for which the Y.1731 LMM operation should be stopped. If a single session is provided, it will be converted into a list internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "list, tuple, set, or single object",
        "description": "A MEP handle or collection of MEP handles for which the LMM should be stopped. If a single MEP handle is provided, it will be converted into a list internally. If the elements are instances of Y1731MpConfig, their `handle` attributes will be extracted and used.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "example": "| Stop Y1731 Lmm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.stop_y1731_ltm",
    "return_type": "bool",
    "return": "Returns True if the Y.1731 LTM operation was successfully stopped, otherwise False (which raises a ContinuableFailure exception).",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list of Y1731 session objects",
        "description": "A list of Y.1731 protocol session objects for which the LTM (Loopback and Test Message) operation should be stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MepHandles",
        "type": "Y1731MpConfig or list/tuple/set of Y1731MpConfig objects",
        "description": "Optional. Specifies MEP handles associated with the Y.1731 sessions to stop LTM operations. If Y1731MpConfig objects are provided, their 'handle' attributes are used internally.",
        "default": "",
        "range_or_options": "not_found"
      }
    ],
    "description": "Stops the Y.1731 Loopback and Test Message (LTM) operation for the specified Y1731 session(s). Optionally, it can also stop LTM operations related to specific MEP (Maintenance End Point) handles. This function wraps around the backend API call `RenixAPI.stop_y1731_ltm` and adds error handling by raising a `ContinuableFailure` exception if the result is False.",
    "example": "| Stop Y1731 Ltm | Sessions=${Sessions} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.get_y1731_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with keys corresponding to requested statistical items if exactly one row matches the filters. If multiple rows match, returns a pandas DataFrame. Returns False if no matching result is found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects (optional)",
        "description": "A port object or collection of port objects for which Y.1731 statistics are to be retrieved. Each object must have a 'Name' attribute representing its handle. If None, no specific port is targeted.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None (optional)",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available properties are used. If a string, it is converted into a single-element list. Must be a subset of available columns.",
        "default": "None",
        "range_or_options": "MaOrMegCount DropPacketCount TxAis RxAis TxCcm RxCcm TxDmm RxDmm TxLbm RxLbm TxLck RxLck TxLmm RxLmm TxLtm RxLtm Tx1Dm Rx1Dm"
      }
    ],
    "kwargs": [],
    "description": "Retrieves Y.1731 port-level statistics for specified port(s), optionally filtered to specific statistical items. This function wraps `_get_statictis` and prepares the `PortHandle` identifier based on the provided `Port` input to query statistics related to Y.1731 protocol performance metrics like packet transmission counts, AIS status, CCM, DMM, LBM, etc.",
    "example": "| Get Y1731 Port Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.get_y1731_meg_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns statistics for Y.1731 MEG (Maintenance Entity Group) based on the provided filters. If exactly one row matches, returns a dictionary with statistical items as keys; if multiple rows match, returns a pandas DataFrame; if no rows match, returns False.",
    "parameters": [
      {
        "name": "Meg",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A MEG object or collection of MEG objects used to filter statistics. If an object, its Name attribute is used as the identifier. If None, no filtering by MEG is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A port object or collection of port objects used to filter statistics. If an object, its Name attribute is used as the identifier. If None, no filtering by port is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None, all available items are retrieved. If a string, it is converted into a single-element list. Supported items include MdOrMeLevel, DropPacketCount, TimeOuts, UnexpectedId, UnexpectedLevel, Meps, UnexpectedMeps, UnexpectedPeriod, BadCcReceiveCount, CcRxState, and CcTxState.",
        "default": "None",
        "range_or_options": "MdOrMeLevel DropPacketCount TimeOuts UnexpectedId UnexpectedLevel Meps UnexpectedMeps UnexpectedPeriod BadCcReceiveCount CcRxState CcTxState"
      }
    ],
    "kwargs": [],
    "description": "This function retrieves Y.1731 MEG statistics based on the provided Meg and Port identifiers. It wraps the internal `_get_statictis` method to specifically fetch 'Y1731MegStats' type statistics. It allows filtering by one or more MEGs and/or ports, and optionally specifies which statistical items to return. The function supports both dynamic querying and result view-based retrieval depending on internal logic.",
    "example": ".. code:: RobotFramework\n\n    | Get Y1731 Meg Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Protocol.y1731.get_y1731_mp_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回值取决于匹配的统计结果数量。如果只有一条记录匹配，返回一个包含统计项的字典；如果有多个匹配记录，返回一个 pandas DataFrame；如果没有匹配项，则返回 False。",
    "parameters": [
      {
        "name": "Mp",
        "type": "object or list/set/tuple of objects, optional",
        "description": "一个或多个 Y.1731 维护点（MP）对象。每个 MP 对象必须包含 'Name' 属性用于标识。若为 None，则不进行特定 MP 过滤。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "需要获取的统计项列表。支持的统计项包括 SessionHandle、MpType、MepId、RemoteMeps 等多种维护点性能指标。若为字符串则自动转为单元素列表；若为 None，则获取所有可用属性。",
        "default": "None",
        "range_or_options": "SessionHandle MpType MepId RemoteMeps CcmTimeout CcmUnexpectMeg CcmUnexpectMep CcmUnexpectMeLevel UnexpectedPeriod TxCcm300Hz TxCcm10ms TxCcm100ms TxCcm1s TxCcm10s TxCcm1min TxCcm10min RxCcm LastTxCcmSeqNum LbmTimeout LbTransIdMismatch TxLbm RxLbm TxLbr RxLbr TxLtm RxLtm TxLtr RxLtr LtmTimeout TxAis RxAis AisTimeout TxLck RxLck LckTimeout Tx1Dm Rx1Dm TxDmm RxDmm TxDmr RxDmr DmmTimeout TxLmm RxLmm TxLmr RxLmr LmmTimeout"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取 Y.1731 协议中指定维护点（MP）的统计信息。它是一个封装了底层 `_get_statictis` 函数的接口，并根据传入的 MP 对象及其名称进行过滤，返回相应的统计值。支持从结果视图直接查询或通过动态逻辑分页查询。",
    "example": ".. code:: RobotFramework\n\n    | Get Y1731 Mp Statistic | Session=${Session} | StaItems=@{StaItems} |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.subscribe_result",
    "return_type": "bool",
    "return": "Returns True if the subscription to the specified statistic types is successful, otherwise raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Types",
        "type": "list or None",
        "description": "A list of strings specifying the types of statistics to subscribe to. If None, subscribes to all currently configured statistic views.",
        "default": "None",
        "range_or_options": "List of valid options includes: 'PortStats', 'PortAvgLatencyStats', 'StreamStats', 'StreamTxStats', 'StreamRxStats', 'StreamBlockStats', 'StreamBlockTxStats', 'StreamBlockRxStats', 'BfdIpv4SessionResult', 'BfdIpv6SessionResult', 'BfdSessionResult', 'IsisBfdSessionResult', 'IsisBfdIpv6SessionResult', 'Ospfv2BfdSessionResult', 'Ospfv3BfdSessionResult', 'EvpnRoutesStatistic', 'BgpLinkStateStatistic', 'BgpSessionStatistic', 'BgpSessionBlockStatistic', 'IsisSessionStats', 'IsisTlvStats', 'Ospfv2SessionResultPropertySet', 'Ospfv3SessionResultPropertySet', 'PimSessionStats', 'PimGroupStats', 'RipSessionBlockStats', 'RipSessionStats', 'IgmpHostResults', 'IgmpPortAggregatedResults', 'IgmpQuerierResults', 'MldHostResults', 'MldPortAggregatedResults', 'MldQuerierResults', 'PppoePortStatistic', 'PppoeServerBlockStatistic', 'PppoeServerStatistic', 'PppoeClientBlockStatistic', 'PppoeClientStatistic', 'Dhcpv4ServerStats', 'Dhcpv4ClientBlockStats', 'Dhcpv4ClientStats', 'Dhcpv4PortStats', 'Dhcpv6PortStatistics', 'Dhcpv6ServerStatistics', 'Dhcpv6ClientStatistics', 'Dhcpv6ClientBlockStatistics', 'Dhcpv6PdClientStatistics', 'L2tpPortStatistic', 'L2tpBlockStatistic', 'L2tpSessionStatistic', 'L2tpTunnelStatistic', 'Dot1xBlockStatistics', 'Dot1xPortStatistics', 'Dot1xStatistics', 'LdpSessionStatistic', 'LdpLspStatistic', 'PcepLspStatistic', 'PcepLspBlockStatistic', 'PcepPortStatistic', 'PcepSessionStatistic', 'PcepSessionBlockStatistic', 'LspPingSessionStats', 'LspPingEchoRequestStats', 'LspTraceEchoRequestStats'."
      }
    ],
    "kwargs": [],
    "description": "Subscribes to specified result types for statistic tracking or reporting. This function configures which statistics are monitored and creates appropriate result views and subscriptions based on the provided parameters. It supports both continuous and one-time statistic monitoring depending on the type used. The internal implementation interacts with Renix commands to manage result views and subscriptions.",
    "example": "| @{Types} | Create List | PortStats | StreamBlockStats |\n| Subscribe Result | Types=${Types} |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.clear_result",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful (True) or failed (False).",
    "parameters": [
      {
        "name": "All",
        "type": "bool",
        "description": "Flag to determine if all result views should be cleared. If True, clears all subscribed statistics; if False, only clears for specified objects.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "Objects",
        "type": "list or None",
        "description": "List of objects whose handles will be used to clear results. Only applicable when All=False.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Clears the result data for specified result views or all available result views in the system. This function is typically used after test execution to reset statistics. It internally uses the ClearResultCommand and interacts with ResultView and PageResultView instances under sys_entry.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.reset_statistic",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（范围：True / False）",
    "parameters": [],
    "kwargs": [],
    "description": "该函数用于重置测试仪表中已缓存的统计信息。其主要作用是清除内部存储静态统计数据的字典，确保统计模块处于一个干净的状态。这在开始新的测试运行之前或在获取当前统计数据进行报告之后非常有用。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Reset Statistic |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.save_result",
    "return_type": "str",
    "return": "The full path to the saved database file including the .db extension.",
    "parameters": [
      {
        "name": "Path",
        "type": "str",
        "description": "The directory path where the result file should be saved. If the directory does not exist, it will be created automatically.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FileName",
        "type": "str",
        "description": "The name of the file (without extension) to save the result in. The actual file will have a .db extension added automatically.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Saves the test instrument statistics results to a database (.db) file at the specified directory with the given filename. This function ensures that the target directory exists by creating it if necessary and then constructs the full path for the output file with a .db extension. It uses an internal command layer instance to execute the saving operation.",
    "example": "| ${DB} | Save Result | Path=D:\\test | FileName=test |\nThis example saves the test statistics into a file named 'test.db' inside the 'D:\\test' directory."
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_port_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary if one row of data is retrieved, a pandas DataFrame if multiple rows are retrieved, or False if no matching results were found.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list or set or tuple or None",
        "description": "A port object or collection of port objects for which statistics should be retrieved. If None, no specific port handle will be used in the query.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Specifies the statistical items (columns) to retrieve. If None, all available items are fetched. Valid items correspond to supported port-level statistics such as TxTotalFrames, RxTotalFrames, etc.",
        "default": "None",
        "range_or_options": "TxTotalFrames RxTotalFrames TxStreamFrames TxSignatureStreamFrames RxSignatureStreamFrames TxFrameRate RxFrameRate TxL1Rate RxL1Rate TxUtil RxUtil TxByteRate RxByteRate TxBitRate RxBitRate TxTotalBytes RxTotalBytes RxFCSErr RxIpv4ChecksumError RxTcpChecksumError RxUdpChecksumError RxPrbsFillBytes RxPrbsErrorBits RxPrbsErrorFrames RxIpv4Frames RxIpv6Frames RxTcpFrames RxUdpFrames RxMplsCount RxIcmpFrames RxVlanFrames RxFCoEFrames RxPauseFrames RxUndersizeFrames RxOversizeFrames RxJumboFrames RxOutofSequenceCount RxFilter0Count RxFilter1Count RxFilter2Count RxFilter3Count RxFilter4Count RxFilter5Count RxFilter6Count RxFilter7Count RxPktLossCount RxInOrderCount RxReorderCount RxRepeatFrameCount RxPortLateCount RxCorrectedRSFECErrorsFramesCodewords RxUncorrectedRSFECErrorsFramesCodewords RxCorrectedBaseRFECErrorsFramesCodewords RxUncorrectedBaseRFECErrorsFramesCodewords TxCrcFrameCount TxErr3CheckFrameCount TxErr4CheckFrameCount TxIpv4Count TxIpv6Count TxMplsCount TxIpv4FrameCount TxIpv6FrameCount TxVlanFrameCount TxMplsFrameCount TxOversizeFrames TxUndersizeFrames TxJumboFrames RxPFCFrames RxPFCRate RxPFCPriority0Frames RxPFCPriority1Frames RxPFCPriority2Frames RxPFCPriority3Frames RxPFCPriority4Frames RxPFCPriority5Frames RxPFCPriority6Frames RxPFCPriority7Frames TxPFCFrames TxPFCRate TxPFCPriority0Frames TxPFCPriority1Frames TxPFCPriority2Frames TxPFCPriority3Frames TxPFCPriority4Frames TxPFCPriority5Frames TxPFCPriority6Frames TxPFCPriority7Frames RxARPFrames TxARPFrames RxBroadcastFrames TxBroadcastFrames RxIpv4LengthErrorFrames RxUserDefinedCapture0Frames RxUserDefinedCapture0Rate RxUserDefinedCapture1Frames RxUserDefinedCapture1Rate RxUserDefinedCapture2Frames RxUserDefinedCapture2Rate RxUserDefinedCapture3Frames RxUserDefinedCapture3Rate RxUserDefinedCapture4Frames RxUserDefinedCapture4Rate RxUserDefinedCapture5Frames RxUserDefinedCapture5Rate RxFirstFrameArrivalTime RxLastFrameArrivalTime"
      },
      {
        "name": "Mode",
        "type": "bool",
        "description": "Controls whether performance-based refreshing of statistics is performed before retrieval. If True (default), internal methods may be called to ensure up-to-date statistics. If False, skips such refresh steps.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical information for one or more specified ports. This function gathers port statistics by calling the internal `_get_statictis` method with appropriate parameters. It supports both single and multiple port inputs and allows filtering of specific statistical items. The behavior of data retrieval can be controlled via the `Mode` flag.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | @{StaItems} | Create List | TxTotalFrames | RxTotalFrames |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Port} | Get Ports |\n    | &{Result} | Get Port Statistic | Port=${Port} | StaItems=@{StaItems} |\n    | ${DataFrame} | Get Port Statistic | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_port_latency_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "If exactly one matching row is found: Returns a dictionary where keys correspond to requested `StaItems` and values represent their respective statistical values. If multiple rows match the query criteria: Returns a pandas DataFrame containing filtered latency statistics across multiple ports. If no matching result is found: Returns False.",
    "parameters": [
      {
        "name": "Port",
        "type": "object or list/tuple/set of objects, optional",
        "description": "A port object or a collection of port objects for which latency statistics are to be retrieved. Each port object is expected to have a `Name` attribute representing its identifier. If multiple ports are provided, only the name of each port is used. If None (default), no specific port filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "bool, optional",
        "description": "Controls how statistics are retrieved when not in ResultView mode. If True (default), internal performance-based methods are called to refresh or collect statistics before retrieval. If False, alternative methods may be used depending on the statistic type.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical items (columns) to retrieve. If None (default), all available properties are queried using ROM property listings. If a string is provided, it is converted into a list containing one item. The selected items must be a subset of available statistics for 'PortAvgLatencyStats'.",
        "default": "not_found",
        "range_or_options": "PortID MinLatency MaxLatency AvaLatency"
      }
    ],
    "description": "Retrieves port latency statistics for specified port(s) using internal statistical querying mechanisms. This function gathers average latency statistics at the port level by calling `_get_statictis` with 'PortAvgLatencyStats' as the statistic type. It supports both single and multiple port queries. If no port is provided (`Port` is None), the query will not be filtered by any specific port ID.",
    "example": ".. code:: robotframework\n\n    | @{StaItems} | Create List | MinLatency | MaxLatency |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Port} | Get Ports |\n    | &{Result} | Get Port Latency Statistic | Port=${Port} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_streamblock_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "If exactly one matching StreamBlock statistic row is found, returns a dictionary. If multiple rows match, returns a pandas DataFrame. If no result is found, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamBlock or list/set/tuple of StreamBlock or None",
        "description": "One or more StreamBlock objects for which statistics are requested. If multiple are provided, their names are extracted for use as identifiers. If None, no specific identifier is used for filtering.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "Statistical items (columns) to retrieve. If None, all available properties are queried. If a string, it's converted into a single-element list. Must be a subset of available statistic properties for StreamBlocks.",
        "default": "not_found",
        "range_or_options": "TxPortID RxPortID TxStreamFrames RxStreamFrames TxFrameRate RxFrameRate TxL1Rate RxL1Rate TxUtil RxUtil RxLossStreamFrames RealtimeLossRate ResumeTime StartTime MinLatency MaxLatency AvaLatency MinJitter MaxJitter AvaJitter TxByteRate RxByteRate TxBitRate RxBitRate TxTotalBytes RxTotalBytes RxPayloadErr RxInSequenceCount RxFCSErr RxIpv4ChecksumError RxTcpChecksumError"
      },
      {
        "name": "Mode",
        "type": "bool",
        "description": "Controls whether performance-based methods are used to refresh statistics before retrieval. If True (default), internal performance counters may be refreshed prior to fetching stats. If False, statistics may be retrieved without refreshing first.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Retrieves statistical data for one or more StreamBlock objects based on specified criteria. This function prepares the identifiers for the given StreamBlock(s) and calls the internal `_get_statictis` method to fetch and filter statistics. It supports both single and multiple StreamBlock inputs. The behavior of the statistic retrieval can be controlled via the `Mode` and `ResultView` parameters.",
    "example": ".. code:: robotframework\n\n    | @{StaItems} | Create List | MinLatency | RxIpv4ChecksumError |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Stream} | Get Streams |\n    | &{Result} | Get Streamblock Statistic | Stream=${Stream} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_streamblock_tx_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回请求的流模块发送统计结果。若仅匹配一行数据，返回字典类型；若匹配多行，返回pandas DataFrame；若无匹配数据，返回False。",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list/set/tuple of objects or None",
        "description": "指定要获取统计信息的流模块对象或对象集合。若为对象，使用其`Name`属性；若为集合，提取每个元素的`Name`。若为None，则不按流模块过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects or None",
        "description": "指定要获取统计信息的端口对象或对象集合。若为对象，使用其`handle`属性；若为集合，提取每个元素的`handle`。若为None，则不按端口过滤。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None",
        "description": "需要获取的统计项列表，支持的统计项包括：StreamBlockID, PortID, ChannelCount, TxStreamFrames(发送报文数), TxFrameRate(发送速率fps), TxByteRate(发送字节速率Bps), TxBitRate(发送比特速率bps), TxL1Rate(发送线速bps), TxUtil(发送百分比%), TxTotalBytes(发送字节数)。若为字符串则转换为列表。若为None，则自动从ROM查询所有可用列。",
        "default": "not_found",
        "range_or_options": "StreamBlockID PortID ChannelCount TxStreamFrames TxFrameRate TxByteRate TxBitRate TxL1Rate TxUtil TxTotalBytes"
      },
      {
        "name": "Mode",
        "type": "bool",
        "description": "控制是否从仪表后台刷新并读取最新统计数据。True表示强制刷新后读取，False可能使用缓存值。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取测试仪表中指定流模块和端口的发送统计信息（如帧数、速率等）。它调用底层方法通过性能优化方式读取仪表后台数据，并根据输入参数过滤特定流块和端口的统计结果。支持多种统计项选择，并能处理单条或多条结果的返回格式。",
    "example": ".. code:: robotframework\n\n    | @{StaItems} | Create List | MinLatency | RxIpv4ChecksumError |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Stream} | Get Streams |\n    | &{Result} | Get Streamblock Tx Statistic | Stream=${Stream} | Port=${Port} | StaItems=@{StaItems} |\n    | Clear Result"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_streamblock_rx_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary if there is exactly one matching row of statistics, a pandas DataFrame if multiple rows match the criteria, or False if no matching result is found.",
    "description": "Retrieves receive statistics for one or more stream blocks on specified ports. The function gathers and filters StreamBlockRxStats-type statistics using `_get_statictis()`. It supports filtering by stream block(s) and/or port(s), and allows specification of which statistical items to return.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list/set/tuple of objects, optional",
        "description": "Specifies one or more stream block objects to filter statistics. If a single object is provided, its `.Name` attribute is used. If a collection is provided, the `.Name` attributes of all elements are collected. If None, no stream-based filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects, optional",
        "description": "Specifies one or more port objects to filter statistics. If a single object is provided, its `.handle` attribute is used. If a collection is provided, the `.handle` attributes of all elements are collected. If None, no port-based filtering is applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "Specifies which statistical properties (columns) to retrieve. If None, defaults to querying available properties via ListROMPropertiesCommand. If a string is provided, it is converted into a list with one item. Must be a subset of available StreamBlockRxStats properties.",
        "default": "not_found",
        "range_or_options": "StreamBlockID PortID LoadBalance RxStreamFrames RxFrameRate RxByteRate RxSeqErr RxPayloadErr MinLatency MaxLatency AvaLatency ShortTermAvgLatency RxBitRate RxUtil MinJitter MaxJitter AvaJitter ShortTermAvgJitter RxLossStreamFrames RxIpLengthErrorCount RxL1Rate RxIpv4ChecksumErrorFrames PrbsFillBytes DuplicateFrames InOrderFrames ReOrderFrames PrbsErrorBits PrbsErrorFrames RxFcsErrorFrames RxFcsErrorFrameRate TcpChecksumErrorFrames RxAvgRate RxAvgFps RxMaxRate RxMaxFps RxTotalBytes RxLateCount RxInSequenceCount RxOutofSequenceCount RxMinInterArrivalTime RxMaxInterArrivalTime RxAvgInterArrivalTime RxShortTermAvgInterArrivalTime"
      },
      {
        "name": "Mode",
        "type": "bool, optional",
        "description": "Controls how statistics are retrieved when not in ResultView mode. If True, internal performance-based methods are called to refresh or collect statistics before retrieval.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "example": ">>> api.get_streamblock_rx_statistic(Stream=stream1, Port=port1, StaItems=['Rx Frames', 'Rx Bytes'])\n{'Rx Frames': 1000, 'Rx Bytes': 64000}",
    "exceptions": [
      {
        "exception_type": "TesterException",
        "description": "May be raised during command execution or data retrieval if issues occur in the test equipment interaction."
      },
      {
        "exception_type": "sqlite3.Error",
        "description": "If any database access errors occur during performance-based statistic retrieval."
      },
      {
        "exception_type": "KeyError",
        "description": "If column names specified in the internally constructed `Idx` do not exist in the resulting DataFrame."
      }
    ],
    "side_effects": [
      "Modifies internal state by potentially calling `.get()` on various objects to refresh their data.",
      "Executes commands like GotoResultPageCommand for navigating paginated results.",
      "Uses time.sleep(3) to allow for data consistency when navigating between pages in ResultView.",
      "Logs the resulting DataFrame in a tabulated format for debugging purposes."
    ]
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_stream_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "Returns a dictionary with statistic names and values if exactly one stream result is found, a pandas DataFrame if multiple results are found, or False if no matching results exist.",
    "parameters": [
      {
        "name": "Stream",
        "type": "Stream object or list/set/tuple of Stream objects, optional",
        "description": "Specifies the stream or streams for which statistics are retrieved. If provided, the Name attribute(s) of the stream(s) will be used as 'StreamBlockID' in the query. If None (default), 'StreamBlockID' will be None.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamID",
        "type": "str or int or list, optional",
        "description": "An identifier for filtering statistics by specific stream IDs. Can be a single ID or multiple IDs. Used to narrow down results to particular streams in the system.",
        "default": "not_found",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StaItems",
        "type": "list of str, optional",
        "description": "List of specific statistic names (columns) to retrieve. If not provided, defaults to a comprehensive set of stream-related metrics including frame transmission/reception counts, rate information, latency, jitter, utilization, byte/bit rates, and various error counters.",
        "default": "not_found",
        "range_or_options": "StreamBlockID StreamID TxPortID RxPortID LoadBalance TxStreamFrames RxStreamFrames TxFrameRate RxFrameRate TxL1Rate RxL1Rate RxLossStreamFrames RealtimeLossRate ResumeTime StartTime TxUtil RxUtil RxPayloadErr RxSeqErr RxIpLengthErrorCount TxByteRate RxByteRate TxBitRate RxBitRate MinLatency MaxLatency AvaLatency MinJitter MaxJitter AvaJitter RxIpv4ChecksumErrorFrames PrbsFillBytes DuplicateFrames InOrderFrames ReOrderFrames PrbsErrorBits PrbsErrorFrames RxFcsErrorFrames RxFcsErrorFrameRate TcpChecksumErrorFrames LostStreamFrames"
      },
      {
        "name": "Mode",
        "type": "bool, optional",
        "description": "Controls whether internal performance-based methods should be invoked before retrieving statistics. If True (default), ensures statistics are refreshed before querying. If False, retrieves current cached values without refreshing.",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Retrieves stream-level statistics for one or more traffic streams in a test scenario. This function gathers detailed performance metrics such as frame counts, rates, latency, jitter, and various error counters for the specified stream(s). It acts as a wrapper around the _get_statictis method with pre-configured statistical items relevant to stream-level data when operating in database mode. The target stream(s) can be identified either directly via a stream object or by StreamID.",
    "example": ">>> api.get_stream_statistic(Stream=my_stream)\n{'StreamBlockID': 'Stream1', 'TxStreamFrames': 10000, 'RxStreamFrames': 9950, 'MinLatency': 1.2, ...}"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_stream_tx_statistic",
    "return_type": "dict or pd.DataFrame or bool",
    "return": "返回获取的流发送统计结果。若只有一行数据，返回字典；若多行，返回pandas DataFrame；若无匹配项则返回False。",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamBlock object or list/set/tuple of StreamBlock objects, optional",
        "description": "指定要查询统计信息的一个或多个流模板对象。如果提供单个对象，则使用其名称；如果是多个对象，则收集它们的名称。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "Port object or list/set/tuple of Port objects, optional",
        "description": "与流相关联的一个或多个端口对象。用于限定统计信息查询范围。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamID",
        "type": "str or int, optional",
        "description": "指定需要查询的流模板的唯一标识符（ID）。",
        "default": "None",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "StaItems",
        "type": "list or str or None, optional",
        "description": "需要获取的统计项列表。可以是字符串或列表形式，支持的统计项包括：StreamID、StreamBlockID、ChannelId、PortID、TxStreamFrames、TxFrameRate、TxByteRate、TxBitRate、TxL1Rate、TxUtil、TxTotalBytes。",
        "default": "None",
        "range_or_options": "StreamID StreamBlockID ChannelId PortID TxStreamFrames TxFrameRate TxByteRate TxBitRate TxL1Rate TxUtil TxTotalBytes"
      },
      {
        "name": "Mode",
        "type": "bool, optional",
        "description": "是否从仪表后台刷新并读取最新统计信息。True表示刷新后读取，False表示使用已有数据。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "该函数用于获取一个或多个流模板的发送统计信息，包括发送报文数、速率、字节率、线速、利用率等关键指标。可用于性能监控和测试分析。",
    "example": ".. code:: robotframework\n\n    | @{StaItems} | Create List | TxUtil | TxTotalBytes |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Stream} | Get Streams |\n    | &{Result} | Get Stream Tx Statistic | Stream=${Stream} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Statistic.common.get_stream_rx_statistic",
    "return_type": "dict or pandas.DataFrame or bool",
    "return": "If exactly one matching row is found: returns a dictionary. If multiple rows match: returns a pandas DataFrame. If no matching result is found: returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A stream object or collection of stream objects. If provided, their `Name` attributes are extracted to identify stream blocks.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "object or list/set/tuple of objects, optional",
        "description": "A port object or collection of port objects. If provided, their `handle` attributes are extracted to identify ports.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamID",
        "type": "str or int, optional",
        "description": "The ID of the stream for additional filtering.",
        "default": "None",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Mode",
        "type": "bool, optional",
        "description": "Controls whether performance-based methods are used to refresh statistics before retrieval.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "StaItems",
        "type": "list or str, optional",
        "description": "Statistical items (columns) to retrieve. If None, all available items are fetched. If a string, it is converted into a single-element list.",
        "default": "None",
        "range_or_options": "StreamID StreamBlockID ChannelId PortID LoadBalance RxStreamFrames RxFrameRate RxByteRate RxSeqErr RxPayloadErr MinLatency MaxLatency AvaLatency ShortTermAvgLatency RxBitRate RxUtil MinJitter MaxJitter AvaJitter ShortTermAvgJitter RxLossStreamFrames RxIpLengthErrorCount RxIpv4ChecksumErrorFrames PrbsFillBytes DuplicateFrames InOrderFrames ReOrderFrames PrbsErrorBits PrbsErrorFrames RxFcsErrorFrames RxFcsErrorFrameRate TcpChecksumErrorFrames RxL1Rate RxTotalBytes RxLateCount RxInSequenceCount RxOutofSequenceCount RxMinInterArrivalTime RxMaxInterArrivalTime RxAvgInterArrivalTime RxShortTermAvgInterArrivalTime"
      }
    ],
    "kwargs": [],
    "description": "Retrieves receive statistics for one or more streams based on provided identifiers and filters. This function acts as a convenience wrapper around `_get_statictis`, pre-configuring it to fetch 'StreamRxStats' type statistics. It supports filtering by stream objects, port handles, stream IDs, and specific statistical items.",
    "example": ".. code:: robotframework\n\n    | @{StaItems} | Create List | RxAvgInterArrivalTime | RxShortTermAvgInterArrivalTime |\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | ${Stream} | Get Streams |\n    | &{Result} | Get Stream Rx Statistic | Stream=${Stream} | StaItems=@{StaItems} |\n    | Clear Result |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.add_stream",
    "return_type": "list (:obj:`StreamTemplate`)",
    "return": "A list of created stream template objects. Returns a single stream if only one is created, otherwise returns a list of streams.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "Type of stream to create",
        "default": "'raw'",
        "range_or_options": "raw binding pcap"
      },
      {
        "name": "Ports",
        "type": "Port object or list of Port objects",
        "description": "Port(s) where the stream will be added (required for 'raw' and 'pcap')",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Names",
        "type": "str or list of str",
        "description": "Name(s) to assign to the created stream(s)",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "FilePath",
        "type": "str",
        "description": "Path to PCAP file (required only if Type is 'pcap')",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IncludeCrc",
        "type": "bool",
        "description": "Whether to include CRC in packets when loading from a PCAP file (applicable only if Type is 'pcap')",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "SrcPoints",
        "type": "Endpoint object or list of Endpoint objects",
        "description": "Source endpoint(s) for binding streams (overrides SrcInterface if both are provided)",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DstPoints",
        "type": "Endpoint object or list of Endpoint objects",
        "description": "Destination endpoint(s) for binding streams (overrides DstInterface if both are provided)",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SrcInterface",
        "type": "Interface object or list of Interface objects",
        "description": "Source interface(s) from which to derive source endpoints for binding streams (used if Type is 'binding' and SrcPoints is not provided)",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DstInterface",
        "type": "Interface object or list of Interface objects",
        "description": "Destination interface(s) from which to derive destination endpoints for binding streams (used if Type is 'binding' and DstPoints is not provided)",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Bidirection",
        "type": "bool",
        "description": "If True, creates bidirectional traffic between source and destination endpoints (applicable only if Type is 'binding')",
        "default": "not_found",
        "range_or_options": "True False"
      },
      {
        "name": "Direction",
        "type": "str",
        "description": "Direction of traffic for binding streams",
        "default": "not_found",
        "range_or_options": "source_to_destination destination_to_source other_valid_direction_strings"
      },
      {
        "name": "Layer",
        "type": "str",
        "description": "Protocol layer to use for binding streams",
        "default": "'IPV4'",
        "range_or_options": "ETHERNETII VLAN GRE IPV4 IPV6"
      },
      {
        "name": "TrafficMeshMode",
        "type": "int",
        "description": "Specifies how endpoints are paired in binding streams",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EndpointMapping",
        "type": "list of tuples",
        "description": "Custom mapping between source and destination endpoints",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "AutoCreateTunnel",
        "type": "bool",
        "description": "If True, automatically creates tunnels for binding streams",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StreamOnly",
        "type": "bool",
        "description": "Configures whether the stream should be treated as 'stream-only' mode",
        "default": "not_found",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict",
        "description": "Additional attributes to apply to the created stream(s), passed through `edit_stream`. These may include any valid stream properties like rate, frame size, etc.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Adds a stream of specified type (raw, pcap, or binding) to the test configuration with optional configurations. Depending on the Type parameter, different sets of parameters are used. The created stream(s) can be further customized using keyword arguments via `edit_stream`.",
    "example": ".. code:: RobotFramework\n\n    # raw流\n    | ${Streams} | add_stream | Port=${Port} |\n    # pcap流\n    | ${Streams} | add_stream | Type=pcap |  Port=${Port} |  FilePath=${Pcap_File_Path} | IncludeCrc=True |\n    # binding流\n    | ${Streams} | add_stream | Type=binding |  SrcPoints=${Points_1} | DstPoints=${Points_2} |  Bidirection=True |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.edit_stream",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Stream",
        "type": ":obj:`StreamTemplate`",
        "description": "测试仪表流量对象，类型为StreamTemplate。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RepeatCount",
        "type": "int",
        "description": "流模板发送重复次数。",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableSignature",
        "type": "bool",
        "description": "启用签名。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "FrameLengthType",
        "type": "str",
        "description": "流模板帧长度类型。",
        "default": "FIXED",
        "range_or_options": "FIXED INCREMENT RANDOM AUTO DECREMENT IMIX"
      },
      {
        "name": "RandomLengthSeed",
        "type": "int",
        "description": "随机种子。",
        "default": "10900842",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "FixedLength",
        "type": "int",
        "description": "固定帧长。",
        "default": "128",
        "range_or_options": "12-16383"
      },
      {
        "name": "MinLength",
        "type": "int",
        "description": "最小帧长。",
        "default": "128",
        "range_or_options": "12-16383"
      },
      {
        "name": "MaxLength",
        "type": "int",
        "description": "最大帧长。",
        "default": "256",
        "range_or_options": "12-16383"
      },
      {
        "name": "StepLength",
        "type": "int",
        "description": "帧长跳变步长。",
        "default": "1",
        "range_or_options": "1-8192"
      },
      {
        "name": "PayloadType",
        "type": "str",
        "description": "净荷类型。",
        "default": "CYCLE",
        "range_or_options": "CYCLE INCREMENT RANDOM"
      },
      {
        "name": "PayloadValue",
        "type": "str",
        "description": "帧长跳变步长值。",
        "default": "0x0",
        "range_or_options": "not_found"
      },
      {
        "name": "PayloadValueType",
        "type": "str",
        "description": "净荷值类型。",
        "default": "CYCLE",
        "range_or_options": "SINGLE_BYTE DOUBLE_BYTE"
      },
      {
        "name": "EnableNDResponse",
        "type": "bool",
        "description": "使用ARP ND自动回复。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "TopLayerType",
        "type": "str",
        "description": "流模板报文模板类型。",
        "default": "IPV4",
        "range_or_options": "ETHERNETII VLAN GRE IPV4 IPV6"
      },
      {
        "name": "RxPorts",
        "type": "list (:obj:`Port`)",
        "description": "指定流量收端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "TrafficMeshMode",
        "type": "str",
        "description": "binding流参数。",
        "default": "MANY_TO_MANY",
        "range_or_options": "ONE_TO_ONE MANY_TO_MANY FULL_MESH CONGESTION LEARNING BACK_BONE PAIR"
      },
      {
        "name": "HostsMesh",
        "type": "str",
        "description": "binding流参数。",
        "default": "ROUND_ROBIN",
        "range_or_options": "ROUND_ROBIN MANY_TO_MANY"
      }
    ],
    "description": "修改测试仪表流量模板参数。该函数用于编辑一个或多个流模板的属性，并可配置接收端口。支持设置多种流行为相关参数，如帧长度、净荷类型、拓扑模式等。",
    "example": "| Edit Stream | Stream=${Stream} | TopLayerType=ETHERNETII | TrafficMeshMode=FULL_MESH |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.create_stream_header",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Stream",
        "type": ":obj:`StreamTemplate`",
        "description": "测试仪表流量对象，用于指定需要操作的流。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int or None",
        "description": "报文头部插入的位置索引。当 Index 为 None 时，表示重新创建流量报文类型；绑定流时需要指定该参数。",
        "default": "None",
        "range_or_options": "0-16383"
      },
      {
        "name": "HeaderTypes",
        "type": "list",
        "description": "报文头部类型列表，支持多种协议类型（不区分大小写）。",
        "default": "not_found",
        "range_or_options": "ethernetii raw vlan vxlan arp gre ipv4 ipv6 tcp udp l2tpv2data l2tpv2control l2tpv3controloverip l2tpv3controloverudp l2tpv3dataoverip l2tpv3dataoverudp dhcpv4server dhcpv4client dhcpv6client dhcpv6server ppp pppoe pppoediscovery icmpv4echorequest destunreach icmpv4echoreply informationreply informationrequest icmpv4parameterproblem icmpv4redirect sourcequench timeexceeded timestampreply timestamprequest icmpmaskrequest icmpmaskreply destinationunreachable icmpv6echoreply icmpv6echorequest packettoobig icmpv6parameterproblem timeexceed routersolicit routeradvertise icmpv6redirect neighborsolicit neighboradvertise mldv1query mldv1report mldv1done mldv2query mldv2report igmpv1 igmpv1query igmpv2 igmpv2query igmpv3report igmpv3query custom ospfv2linkstateupdate ospfv2linkstaterequest ospfv2databasedescription ospfv2linkstateacknowledge ospfv2unknown ospfv2hello mpls l1csnpheader isisl1helloheader l1lspheader l1psnpheader l2csnpheader isisl2helloheader l2lspheader l2psnpheader p2phelloheader gtpv1 gtpv1opt gtpv1exthdr gtpv1ext ipv6fragmentheader ipv6routingheader ipv6authenticationheader ipv6destinationheader ipv6encapsulationheader ipv6hopbyhopheader ipv6srheader stag encapethernetii encapbackboneeth itag mac-in-mac encapcustomereth portmanagement bier ccm chdlc cw elsflogi 8023 goose logiclinkcontrol cfg pause pfc vntag fc chassisidtlv portidtlv ttltlv endtlv hsrtag prptag rtag sctp trill"
      }
    ],
    "kwargs": [],
    "description": "该函数用于在指定流中创建或插入一个或多个报文头部。支持多种常见的网络协议头，并可以指定插入位置。如果 Index 为 None，则会重新创建整个报文结构；否则会在指定位置插入新头部。",
    "example": ".. code:: RobotFramework\n\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | TCP |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.edit_modifier",
    "return_type": "dict",
    "return": "A dictionary containing details of the applied modifier with keys 'Stream', 'Header', 'Attribute', and 'Index'.",
    "description": "Edits or configures a header modifier for a specific stream and header attribute. If the modifier does not exist, it will be created. The modification is applied immediately to the system.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object (StreamTemplate) that uniquely identifies the traffic stream. Must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Attribute",
        "type": "str",
        "description": "Name of the header field to modify. Can optionally include a header prefix like 'Ethernet.Header.MAC'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of headers in the stream. When HeaderType is None, this selects the header by its position across all types; when HeaderType is provided, this selects among headers of the specified type.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the modifier within the header's modifier list. If None, the first available index will be used or auto-assigned.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of modification behavior: Increment, Decrement, Random, or List.",
        "default": "None",
        "range_or_options": "Increment Decrement Random List"
      },
      {
        "name": "Start",
        "type": "str",
        "description": "Starting value for the modifier (e.g., IP address or port).",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of values to generate or apply.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "Step between generated values (e.g., increment step).",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Repeat",
        "type": "int",
        "description": "Number of times to repeat the pattern or sequence.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Range",
        "type": "int",
        "description": "Specifies a range for random variation in randomized modifiers.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Seed",
        "type": "int",
        "description": "Seed value for deterministic randomization.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamType",
        "type": "str",
        "description": "Type of stream modifier: IntraModifier or InterModifier.",
        "default": "None",
        "range_or_options": "IntraModifier InterModifier"
      },
      {
        "name": "Offset",
        "type": "int",
        "description": "Offset from the start of the field where the modifier should begin applying.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Mask",
        "type": "str",
        "description": "Bitmask or mask string applied to the modified field.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "List",
        "type": "list",
        "description": "An explicit list of values to use when Type is List.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderType",
        "type": "str",
        "description": "Filter the headers to apply the modifier only to headers of this type (case-insensitive). If None, Level determines which header to select.",
        "default": "None",
        "range_or_options": "ethernetii vlan vxlan arp ipv4 ipv6 tcp udp l2tpv2data ppp icmpv4echorequest destunreach icmpv4echoreply informationreply informationrequest icmpv4parameterproblem icmpv4redirect sourcequench timeexceeded timestampreply timestamprequest icmpmaskrequest icmpmaskreply destinationunreachable icmpv6echoreply icmpv6echorequest packettoobig icmpv6parameterproblem timeexceed routersolicit routeradvertise icmpv6redirect neighborsolicit neighboradvertise mldv1query mldv1report mldv1done mldv2query mldv2report igmpv1 igmpv1query igmpv2 igmpv2query igmpv3report igmpv3query custom ospfv2linkstateupdate ospfv2linkstaterequest ospfv2databasedescription ospfv2linkstateacknowledge ospfv2unknown ospfv2hello mpls"
      }
    ],
    "example": "| ${Streams} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | TCP |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n# 不指定HeaderType, Level=1选中IPv4头部\n| Edit Modifier | Stream=${Stream} | Level=1 | Attribute=source | Start=192.168.1.1 | Count=10 | Step=1 |\n# 指定HeaderType=IPv4, Level=0选中IPv4头部\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=destination | Start=192.168.1.1 | Count=10 | Step=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.edit_modifier_link",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the command. Returns False on failure, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or iterable",
        "description": "The stream object or an iterable containing a stream object. The stream must have a 'handle' attribute for unique identification in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Link",
        "type": "list or list of lists",
        "description": "A list representing link information. Each element should be a dictionary with keys: 'Header', 'Attribute', and 'Index'. If sublists exist (list of links), each is processed individually.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LinkModifierType",
        "type": "str",
        "description": "Specifies the type of modifier being applied. This value is passed directly to the backend command and may affect how the modifier is interpreted.",
        "default": "'MODIFIER_ID'",
        "range_or_options": "MODIFIER_ID LINK_MODIFIER_PATH"
      },
      {
        "name": "BindingModifier",
        "type": "bool",
        "description": "If True, binds the modifier to the link; if False, does not bind. Affects persistence or behavior of the modifier in the system context.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Edits a modifier link for a given stream in the Renix API. This function constructs and executes a command to update a link modifier associated with a specific stream. It supports both single and multiple link configurations, formatting the parameters accordingly for execution. Internally, it uses `UpdateLinkModifierCommand` to apply changes through the system's command execution mechanism.",
    "example": "::\n\n    | ${Streams} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | TCP |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    # 不指定HeaderType, Level=1选中IPv4头部\n    | ${Modifier_1} | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=source | Start=192.168.1.1 | Count=10 | Step=1 |\n    # 指定HeaderType=IPv4, Level=0选中IPv4头部\n    | ${Modifier_2} | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=destination | Start=192.168.1.1 | Count=10 | Step=1 |\n    | ${LinkModifier} | Create List | ${Modifier_1} | ${Modifier_2} |\n    | Edit Modifier Link | Stream=${Stream} | Link=${LinkModifier} |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.select_rx_port",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Streams",
        "type": "list (:obj:`StreamTemplate`)",
        "description": "测试仪表流量对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RxPorts",
        "type": "list (:obj:`Port`)",
        "description": "指定流量接收端口对象列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "int",
        "description": "模式，用于定义收发端口映射关系。支持的模式：ONE_TO_ONE (1), ONE_TO_MANY (2), MANY_TO_ONE (3), PAIR (4)。",
        "default": "1",
        "range_or_options": "1 2 3 4"
      },
      {
        "name": "ExcludeTxPort",
        "type": "bool",
        "description": "是否排除发送端口作为接收端口。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "该函数用于为指定的流量（Streams）配置其接收端口（RxPorts），在 Renix 测试环境中实现流量接收端口的选择与绑定。内部调用 `SelectRxPortCommand` 命令完成实际操作。每个 Stream 和 Port 对象必须包含唯一标识符 `handle`。此方法封装了底层命令交互，并确保参数正确传递。",
    "example": "| Select Rx Port | Streams=${Streams} | RxPorts=${Ports} | Mode=ONE_TO_MANY | ExcludeTxPort=True |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.start_stream",
    "return_type": "bool",
    "return": "Returns True if the stream(s) are started successfully, otherwise False.",
    "parameters": [
      {
        "name": "Type",
        "type": "str or None",
        "description": "Specifies how streams should be selected for starting. If 'port', it starts all streams associated with the provided port objects. If None, all available streams are started. If unspecified, it assumes direct stream objects are provided in 'Objects'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Objects",
        "type": "list or object or None",
        "description": "A single object or list of objects representing either ports (if Type='port') or streams to start directly. If not specified and Type is None, all streams will be started.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function initiates data transmission from test equipment by starting one or more data streams based on the given parameters. If no type is specified, it starts all available streams. If Type is set to 'port', it starts all streams associated with the specified port objects. Otherwise, it treats the Objects parameter as direct references to stream objects that should be started. This function internally calls the backend API to execute the start command and wraps either StartAllStreamCommand or StartStreamCommand depending on the input.",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | @{Objects} | Get Ports |\n    | Start Stream | Type=port | Objects=@{Objects} |\n    | Sleep | 10 |\n    | Stop Stream | Type=port | Objects=@{Objects} |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.stop_stream",
    "return_type": "bool",
    "return": "Indicates whether the stop stream command was executed successfully (True) or failed (False).",
    "parameters": [
      {
        "name": "Type",
        "type": "str, optional",
        "description": "Specifies the type of object in 'Objects'. If None, all streams are stopped. If 'port', streams associated with the given port objects are stopped.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Objects",
        "type": "list or object, optional",
        "description": "A single object or list of objects for which streams need to be stopped. When Type is 'port', each object in Objects is expected to have children of type 'StreamTemplate'. When Type is not 'port', the objects themselves are expected to be stream-related entities.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops one or more streams based on the provided Type and Objects parameters. This function constructs and executes a command to stop stream(s), either globally (all streams) or specific to given objects. It internally uses StopAllStreamCommand or StopStreamCommand depending on the input arguments.\n\n- If Type is None, this function stops all streams using StopAllStreamCommand.\n- If Type is 'port', it retrieves all child 'StreamTemplate' objects from the provided ports, collects their handles, and stops those streams.\n- Otherwise, it treats the provided objects as stream-related entities, collects their handles, and stops the corresponding streams.",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start Stream |\n    | Sleep | 10 |\n    | Stop Stream |\n    | Sleep | 3 |\n    | @{Objects} | Get Ports |\n    | Start Stream | Types=port | Objects=@{Objects} |\n    | Sleep | 10 |\n    | Stop Stream | Types=port | Objects=@{Objects} |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.wait_stream_state",
    "return_type": "bool",
    "return": "True if all streams reach one of the expected states within the timeout; False otherwise.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate or list/set/tuple of StreamTemplate, optional",
        "description": "The stream or streams to monitor. If None (default), all streams managed by the rom_manager will be considered.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "State",
        "type": "str or list/set/tuple of str, optional",
        "description": "The target state or states that each stream should reach. Valid states include 'disabled', 'notready', 'ready', 'running', 'stopped', 'paused'. Defaults to ['ready'].",
        "default": "['READY']",
        "range_or_options": "'DISABLED' 'NOTREADY' 'READY' 'RUNNING' 'STOPPED' 'PAUSED'"
      },
      {
        "name": "TimeOut",
        "type": "int, optional",
        "description": "Maximum time in seconds to wait for all streams to reach the desired state(s). Defaults to 60 seconds.",
        "default": "60",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Waits until all specified streams reach one of the desired states or until a timeout occurs. This function continuously checks the current state of each provided stream (or all known streams if none is provided). It waits until every stream has entered one of the specified target states. If the timeout is reached before all streams are in the correct state, it logs a timeout message and returns False. Otherwise, it returns True once all streams have reached the expected state(s).",
    "example": ".. code:: RobotFramework\n\n    | Start Stream |\n    | Sleep | 10 |\n    | Wait Stream State |\n    | Sleep | 3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.start_l2_learning",
    "return_type": "bool",
    "return": "Boolean indicating success (True) or failure (False) of initiating L2 learning. If False, a ContinuableFailure exception is raised.",
    "description": "Starts Layer 2 (L2) learning on specified ports or streams using the Renix API. This function initiates L2 learning either on provided ports, specific streams, or all available stream templates in the system if neither ports nor streams are specified. It supports both standard L2 learning and RX-based L2 learning depending on the 'Type' parameter.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of L2 learning to perform. If None, standard L2 learning is initiated using StartL2LearningCommand. If a value is provided (typically indicating RX-based learning), StartL2RxLearningCommand is used instead.",
        "default": "not_found",
        "range_or_options": "Tx Rx"
      },
      {
        "name": "Ports",
        "type": "list or object",
        "description": "A port or list of ports to perform L2 learning on. Each port should be an object that has a method get_children('StreamTemplate') which returns stream templates. If not None, Streams must be None.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "list or object",
        "description": "A stream or list of streams to use for L2 learning. Each stream must have a 'handle' attribute. If not None, Ports must be None.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "WaitLearningDone",
        "type": "bool",
        "description": "If True, the function will wait until the learning process completes before returning. If False, it starts the learning asynchronously. Only applicable when Type is None.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "WaitTime",
        "type": "int",
        "description": "Maximum time in seconds to wait for learning to complete. Only applicable when Type is None and WaitLearningDone is True.",
        "default": "30",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start L2 Learning |\n    | Sleep | 10 |\n    | Stop L2 Learning |\n    | Sleep | 3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.stop_l2_learning",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Ports",
        "type": "list (:obj:`Port`)",
        "description": "测试仪表端口对象列表，用于指定在哪些端口上停止L2学习。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "list (:obj:`StreamTemplate`)",
        "description": "测试仪表流量模板对象列表，用于指定在哪些流模板上停止L2学习。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于停止指定端口或流模板上的二层（L2）学习过程。如果提供了Ports参数，则会在指定的端口上停止L2学习；如果提供了Streams参数，则会在指定的流模板上停止L2学习；若两者均未提供，则默认对系统中所有可用的流模板执行停止操作。该函数通过调用底层Renix API实现功能。",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start L2 Learning |\n    | Sleep | 10 |\n    | Stop L2 Learning |\n    | Sleep | 3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.start_l3_learning",
    "return_type": "str or bool",
    "return": "Returns EnumBase.TRUE.value (typically a string representing true state) if the operation was successfully initiated. If the operation fails, it returns False and raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list], optional",
        "description": "A port or a list of ports whose associated stream templates will be used for starting L3 learning. Each port object must have a method 'get_children' that can retrieve 'StreamTemplate' children.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "Union[object, list], optional",
        "description": "A stream or a list of streams for which L3 learning should be initiated. Each stream object must have a 'handle' attribute.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Starts Layer 3 (L3) learning on specified ports or streams. This function initiates ARP learning for either all stream templates associated with the provided ports or for explicitly given streams. It ensures that only one of 'Ports' or 'Streams' is used at a time. If both are None, it starts ARP learning on all streams. Using both 'Ports' and 'Streams' simultaneously raises a TesterException.",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start L3 Learning |\n    | Sleep | 10 |\n    | Stop L3 Learning |\n    | Sleep | 3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.stop_l3_learning",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[object, list], optional",
        "description": "端口或端口列表对象，用于获取关联的流量模板以停止L3学习。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "Union[object, list], optional",
        "description": "流量模板或流量模板列表对象，直接指定需要停止L3学习的流量。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于停止测试仪表中指定端口或流量模板的三层（L3）ARP学习。它确保只能同时使用 'Ports' 或 'Streams' 中的一个参数进行操作。如果两者同时提供，会抛出异常。若均未提供，则停止所有流的L3学习。",
    "example": ".. code:: RobotFramework\n\n    | Subscribe Result |\n    | Start L3 Learning |\n    | Sleep | 10 |\n    | Stop L3 Learning |\n    | Sleep | 3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.del_stream",
    "return_type": "bool",
    "return": "True if the deletion was successful (including partial success in case of multiple deletions). False if both `Ports` and `Streams` are provided, which is considered an invalid operation.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port], Set[Port], Tuple[Port]], optional",
        "description": "A single port or a collection of ports whose associated streams should be deleted. If provided, only streams attached to these ports will be deleted.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "Union[StreamTemplate, List[StreamTemplate], Set[StreamTemplate], Tuple[StreamTemplate]], optional",
        "description": "A single stream or a collection of stream templates to delete. If provided, these specific streams will be deleted regardless of their associated ports.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Deletes specified stream templates either associated with given ports or provided directly. This function handles multiple scenarios: \n- If neither `Ports` nor `Streams` is provided, it deletes all stream templates in the current session.\n- If only `Ports` is provided, it deletes all stream templates attached to the specified ports.\n- If only `Streams` is provided, it deletes the specified stream templates.\n- If both `Ports` and `Streams` are provided, the function returns False indicating an invalid combination.\n\nNotes:\n- The function also removes associated handlers for each stream from the global `map_stream_header`.\n- Each stream template is deleted using its `delete()` method.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream_1} | Add Stream | Ports=${Port_1} |\n    | ${Stream_2} | Add Stream | Ports=${Port_2} |\n    | ${Stream_2} | Add Stream | Ports=${Port_3} |\n    | Del Stream | Streams=${Stream_1} |\n    | Del Stream | Ports=${Port_2} |\n    | Del Stream |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.get_streams",
    "return_type": "list of StreamTemplate objects",
    "return": "A list of StreamTemplate objects representing the streams configured on the specified port(s). Each StreamTemplate object contains information about the stream, including its handle and associated headers after mapping.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Port object or list of Port objects, optional",
        "description": "A single port or a list of ports to retrieve streams from. If None (default), all ports in the system are considered.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves all StreamTemplate objects (streams) associated with the specified ports.\n\nIf no ports are provided, streams from all available ports in the system are retrieved.\nAdditionally, this function configures the header map for all retrieved streams by calling\n`set_stream_header_map`, which prepares and maps header objects for each stream.\n\nDescription:\n    - When `Ports` is None:\n      1. The function retrieves all port objects under the system entry using `get_children('Port')`.\n      2. For each port, it fetches the associated StreamTemplate objects and accumulates them into a result list.\n    - When `Ports` is provided:\n      1. It ensures the input is a list (if not, wraps it into a list).\n      2. For each port in the list, it fetches the associated StreamTemplate objects and adds them to the result.\n    - After collecting all streams, it calls `set_stream_header_map(Streams=result)` to configure\n      the header mappings for these streams.\n\nThis function is typically used to gather all relevant streams for further configuration or analysis,\nespecially when working with network traffic simulation or test scenarios involving multiple ports.",
    "example": "| Get Streams | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.start_stream_arp",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True 表示成功，False 表示失败）",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port]], optional",
        "description": "端口或端口列表，其关联的流将启动ARP功能。如果未指定 Ports 和 Stream，则会为系统中所有流启动ARP。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Stream",
        "type": "Union[Stream, List[Stream]], optional",
        "description": "一个具体的流对象或多个流对象列表，用于启动ARP传输。若提供了 Stream，则 Ports 必须为 None。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于在指定的端口上或特定的流对象上启动ARP传输功能。用户可以通过指定 Ports 或 Stream 参数来控制哪些流应触发ARP，若两者均不指定，则默认对系统中所有流启动ARP。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Start Stream Arp |"
  },
  {
    "method_name": "TesterLibrary.Stream.common.stop_stream_arp",
    "return_type": "bool",
    "return": "True if the operation is successful, False otherwise.",
    "parameters": [
      {
        "name": "Ports",
        "type": "Union[Port, List[Port]]",
        "description": "A single Port object or a list of Port objects whose associated streams should have their ARP stopped. This parameter must be None if Stream is provided.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Stream",
        "type": "Union[Stream, List[Stream]]",
        "description": "A single Stream object or a list of Stream objects for which ARP should be stopped. This parameter must be None if Ports is provided.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Stops ARP stream(s) either associated with specific ports or directly specified stream objects.\n\nThis function allows stopping ARP streams in three different modes:\n- If `Stream` is provided, it will stop ARP on those specific stream(s), and `Ports` must be None.\n- If no `Stream` is provided but `Ports` are given, it stops ARP for all streams associated with the specified port(s).\n- If neither `Ports` nor `Stream` is provided, it stops ARP on all streams globally.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Stop Stream Arp |"
  },
  {
    "method_name": "TesterLibrary.Stream.imix.create_imix",
    "return_type": "IMix",
    "return": "Imix模板对象，用于标识创建的IMix实例。",
    "parameters": [
      {
        "name": "Name",
        "type": "str",
        "description": "创建的IMIX模板名称，通常用于标识该IMIX实例。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Seed",
        "type": "int or None",
        "description": "IMIX模板使用的随机种子值。如果未提供，则使用默认值None。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于创建并返回一个IMIX对象，该对象由指定的名称和可选的随机种子初始化。此函数作为IMIX构造函数的封装，为创建IMIX模板提供了便捷接口。在内部调用renix.create_imix()方法实现模板创建功能，并通过异常处理机制对失败情况做进一步处理。",
    "example": "| Create Imix | Name=Imix_1 | Seed=10121112 |"
  },
  {
    "method_name": "TesterLibrary.Stream.imix.get_imix_from_name",
    "return_type": "any",
    "return": "The IMIX value associated with the provided name. The type depends on the values stored in the `map_name_imix` dictionary.",
    "parameters": [
      {
        "name": "Name",
        "type": "str",
        "description": "The name for which the IMIX value is to be retrieved. This should be a key present in the `map_name_imix` dictionary.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Retrieves the corresponding IMIX value for a given name from a global or predefined mapping. This function uses a decorator `@abnormal_check()` which may perform additional checks or handle abnormal conditions before executing the main logic. It looks up the input name in a global dictionary `map_name_imix` and returns the associated IMIX value. If the provided `Name` does not exist in the `map_name_imix` dictionary, a KeyError will be raised.",
    "example": "| ${Imix_TCPv4} | Get Imix From Name | Name=TCPv4 |"
  },
  {
    "method_name": "TesterLibrary.Stream.imix.bind_stream_imix",
    "return_type": "bool",
    "return": "Returns True if the IMIX template is successfully bound to the stream, otherwise False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate",
        "description": "The StreamTemplate object representing the traffic stream to be associated with the IMIX template.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IMix",
        "type": "Imix",
        "description": "The Imix object representing the IMIX length distribution template to bind to the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Binds an IMIX template to a given traffic stream template. This function configures the stream's frame length type to use IMIX and associates it with the specified IMIX template for network testing purposes. If the binding fails, a ContinuableFailure exception is raised.",
    "example": ".. code:: RobotFramework\n\n    | ${Imix} | Create Imix | Name=Imix_1 | Seed=10121112 |\n    | Bind Stream Imix | Stream=${Stream} | Imix=${Imix} |"
  },
  {
    "method_name": "TesterLibrary.Stream.imix.add_imix_distribution_frame",
    "return_type": "bool",
    "return": "布尔值，表示是否成功将帧长分布配置添加到IMix对象（True = 成功，False = 失败）",
    "parameters": [
      {
        "name": "IMix",
        "type": "object",
        "description": "测试仪表中的IMix模板对象，必须支持`add_frame_length`方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "指定帧长的分布类型。用于定义帧长度是如何选择的。",
        "default": "'fixed'",
        "range_or_options": "fixed random"
      },
      {
        "name": "Length",
        "type": "int or float",
        "description": "当Type为'fixed'时使用的固定帧长值。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Min",
        "type": "int or float",
        "description": "当Type为'random'或类似范围类型时使用的最小帧长。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Max",
        "type": "int or float",
        "description": "当Type为'random'或类似范围类型时使用的最大帧长。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Weight",
        "type": "int or float",
        "description": "在加权分布中用于影响该帧长或区间被选中的概率权重。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于向指定的IMix对象添加一个帧长分布配置。它封装了IMix对象的`add_frame_length`方法，根据传入的参数配置不同类型的帧长度分布（如固定、随机等）。适用于网络流量建模中的混合帧长生成。",
    "example": ".. code:: RobotFramework\n\n    | ${Imix} | Create Imix | Name=Imix_1 | Seed=10121112 |\n    | Add IMix Distribution Frame | IMix=${Imix} | Type=random | Min=64 | Max=128 | Weight=50 |\n    | Add IMix Distribution Frame | IMix=${Imix} | Type=random | Min=128 | Max=256 | Weight=50 |\n    | Bind Stream Imix | Stream=${Stream} | Imix=${Imix} |"
  },
  {
    "method_name": "TesterLibrary.Stream.imix.del_imix_distribution_frame",
    "return_type": "bool",
    "return": "布尔值，表示删除操作是否成功（True 表示成功，False 表示失败）。",
    "parameters": [
      {
        "name": "IMix",
        "type": "Imix",
        "description": "代表测试仪表中 Imix 模板的对象。该对象必须包含 `del_frame_length` 方法以支持删除帧长条目。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "要删除的自定义帧长条目的索引序号。如果未提供，则行为取决于底层实现（可能删除默认或最后一个条目）。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "此函数用于从指定的 Imix 模板中删除特定索引位置的帧长分布条目。它是一个用户接口函数，封装了底层 Renix API 的 `del_imix_distribution_frame` 方法。若删除失败，将抛出带有详细信息的 `ContinuableFailure` 异常；若成功，则返回 True。",
    "example": ".. code:: RobotFramework\n\n    | ${Imix} | Create Imix | Name=Imix_1 | Seed=10121112 |\n    | Add IMix Distribution Frame | IMix=${Imix} | Type=random | Min=64 | Max=128 | Weight=50 |\n    | Add IMix Distribution Frame | IMix=${Imix} | Type=random | Min=128 | Max=256 | Weight=50 |\n    | Bind Stream Imix | Stream=${Stream} | Imix=${Imix} |\n    | Del IMix Distribution Frame | IMix=${Imix} | Index=1"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.bier.edit_header_bier",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated parameter name to its corresponding internal attribute name (e.g., {'BiftId': 'biftId', 'TrafficClass': 'trafficClass'}). Only parameters that were provided and updated are included in the return value.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it within the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the BIER header in the filtered list of all BIER headers in the stream to be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "BiftId",
        "type": "int",
        "description": "Sets the BIFT-ID (Bit Forwarding Table Identifier) for the BIER header.",
        "default": "1",
        "range_or_options": "0-1048575"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Sets the Traffic Class field in the BIER header, used for traffic prioritization.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "SBit",
        "type": "bit",
        "description": "Sets the S-Bit (Supervisory Bit), indicating special handling for OAM packets.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Ttl",
        "type": "int",
        "description": "Sets the Time-to-Live (TTL) value for the BIER header, determining how many hops the packet can traverse.",
        "default": "64",
        "range_or_options": "0-255"
      },
      {
        "name": "Nibble",
        "type": "bit",
        "description": "Sets the Nibble field, which is a 4-bit value used for protocol version negotiation.",
        "default": "0101",
        "range_or_options": "0000-1111"
      },
      {
        "name": "BierVer",
        "type": "int",
        "description": "Sets the BIER Version number for compatibility with different versions of the BIER specification.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "Bsl",
        "type": "int",
        "description": "Sets the BIER Subdomain Length (BSL), indicating the size of the bitstring in bytes.",
        "default": "4",
        "range_or_options": "0-7"
      },
      {
        "name": "Entropy",
        "type": "int",
        "description": "Sets the Entropy field, used to seed hash functions for load balancing.",
        "default": "1",
        "range_or_options": "0-1048575"
      },
      {
        "name": "Oam",
        "type": "int",
        "description": "Sets the OAM (Operations, Administration, and Maintenance) field, controlling diagnostic functions.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "Rsv",
        "type": "int",
        "description": "Sets the Reserved field, typically unused and set to zero.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "Dscp",
        "type": "int",
        "description": "Sets the Differentiated Services Code Point (DSCP) for QoS classification.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "Protocol",
        "type": "int",
        "description": "Sets the encapsulated protocol type carried in the BIER header.",
        "default": "63",
        "range_or_options": "0-63"
      },
      {
        "name": "BfirId",
        "type": "int",
        "description": "Sets the BFIR-ID (Bit-Forwarding Ingress Router ID), identifying the source of the BIER packet.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "BierbitString",
        "type": "int",
        "description": "Sets the number of bit strings to be inserted into the BIER header. This does not affect the return value.",
        "default": "0",
        "range_or_options": "0-100"
      }
    ],
    "description": "Modifies the attributes of a BIER (Bit Index Explicit Replication) header in the specified stream at the given level. This function retrieves the list of headers for the provided stream and filters only the 'bier' type headers. It then updates the fields of the BIER header at the specified level with the provided values. Only non-None parameters are applied to the header. The updated fields are returned in a dictionary mapping original parameter names to their corresponding internal attribute names.",
    "example": "| Edit Header Bier | Stream=${Stream} | Level=0 | BiftId=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.bier.edit_header_bier_bit_string",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the configuration change if successful. If the operation fails or no result is returned from the backend, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "Either a single stream object or a list of stream objects. If a list is provided, only the first stream will be processed. Each stream must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the list of BIER headers associated with the stream. This specifies which level of BIER header to modify (e.g., inner or outer header).",
        "default": "0",
        "range_or_options": "0 to number of BIER headers in the stream - 1"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index within the BIER bit string where the configuration should be applied. Typically refers to the position of the bit field to be modified.",
        "default": "0",
        "range_or_options": "0 to number of bit strings in the BIER header - 1"
      }
    ],
    "kwargs": [
      {
        "name": "BitString",
        "type": "bit",
        "description": "The value for BitString in the BIER header, represented as a 32-bit binary string.",
        "default": "01010101010101010101010101010101",
        "range_or_options": "length of 32 binary digits (0s and 1s)"
      },
      {
        "name": "BitString2",
        "type": "bit",
        "description": "An additional BitString value in the BIER header, also represented as a 32-bit binary string.",
        "default": "01010101010101010101010101010101",
        "range_or_options": "length of 32 binary digits (0s and 1s)"
      }
    ],
    "description": "Modifies the bit string configuration of a BIER (Bit Index Explicit Replication) header associated with a given stream. This function allows editing specific fields within the BIER bit string at a specified index and level in the header hierarchy. The function retrieves the BIER headers for the stream, selects the appropriate header based on Level, and then applies the configuration changes via the `config_bit_string` method at the specified Index.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=bier |\n| Edit Header Bier Bit String | Stream=${Stream} | Level=0 | Index=0 | BitString=10101010101010101010101010101010 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding internal attribute path in the EOAM header structure. If no parameters are provided, an empty dictionary is returned.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the EOAM header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream within the system. If a list of streams is passed, only the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the EOAM (Connectivity Check Message) header to modify among all EOAM headers in the stream's header hierarchy. This allows targeting nested or multiple EOAM headers if they exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "MDlevel",
        "type": "int",
        "description": "Maintenance Domain level for the EOAM header. Used to define the domain hierarchy and message priority.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Protocol version number in the EOAM header. Ensures compatibility between sender and receiver.",
        "default": "0",
        "range_or_options": "0-31"
      },
      {
        "name": "OpCode",
        "type": "hex",
        "description": "Operation code indicating the type of EOAM message being sent.",
        "default": "01",
        "range_or_options": "1-byte hex value"
      },
      {
        "name": "RDIbit",
        "type": "int",
        "description": "Remote Defect Indication bit; signals whether a remote defect has been detected.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "Reserved bits in the EOAM header; typically set to zero unless otherwise specified by standards.",
        "default": "0000",
        "range_or_options": "0-15"
      },
      {
        "name": "CCMIntervalField",
        "type": "int",
        "description": "Defines the interval between consecutive Connectivity Check Messages (CCMs).",
        "default": "4",
        "range_or_options": "0 1 2 3 4 5 6 7"
      },
      {
        "name": "FirstTLVOffset",
        "type": "hex",
        "description": "Offset from the start of the frame to the first TLV (Type-Length-Value) block in the EOAM message.",
        "default": "46",
        "range_or_options": "00-FF"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sequence number used for tracking CCM messages and detecting loss or misordering.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MAEPI",
        "type": "int",
        "description": "Maintenance Association End Point Identifier (MAEP ID); uniquely identifies an end point within a maintenance association.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "MDNF",
        "type": "hex",
        "description": "Maintenance Domain Name Format; defines how the Maintenance Domain Name (MDN) is encoded.",
        "default": "01",
        "range_or_options": "00 01 02 03 04 05 20 40"
      },
      {
        "name": "MDNL",
        "type": "hex",
        "description": "Maintenance Domain Name Length; specifies the length of the Maintenance Domain Name field.",
        "default": "<AUTO>00",
        "range_or_options": "00-FF"
      },
      {
        "name": "MDN",
        "type": "hex",
        "description": "Maintenance Domain Name; identifies the maintenance domain associated with this EOAM message.",
        "default": "00",
        "range_or_options": "0-255 bytes hex string"
      },
      {
        "name": "SMAF",
        "type": "hex",
        "description": "Source MAC Address Flag in MAID; indicates how the source MAC address is formatted.",
        "default": "01",
        "range_or_options": "00-FF"
      },
      {
        "name": "SMAL",
        "type": "hex",
        "description": "Length of the Short MA Name field in the MAID.",
        "default": "01",
        "range_or_options": "00-FF"
      },
      {
        "name": "SMAN",
        "type": "hex",
        "description": "Short MA Name; provides a short identifier for the maintenance association.",
        "default": "00",
        "range_or_options": "1-255 bytes hex string"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Optional padding data appended to the EOAM header.",
        "default": "00",
        "range_or_options": "0-48 bytes hex string"
      },
      {
        "name": "ITUTY1731",
        "type": "hex",
        "description": "ITU-T Y.1731 compatibility flag or field for enhanced performance monitoring and fault management.",
        "default": "00000000000000000000000000000000",
        "range_or_options": "16-byte hex string"
      },
      {
        "name": "Tlvs",
        "type": "list",
        "description": "List of TLVs (Type-Length-Value blocks) to insert into the EOAM header.",
        "default": "[]",
        "range_or_options": "SenderIDTLV PortStatusTLV InterfaceStatusTLV OrgSpecTLV EndTLV"
      }
    ],
    "description": "This function edits the EOAM (Ethernet Operations, Administration, and Maintenance) header parameters for a given traffic stream. It supports detailed configuration of various fields within the EOAM header such as Maintenance Domain Level, Version, OpCode, RDI Bit, Reserved bits, CCM Interval, Sequence Number, and more. The function modifies the header at the specified level index and returns a dictionary showing which internal attributes were updated.",
    "example": "| Edit Header Eoam | Stream=${Stream} | Level=0 | MDlevel=7 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_sender_id_tlv",
    "return_type": "dict",
    "return": "A dictionary containing the result of the configuration operation, typically including status information or updated field values from the Sender ID TLV after applying the changes.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. If a list is provided, the first element will be used. The stream object must have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'ccm' type header in the header hierarchy of the stream to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the Sender ID TLV within the selected header to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type value for the Sender ID TLV (1-byte hexadecimal number).",
        "default": "01",
        "range_or_options": "00-FF"
      },
      {
        "name": "Length",
        "type": "hex",
        "description": "Length value for the Sender ID TLV (2-byte hexadecimal number).",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "ChassisIDLen",
        "type": "hex",
        "description": "Chassis ID Length (1-byte hexadecimal number).",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "TheChassisID",
        "type": "str",
        "description": "Chassis ID type specifying how the chassis identifier should be interpreted.",
        "default": "\"\"",
        "range_or_options": "ChassisComponent InterfaceAlias PortComponent MacAddress NetworkAddress4 NetworkAddress6 InterfaceName LocallyAssigned Custom"
      },
      {
        "name": "TheManagementAddressDomain",
        "type": "str",
        "description": "Management Address Domain specifies the domain of the management address.",
        "default": "\"\"",
        "range_or_options": "MADtDU4 MADtDU6 MADtDU4z MADtDU6z MADtDT4 MADtDT6 MADtDT4z MADtDT6z MADtDS4 MADtDS6 MADtDS4z MADtDS6z MADtDL MADtDU MADtTU MADtSU MADsI802 MADCustom"
      }
    ],
    "description": "Edits the EOAM Sender ID TLV (Type-Length-Value) of a specific header in the given stream. This function retrieves the headers associated with the provided stream and selects the 'ccm' type header at the specified level. It then configures the Sender ID TLV at the given index using the provided keyword arguments.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n| Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n| Edit Header Eoam Sender Id Tlv | Stream=${Stream} | Level=0 | Index=0 | Type=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_sender_id_tlv_chassis_id",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration operation if successful. Returns False if no result is returned from the configuration operation.",
    "description": "Edits the chassis ID field of the EOAM Sender ID TLV in a specified header of a stream template. This function allows users to configure various types of chassis IDs (e.g., MAC address, interface name, etc.) and supports optional advanced settings via keyword arguments.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, only the first element is used. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "The type of chassis ID to configure. Valid values include 'ChassisComponent', 'InterfaceAlias', 'PortComponent', 'MacAddress', 'NetworkAddress4', 'NetworkAddress6', 'InterfaceName', 'LocallyAssigned', 'Custom'.",
        "default": "not_found",
        "range_or_options": "ChassisComponent InterfaceAlias PortComponent MacAddress NetworkAddress4 NetworkAddress6 InterfaceName LocallyAssigned Custom"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the filtered list of 'ccm' headers associated with the stream. Use this parameter to select which EOAM header to modify if multiple exist.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the Sender ID TLV within the EOAM message where the chassis ID will be set.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The position or identifier for selecting among multiple chassis IDs within the TLV.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ChassisIDSubtype",
        "type": "hex",
        "description": "Subtype of the chassis ID. The default value depends on the selected Type. Range: 00-FF.",
        "default": "01 (for ChassisComponent), 02 (InterfaceAlias), 03 (PortComponent), 04 (MAC Address), 05 (NetworkAddress), 06 (InterfaceName), 07 (LocallyAssigned), or 00 (Custom)",
        "range_or_options": "00-FF"
      },
      {
        "name": "ChassisID",
        "type": "str or hex",
        "description": "The actual chassis ID value. Default values vary based on the Type. Acceptable formats depend on the Type (string or hexadecimal).",
        "default": "'XINERTEL' (for string types), '00:00:00:00:00:00' (MAC), '0.0.0.0' (IPv4), '::0' (IPv6), or '00' (Custom)",
        "range_or_options": "varies by Type"
      },
      {
        "name": "IanaFamilyNumber",
        "type": "hex",
        "description": "IANA Family Number for network address types. Only applicable when Type is NetworkAddress4 or NetworkAddress6.",
        "default": "01 (IPv4), 02 (IPv6)",
        "range_or_options": "00-FF"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n    | Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n    | Edit Header Eoam Sender Id Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | Index=0 | ChassisID=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_sender_id_tlv_management_address_domain",
    "return_type": "dict or False",
    "return": "A dictionary containing internal identifiers for the modified management address domain fields if successful, or False if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate object",
        "description": "The stream object that represents a traffic template in the test equipment. Must be an instance of `StreamTemplate` with valid attributes like 'handle'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of management address domain to configure. This determines which set of keyword arguments is expected.",
        "default": "not_found",
        "range_or_options": "MADtDU4 MADtDU6 MADtDU4z MADtDU6z MADtDT4 MADtDT6 MADtDT4z MADtDT6z MADtDS4 MADtDS6 MADtDS4z MADtDS6z MADtDL MADtDU MADtTU MADtSU MADsI802 MADCustom"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the EOAM header (of type 'ccm') within the stream's list of headers to operate on.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index of the Sender ID TLV inside the selected EOAM header.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the specific management address domain entry within the Sender ID TLV to modify.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MADL",
        "type": "hex",
        "description": "Management Address Domain Length in hexadecimal format.",
        "default": "08",
        "range_or_options": "00-FF"
      },
      {
        "name": "MAD",
        "type": "hex",
        "description": "Management Address Domain value as a hexadecimal string.",
        "default": "varies by Type",
        "range_or_options": "length 0-255 bytes hexadecimal number"
      },
      {
        "name": "MAL",
        "type": "hex",
        "description": "Length of the Management Address field in hexadecimal.",
        "default": "varies by Type",
        "range_or_options": "00-FF"
      },
      {
        "name": "IPv4",
        "type": "str",
        "description": "IPv4 address used when applicable (e.g., MADtDU4).",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "IPv6",
        "type": "str",
        "description": "IPv6 address used when applicable (e.g., MADtDU6).",
        "default": "::0",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Port",
        "type": "hex",
        "description": "Port number in hexadecimal format.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Name",
        "type": "str",
        "description": "String-based name used for certain types (e.g., MADtDL).",
        "default": "XINERTEL",
        "range_or_options": "string of length 1-255"
      },
      {
        "name": "ManAdd",
        "type": "str or hex",
        "description": "Management Address; either MAC address or raw hexadecimal depending on Type.",
        "default": "00:00:00:00:00:00 or 00",
        "range_or_options": "valid MAC address or hexadecimal string"
      }
    ],
    "description": "This function edits the management address domain fields within a Sender ID TLV of an EOAM header at a specified level in a given stream. It supports various types of management address domains (like IPv4, IPv6, DNS, custom, etc.) and allows configuration of relevant fields based on the selected type. The function internally calls a backend implementation and raises an exception if the operation fails.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n| Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n| Edit Header Eoam Sender Id Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | Index=0 | ChassisID=FF |\n| Edit Header Eoam Sender Id Tlv Management Address Domain | Stream=${Stream} | Type=MADCustom | Level=0 | TlvIndex=0 | Index=0 | MADL=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_port_status_tlv",
    "return_type": "dict or False",
    "return": "A dictionary containing the configured fields of the EOAM Port Status TLV if successful, or False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) for which the EOAM header needs to be edited. The stream must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'ccm' type EOAM header in the list of headers for the stream.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the Port Status TLV within the selected EOAM header where the configuration should be applied.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type field of the EOAM Port Status TLV, length is 1 byte.",
        "default": "02",
        "range_or_options": "0x00-0xFF"
      },
      {
        "name": "Length",
        "type": "hex",
        "description": "Length field of the EOAM Port Status TLV, length is 2 bytes. If not provided, it's set to <AUTO>.",
        "default": "<AUTO>",
        "range_or_options": "0x0000-0xFFFF"
      },
      {
        "name": "PortStatusValues",
        "type": "hex",
        "description": "Value representing the port status with options: 01 = Blocked, 02 = Up.",
        "default": "01",
        "range_or_options": "01 02"
      }
    ],
    "description": "Edits the EOAM Port Status TLV (Type-Length-Value) field in a specific header of a stream. This function retrieves and filters the stream's headers to find those of type 'ccm', selects the header at the specified level, and configures the Port Status TLV at the given index using the provided keyword arguments.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n| Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n| Edit Header Eoam Port Status Tlv | Stream=${Stream} | Level=0 | Index=0 | Type=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_interface_status_tlv",
    "return_type": "dict or bool",
    "return": "A dictionary containing the configured values of the Interface Status TLV (Type, Length, IntStatusValues) if successful. Returns False if configuration fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) for which the EOAM header will be modified. Must have a 'handle' attribute to uniquely identify it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the filtered list of 'ccm' type EOAM headers to select the target header for configuration.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index used to identify a specific Interface Status TLV instance within the selected EOAM header, typically used when multiple TLVs exist.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "The Type field of the Interface Status TLV, typically a 1-byte hexadecimal value.",
        "default": "04",
        "range_or_options": "00-FF"
      },
      {
        "name": "Length",
        "type": "hex",
        "description": "The Length field of the TLV, indicating the length of the Value field in bytes as a 2-byte hexadecimal value.",
        "default": "<AUTO>",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "IntStatusValues",
        "type": "hex",
        "description": "The Interface Status value indicating the port status.",
        "default": "01",
        "range_or_options": "01 02 03 04 05 06 07"
      }
    ],
    "description": "Modifies the EOAM Interface Status TLV (Type-Length-Value) of a specific header in a stream. The function filters EOAM headers to only include 'ccm' (Continuity Check Message) type headers, selects the header at the specified level, and updates its Interface Status TLV using the provided index and keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n    | Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n    | Edit Header Eoam Interface Status Tlv | Stream=${Stream} | Level=0 | Index=0 | Type=FF"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_organization_specific_tlv",
    "return_type": "dict or False",
    "return": "A dictionary containing the configuration details of the Organization-Specific TLV (Type, Length, OUI, SubType, Value) if the operation is successful. If the operation fails or no result is returned, False is returned.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object for which the EOAM header's Organization-Specific TLV is to be edited. If a list is passed, the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the list of 'ccm'-type headers retrieved from the stream. This determines which level of EOAM header to edit.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the Organization-Specific TLV within the selected EOAM header to configure.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the Type field of the Organization-Specific TLV, which is a 1-byte hexadecimal value.",
        "default": "1F",
        "range_or_options": "0x00-0xFF"
      },
      {
        "name": "Length",
        "type": "hex",
        "description": "Specifies the Length field of the TLV, which is a 2-byte hexadecimal value. If not specified, it defaults to <AUTO> and is calculated automatically.",
        "default": "<AUTO>",
        "range_or_options": "0x0000-0xFFFF"
      },
      {
        "name": "OUI",
        "type": "hex",
        "description": "Organizationally Unique Identifier (OUI), a 3-byte hexadecimal value identifying the organization responsible for the TLV format.",
        "default": "000000",
        "range_or_options": "0x000000-0xFFFFFF"
      },
      {
        "name": "SubType",
        "type": "hex",
        "description": "Specifies the Sub-Type of the Organization-Specific TLV, an additional identifier used by the organization defined by the OUI.",
        "default": "00",
        "range_or_options": "0x00-0xFF"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Specifies the variable-length value of the TLV, with length ranging from 0 to 65535 bytes. Represented as a hexadecimal string.",
        "default": "\"\"",
        "range_or_options": "length: 0-65535 bytes"
      }
    ],
    "description": "Edits the Organization-Specific TLV (Type-Length-Value) field in an EOAM (Ethernet Operations, Administration, and Maintenance) header at a specified level within a stream's header hierarchy. This function retrieves the headers associated with the provided stream and filters them to find those of type 'ccm' (Continuity Check Message). It then selects the header at the specified level and configures the Organization-Specific TLV at the given index using the provided keyword arguments.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n| Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n| Edit Header Eoam Organization Specific Tlv | Stream=${Stream} | Level=0 | Index=0 | Type=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.eoam.edit_header_eoam_end_tlv",
    "return_type": "dict or bool",
    "return": "Returns a dictionary containing the result of the configuration update if successful. Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the hierarchical level of the EOAM CCM header within the stream's header stack.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the End TLV within the list of TLVs in the EOAM header to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type field of the End TLV, represented as a hexadecimal value.",
        "default": "01",
        "range_or_options": "00-FF"
      }
    ],
    "description": "Edits the End TLV (Type-Length-Value) of an EOAM (Ethernet Operations, Administration, and Maintenance) header in a specified stream at a given header level. This function retrieves the headers associated with the provided stream and filters them to find EOAM CCM (Continuity Check Message) type headers. It then configures the End TLV at the specified index of the header located at the given level using the provided keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=ccm |\n    | Edit Header Eoam | Stream=${Stream} | Level=0 | Tlvs=SenderIDTLV |\n    | Edit Header Eoam End Tlv | Stream=${Stream} | Level=0 | Index=0 | Type=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.trill.edit_header_trill",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping parameter names to the corresponding TRILL header field names that were successfully updated. If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose TRILL header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The hierarchy level of the TRILL header to edit within the stream's header list.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "any",
        "description": "Value to set for the TRILL header's version field.",
        "default": "1",
        "range_or_options": "0-3"
      },
      {
        "name": "Reserved",
        "type": "any",
        "description": "Value to set for the reserved field in the TRILL header.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "MultiDestination",
        "type": "any",
        "description": "Value to set for the multiDestination field indicating whether the packet has multiple destinations.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "OptionLength",
        "type": "any",
        "description": "Value to set for the optionLength field indicating the length of optional data in the header.",
        "default": "0",
        "range_or_options": "0-31"
      },
      {
        "name": "HopCount",
        "type": "any",
        "description": "Value to set for the hopCount field, which limits the number of hops a packet can traverse.",
        "default": "1",
        "range_or_options": "0-63"
      },
      {
        "name": "EgressRBridge",
        "type": "any",
        "description": "Value to set for the egressRBridge field indicating the RBridge through which the packet exits the TRILL domain.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "IngressBridge",
        "type": "any",
        "description": "Value to set for the ingressBridge field indicating the RBridge through which the packet enters the TRILL domain.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the fields of a TRILL (TRansparent Interconnection of Lots of Links) header in a specified stream. This function retrieves the TRILL headers from the given stream and modifies the specified fields of the TRILL header at the given hierarchy level. Only the fields provided (not None) are updated.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header Trill | Stream=${Stream} | Level=0 | Version=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.ancp.edit_header_ancp",
    "return_type": "dict",
    "return": "A dictionary mapping the provided parameter names to their corresponding internal attribute names in the ANCP header. Only modified fields are included in the result.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ANCP Port Management header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ANCP Port Management header within the list of such headers in the stream template. Used to select which header to modify.",
        "default": "0",
        "range_or_options": "0-n (number of ANCP Port Management headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Identifier",
        "type": "hex",
        "description": "Sets the Identifier field of the TCP/IP encapsulation header.",
        "default": "880C",
        "range_or_options": "2-digit hexadecimal number"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Sets the Length of the TCP/IP Encapsulating Header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the Version field of the ANCP Port Management message header.",
        "default": "50",
        "range_or_options": "0-255"
      },
      {
        "name": "MessageType",
        "type": "int",
        "description": "Sets the Message Type field (messageType1) of the ANCP Port Management message header.",
        "default": "32",
        "range_or_options": "0-255"
      },
      {
        "name": "ResultField",
        "type": "int",
        "description": "Sets the Result Field of the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0-4"
      },
      {
        "name": "ResultCode",
        "type": "int",
        "description": "Sets the Result Code field of the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0 2 6 19 81 83 84 85 1280"
      },
      {
        "name": "PartitionId",
        "type": "int",
        "description": "Sets the Partition ID field of the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "TransactionId",
        "type": "int",
        "description": "Sets the Transaction ID field of the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Ignore",
        "type": "int",
        "description": "Sets the Ignore flag in the ANCP Port Management message header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "SubMessageNumber",
        "type": "int",
        "description": "Sets the Sub Message Number field of the ANCP Port Management message header.",
        "default": "1",
        "range_or_options": "0-32767"
      },
      {
        "name": "Length2",
        "type": "int",
        "description": "Sets the Length field (len) of the ANCP Port Management message header.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Unused",
        "type": "hex",
        "description": "Sets the Unused field of the ANCP Port Management message header.",
        "default": "0000000000000000000000000000",
        "range_or_options": "14-digit hexadecimal number"
      },
      {
        "name": "Function",
        "type": "hex",
        "description": "Sets the Function field of the ANCP Port Management message header.",
        "default": "09",
        "range_or_options": "1-digit hexadecimal number"
      },
      {
        "name": "XFunction",
        "type": "hex",
        "description": "Sets the X-Function field of the ANCP Port Management message header.",
        "default": "00",
        "range_or_options": "1-digit hexadecimal number"
      },
      {
        "name": "Unused2",
        "type": "hex",
        "description": "Sets the Unused2 field of the ANCP Port Management message header.",
        "default": "00000000",
        "range_or_options": "4-digit hexadecimal number"
      },
      {
        "name": "ExtensionFlag",
        "type": "hex",
        "description": "Sets the Extension Flag field of the ANCP Port Management message header.",
        "default": "00",
        "range_or_options": "1-digit hexadecimal number"
      },
      {
        "name": "MessageType2",
        "type": "int",
        "description": "Sets the second Message Type field (messageType2) of the ANCP Port Management message header.",
        "default": "32",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Sets the Reserved field of the ANCP Port Management message header.",
        "default": "0000",
        "range_or_options": "2-digit hexadecimal number"
      },
      {
        "name": "NumberOfTlvs",
        "type": "int",
        "description": "Sets the Number of TLVs field in the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ExtensionBlockLength",
        "type": "int",
        "description": "Sets the Extension Block Length field in the ANCP Port Management message header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "AccessLineIdentifyingTlvs",
        "type": "int",
        "description": "Specifies the number of Access Line Identifying TLVs to insert into the ANCP message.",
        "default": "0",
        "range_or_options": "0-256"
      },
      {
        "name": "TestingRelatedTlvs",
        "type": "int",
        "description": "Specifies the number of Testing Related TLVs to insert into the ANCP message.",
        "default": "0",
        "range_or_options": "0-256"
      },
      {
        "name": "StatusInfoTlvs",
        "type": "int",
        "description": "Specifies the number of Status-Info TLVs to insert into the ANCP message.",
        "default": "0",
        "range_or_options": "0-256"
      }
    ],
    "description": "Edits the fields of an ANCP (Access Node Control Protocol) header in a specified stream. This function modifies the specified fields of the selected ANCP Port Management header at the given level within the stream. Each provided parameter updates its corresponding internal attribute in the header and is returned in a dictionary indicating which parameters were successfully set.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=portManagement |\n| Edit Header Ancp | Stream=${Stream} | Level=0 | Identifier=ffff |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.ancp.edit_header_ancp_access_line_identifying_tlv",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the TLV configuration operation, including 'Type', 'Length', and 'Value' field references if successful. Returns False if no matching header is found or the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "Either a stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'portmanagement' header in the header hierarchy of the stream. Used to select the specific ANCP Port Management header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the Access Line Identifying TLV within the selected header to be edited. Used to target a specific TLV when multiple exist.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "The Type value for the TLV, represented as a 2-digit hexadecimal number.",
        "default": "0001",
        "range_or_options": "00-FF (2-digit hex)"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The Length value for the TLV, indicating the size of the Value field in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "The Value field of the TLV, represented as a hexadecimal string with up to 63 characters.",
        "default": "00",
        "range_or_options": "hex string of length 0-63"
      }
    ],
    "description": "Edits the ANCP Access Line Identifying TLV (Type-Length-Value) in a specified header of a stream. This function retrieves the headers associated with the provided stream, filters them to find those of type 'portmanagement', selects the appropriate header based on the Level, and modifies an Access Loop Circuit ID TLV at the given TlvIndex using the provided parameters.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=portManagement |\n    | Edit Header Ancp Access Line Identifying Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | Type=ffff |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.ancp.edit_header_ancp_testing_related_tlv",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the TLV configuration operation if successful. Returns False if no result is returned from the internal method, indicating possible failure or no effect.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it within the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ANCP Port Management header in the stream's header hierarchy. This specifies which ANCP header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the Testing Related TLV within the selected ANCP Port Management header to be configured.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Hexadecimal value specifying the TLV type field.",
        "default": "0008",
        "range_or_options": "00-FF"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Integer value specifying the length of the TLV content. If set to <AUTO>0, the length may be automatically calculated.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value1",
        "type": "int",
        "description": "First value to be stored in the TLV content field. Typically used for numeric parameters.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Value2",
        "type": "int",
        "description": "Second value to be stored in the TLV content field. Typically used for numeric parameters.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function modifies the Testing Related TLV content of an ANCP Port Management header in a specified stream template. It allows configuring specific fields (Type, Length, Value1, Value2) of the TLV at a given index within the selected ANCP header. Internally, it retrieves the headers associated with the stream, filters for 'portmanagement' type headers, selects the appropriate one using Level, and configures the TLV at the provided TlvIndex by calling its internal configuration method.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=portManagement |\n| Edit Header Ancp Testing Related Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | Type=ffff |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.ancp.edit_header_ancp_status_info_tlv",
    "return_type": "dict",
    "return": "A dictionary containing the result of the configuration operation, typically including success/failure status and possibly other metadata returned by the underlying method.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing a single stream object) for which the ANCP status info TLV of a header needs to be edited. If a list is passed, only the first item is used. The stream object should have a 'handle' attribute uniquely identifying it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which 'portmanagement' header to select from the filtered list of headers.",
        "default": "0",
        "range_or_options": "0-n (n depends on number of port management headers)"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index specifying which TLV within the selected header needs to be modified.",
        "default": "0",
        "range_or_options": "0-n (n depends on number of TLVs in the selected header)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type field of the Status Info TLV.",
        "default": "0106",
        "range_or_options": "2-digit hexadecimal value"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length field of the Status Info TLV.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Reserved field in the Status Info TLV.",
        "default": "00",
        "range_or_options": "1-digit hexadecimal value"
      },
      {
        "name": "MsgType",
        "type": "int",
        "description": "Message Type field in the Status Info TLV.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ErrMsgLength",
        "type": "int",
        "description": "Length of the Error Message field in the TLV.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ErrMsg",
        "type": "hex",
        "description": "Error Message content as hexadecimal data.",
        "default": "\"\"",
        "range_or_options": "0-65535 hex digits"
      },
      {
        "name": "OptionalSubTLV",
        "type": "int",
        "description": "Number of optional sub-TLVs to insert.",
        "default": "0",
        "range_or_options": "0-64"
      }
    ],
    "description": "Edits the ANCP (Access Node Control Protocol) status information TLV (Type-Length-Value) of a header in the specified stream at the given level. This function specifically targets headers of type 'portmanagement'. It modifies the TLV fields based on provided keyword arguments.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=portManagement |\n| Edit Header Ancp Status Info Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | Type=ffff |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.ancp.edit_header_ancp_status_info_tlv_optional_sub_tlv",
    "return_type": "dict or bool",
    "return": "A dictionary containing the configuration details of the modified optional sub-TLV (including Type, Length, and Data) if successful. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object for which an ANCP Port Management header's optional sub-TLV will be edited. If a list is provided, the first element is used as the stream object. It must have a 'handle' attribute to uniquely identify the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which ANCP Port Management header in the stream to target. This allows selecting among multiple such headers in the stream template.",
        "default": "0",
        "range_or_options": "0-n (where n is number of ANCP Port Management headers)"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index specifying which TLV within the selected ANCP Port Management header's Status Info TLVs to modify.",
        "default": "0",
        "range_or_options": "0-n (where n is number of Status Info TLVs)"
      },
      {
        "name": "SubTlvIndex",
        "type": "int",
        "description": "Index specifying which optional sub-TLV within the selected TLV to modify.",
        "default": "0",
        "range_or_options": "0-n (where n is number of Optional Sub TLVs)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "The type value of the optional sub-TLV to be set.",
        "default": "0001",
        "range_or_options": "0000-ffff"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The length of the data field in the optional sub-TLV. If not specified, it defaults to auto-calculate based on data.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Hexadecimal string representing the data content of the optional sub-TLV.",
        "default": "''",
        "range_or_options": "0-65535 hex characters"
      }
    ],
    "description": "Edits the configuration of an optional sub-TLV that belongs to a specific TLV within an ANCP (Access Node Control Protocol) Port Management header at a specified level in the stream hierarchy. This function targets only headers of type 'portmanagement'. The function ensures the validity of the stream, selects the appropriate header based on Level, TLV index, and Sub-TLV index, and applies the given configuration parameters to the selected optional sub-TLV.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=portManagement |\n    | Edit Header Ancp Status Info Tlv Optional Sub Tlv | Stream=${Stream} | Level=0 | TlvIndex=0 | SubTlvIndex=0 | Type=ffff |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_ppp",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping modified field names ('Addresses', 'Controls', 'Protocol') to their respective new values (as string references to internal attributes) if any modifications were made. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing one stream object. If a list, the first element will be used. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of PPP headers associated with the stream. Selects which PPP header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Addresses",
        "type": "hex",
        "description": "Optional value to assign to the 'addresses' field of the selected PPP header.",
        "default": "<AUTO>FF",
        "range_or_options": "00-FF"
      },
      {
        "name": "Controls",
        "type": "hex",
        "description": "Optional value to assign to the 'controls' field of the selected PPP header.",
        "default": "<AUTO>03",
        "range_or_options": "00-FF"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "Optional value to assign to the 'protocol' field of the selected PPP header.",
        "default": "<AUTO>0000",
        "range_or_options": "0000-FFFF"
      }
    ],
    "description": "Modifies specific fields of a Point-to-Point Protocol (PPP) header in the given stream. This function allows editing of the 'addresses', 'controls', and 'protocol' fields of the selected PPP header. The function first checks if the provided Stream is a list; if so, it uses the first element. It then retrieves the list of headers for the stream using `get_stream_header`, filters to only PPP-type headers, and selects the header at the specified Level index. If any of the editable fields are provided, their corresponding values are updated in the selected header, and the result dictionary is populated with the names of the modified fields and their new values (as string references to internal attributes).",
    "example": "| Edit Header Ppp | Stream=${Stream} | Level=0 | Addresses=192.168.0.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe",
    "return_type": "Union[dict, False]",
    "return": "Returns a dictionary mapping the input parameter names to the actual attribute names modified in the PPPoE header (e.g., {'Version': 'version'}). Returns False if no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a stream object. If a list is provided, the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of PPPoE headers found in the stream. Use 0 to modify the first PPPoE header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "New value for the PPPoE version field.",
        "default": "1",
        "range_or_options": "0-15"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "New value for the PPPoE type field.",
        "default": "1",
        "range_or_options": "0-15"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "New value for the PPPoE code field. Should be provided as an integer representing a hex byte (e.g., 0x11 = 17).",
        "default": "0",
        "range_or_options": "0-255 (0x00-0xFF)"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "New value for the PPPoE session identifier field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "PayloadLen",
        "type": "int",
        "description": "New value for the PPPoE payload length field. If not provided, defaults to <AUTO>0.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies specific fields of a PPPoE (Point-to-Point Protocol over Ethernet) header in a given stream template. This function retrieves the list of headers for the provided stream and filters out only the PPPoE headers. It then selects the PPPoE header at the specified level/index and updates any of its fields that are passed with non-None values.",
    "example": "| Edit Header Pppoe | Stream=${Stream} | Level=0 | Code=11 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery",
    "return_type": "dict",
    "return": "A dictionary mapping the modified header fields (e.g., 'Version', 'Type') to their corresponding attribute names in the header object. Tag-related fields are not included in the return value.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing the traffic template on which the PPPoE Discovery header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element will be used as the stream object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the PPPoE Discovery header in the list of headers of type 'pppoediscovery' associated with the stream. Used to identify which instance of the PPPoE Discovery header to edit.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the 'version' field of the PPPoE Discovery header. If provided, updates the header.version and includes it in the result dictionary.",
        "default": "1",
        "range_or_options": "0-15"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the PPPoE Discovery header. If provided, updates the header.type and includes it in the result dictionary.",
        "default": "1",
        "range_or_options": "0-15"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the PPPoE Discovery header. This field defines the type of PPPoE Discovery message (PADI, PADO, PADR, PADS, PADT).",
        "default": "9",
        "range_or_options": "9(PADI) 7(PADO) 25(PADR) 101(PADS) 167(PADT)"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "Sets the 'session ID' field of the PPPoE Discovery header. If provided, updates the header.sessionId and includes it in the result dictionary.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "PayloadLen",
        "type": "int",
        "description": "Sets the 'payload length' field of the PPPoE Discovery header. If provided, updates the header.payloadLen and includes it in the result dictionary.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EndOfListTag",
        "type": "int",
        "description": "Specifies how many End Of List Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ServiceNameTag",
        "type": "int",
        "description": "Specifies how many Service Name Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "AcNameTag",
        "type": "int",
        "description": "Specifies how many AC Name Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "HostUniqTag",
        "type": "int",
        "description": "Specifies how many Host Uniq Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "AcCookieTag",
        "type": "int",
        "description": "Specifies how many AC Cookie Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "VendorSpecificTag",
        "type": "int",
        "description": "Specifies how many Vendor Specific Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RelaySessionIdTag",
        "type": "int",
        "description": "Specifies how many Relay Session ID Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ServiceNameErrorTag",
        "type": "int",
        "description": "Specifies how many Service Name Error Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "AcSystemErrorTag",
        "type": "int",
        "description": "Specifies how many AC System Error Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "GenericErrorTag",
        "type": "int",
        "description": "Specifies how many Generic Error Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UnknownTag",
        "type": "int",
        "description": "Specifies how many Unknown Tags to insert into the PPPoE Discovery header. Does not appear in the return dictionary.",
        "default": "0",
        "range_or_options": "0-1"
      }
    ],
    "description": "Edits the fields of a PPPoE Discovery header within a specified stream. This function allows modification of core header fields such as Version, Type, Code, SessionId, and PayloadLen, while also enabling insertion of various tag types like End Of List, Service Name, AC Name, etc. The function returns a dictionary of modified fields excluding tags, which maps parameter names to their respective internal attribute names in the header object.",
    "example": "| Edit Header Pppoe Discovery | Stream=${Stream} | Level=0 | Code=11 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_end_of_list_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the configuration result (e.g., 'Type' and 'Length') if successful, otherwise False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Hierarchical level index of the PPPoE Discovery header in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "Index of the End Of List Tag to configure within the selected PPPoE Discovery header.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type of the End Of List Tag.",
        "default": "0000",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the End Of List Tag value.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the 'End of List' tag in a PPPoE Discovery header at the specified hierarchical level within a stream template. This function is used to configure specific attributes of the End Of List tag such as Type and Length.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery End Of List Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_service_name_tag",
    "return_type": "dict or False",
    "return": "返回一个字典，包含配置操作的结果（如 Type、Length 和 Value 的路径信息）；若操作失败或未应用任何更改，则返回 False。",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "测试仪表流量对象，或者包含该对象的列表。如果提供了列表，则使用第一个元素。该对象必须具有唯一标识它的 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "指定要修改的 PPPoE Discovery 头部在流中所有此类头部中的索引位置（从0开始计数）。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "指定要修改的 Service Name Tag 在 PPPoE Discovery 头部中 Tags 列表中的索引位置（从0开始计数）。",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Tag 的类型值。",
        "default": "0101",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Tag 的长度值。",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Tag 的十六进制数值内容。",
        "default": "0",
        "range_or_options": "十六进制字符串，长度范围：0-250"
      }
    ],
    "description": "编辑流模板中指定层级的PPPoE Discovery报文头部中的Service Name Tag字段。该函数通过提供的参数定位到特定的头部和Tag，并根据传入的关键字参数更新其配置。",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n    | Edit Header Pppoe Discovery Server Name Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_ac_name_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the configuration result (Type, Length, Value) if successful; otherwise returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "Either a single stream object or a list containing one stream object. The stream must have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which PPPoE Discovery header in the stream to modify.",
        "default": "0",
        "range_or_options": "0 - number of pppoe discovery headers in the stream"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "Index specifying which AC Name Tag within the selected PPPoE Discovery header to modify.",
        "default": "0",
        "range_or_options": "0 - number of AC name tags in the selected header"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the type of the tag being configured.",
        "default": "0102",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the tag value in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value of the tag content.",
        "default": "0",
        "range_or_options": "length 0-250 hexadecimal numbers"
      }
    ],
    "description": "Edits the Access Concentrator (AC) name tag in a PPPoE Discovery header at the specified level within the stream's header hierarchy. This function modifies the selected header's AC name tag using provided configuration parameters such as Type, Length, and Value.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery Ac Name Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_host_uniq_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration change if successful. Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, the first element is used. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the PPPoE Discovery header in the list of headers of the stream. Used to select which PPPoE Discovery header to modify if multiple such headers exist.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "The index of the 'Host-Uniq' tag within the PPPoE Discovery header to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type of the Tag. Default value: 0103. This determines what kind of tag this is.",
        "default": "0103",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the Tag Value field in bytes. Default value: <AUTO>0. Valid range is 0-65535.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value for the Tag. Default value: 0. Valid values are hexadecimal strings with length between 0 and 250 characters.",
        "default": "0",
        "range_or_options": "length 0-250 hex string"
      }
    ],
    "description": "Modifies the 'Host-Uniq' tag in a PPPoE Discovery header of a specified stream. This function selects a specific PPPoE Discovery header (based on Level) from the list of headers associated with the provided stream and edits the 'Host-Uniq' tag at the specified TagIndex. Additional parameters for configuring the tag are passed via **kwargs.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery Host Uniq Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_ac_cookie_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration operation (e.g., Type, Length, Value) if successful. Returns False if no result was produced.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object representing the traffic stream whose headers are being edited. It must have a 'handle' attribute used to uniquely identify the stream. If a list is passed, the first item will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the filtered list of 'pppoediscovery' headers to select the target header.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "The index of the AC-Cookie tag to edit within the selected PPPoE Discovery header.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the type of the Tag.",
        "default": "0104",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Specifies the length of the Tag value in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Specifies the value of the Tag as a hexadecimal string.",
        "default": "0",
        "range_or_options": "length 0-250 hexadecimal values"
      }
    ],
    "description": "Modifies the 'AC-Cookie' tag in a PPPoE Discovery header at a specified level within the header stack of a stream. This function retrieves the headers for the given stream and filters them to find those of type 'pppoediscovery'. It then selects the header at the specified level (index) from this filtered list and calls its method to configure or modify the AC-Cookie tag at the provided tag index using additional keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n    | Edit Header Pppoe Discovery Ac Cookie Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_vendor_specific_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration operation (e.g., 'Type', 'Length', and 'Value' of the modified tag). Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object to modify. If a list is provided, the first element will be used. Must have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which PPPoE Discovery header in the chain should be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "Index of the vendor-specific tag within the PPPoE Discovery header to be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the type of the tag. Used to classify the purpose of the tag.",
        "default": "0105",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the Tag Value field in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value representing the content of the Tag Value field.",
        "default": "0",
        "range_or_options": "length_0_to_250_hex"
      }
    ],
    "description": "Edits a vendor-specific tag within the PPPoE Discovery header at a specified level in the packet stream. This function modifies the tag fields such as Type, Length, and Value of the vendor-specific tag in the selected PPPoE Discovery header. It allows fine-grained control over the contents of PPPoE Discovery packets being generated or analyzed by the testing framework.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n    | Edit Header Pppoe Discovery Vendow Specific Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_relay_session_id_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration operation (including 'Type', 'Length', and 'Value' fields) if successful. Returns False if no changes were applied or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of PPPoE Discovery headers associated with the stream to identify which header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "Index of the Relay Session ID tag within the selected PPPoE Discovery header to configure.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the type of the Tag being configured.",
        "default": "0110",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Specifies the length of the Tag value in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value for the Tag content, with a length ranging from 0 to 250 bytes.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "description": "Modifies the Relay Session ID tag in a specified PPPoE Discovery header of a given stream. This function allows setting various attributes of the Relay Session ID tag such as Type, Length, and Value.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery Relay Session Id Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_server_name_error_tag",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the configuration operation if successful. If the operation fails or no result is returned by the underlying method, False is returned.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "Either a single stream object or a list containing one stream object. The stream object must have a 'handle' attribute that uniquely identifies it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the PPPoE Discovery header in the filtered list of headers of type 'pppoediscovery'. This allows selection of headers in case multiple such headers exist in the stream's header stack.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "The index of the tag within the PPPoE Discovery header where the error tag configuration should be applied.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type of the PPPoE Discovery Tag.",
        "default": "0110",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the PPPoE Discovery Tag value.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value of the PPPoE Discovery Tag, with length ranging from 0 to 250.",
        "default": "0",
        "range_or_options": "0-250 hexadecimal digits"
      }
    ],
    "description": "Modifies the 'Server Name Error Tag' field in a PPPoE Discovery header at a specified level within the header stack of a given stream. This function filters the headers of the provided stream to find those of type 'pppoediscovery', selects the header at the specified level, and applies configuration changes to the selected Server Name Error Tag using keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n    | Edit Header Pppoe Discovery Server Name Error Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_ac_system_error_tag",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the configuration (e.g., Type, Length, Value paths) if successful. Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) where the PPPoE Discovery header resides. Must have a valid 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the hierarchical level of the PPPoE Discovery header in the stream. Level=0 refers to the topmost PPPoE Discovery header.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "Index of the 'AC-System-Error' tag within the tag list of the selected PPPoE Discovery header.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type of the Tag to be set. This determines how the tag is interpreted by the system.",
        "default": "0202",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the Tag value field in bytes. If not specified, it is automatically determined based on the Value provided.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value for the Tag content. The length of this value must be between 0 and 250 bytes.",
        "default": "0",
        "range_or_options": "length 0-250 hexadecimal number"
      }
    ],
    "description": "Edits the 'AC-System-Error' tag in a PPPoE Discovery header at the specified level within a stream. This function allows modification of various properties of the tag, including its type, length, and value. It retrieves and caches headers if necessary, and applies the configuration via internal methods.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery Ac System Error Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_generic_error_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the configuration if successful; otherwise, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list of stream objects. If a list is provided, the first element will be used. The stream object must have a 'handle' attribute used to uniquely identify it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the PPPoE Discovery header in the header hierarchy of the stream. This allows selection of headers at different levels (e.g., inner or outer headers).",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "The index of the generic error tag within the PPPoE Discovery header to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Type of the Generic Error Tag.",
        "default": "0203",
        "range_or_options": "0000 0101 0102 0103 0104 0105 0110 0201 0202 0203"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the Generic Error Tag value in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Value of the Generic Error Tag in hexadecimal format.",
        "default": "0",
        "range_or_options": "length 0-250 hexadecimal number"
      }
    ],
    "description": "Edits the generic error tag of a PPPoE Discovery header at a specified level in the header chain of a stream. This function selects the appropriate PPPoE Discovery header based on the given Level and modifies its generic error tag using the provided TagIndex and optional additional parameters (**kwargs). If multiple streams are passed, only the first one is used. The function ensures that only 'pppoediscovery' type headers are considered when selecting the target header to edit.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n| Edit Header Pppoe Discovery Generic Error Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.common.edit_header_pppoe_discovery_unknown_tag",
    "return_type": "dict or bool",
    "return": "A dictionary containing the updated fields of the tag (e.g., 'Type', 'Length', 'Value') if successful. Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the PPPoE Discovery header within the stream's headers list. Used to identify which PPPoE Discovery header to modify.",
        "default": "0",
        "range_or_options": "0-n (number of PPPoE Discovery headers in the stream)"
      },
      {
        "name": "TagIndex",
        "type": "int",
        "description": "The index of the unknown tag within the selected PPPoE Discovery header to be edited.",
        "default": "0",
        "range_or_options": "0-n (number of unknown tags in the selected PPPoE Discovery header)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "The Type value for the Unknown Tag, specified as a hexadecimal number.",
        "default": "0000",
        "range_or_options": "00-FF"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The Length field for the Unknown Tag, indicating the size of the Value field in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "The hexadecimal value to be set for the Unknown Tag, with a maximum length of 40 bytes.",
        "default": "0",
        "range_or_options": "hex string up to 40 bytes in length"
      }
    ],
    "description": "Edits an unknown tag in the PPPoE Discovery header of a specified stream at a given level and tag index. This function modifies the configuration of the tag using the provided keyword arguments representing the tag's fields such as Type, Length, and Value.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=pppoediscovery |\n    | Edit Header Pppoe Discovery Unknown Tag | Stream=${Stream} | Level=0 | TagIndex=0 | Type=0101 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv4.edit_header_dhcpv4_server",
    "return_type": "dict",
    "return": "A dictionary indicating which header fields were successfully updated, mapping parameter names to internal attribute names (e.g., {'MessageType': 'messageType'}). If no fields were updated, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing a single stream object) whose DHCPv4 server header needs to be edited. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the DHCPv4 server header in the stream's header list that should be modified. Defaults to 0 if not provided.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MessageType",
        "type": "str or int, optional",
        "description": "Sets the DHCP message type field (e.g., discover, offer, request).",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "HardwareType",
        "type": "str or int, optional",
        "description": "Sets the hardware type field in the DHCP header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "HaddrLen",
        "type": "str or int, optional",
        "description": "Sets the length of the client hardware address field.",
        "default": "6",
        "range_or_options": "0-255"
      },
      {
        "name": "Hops",
        "type": "str or int, optional",
        "description": "Sets the number of hops allowed for the message.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Xid",
        "type": "str or int, optional",
        "description": "Sets the transaction ID field.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Elapsed",
        "type": "str or int, optional",
        "description": "Sets the elapsed time since the client began attempting to acquire a lease.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Bootpflags",
        "type": "str or int, optional",
        "description": "Sets the BOOTP flags field.",
        "default": "8000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "ClientAddr",
        "type": "str, optional",
        "description": "Sets the client IP address field.",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "YourAddr",
        "type": "str, optional",
        "description": "Sets the 'your' (assigned) IP address field.",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "NextServerAddr",
        "type": "str, optional",
        "description": "Sets the next server IP address field.",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "RelayAgentAddr",
        "type": "str, optional",
        "description": "Sets the relay agent IP address field.",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "ClientMac",
        "type": "str, optional",
        "description": "Sets the client's MAC address field.",
        "default": "00:00:02:00:00:02",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "ClientHWPad",
        "type": "str, optional",
        "description": "Sets padding bytes for the client hardware address.",
        "default": "00000000000000000000",
        "range_or_options": "长度10字节"
      },
      {
        "name": "ServerHostName",
        "type": "str, optional",
        "description": "Sets the server host name field.",
        "default": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "range_or_options": "长度64字节"
      },
      {
        "name": "BootFileName",
        "type": "str, optional",
        "description": "Sets the boot file name field.",
        "default": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "range_or_options": "长度128字节"
      },
      {
        "name": "MagicCookie",
        "type": "str, optional",
        "description": "Sets the DHCP magic cookie value.",
        "default": "63825363",
        "range_or_options": "长度4字节十六进制数"
      },
      {
        "name": "Padding",
        "type": "str, optional",
        "description": "Sets additional padding bytes in the header.",
        "default": "",
        "range_or_options": "长度1500字节以内的十六进制数"
      },
      {
        "name": "OptionHeaders",
        "type": "list or dict, optional",
        "description": "A list or dictionary representing additional DHCP options to be inserted into the header. These are processed by calling insert_option_header on the header object.",
        "default": "not_found",
        "range_or_options": "messageType serverId message leaseTime endOfOptions messageSize clientIdHW clientIdNoneHW hostName paramReqList reqAddr optionOverload customOption generalTLV"
      }
    ],
    "description": "Edits the DHCPv4 server header fields of a specified stream at a given level. This function allows modification of various DHCPv4 server header attributes such as message type, hardware type, client and server addresses, and other related options.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | dhcpv4Server |\n    | ${OptionHeaders} | Create List | messageSize | clientIdHW | clientIdNoneHW | hostName |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header DHCPv4 Server | Stream=${Stream} | Level=0 | messageType=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv4.edit_header_dhcpv4_client",
    "return_type": "dict or False",
    "return": "A dictionary mapping the successfully updated parameter names to their internal field names if any changes were made. Returns `False` if no parameters were provided and no modifications occurred.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) whose DHCPv4 client header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index specifying which DHCPv4 client header to edit if multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-n (depending on number of DHCPv4 Client/Server headers)"
      }
    ],
    "kwargs": [
      {
        "name": "MessageType",
        "type": "str or int, optional",
        "description": "DHCP message type (e.g., DHCPDISCOVER = 1, DHCPOFFER = 2).",
        "default": "not_found",
        "range_or_options": "1-8 (standard DHCP message types)"
      },
      {
        "name": "HardwareType",
        "type": "str or int, optional",
        "description": "Type of hardware address (e.g., Ethernet = 1).",
        "default": "not_found",
        "range_or_options": "1-65535"
      },
      {
        "name": "HaddrLen",
        "type": "int, optional",
        "description": "Length of the hardware address in bytes.",
        "default": "not_found",
        "range_or_options": "0-255"
      },
      {
        "name": "Hops",
        "type": "int, optional",
        "description": "Number of relay agents between client and server.",
        "default": "not_found",
        "range_or_options": "0-255"
      },
      {
        "name": "Xid",
        "type": "str or int, optional",
        "description": "Transaction ID identifying this transaction.",
        "default": "not_found",
        "range_or_options": "0x00000000-0xFFFFFFFF"
      },
      {
        "name": "Elapsed",
        "type": "int, optional",
        "description": "Number of seconds elapsed since the client began trying to acquire a lease.",
        "default": "not_found",
        "range_or_options": "0-65535"
      },
      {
        "name": "Bootpflags",
        "type": "str or int, optional",
        "description": "BOOTP flags field.",
        "default": "not_found",
        "range_or_options": "0x0000-0xFFFF"
      },
      {
        "name": "ClientAddr",
        "type": "str, optional",
        "description": "Client's IP address.",
        "default": "not_found",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "YourAddr",
        "type": "str, optional",
        "description": "IP address assigned by the server to the client.",
        "default": "not_found",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "NextServerAddr",
        "type": "str, optional",
        "description": "IP address of next server to use in bootstrap.",
        "default": "not_found",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "RelayAgentAddr",
        "type": "str, optional",
        "description": "IP address of the relay agent.",
        "default": "not_found",
        "range_or_options": "IPv4 Address"
      },
      {
        "name": "ClientMac",
        "type": "str, optional",
        "description": "Client's MAC address.",
        "default": "not_found",
        "range_or_options": "MAC Address"
      },
      {
        "name": "ClientHWPad",
        "type": "str, optional",
        "description": "Padding field for client hardware address.",
        "default": "not_found",
        "range_or_options": "Hex string"
      },
      {
        "name": "ServerHostName",
        "type": "str, optional",
        "description": "Name of the server providing configuration.",
        "default": "not_found",
        "range_or_options": "String"
      },
      {
        "name": "BootFileName",
        "type": "str, optional",
        "description": "Boot file name requested by the client.",
        "default": "not_found",
        "range_or_options": "String"
      },
      {
        "name": "MagicCookie",
        "type": "str, optional",
        "description": "Magic cookie field used to identify DHCP messages.",
        "default": "not_found",
        "range_or_options": "Hex string"
      },
      {
        "name": "Padding",
        "type": "str, optional",
        "description": "Padding data to fill the packet to a minimum size.",
        "default": "not_found",
        "range_or_options": "Hex string"
      },
      {
        "name": "OptionHeaders",
        "type": "list or dict, optional",
        "description": "List or dictionary of DHCP options to insert into the header.",
        "default": "not_found",
        "range_or_options": "messageType messageSize clientIdHW clientIdNoneHW hostName paramReqList reqAddr optionOverload serverId message leaseTime customOption endOfOptions generalTLV"
      }
    ],
    "description": "This function modifies the DHCPv4 client header fields of a specified stream at a given level. It allows editing various DHCPv4 parameters including message type, hardware type, MAC address, IP addresses, and other optional fields. If a parameter is provided (not None), it updates the corresponding field in the DHCPv4 client header. The function returns a dictionary indicating the updated fields or False if no changes were applied.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | dhcpv4Client |\n    | ${OptionHeaders} | Create List | messageSize | clientIdHW | clientIdNoneHW | hostName |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header DHCPv4 Client | Stream=${Stream} | Level=0 | messageType=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv4.edit_header_dhcpv4_option",
    "return_type": "dict",
    "return": "A dictionary containing the result of the edit operation, typically including status and any relevant output from the underlying method. If no valid edit was performed, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing a single stream object) whose DHCPv4 header needs to be edited. If a list is provided, only the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str",
        "description": "Specifies which DHCPv4 option field to edit. Valid values are: 'messagetype', 'messagesize', 'clientidhw', 'clientidnonehw', 'hostname', 'paramreqlist', 'reqaddr', 'optionoverload', 'serverid', 'message', 'leasetime', 'customoption', 'endofoptions', 'generaltlv'.",
        "default": "not_found",
        "range_or_options": "messagetype messagesize clientidhw clientidnonehw hostname paramreqlist reqaddr optionoverload serverid message leasetime customoption endofoptions generaltlv"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the DHCPv4 header in the stream's header hierarchy. Defaults to 0 (the topmost DHCPv4 header in the stream).",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index within the selected option field if it contains multiple entries. Used by some option types to specify which entry to modify. Defaults to 0.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Option Type for the DHCPv4 Option. Default varies depending on `Types`. Range: 00-FF.",
        "default": "varies based on Types",
        "range_or_options": "00-FF"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the DHCPv4 Option Value. Default varies depending on `Types`. Range: 0-255.",
        "default": "<AUTO>",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "DHCP Message Code for MessageType Option. Default: 1. Range: 1-8.",
        "default": "1",
        "range_or_options": "1-8"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value of the DHCPv4 Option. Default varies depending on `Types`. Range: length 0-256 bytes hexadecimal number.",
        "default": "varies based on Types",
        "range_or_options": "length 0-256 bytes hexadecimal number"
      },
      {
        "name": "IdType",
        "type": "hex",
        "description": "ID Type for Client Identifier (Hardware/Non-Hardware). Default: varies depending on `Types`. Range: 00-FF.",
        "default": "varies based on Types",
        "range_or_options": "00-FF"
      },
      {
        "name": "ClientHWA",
        "type": "hex",
        "description": "Client Hardware Address. Default: 00:00:02:01:01:02. Must be a valid MAC address.",
        "default": "00:00:02:01:01:02",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "ReqAddr",
        "type": "str",
        "description": "Requested IP Address. Default: 0.0.0.0. Must be a valid IPv4 address.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Overload",
        "type": "int or hex",
        "description": "Option Overload configuration. Default varies depending on `Types`. Range: 1-8 for int; length 0-256 bytes hexadecimal number for hex.",
        "default": "varies based on Types",
        "range_or_options": "1-8 or length 0-256 bytes hexadecimal number"
      },
      {
        "name": "LeaseTime",
        "type": "int",
        "description": "Lease Time in seconds. Default: 0. Range: 0-4294967295.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits a specific DHCPv4 option field in the header of a given stream based on the provided type. This function identifies the DHCPv4 header (client or server) at the specified level in the stream, then delegates the editing operation to the appropriate method based on the `Types` parameter. It supports various DHCPv4 options such as Server ID, Message Type, Lease Time, Client ID, and more.",
    "example": ".. code:: RobotFramework\n\n        | ${Stream} | add_stream | Port=${Port} |\n        | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | dhcpv4Client |\n        | ${LsaHeaders} | Create List | messageSize | clientIdHW | clientIdNoneHW | hostName |\n        | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n        | Edit Header DHCPv4 Client | Stream=${Stream} | Level=0 | UsePriority=1 | OptionHeaders=${OptionHeaders} |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=0 | Types=MessageSize | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=1 | Types=ClientIdHW | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=2 | Types=ClientIdNoneHW | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=3 | Types=HostName | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=4 | Types=ParamReqList | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=5 | Types=ReqAddr | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=6 | Types=OptionOverload | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=7 | Types=CustomOption | Xid=1 |\n        | Edit Header DHCPv4 Client Option | Stream=${Stream} | Level=0 | Index=8 | Types=GeneralTLV | Xid=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv6.edit_header_dhcpv6_client",
    "return_type": "dict",
    "return": "A dictionary mapping the modified field names ('MessageType', 'TransId', 'OptionHeaders') to their corresponding internal attribute names or update results. Returns False if no modifications were applied (i.e., all input parameters were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象object，用于标识需要修改的DHCPv6 Client报文头部所属的流模板。该对象应包含一个唯一标识流的'handle'属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "指定在多个DHCPv6 Client头部的情况下，要修改的是第几个头部（索引）。默认为0。",
        "default": "0",
        "range_or_options": "0-n (取决于流中DHCPv6 Client头部的数量)"
      }
    ],
    "kwargs": [
      {
        "name": "MessageType",
        "type": "int",
        "description": "设置DHCPv6 Client报文头部的消息类型字段的新值。",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "TransId",
        "type": "int",
        "description": "设置DHCPv6 Client报文头部的事务ID字段的新值。",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "指定要插入或更新的选项头字段。支持的选项包括：clientIdOption, serverIdOption, ianaOption, requestOption, elapsedTimeOption, serverUnicastOption, statusCodeOption, rapidCommitOption, interfaceIdOption, reconfigureAcceptOption, iapdOption, customOption, generalTLV。",
        "default": "not_found",
        "range_or_options": "clientIdOption serverIdOption ianaOption requestOption elapsedTimeOption serverUnicastOption statusCodeOption rapidCommitOption interfaceIdOption reconfigureAcceptOption iapdOption customOption generalTLV"
      }
    ],
    "description": "该函数用于修改指定流模板中的DHCPv6 Client报文头部内容。可修改的字段包括消息类型（MessageType）、事务ID（TransId）以及一组选项头部（OptionHeaders）。只有提供了非None值的字段会被修改。",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | UDP | dhcpv6Client |\n    | ${OptionHeaders} | Create List | clientIdOption | serverIdOption | ianaOption | requestOption |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header DHCPv6 Client | Stream=${Stream} | Level=0 | messageType=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv6.edit_header_dhcpv6_server",
    "return_type": "dict or False",
    "return": "A dictionary indicating the successfully updated fields with keys as field names ('MessageType', 'TransId', 'OptionHeaders') and their corresponding internal attribute names as values. If none of the fields were updated, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing a traffic template in the test instrument. It must have a 'handle' attribute that uniquely identifies it within the system. If a list is passed, only the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index (sequence number) of the DHCPv6 Server header to modify among all DHCPv6 Server headers in the stream. This allows editing multiple DHCPv6 Server headers if more than one exists in the stream.",
        "default": "0",
        "range_or_options": "0 - Number of DHCPv6 Server Headers in Stream - 1"
      }
    ],
    "kwargs": [
      {
        "name": "MessageType",
        "type": "int",
        "description": "Specifies the new value for the Message Type field in the DHCPv6 Server header. If not provided, this field remains unchanged.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "TransId",
        "type": "int",
        "description": "Specifies the new value for the Transaction ID field in the DHCPv6 Server header. If not provided, this field remains unchanged.",
        "default": "1",
        "range_or_options": "0-16777215"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "A list specifying which option headers to insert or update in the DHCPv6 Server header. Supported options include: clientIdOption, serverIdOption, ianaOption, requestOption, elapsedTimeOption, serverUnicastOption, statusCodeOption, rapidCommitOption, interfaceIdOption, reconfigureAcceptOption, iapdOption, customOption, generalTLV. If not provided or empty, no changes are made to the option headers.",
        "default": "",
        "range_or_options": "clientIdOption serverIdOption ianaOption requestOption elapsedTimeOption serverUnicastOption statusCodeOption rapidCommitOption interfaceIdOption reconfigureAcceptOption iapdOption customOption generalTLV"
      }
    ],
    "description": "This function modifies specific fields of a DHCPv6 Server header in a given traffic stream template. It allows updating the Message Type, Transaction ID, and Option Headers. The function filters all headers in the stream to find DHCPv6 Server headers, selects the one at the specified Level (index), and updates the provided fields.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | UDP | dhcpv6Server |\n    | ${OptionHeaders} | Create List | clientIdOption | serverIdOption | ianaOption | requestOption |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header DHCPv6 Server | Stream=${Stream} | Level=0 | messageType=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv6.edit_header_dhcpv6_option",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the edit operation, typically including status information or updated field values. Returns False if no edit was performed due to invalid input.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing one stream object. The stream must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str",
        "description": "Specifies the type of DHCPv6 option to edit. Valid values include: ClientIdOption, ServerIdOption, IanaOption, RequestOption, ElapsedTimeOption, ServerUnicastOption, StatusCodeOption, RapidCommitOption, InterfaceIdOption, ReconfigureAcceptOption, IapdOption, CustomOption, GeneralTLV.",
        "default": "not_found",
        "range_or_options": "ClientIdOption ServerIdOption IanaOption RequestOption ElapsedTimeOption ServerUnicastOption StatusCodeOption RapidCommitOption InterfaceIdOption ReconfigureAcceptOption IapdOption CustomOption GeneralTLV"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of DHCPv6 headers (client/server) found for the stream. Used when multiple DHCPv6 headers exist.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the specific option within the selected option type to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Option Type value for the DHCPv6 option.",
        "default": "<AUTO>",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the DHCPv6 option content.",
        "default": "<AUTO>",
        "range_or_options": "0-65535"
      },
      {
        "name": "Duid",
        "type": "hex",
        "description": "DUID (DHCP Unique Identifier) for Client ID Option.",
        "default": "00030001000003010103",
        "range_or_options": "length 0-1024 bytes hex"
      },
      {
        "name": "DuidType",
        "type": "int",
        "description": "DUID Type for Server ID Option.",
        "default": "<AUTO>3",
        "range_or_options": "0-65535"
      },
      {
        "name": "HardwareType",
        "type": "int",
        "description": "Hardware Type for Server ID Option.",
        "default": "<AUTO>1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LinkAddress",
        "type": "str",
        "description": "Link-layer Address for Server ID Option.",
        "default": "00:00:03:01:01:02",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "Iaid",
        "type": "hex",
        "description": "IAID (Identity Association Identifier) for IANA and IAPD Options.",
        "default": "00050001",
        "range_or_options": "length 4 bytes hex"
      },
      {
        "name": "T1",
        "type": "int",
        "description": "Renew timer value for IANA and IAPD Options.",
        "default": "302400",
        "range_or_options": "0-65535"
      },
      {
        "name": "T2",
        "type": "int",
        "description": "Rebind timer value for IANA and IAPD Options.",
        "default": "483840",
        "range_or_options": "0-65535"
      },
      {
        "name": "IaOption",
        "type": "int",
        "description": "Number of IA options for IANA and IAPD Options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Request Code or custom data for certain options like RequestOption, CustomOption, GeneralTLV.",
        "default": "00",
        "range_or_options": "length 0-256 bytes hex"
      },
      {
        "name": "ElapseTime",
        "type": "int",
        "description": "Elapsed Time value for ElapsedTimeOption.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ServerAddress",
        "type": "str",
        "description": "IPv6 Server Address for ServerUnicastOption.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "StatusCode",
        "type": "int",
        "description": "Status code for StatusCodeOption.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "StatusMsg",
        "type": "hex",
        "description": "Status message in hexadecimal format for StatusCodeOption.",
        "default": "53756363657373",
        "range_or_options": "length 5-1024 bytes hex"
      },
      {
        "name": "InterfaceId",
        "type": "hex",
        "description": "Interface-ID for InterfaceIdOption.",
        "default": "0123456789",
        "range_or_options": "length 5-1024 bytes hex"
      }
    ],
    "description": "Edits a specific DHCPv6 option within a stream's header based on the provided option type and parameters. This function supports various types of DHCPv6 options such as Client ID, Server ID, IANA, IAPD, Request, Status Code, etc. It modifies the configuration of the specified option in the stream's DHCPv6 header.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | UDP | dhcpv6Server |\n    | ${LsaHeaders} | Create List | clientIdOption | serverIdOption | ianaOption | iapdOption |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header DHCPv6 Server | Stream=${Stream} | Level=0 | UsePriority=1 | OptionHeaders=${OptionHeaders} |\n    | Edit Header DHCPv6 Server Option | Stream=${Stream} | Level=0 | Index=0 | Types=ClientIdOption | Length=1 |\n    | Edit Header DHCPv6 Server Option | Stream=${Stream} | Level=0 | Index=1 | Types=ServerIdOption | Length=1 |\n    | Edit Header DHCPv6 Server Option | Stream=${Stream} | Level=0 | Index=2 | Types=IanaOption | Length=1 | OptionIndex=0 | Subtype=Dhcpv6IaAddress | IaOption=1 |\n    | Edit Header DHCPv6 Server Option | Stream=${Stream} | Level=0 | Index=2 | Types=iapdOption | Length=1 | OptionIndex=0 | Subtype=Dhcpv6IaPrefix | IaOption=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv6.edit_header_dhcpv6_option_ia_address",
    "return_type": "dict or False",
    "return": "A dictionary containing the updated fields of the IA Address option (e.g., Type, Length, Ipv6Address, PreferredLifetime, ValidLifetime) if the operation is successful. If the operation fails, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) that contains the DHCPv6 headers to be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the DHCPv6 header (either 'dhcpv6server' or 'dhcpv6client') within the stream's list of DHCPv6 headers to target for modification.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the IA Address option within the selected DHCPv6 header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The numeric type identifier of the IA Address option.",
        "default": "5",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The length in bytes of the IA Address option data field.",
        "default": "24",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv6Address",
        "type": "str",
        "description": "IPv6 address associated with this IA Address option.",
        "default": "2001::3",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "PreferredLifetime",
        "type": "hex",
        "description": "Preferred lifetime of the assigned IPv6 address, in seconds.",
        "default": "604800",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "Maximum valid lifetime of the assigned IPv6 address, in seconds.",
        "default": "2592000",
        "range_or_options": "0-4294967245"
      }
    ],
    "description": "Edits the Identity Association (IA) Address option within a DHCPv6 Server or Client header at a specified level in a stream template. This function allows updating specific fields of an existing IA Address option, such as IPv6 address, preferred lifetime, and valid lifetime. It internally identifies the correct DHCPv6 header and modifies the targeted IA Address option using provided parameters.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | UDP | dhcpv6Server |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Dhcpv6 Option Ia Address | Stream=${Stream} | Level=0 | Index=2 | Type=5 | Ipv6Address=2020::1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.dhcpv6.edit_header_dhcpv6_option_ia_prefix",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the `edit_ia_prefix_option` call if successful. Returns False if no changes were made or if the operation failed.",
    "description": "Edits a DHCPv6 IA Prefix option in the specified stream's DHCPv6 header at the given level and index. This function modifies the IA Prefix option content for a DHCPv6 Server/Client within the traffic template associated with the provided stream object.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "测试仪表流量对象或包含该对象的列表，用于标识需要修改的流量模板。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "DHCPv6头部在流中所有DHCPv6头部中的索引号，默认为0。",
        "default": "0",
        "range_or_options": "0-最大DHCPv6头部数量减1"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "IA Prefix选项在其所属DHCPv6头部中的索引号，默认为0。",
        "default": "0",
        "range_or_options": "0-最大IA Prefix选项数量减1"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Option字段值。",
        "default": "26",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length字段值。",
        "default": "25",
        "range_or_options": "0-65535"
      },
      {
        "name": "PreferredLifetime",
        "type": "hex",
        "description": "Preferred Lifetime值。",
        "default": "604800",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "Valid Lifetime值。",
        "default": "2592000",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "IPv6前缀长度。",
        "default": "64",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv6Address",
        "type": "str",
        "description": "IPv6地址值。",
        "default": "2001::3",
        "range_or_options": "有效的IPv6地址格式"
      }
    ],
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv6 | UDP | dhcpv6Server |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header DHCPv6 Server Option | Stream=${Stream} | Level=0 | Index=3 | Types=iapdOption | Length=1 | Subtype=Dhcpv6IaPrefix |\n| Edit Header Dhcpv6 Option Ia Prefix | Stream=${Stream} | Level=0 | Index=3 | PrefixLength=128 | Ipv6Address=2022::3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv2.edit_header_l2tpv2_data",
    "return_type": "dict",
    "return": "A dictionary mapping the names of modified fields to their corresponding internal attribute names (e.g., {'Type': 'type', 'UseLength': 'useLength'}). Only modified fields are included in the result.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the L2TPv2 data headers. Must have a valid 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of L2TPv2 data headers in the stream. Only the header at this index will be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "bit",
        "description": "Sets the 'type' field of the L2TPv2 data header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UseLength",
        "type": "bit",
        "description": "Indicates whether the Length field is used in the header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved1",
        "type": "bit",
        "description": "First reserved field, typically used for padding or future use.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "UseSequence",
        "type": "bit",
        "description": "Indicates whether sequence numbers are used in the header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved2",
        "type": "bit",
        "description": "Second reserved field, typically used for padding or future use.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UseOffset",
        "type": "bit",
        "description": "Indicates whether the Offset field is used in the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UsePriority",
        "type": "bit",
        "description": "Indicates whether priority information is used in the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved3",
        "type": "bit",
        "description": "Third reserved field, typically used for padding or future use.",
        "default": "0000",
        "range_or_options": "0000-1111"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "L2TP version number used in the header.",
        "default": "2",
        "range_or_options": "0-15"
      },
      {
        "name": "LengthOption",
        "type": "int",
        "description": "Controls length encoding behavior in the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TunnelId",
        "type": "int",
        "description": "Identifies the tunnel associated with the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "Identifies the session within the tunnel.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SeqNum",
        "type": "int",
        "description": "Represents the message sequence number for this session.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "OffsetPadding",
        "type": "int",
        "description": "Controls offset padding behavior in the header.",
        "default": "0",
        "range_or_options": "0-1"
      }
    ],
    "description": "Modifies specific fields of an L2TPv2 data header in a given stream. This function allows configuration and customization of various L2TPv2 data header properties such as Type, Sequence Number, Tunnel ID, Session ID, and other optional or reserved flags.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header L2tpv2 Data | Stream=${Stream} | Level=0 | TunnelId=1000 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv2.edit_header_l2tpv2_data_option",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the header option update operation if successful, as returned by the `editHeaderOptions` method of the header object. Returns False if no result was produced.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing a single stream object) for which the 'l2tpv2data' header options will be edited. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the filtered list of 'l2tpv2data' headers, specifying which header in the hierarchy should be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Size",
        "type": "int",
        "description": "Offset Padding Size to be set in the L2TPv2 Data Option header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Offset Padding Value in hexadecimal format, with length ranging from 0 to 1500 bytes.",
        "default": "\"\"",
        "range_or_options": "0-1500 bytes hexadecimal number"
      },
      {
        "name": "Ns",
        "type": "int",
        "description": "Sequence Number Ns Value to be set in the L2TPv2 Data Option header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Nr",
        "type": "int",
        "description": "Sequence Number Nr Value to be set in the L2TPv2 Data Option header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the options of a specific 'l2tpv2data' header in the given stream. The function retrieves the list of headers for the specified stream, filters for headers of type 'l2tpv2data', and edits the options of the header at the specified level/index. Any provided keyword arguments (**kwargs) are used to update the corresponding options of the target header. This function assumes that the stream has already been configured with at least one 'l2tpv2data' header. If multiple streams are passed, only the first one is considered.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv2Data |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv2 Data | Stream=${Stream} | Level=0 | UsePriority=1 |\n    | Edit Header L2tpv2 Data Option | Stream=${Stream} | Level=0 | size=1 | value=FF | ns=1 | nr=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv2.edit_header_l2tpv2_control",
    "return_type": "dict or bool",
    "return": "If one or more fields are successfully updated, returns a dictionary mapping the updated parameter names to their corresponding internal attribute names. If no fields are updated (i.e., all provided parameters are None), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the headers. It must have a 'handle' attribute uniquely identifying the stream in the system. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the L2TPv2 Control header in the list of headers of the stream.",
        "default": "0",
        "range_or_options": "0-n (number of L2TPv2 Control headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "bit",
        "description": "New value for the 'type' field of the header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UseLength",
        "type": "bit",
        "description": "New value for the 'useLength' field of the header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved1",
        "type": "bit",
        "description": "New value for the 'reserved1' field of the header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "UseSequence",
        "type": "bit",
        "description": "New value for the 'useSequence' field of the header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved2",
        "type": "bit",
        "description": "New value for the 'reserved2' field of the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UseOffset",
        "type": "bit",
        "description": "New value for the 'useOffset' field of the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UsePriority",
        "type": "bit",
        "description": "New value for the 'usePriority' field of the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved3",
        "type": "bit",
        "description": "New value for the 'reserved3' field of the header.",
        "default": "0000",
        "range_or_options": "0000-1111"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "New value for the 'version' field of the header.",
        "default": "2",
        "range_or_options": "0-15"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "New value for the 'length' field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TunnelId",
        "type": "int",
        "description": "New value for the 'tunnelId' field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "New value for the 'sessionId' field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ns",
        "type": "int",
        "description": "New value for the 'ns' field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Nr",
        "type": "int",
        "description": "New value for the 'nr' field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "New option headers to be inserted into the L2TPv2 Control header. These are processed using the header's insert_option_header method.",
        "default": "not_found",
        "range_or_options": "generalTLV messageType resultCode protocolVersion framingCapabilities bearerCapabilities tieBreaker firmwareRevision assignedTunnelId receiveWindowSize assignedSessionId response callSerialNumber minimumBps maximumBps bearerType framingType txConnectSpeed rxConnectSpeed physicalChannelId proxyAuthenType proxyAuthenId"
      }
    ],
    "description": "Edits the fields of an L2TPv2 Control header in a specified stream. This function retrieves the list of headers for the given stream and filters for 'l2tpv2control' type headers. It then selects the header at the specified level (index) and updates any provided fields with new values. If a field is not provided (i.e., set to None), it remains unchanged.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv2Control |\n    | ${OptionHeaders} | Create List | generalTLV | messageType | resultCode | protocolVersion |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv2 Control | Stream=${Stream} | Level=0 | UsePriority=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv2.edit_header_l2tpv2_control_option",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the edit operation, typically including success status or any returned data from the underlying edit method. Returns False if no changes were made or if the operation failed (e.g., invalid header type).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) whose L2TPv2 Control Option header needs to be edited. The stream is expected to have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str",
        "description": "Specifies the type of L2TPv2 Control Option header to edit. Valid values include: 'generaltlv', 'messagetype', 'resultcode', 'protocolversion', 'framingcapabilities', 'bearercapabilities', 'tiebreaker', 'firmwarerevision', 'assignedtunnelid', 'receivewindowsize', 'assignedsessionid', 'response', 'callserialnumber', 'minimumbps', 'maximumbps', 'bearertype', 'framingtype', 'txconnectspeed', 'rxconnectspeed', 'physicalchannelid', 'proxyauthentype', 'proxyauthenid'.",
        "default": "not_found",
        "range_or_options": "generaltlv messagetype resultcode protocolversion framingcapabilities bearercapabilities tiebreaker firmwarerevision assignedtunnelid receivewindowsize assignedsessionid response callserialnumber minimumbps maximumbps bearertype framingtype txconnectspeed rxconnectspeed physicalchannelid proxyauthentype proxyauthenid"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the L2TPv2 Control header in the stream's header chain to edit. Used when multiple such headers exist.",
        "default": "0",
        "range_or_options": "0-1023"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific AVP/TLV within the L2TPv2 Control header to modify. Useful when multiple entries of the same type exist.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "Mbit",
        "type": "bit",
        "description": "M Bit indicating whether this AVP is mandatory for the receiver to understand and process.",
        "default": "0 or 1 depending on Type",
        "range_or_options": "0-1"
      },
      {
        "name": "Hbit",
        "type": "bit",
        "description": "H Bit indicating whether this AVP contains hidden information.",
        "default": "0 or 1 depending on Type",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "Reserved Bits used for future use or padding.",
        "default": "0000",
        "range_or_options": "0000-1111"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the value field in bytes. Auto-calculated by default.",
        "default": "<AUTO>0",
        "range_or_options": "0-1023"
      },
      {
        "name": "VendorId",
        "type": "int",
        "description": "Vendor ID used to identify vendor-specific attributes.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Attribute Type identifying the kind of AVP.",
        "default": "depends on option type",
        "range_or_options": "0-65535"
      },
      {
        "name": "AttributeValue",
        "type": "hex",
        "description": "Hexadecimal representation of the value for GeneralTLV type.",
        "default": "00000000000000000000000000000000",
        "range_or_options": "length 0-1017 bytes hex string"
      },
      {
        "name": "messageType",
        "type": "int",
        "description": "Message Type field used in MessageType option.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "ResultCode",
        "type": "int",
        "description": "Result Code field used in ResultCode option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ErrorCode",
        "type": "int",
        "description": "Error Code field used in ResultCode option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ErrorMessage",
        "type": "hex",
        "description": "Error Message field used in ResultCode option.",
        "default": "\"\"",
        "range_or_options": "length 0-1017 bytes hex string"
      },
      {
        "name": "Ver",
        "type": "int",
        "description": "Protocol version number used in ProtocolVersion option.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Rev",
        "type": "int",
        "description": "Protocol revision number used in ProtocolVersion option.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "Reserved field used in various options like FramingCapabilities, BearerCapabilities, etc.",
        "default": "0",
        "range_or_options": "0-1073741823"
      },
      {
        "name": "Abit",
        "type": "bit",
        "description": "A Bit flag used in FramingCapabilities, BearerCapabilities, FramingType, etc.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Sbit",
        "type": "bit",
        "description": "S Bit flag used in FramingCapabilities, FramingType, etc.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Dbit",
        "type": "bit",
        "description": "D Bit flag used in BearerCapabilities.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "tieBreakerValue",
        "type": "hex",
        "description": "Tie Breaker Value used in TieBreaker option.",
        "default": "0000000000000000",
        "range_or_options": "length 0-8 bytes hex string"
      },
      {
        "name": "firmwareRevision",
        "type": "int",
        "description": "Firmware Revision number used in FirmwareRevision option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "tunnelId",
        "type": "int",
        "description": "Assigned Tunnel ID used in AssignedTunnelId option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "WindowSize",
        "type": "int",
        "description": "Receive Window Size used in ReceiveWindowSize option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "sessionId",
        "type": "int",
        "description": "Assigned Session ID used in AssignedSessionId option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "responseValue",
        "type": "hex",
        "description": "Response Value used in Response option.",
        "default": "00000000000000000000000000000000",
        "range_or_options": "length 0-16 bytes hex string"
      },
      {
        "name": "callSerialNumber",
        "type": "int",
        "description": "Call Serial Number used in CallSerialNumber option.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "MinimumBps",
        "type": "int",
        "description": "Minimum bits per second used in MinimumBps option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MaximumBps",
        "type": "int",
        "description": "Maximum bits per second used in MaximumBps option.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PhysicalChannelId",
        "type": "int",
        "description": "Physical Channel ID used in PhysicalChannelId option.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthenType",
        "type": "int",
        "description": "Authentication Type used in ProxyAuthenType option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "AuthenId",
        "type": "int",
        "description": "Authentication ID used in ProxyAuthenId option.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits a specific L2TPv2 Control header option in a stream based on the provided type. This function identifies the appropriate L2TPv2 Control header at the specified level and modifies the corresponding AVP (Attribute-Value Pair) or TLV (Type-Length-Value) field. It allows configuration of various fields like M bit, H bit, Reserved bits, Length, Vendor ID, Attribute Type, and more depending on the selected option type.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv2Control |\n    | ${LsaHeaders} | Create List | generalTLV | messageType | resultCode | protocolVersion | FramingCapabilities |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv2 Control | Stream=${Stream} | Level=0 | UsePriority=1 | OptionHeaders=${OptionHeaders} |\n    | Edit Header L2tpv2 Control Option | Stream=${Stream} | Level=0 | Index=0 | Types=MessageType | Mbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_control_over_ip",
    "return_type": "dict",
    "return": "A dictionary mapping the parameter names to their corresponding internal attribute names or command paths indicating the successfully updated fields. Returns False if no parameters were provided or none of the parameters resulted in any changes.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the L2TPv3 control over IP header needs to be edited. It should have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the L2TPv3 control over IP header in the list of headers of the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SessionId",
        "type": "int",
        "description": "Session ID for the L2TPv3 connection.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Type",
        "type": "bit",
        "description": "Type field of the L2TPv3 header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UseLength",
        "type": "bit",
        "description": "Flag indicating whether to use length in the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved1",
        "type": "bit",
        "description": "First reserved field in the L2TPv3 header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "UseSequence",
        "type": "bit",
        "description": "Flag indicating whether to use sequence numbers in the header.",
        "default": "<AUTO>0",
        "range_or_options": "00-11"
      },
      {
        "name": "Reserved2",
        "type": "bit",
        "description": "Second reserved field in the L2TPv3 header.",
        "default": "0000000",
        "range_or_options": "0000000-1111111"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Version number of the L2TPv3 protocol.",
        "default": "3",
        "range_or_options": "0-15"
      },
      {
        "name": "ExcludeSessionLength",
        "type": "int",
        "description": "Length value to exclude session length option from the header.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ControlId",
        "type": "int",
        "description": "Control Connection ID for the L2TPv3 connection.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SequenceNumberNs",
        "type": "int",
        "description": "Message sequence number Ns value.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumberNr",
        "type": "int",
        "description": "Message sequence number Nr value.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OptionHeaders",
        "type": "any",
        "description": "Additional optional headers to insert into the L2TPv3 header. Supported values include: generalTLV, messageType, resultCode, tieBreaker, receiveWindowSize, callSerialNumber, physicalChannelId, circuitError, routeId, assignedConnection, localSessionId, remoteSessionId, assignedCookie, pwType, l2SpecificSub, dataSequencing, txConnectSpeed, rxConnectSpeed, circuitStatus.",
        "default": "not_found",
        "range_or_options": "generalTLV messageType resultCode tieBreaker receiveWindowSize callSerialNumber physicalChannelId circuitError routeId assignedConnection localSessionId remoteSessionId assignedCookie pwType l2SpecificSub dataSequencing txConnectSpeed rxConnectSpeed circuitStatus"
      }
    ],
    "description": "Edits the fields of an L2TPv3 control over IP header in a given stream. This function modifies the specified fields of the L2TPv3 control over IP header at the given level within the stream's header hierarchy. If a field is not None, its value will be updated in the header, and the corresponding key-value pair will be included in the result dictionary returned by the function.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | l2tpv3ControlOverIp |\n    | ${OptionHeaders} | Create List | generalTLV | messageType | resultCode | tieBreaker |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv3 Control Over Ip | Stream=${Stream} | Level=0 | Type=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_control_over_udp",
    "return_type": "dict or bool",
    "return": "A dictionary mapping parameter names to the corresponding updated field names if any changes were successfully applied. If no parameters are provided (no changes occur), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "测试仪表流量对象，用于指定需要编辑的流模板。如果传入的是列表，则必须包含一个流对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "要修改的L2TPv3 Control Over UDP头部在该流模板中所有L2TPv3 Control Over UDP头部中的索引位置。",
        "default": "0",
        "range_or_options": "0-N (取决于当前流模板中存在的L2TPv3 Control Over UDP头部数量)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "bit",
        "description": "设置报文头部的 'Type' 字段值。",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UseLength",
        "type": "bit",
        "description": "设置报文头部的 'UseLength' 字段值。",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved1",
        "type": "bit",
        "description": "设置报文头部的 'Reserved1' 字段值。",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "UseSequence",
        "type": "bit",
        "description": "设置报文头部的 'UseSequence' 字段值。",
        "default": "<AUTO>0",
        "range_or_options": "00-11"
      },
      {
        "name": "Reserved2",
        "type": "bit",
        "description": "设置报文头部的 'Reserved2' 字段值。",
        "default": "0000000",
        "range_or_options": "0000000-1111111"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "设置报文头部的 'Version' 字段值。",
        "default": "3",
        "range_or_options": "0-15"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "设置报文头部的 'Length' 字段值。",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ControlId",
        "type": "int",
        "description": "设置报文头部的 'Control Connection ID' 字段值。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SequenceNumberNs",
        "type": "int",
        "description": "设置报文头部的 'Message Sequence Number Ns Value' 字段值。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumberNr",
        "type": "int",
        "description": "设置报文头部的 'Message Sequence Number Nr Value' 字段值。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "指定要插入的可选头部字段，支持以下选项：generalTLV, messageType, resultCode, tieBreaker, receiveWindowSize, callSerialNumber, physicalChannelId, circuitError, routeId, assignedConnection, localSessionId, remoteSessionId, assignedCookie, pwType, l2SpecificSub, dataSequencing, txConnectSpeed, rxConnectSpeed, circuitStatus。",
        "default": "not_found",
        "range_or_options": "generalTLV messageType resultCode tieBreaker receiveWindowSize callSerialNumber physicalChannelId circuitError routeId assignedConnection localSessionId remoteSessionId assignedCookie pwType l2SpecificSub dataSequencing txConnectSpeed rxConnectSpeed circuitStatus"
      }
    ],
    "description": "Edits the fields of an L2TPv3 control over UDP header in a specified stream. This function allows modifying various fields of an L2TPv3 control over UDP header at a given level within the header hierarchy of the stream. If a field is provided (not None), it updates that field in the header and records the change in the result dictionary. If no changes are made, it returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv3ControlOverUdp |\n    | ${OptionHeaders} | Create List | generalTLV | messageType | resultCode | tieBreaker |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv3 Control Over Udp | Stream=${Stream} | Level=0 | Type=1 | OptionHeaders=${OptionHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_control_option",
    "return_type": "dict",
    "return": "A dictionary containing the result of the operation, such as field names mapped to their updated values. Returns False if no changes were made or an error occurred.",
    "description": "Edits specific fields of an L2TPv3 control header in a given stream based on the provided type and index. This function allows for detailed configuration of various AVP (Attribute Value Pair) options within the L2TPv3 control protocol.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The test instrument stream object where the L2TPv3 Control Over IP/UDP header resides.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Types",
        "type": "str",
        "description": "Specifies the type of L2TPv3 control header option to modify.",
        "default": "not_found",
        "range_or_options": "GeneralTLV MessageType ResultCode TieBreaker ReceiveWindowSize CallSerialNumber PhysicalChannelId CircuitError RouteId AssignedConnection LocalSessionId RemoteSessionId AssignedCookie PwType L2SpecificSub DataSequencing TxConnectSpeed RxConnectSpeed CircuitStatus"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the L2TPv3 header in the stream's header hierarchy, used when multiple L2TPv3 headers are present.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the specific field or option within the selected header type to modify.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Mbit",
        "type": "bit",
        "description": "M Bit flag indicating whether this AVP is mandatory.",
        "default": "0 or 1 depending on header type",
        "range_or_options": "0-1"
      },
      {
        "name": "Hbit",
        "type": "bit",
        "description": "H Bit flag indicating whether hiding this AVP has occurred.",
        "default": "0 or 1 depending on header type",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "Reserved bits in the header, typically set to zero.",
        "default": "0000",
        "range_or_options": "0000-1111"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the attribute value in bytes.",
        "default": "<AUTO>0",
        "range_or_options": "0-1023"
      },
      {
        "name": "VendorId",
        "type": "int",
        "description": "Vendor ID associated with the attribute type.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Attribute Type identifier.",
        "default": "varies per header type",
        "range_or_options": "0-65535"
      },
      {
        "name": "AttributeValue",
        "type": "hex",
        "description": "Hexadecimal representation of the attribute value.",
        "default": "00000000000000000000000000000000",
        "range_or_options": "length 0-1017 bytes"
      },
      {
        "name": "MessageType",
        "type": "int",
        "description": "Message Type of the L2TPv3 control message.",
        "default": "1 or 0 depending on header type",
        "range_or_options": "0-65535"
      },
      {
        "name": "ResultCode",
        "type": "int",
        "description": "Result Code returned by the peer.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ErrorCode",
        "type": "int",
        "description": "Error Code providing additional information about the result.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ErrorMessage",
        "type": "hex",
        "description": "Optional error message in hexadecimal format.",
        "default": "\"\"",
        "range_or_options": "length 0-1017 bytes"
      },
      {
        "name": "TieBreakerValue",
        "type": "hex",
        "description": "Tie Breaker value used during session negotiation.",
        "default": "0000000000000000",
        "range_or_options": "length 0-8 bytes"
      },
      {
        "name": "WindowSize",
        "type": "int",
        "description": "Size of the receive window for flow control.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "CallSerialNumber",
        "type": "int",
        "description": "Unique serial number assigned to a call.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PhysicalChannelId",
        "type": "int",
        "description": "Identifier for the physical channel.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HardwareOverruns",
        "type": "int",
        "description": "Count of hardware overruns.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BufferOverruns",
        "type": "int",
        "description": "Count of buffer overruns.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TimeoutOverruns",
        "type": "int",
        "description": "Count of timeout overruns.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AlignmentOverruns",
        "type": "int",
        "description": "Count of alignment errors.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RouteId",
        "type": "int",
        "description": "Router ID associated with the session.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ConnectionId",
        "type": "int",
        "description": "Assigned connection ID for the control connection.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "Session ID for local or remote session.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Cookie4Byte",
        "type": "hex",
        "description": "4-byte cookie value for session identification.",
        "default": "00000000",
        "range_or_options": "00000000-FFFFFFFF"
      },
      {
        "name": "Cookie8Byte",
        "type": "hex",
        "description": "8-byte cookie value for extended session identification.",
        "default": "0000000000000000",
        "range_or_options": "0000000000000000-FFFFFFFFFFFFFFFF"
      },
      {
        "name": "PwType",
        "type": "int",
        "description": "Pseudowire type associated with the session.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "L2SpecificSublayer",
        "type": "int",
        "description": "L2-specific sublayer type.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "DataSequencing",
        "type": "int",
        "description": "Indicates support for data sequencing.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SpeedBps",
        "type": "hex",
        "description": "Connection speed in bits per second.",
        "default": "0000000000000000",
        "range_or_options": "0000000000000000-FFFFFFFFFFFFFFFF"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "Reserved field for internal use or future expansion.",
        "default": "71 or 0 depending on header type",
        "range_or_options": "0-16383"
      },
      {
        "name": "Nbit",
        "type": "bit",
        "description": "Flag indicating whether notification bit is set.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Abit",
        "type": "bit",
        "description": "Flag indicating acknowledgment required.",
        "default": "0",
        "range_or_options": "0-1"
      }
    ],
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | l2tpv3ControlOverIp |\n| ${LsaHeaders} | Create List | generalTLV | messageType | resultCode | tieBreaker | receiveWindowSize |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header L2tpv3 Control Option | Stream=${Stream} | Level=0 | Index=0 | Types=GeneralTLV | Mbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_data_over_ip",
    "return_type": "dict",
    "return": "A dictionary indicating the mapping of successfully modified header fields. Each key corresponds to the parameter name passed (e.g., 'SessionId', 'Cookie4Byte'), and the value is the internal identifier string used to reference that field in the system.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, the first element is used. The stream object is expected to have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the L2TPv3 data over IP header in the list of headers of the specified stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SessionId",
        "type": "int",
        "description": "The value to set for the session ID field in the L2TPv3 header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Cookie4Byte",
        "type": "hex",
        "description": "The 4-byte cookie value to set in the header.",
        "default": "00000000",
        "range_or_options": "00000000-FFFFFFFF"
      },
      {
        "name": "Cookie8Byte",
        "type": "hex",
        "description": "The 8-byte cookie value to set in the header.",
        "default": "0000000000000000",
        "range_or_options": "0000000000000000-FFFFFFFFFFFFFFFF"
      },
      {
        "name": "L2specificsublayer",
        "type": "int",
        "description": "Value to configure the L2-specific sublayer field in the header.",
        "default": "0",
        "range_or_options": "1"
      },
      {
        "name": "Atmspecificsublayer",
        "type": "int",
        "description": "Value to configure the ATM-specific sublayer field in the header.",
        "default": "0",
        "range_or_options": "1"
      }
    ],
    "description": "Modifies the fields of an L2TPv3 data over IP header in a specified stream. This function retrieves the list of headers for the given stream and selects the L2TPv3 data over IP header at the specified level. It then allows updating various fields of that header, such as Session ID, 4-byte cookie, 8-byte cookie, L2-specific sublayer, and ATM-specific sublayer.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | l2tpv3DataOverIp |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header L2tpv3 Data Over Ip | Stream=${Stream} | Level=0 | SessionId=1 | Cookie4Byte=00000001 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_data_over_udp",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding field name in the header object. Fields that were not modified are not included.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the L2TPv3 Data Over UDP header needs to be edited. It must have a 'handle' attribute used to uniquely identify the stream in the system. If a list of streams is passed, the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index (sequence number) of the 'l2tpv3dataoverudp' header among all such headers in the stream. Used to select which header to edit.",
        "default": "0",
        "range_or_options": "0 - N (where N is number of l2tpv3dataoverudp headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "bit",
        "description": "Sets the Type field of the L2TPv3 Data Over UDP header.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Reserved1",
        "type": "bit",
        "description": "Sets the Reserved1 field of the L2TPv3 Data Over UDP header.",
        "default": "00000000000",
        "range_or_options": "00000000000 11111111111"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the Version field of the L2TPv3 Data Over UDP header.",
        "default": "3",
        "range_or_options": "0-15"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "Sets the Reserved2 field of the L2TPv3 Data Over UDP header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SessionId",
        "type": "int",
        "description": "Sets the Session ID field of the L2TPv3 Data Over UDP header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "cookie4Byte",
        "type": "hex",
        "description": "Sets the 4-byte Cookie value in the L2TPv3 Data Over UDP header.",
        "default": "00000000",
        "range_or_options": "00000000 FFFFFFFFF"
      },
      {
        "name": "cookie8Byte",
        "type": "hex",
        "description": "Sets the 8-byte Cookie value in the L2TPv3 Data Over UDP header.",
        "default": "0000000000000000",
        "range_or_options": "0000000000000000 FFFFFFFFFFFFFFFF"
      },
      {
        "name": "L2specificsublayer",
        "type": "int",
        "description": "Sets the L2 Specific Sublayer count in the L2TPv3 Data Over UDP header.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Atmspecificsublayer",
        "type": "int",
        "description": "Sets the ATM Specific Sublayer count in the L2TPv3 Data Over UDP header.",
        "default": "0",
        "range_or_options": "0 1"
      }
    ],
    "description": "Edits the fields of an 'l2tpv3dataoverudp' type header in a given stream at a specified level. This function allows modifying specific fields of the L2TPv3 Data Over UDP header, such as Type, Reserved, Version, Session ID, and Cookies. Only provided parameters are modified; others remain unchanged.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv3DataOverUdp |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header L2tpv3 Data Over Udp | Stream=${Stream} | Level=0 | SessionId=1 | Cookie4Byte=00000001 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Access.l2tpv3.edit_header_l2tpv3_data_sublayer",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the edit operation if successful, otherwise returns False.",
    "description": "Edits a specific sublayer of the L2TPv3 data over IP or UDP header in a given stream at the specified level. This function retrieves the headers associated with the provided stream and filters them to only include L2TPv3 data over IP or UDP headers. It then selects the header at the specified level and invokes its `edit_specific_sublayer` method with the provided type and additional parameters.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "The type of the sublayer to be edited. This corresponds to the specific field or part of the L2TPv3 data sublayer that needs modification.",
        "default": "''",
        "range_or_options": "L2specificsublayer Atmspecificsublayer"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the L2TPv3 data header in the list of headers found for the stream. Use this parameter to specify which L2TPv3 header (if multiple exist) should be modified.",
        "default": "0",
        "range_or_options": "0 - n (where n depends on number of matching headers)"
      }
    ],
    "kwargs": [
      {
        "name": "Xbit",
        "type": "bit",
        "description": "X Bit flag for both L2specificsublayer and Atmspecificsublayer types.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Sbit",
        "type": "bit",
        "description": "S Bit flag for both L2specificsublayer and Atmspecificsublayer types.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Xbits",
        "type": "bit",
        "description": "Extended X Bits (only for L2specificsublayer).",
        "default": "000000",
        "range_or_options": "000000 - 111111"
      },
      {
        "name": "Sequence",
        "type": "int",
        "description": "Sequence Number for ordering packets.",
        "default": "0",
        "range_or_options": "0 - 16777215"
      },
      {
        "name": "Bbit",
        "type": "bit",
        "description": "B Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Ebit",
        "type": "bit",
        "description": "E Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Tbit",
        "type": "bit",
        "description": "T Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Gbit",
        "type": "bit",
        "description": "G Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Cbit",
        "type": "bit",
        "description": "C Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Ubit",
        "type": "bit",
        "description": "U Bit flag (only for Atmspecificsublayer).",
        "default": "0",
        "range_or_options": "0 1"
      }
    ],
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | UDP | l2tpv3DataOverUdp |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header L2tpv3 Data Over Udp | Stream=${Stream} | Level=0 | SessionId=1 | Cookie4Byte=00000001 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Basic.common.edit_header_custom",
    "return_type": "dict",
    "return": "A dictionary indicating the successfully updated options ('Pattern' and/or 'Checksum') and their values. Returns False if no updates were performed due to invalid or missing parameters.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The hierarchical level of the custom header to modify within the stream's custom headers.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index at which to edit the existing option (Pattern or Checksum) among all PatternByte and Checksum entries in the Custom header.",
        "default": "not_found",
        "range_or_options": "0-2"
      }
    ],
    "kwargs": [
      {
        "name": "Pattern",
        "type": "list",
        "description": "Specifies the hexadecimal pattern value to insert or edit. Each element is a byte represented as a hex string.",
        "default": "['00']",
        "range_or_options": "Length: 1-16384 bytes, Hexadecimal values only"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Specifies the checksum value for the custom header. Can be a hexadecimal string or set to 'AUTO'.",
        "default": "'0000'",
        "range_or_options": "0000-FFFF AUTO"
      }
    ],
    "description": "Edits custom header options (Pattern and/or Checksum) for a specified level in the custom headers of a stream. If an Index is provided, it modifies the existing option at that index; otherwise, it inserts a new option. This function modifies the header structure of the stream and may interact with the backend system via command layer calls.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Custom |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_custom | Stream=${Stream} | Pattern=1212121212 |\n    | edit_header_custom | Stream=${Stream} | Checksum=Auto |\n    | edit_header_custom | Stream=${Stream} | Pattern=343434343 | Checksum=Auto |\n    | edit_header_custom | Stream=${Stream} | Index=0 | Pattern=565656565 |\n    | &{Attribute} | edit_header_custom | Stream=${Stream} | Index=2 | Pattern=787878787 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=Custom | Attribute=${Attribute}[Pattern] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_CustomerStagEthernet",
    "return_type": "dict or False",
    "return": "A dictionary mapping the parameter names to their corresponding field paths in the header that were successfully updated. If no parameters are provided or no changes are made, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. If a list is provided, only the first item is used. The stream must have a handle attribute that uniquely identifies it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'stag' header in the header chain to be edited. Default is 0 (the first 'stag' header).",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EtherType",
        "type": "hex",
        "description": "The value to set for the EtherType field of the header. This defines the type of the encapsulated protocol.",
        "default": "88B5",
        "range_or_options": "2-digit hexadecimal number"
      },
      {
        "name": "VlanType",
        "type": "hex",
        "description": "Service VLAN Type field of the S-tag. Defines the type of service tag being used.",
        "default": "88a8",
        "range_or_options": "2-digit hexadecimal number"
      },
      {
        "name": "VlanPCP",
        "type": "bit",
        "description": "Priority Code Point (PCP) field of the S-tag. Used for Quality of Service prioritization.",
        "default": "001",
        "range_or_options": "3-bit binary number"
      },
      {
        "name": "Dei",
        "type": "bit",
        "description": "Drop Eligible Indicator (DEI) field of the S-tag. Indicates whether the frame may be dropped in case of congestion.",
        "default": "0",
        "range_or_options": "1-bit binary number"
      },
      {
        "name": "Vid",
        "type": "bit",
        "description": "VLAN Identifier (VID) field of the S-tag. Identifies the VLAN to which the frame belongs.",
        "default": "000000000100",
        "range_or_options": "12-bit binary number"
      }
    ],
    "description": "Edits the fields of an 802.1ah Customer S-tag Ethernet header in a specified stream. This function allows modification of specific fields in the 'stag' (Service VLAN tag) header at a given level in the header chain of a stream. If any field is provided (not None), it updates the corresponding attribute of the header object and records the change in the result dictionary.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=sTag |\n| Edit Header 8021ah CustomerStagEthernet | Stream=${Stream} | Level=0 | VlanPCP=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_EncapsulatedCustomerEthernetII",
    "return_type": "dict",
    "return": "Returns a dictionary indicating the successfully updated fields in the header. Keys are field names (e.g., 'EtherType'), and values correspond to the attribute names set on the header object (e.g., 'etherType'). Fields are only included if they were provided in the input.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, only the first element will be used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the 'encapethernetii' header in the stream's list of headers. Only the header at this level will be modified.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EtherType",
        "type": "str or int",
        "description": "The EtherType value to set for the encapsulated Ethernet II header. Updates the 'etherType' attribute of the header.",
        "default": "88B5",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "ServiceTag",
        "type": "any",
        "description": "A flag indicating whether to insert a service tag into the header. If not None, a service tag will be inserted by calling the header's insert_service_tag() method.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerTag",
        "type": "any",
        "description": "A flag indicating whether to insert a customer tag into the header. If not None, a customer tag will be inserted by calling the header's insert_customer_tag() method.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "Edits the attributes of an Encapsulated Ethernet II header (802.1ah) in a specified stream. This function allows modifying the EtherType field, inserting a service tag, and/or inserting a customer tag in the specified header level of the stream.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=encapEthernetII |\n    | Edit Header 8021ah EncapsulatedCustomerEthernetII | Stream=${Stream} | Level=0 | ServiceTag=True |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_EncapsulatedCustomerEthernetII_serviceTag",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the configuration changes made to the service tag. Each key corresponds to a modified field, and the value indicates the success or new value. If no changes were attempted (i.e., all parameters were None), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing a single stream object) for which the header needs to be edited. The stream is expected to have a 'handle' attribute that uniquely identifies it in the system. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the 'encapethernetii' header within the list of headers associated with the stream. This specifies which encapsulated Ethernet II header to modify when multiple such headers are present.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "VlanType",
        "type": "str or hex",
        "description": "Service VLAN Type, represents the Ethertype of the service tag. It should be a 2-character hexadecimal string.",
        "default": "88a8",
        "range_or_options": "two-character hexadecimal string"
      },
      {
        "name": "VlanPCP",
        "type": "str or int",
        "description": "Service VLAN Priority Code Point (PCP). Specifies the priority of the VLAN traffic. Should be a 3-bit binary number represented as a string or integer.",
        "default": "001",
        "range_or_options": "000 001 010 011 100 101 110 111"
      },
      {
        "name": "Dei",
        "type": "str or int",
        "description": "Drop Eligible Indicator (DEI). A bit flag indicating whether the frame is eligible for dropping. Should be a binary digit (0 or 1).",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Vid",
        "type": "str or int",
        "description": "Service VLAN Identifier. A 12-bit identifier for the VLAN. Should be a binary string of length 12 or an integer between 0 and 4095.",
        "default": "000000000100",
        "range_or_options": "12-bit binary string or integer from 0 to 4095"
      }
    ],
    "description": "Edits the service tag (802.1ah Encapsulated Customer Ethernet II) of a specified stream header. This function allows modification of specific fields in an 802.1ah encapsulated Ethernet II header's service tag. It retrieves the headers for the given stream and selects the appropriate header at the specified level that matches the 'encapethernetii' type. If any of the parameters (VlanType, VlanPCP, Dei, or Vid) are provided, they are applied to the service tag via the header object’s config_service_tag method.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=encapEthernetII |\n    | Edit Header 8021ah EncapsulatedCustomerEthernetII | Stream=${Stream} | Level=0 | ServiceTag=True |\n    | Edit Header 8021ah EncapsulatedCustomerEthernetII ServiceTag | Stream=${Stream} | Level=0 | VlanPCP=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_EncapsulatedCustomerEthernetII_customerTag",
    "return_type": "dict or False",
    "return": "A dictionary containing the successfully updated customer tag fields (e.g., Type, Pcp, Cfi, Id) and their new values. If no updates are made or an error occurs, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object of type StreamTemplate",
        "description": "The stream object that contains the 802.1ah encapsulated customer Ethernet II header to be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'encapethernetii' header in the list of headers associated with the stream. Used to identify which header to modify if multiple exist.",
        "default": "0",
        "range_or_options": ">=0"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex string",
        "description": "Sets the customer tag's type field. Typically a 2-character hexadecimal value.",
        "default": "8100",
        "range_or_options": "00-FF"
      },
      {
        "name": "Pcp",
        "type": "bit string or int",
        "description": "Priority Code Point (PCP), indicating the frame's priority level.",
        "default": "001",
        "range_or_options": "000 001 010 011 100 101 110 111"
      },
      {
        "name": "Cfi",
        "type": "bit string or int",
        "description": "Canonical Format Indicator (CFI), indicating whether MAC addresses are in canonical format.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Id",
        "type": "bit string or int",
        "description": "Identifier for the customer tag, typically representing a VLAN ID or similar value.",
        "default": "000000000100",
        "range_or_options": "000000000000-111111111111"
      }
    ],
    "description": "Modifies one or more fields of the customer tag (Type, Priority Code Point (Pcp), Canonical Format Indicator (Cfi), Identifier (Id)) in the specified 802.1ah Encapsulated Customer Ethernet II header within the given stream. This function is used to customize the customer tag part of the packet template for traffic generation and testing purposes.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=encapEthernetII |\n    | Edit Header 8021ah EncapsulatedCustomerEthernetII | Stream=${Stream} | Level=0 | CustomerTag=True |\n    | Edit Header 8021ah EncapsulatedCustomerEthernetII CustomerTag | Stream=${Stream} | Level=0 | Pcp=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_EncapsulatedBackboneEthernet",
    "return_type": "dict or False",
    "return": "A dictionary mapping each successfully modified field name (e.g., 'EtherType', 'Vid') to its corresponding internal property path if any fields were updated. Returns `False` if no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the Encapsulated Backbone Ethernet header to modify, if multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EtherType",
        "type": "str or int",
        "description": "New EtherType value for the header. Updates the 'etherType' field of the header.",
        "default": "88B5",
        "range_or_options": "00-FF (hex)"
      },
      {
        "name": "VlanType",
        "type": "str or int",
        "description": "VLAN type to set in the backbone VLAN tag. Updates the 'vlanType' field in the VLAN tag.",
        "default": "88a8",
        "range_or_options": "00-FF (hex)"
      },
      {
        "name": "VlanPCP",
        "type": "str or int",
        "description": "VLAN Priority Code Point (PCP) to set. Updates the 'vlanPCP' field in the VLAN tag.",
        "default": "001",
        "range_or_options": "000-111 (binary)"
      },
      {
        "name": "Dei",
        "type": "str or int",
        "description": "Drop Eligible Indicator (DEI) bit. Updates the 'dei' field in the VLAN tag.",
        "default": "1",
        "range_or_options": "0-1 (binary)"
      },
      {
        "name": "Vid",
        "type": "str or int",
        "description": "VLAN Identifier (VID). Updates the 'vid' field in the VLAN tag.",
        "default": "100",
        "range_or_options": "0-4095"
      }
    ],
    "description": "Modifies specific fields of an 802.1ah Encapsulated Backbone Ethernet header in a given stream. This function allows editing of various components of the Encapsulated Backbone Ethernet (also known as Provider Backbone Bridge, PBB) header at a specified level within the stream's header hierarchy. Supported fields include EtherType, VLAN-related fields (type, priority, drop eligibility indicator, and VLAN ID).",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=encapbackboneeth |\n    | Edit Header 8021ah EncapsulatedBackboneEthernet | Stream=${Stream} | Level=0 | VlanPCP=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_iTag",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping each modified field name to its internal attribute name if changes were applied. Returns False if no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the iTag header will be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the iTag header in the list of headers of type 'itag'. Default is 0.",
        "default": "0",
        "range_or_options": "0 - n (where n is number of itag headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Pcp",
        "type": "bit (3-bit binary)",
        "description": "Priority Code Point value to set in the iTag header.",
        "default": "000",
        "range_or_options": "000 001 010 ... 111"
      },
      {
        "name": "Drop",
        "type": "bit (boolean)",
        "description": "Drop Eligible Indicator (DEI) flag to mark the packet as eligible for dropping.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Uca",
        "type": "bit",
        "description": "Unicast/Multicast flag; Use Customer Address, typically 1 for unicast and 0 for multicast.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Res1",
        "type": "bit",
        "description": "Reserved bit field 1 (must comply with protocol specifications).",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Res2",
        "type": "bit (2-bit binary)",
        "description": "Reserved bit field 2 (must comply with protocol specifications).",
        "default": "00",
        "range_or_options": "00 01 10 11"
      },
      {
        "name": "ServiceId",
        "type": "int",
        "description": "Service Identifier assigned by the provider network.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "EncapCusDstAddr",
        "type": "str",
        "description": "Encapsulated Customer Destination MAC Address in string format (e.g., '00:00:00:00:00:00').",
        "default": "00:00:00:13:40:20",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "SourceMacAdd",
        "type": "str",
        "description": "Source MAC Address in string format (e.g., '00:00:00:00:00:00').",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address"
      }
    ],
    "description": "Edits the fields of an 802.1ah iTag header in a specified stream. This function retrieves the headers of the given stream and filters for 'itag' type headers. It then modifies the fields of the iTag header at the specified level (index). Only provided parameters are updated; if a parameter is None, the corresponding field remains unchanged.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=iTag |\n| Edit Header 8021ah Itag | Stream=${Stream} | Level=0 | Pcp=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_MacInMac",
    "return_type": "dict or raises ContinuableFailure",
    "return": "Returns a dictionary mapping the provided parameter names to their corresponding internal field names that were successfully updated in the Mac-in-Mac header. If none of the parameters are updated, it returns False and raises a ContinuableFailure.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing the traffic template on which the Mac-in-Mac header is to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the 'mac-in-mac' header in the header hierarchy of the stream. Useful when multiple headers of the same type exist.",
        "default": "0",
        "range_or_options": "0 - depends on number of mac-in-mac headers in stream"
      }
    ],
    "kwargs": [
      {
        "name": "DestMacAdd",
        "type": "str",
        "description": "New destination MAC address value for the Mac-in-Mac header.",
        "default": "00:00:00:13:40:20",
        "range_or_options": "valid MAC addresses (e.g., 00:00:00:00:00:00 to FF:FF:FF:FF:FF:FF)"
      },
      {
        "name": "SourceMacAdd",
        "type": "str",
        "description": "New source MAC address value for the Mac-in-Mac header.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC addresses"
      },
      {
        "name": "EtherType",
        "type": "hex",
        "description": "New EtherType value for the Mac-in-Mac header.",
        "default": "88B5",
        "range_or_options": "two-digit hexadecimal numbers (e.g., 00-FF)"
      },
      {
        "name": "VlanType",
        "type": "hex",
        "description": "New VLAN Type value for the B-VLAN tag within the Mac-in-Mac header.",
        "default": "88a8",
        "range_or_options": "two-digit hexadecimal numbers"
      },
      {
        "name": "VlanPCP",
        "type": "bit",
        "description": "New VLAN Priority Code Point (PCP) value for prioritizing traffic in the B-VLAN tag.",
        "default": "001",
        "range_or_options": "3-bit binary values (000 to 111)"
      },
      {
        "name": "Dei",
        "type": "bit",
        "description": "New Drop Eligible Indicator (DEI) bit value for the B-VLAN tag.",
        "default": "1",
        "range_or_options": "single binary digit (0 or 1)"
      },
      {
        "name": "Vid",
        "type": "int",
        "description": "New VLAN Identifier (VID) value for the B-VLAN tag.",
        "default": "100",
        "range_or_options": "0-4095"
      }
    ],
    "description": "Modifies specific fields of the IEEE 802.1ah Mac-in-Mac header in a given stream at the specified level. Only the fields for which non-default values are passed will be updated. This function is typically used in network testing scenarios where precise control over Ethernet headers is required.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=mac-in-mac |\n    | Edit Header 8021ah MacInMac | Stream=${Stream} | Level=0 | VlanPCP=111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.dot1ah.dot1ah.edit_header_8021ah_EncapsulatedCustomerEthernet",
    "return_type": "dict or False",
    "return": "Returns a dictionary indicating the modified EtherType field if successfully updated (e.g., {'EtherType': 'etherType'}), or False if no modifications were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. If a list is provided, the first element will be used. The stream object must have a 'handle' attribute to uniquely identify it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the filtered list of Encapsulated Customer Ethernet headers within the stream that should be modified.",
        "default": "0",
        "range_or_options": ">=0"
      }
    ],
    "kwargs": [
      {
        "name": "EtherType",
        "type": "int or str (hex)",
        "description": "The new EtherType value to set for the selected header. It can be an integer or a hexadecimal string. If not provided, no change is made to the EtherType.",
        "default": "0x88B5 (default from backend)",
        "range_or_options": "2-byte hexadecimal value (e.g., 0x1111, 1111)"
      }
    ],
    "description": "Modifies the EtherType field of an Encapsulated Customer Ethernet (802.1ah) header in a given stream template. This function filters all headers in the stream to only include those of type 'encapcustomereth', then selects the one at the specified level and updates its EtherType if provided.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=encapCustomerEth |\n    | Edit Header 8021ah EncapsulatedCustomerEthernet | Stream=${Stream} | Level=0 | EtherType=1111 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Gre.common.edit_header_gre",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated parameter name to its corresponding internal field name in the GRE header. Returns False if no changes were made (i.e., all parameters were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the GRE header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index specifying which GRE header to modify if multiple GRE headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "ChecksumPresent",
        "type": "int",
        "description": "Sets whether the checksum field is present in the GRE header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Routing",
        "type": "int",
        "description": "Configures routing-related information in the GRE header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "KeyPresent",
        "type": "int",
        "description": "Sets whether a key field is included in the GRE header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "SequenceNumberPresent",
        "type": "int",
        "description": "Sets whether a sequence number field is included in the GRE header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Sets reserved bits or fields in the GRE header.",
        "default": "0",
        "range_or_options": "0-511"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version of the GRE protocol being used.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "Specifies the type of payload encapsulated within the GRE packet.",
        "default": "0800",
        "range_or_options": "0800 6558 8847 86DD"
      },
      {
        "name": "Checksum",
        "type": "int",
        "description": "Inserts or updates the checksum value in the GRE header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChecksumReserved",
        "type": "int",
        "description": "Inserts or updates the reserved field within the checksum section of the GRE header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Key",
        "type": "int",
        "description": "Inserts or updates the key value in the GRE header. Used for identifying GRE tunnels.",
        "default": "0",
        "range_or_options": "0-4924967295"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Inserts or updates the sequence number in the GRE header. Useful for ordering packets.",
        "default": "0",
        "range_or_options": "0-4924967295"
      },
      {
        "name": "EnableKeepAlive",
        "type": "int",
        "description": "Enables or disables keep-alive functionality for GRE tunnel.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "KeepAlivePeriod",
        "type": "int",
        "description": "Sets the interval between keep-alive messages in seconds.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "KeepAliveRetries",
        "type": "int",
        "description": "Sets the number of failed keep-alive attempts before declaring failure.",
        "default": "3",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits the configuration of a GRE (Generic Routing Encapsulation) header in a specified stream. This function retrieves the GRE headers from the provided stream and modifies the properties of the GRE header at the specified level. If optional parameters are provided, they will be applied to update corresponding fields in the GRE header. The function supports updating both base GRE header fields and optional subfields like checksum, key, and sequence number.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | GRE |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Gre | Stream=${Stream} | Level=0 | KeepAlivePeriod=100 | KeepAliveRetries=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_ethernet",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the modified parameter names to their internal attribute names (e.g., {'DestMacAdd': 'destMacAdd'}) if changes were made. Returns False if no parameters were provided for modification, indicating that no changes occurred.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose Ethernet header needs to be edited. Must have a unique identifier (handle). If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index specifying which Ethernet header in the header chain should be edited. Used to target nested headers.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestMacAdd",
        "type": "str",
        "description": "The new destination MAC address to set in the Ethernet header. Format must follow standard MAC address notation.",
        "default": "00:00:00:13:40:20",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "SourceMacAdd",
        "type": "str",
        "description": "The new source MAC address to set in the Ethernet header. Format must follow standard MAC address notation.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "ProtocolType",
        "type": "str",
        "description": "The EtherType or protocol type value to assign to the Ethernet header. Typically represented as a hexadecimal string.",
        "default": "88B5",
        "range_or_options": "0800 0806 8100 8863 8864 86DD 8808 8847 8926 8914 8906 88CC 88B8"
      }
    ],
    "kwargs": [],
    "description": "Modifies the Ethernet header fields of a specified stream at a given level in the header hierarchy. This function retrieves the Ethernet headers from the specified stream, selects the header at the provided level, and updates its configurable fields (destination MAC address, source MAC address, and protocol type) if new values are provided. Only the fields for which values are passed will be modified. The modification is applied in-place on the stream object.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port[0]} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header Ethernet | Stream=${Stream} | Level=0 | DestMacAdd=00:01:01:01:01:02 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=EthernetII | Attribute=${Attribute}[DestMacAdd] | Type=Increment | Count=10 | Step=2 |\n    | ${Pattern} | Create Capture Pdu Pattern | Port=${Port[1]} | HeaderTypes=${HeaderTypes} | Level=0 | Attribute=${Attribute}[DestMacAdd] | Value=00:01:01:01:01:02 | MaxValue=00:01:01:01:01:02 |\n    | Edit Capture Filter | Port=${Port} | Expression=${Pattern} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_raw_8023",
    "return_type": "dict or False",
    "return": "A dictionary mapping the updated parameter names (e.g., 'DestMacAdd', 'SourceMacAdd', 'PayloadLength') to their corresponding internal attribute names (e.g., 'destMacAdd', 'sourceMacAdd', 'length') if any updates were successfully applied. If no parameters are provided (i.e., all are None), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the Ethernet headers to be edited. Must have a unique identifier such as 'handle'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the raw Ethernet header in the list of headers within the stream. Used to specify which header to edit when multiple exist.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestMacAdd",
        "type": "str",
        "description": "New destination MAC address to set in the Ethernet header. If not provided, this field is not modified.",
        "default": "00:00:00:13:40:20",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "SourceMacAdd",
        "type": "str",
        "description": "New source MAC address to set in the Ethernet header. If not provided, this field is not modified.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "New payload length value to set in the Ethernet header. If not provided, this field is not modified.",
        "default": "AUTO",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Modifies specific fields of a raw 802.3 Ethernet header in the given stream at the specified level. Only the provided fields are updated; others remain unchanged. This function interacts with the backend system and may affect the actual configuration of the test traffic once applied.",
    "example": ".. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port[0]} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header Ethernet | Stream=${Stream} | Level=0 | DestMacAdd=00:01:01:01:01:02 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=EthernetII | Attribute=${Attribute}[DestMacAdd] | Type=Increment | Count=10 | Step=2 |\n    | ${Pattern} | Create Capture Pdu Pattern | Port=${Port[1]} | HeaderTypes=${HeaderTypes} | Level=0 | Attribute=${Attribute}[DestMacAdd] | Value=00:01:01:01:01:02 | MaxValue=00:01:01:01:01:02 |\n    | Edit Capture Filter | Port=${Port} | Expression=${Pattern}"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_8023",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the successfully modified header fields to their internal attribute names (e.g., {'DestMacAdd': 'destMacAdd'}). Returns False if no parameters were provided or no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the IEEE 802.3 header in the stream's header list to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "DestMacAdd",
        "type": "str",
        "description": "New destination MAC address (e.g., '00:11:22:33:44:55').",
        "default": "00:00:00:13:40:20",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "SourceMacAdd",
        "type": "str",
        "description": "New source MAC address (e.g., 'AA:BB:CC:DD:EE:FF').",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "Length of the payload following the MAC headers.",
        "default": "46",
        "range_or_options": "0-65535"
      },
      {
        "name": "Dsap",
        "type": "hex",
        "description": "DSAP (Destination Service Access Point) value for LLC header.",
        "default": "AA",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ssap",
        "type": "hex",
        "description": "SSAP (Source Service Access Point) value for LLC header.",
        "default": "AA",
        "range_or_options": "00-FF"
      },
      {
        "name": "Control",
        "type": "hex",
        "description": "Control field value for LLC header.",
        "default": "03",
        "range_or_options": "00-FF"
      },
      {
        "name": "Oui",
        "type": "hex",
        "description": "Organizationally Unique Identifier for SNAP header.",
        "default": "000000",
        "range_or_options": "3-byte hexadecimal string"
      },
      {
        "name": "Type",
        "type": "hex",
        "description": "Protocol type for SNAP header (2-byte hexadecimal).",
        "default": "FFFF",
        "range_or_options": "2-byte hexadecimal value"
      }
    ],
    "description": "Modifies specific fields of an IEEE 802.3 Ethernet header in a given stream at the specified level. This function allows updating various parts of the Ethernet 802.3 header, including MAC addresses, payload length, LLC fields (DSAP, SSAP, Control), and SNAP fields (OUI, Type).",
    "example": "| Edit Header 8023 | Stream=${Stream} | Level=0 | DestMacAdd=00:01:01:01:01:02 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_llc",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping the modified LLC header fields ('Dsap', 'Ssap', 'Control') to their internal identifiers if any changes were made. If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies which LLC header to modify if multiple LLC headers exist in the stream. A value of 0 means the first LLC header encountered in the stream's header list.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Dsap",
        "type": "hex",
        "description": "The new value for the DSAP (Destination Service Access Point) field of the LLC header. If None, this field remains unchanged.",
        "default": "AA",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ssap",
        "type": "hex",
        "description": "The new value for the SSAP (Source Service Access Point) field of the LLC header. If None, this field remains unchanged.",
        "default": "AA",
        "range_or_options": "00-FF"
      },
      {
        "name": "Control",
        "type": "int",
        "description": "The new value for the Control field of the LLC header. If None, this field remains unchanged.",
        "default": "03",
        "range_or_options": "00-FF"
      }
    ],
    "description": "Modifies the Logical Link Control (LLC) header of a specified stream at a given level. This function allows selective updating of the DSAP, SSAP, and Control fields in the LLC header. Only the fields provided (i.e., not None) are updated. The function modifies the stream's header directly and internally manages caching of the stream's headers via `get_stream_header` if needed.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Header Llc | Stream=${Stream} | Level=0 | Dsap=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_vlan",
    "return_type": "dict or False",
    "return": "A dictionary mapping the modified VLAN header attribute names (e.g., 'ID', 'Priority') to their corresponding internal attribute names (e.g., 'id', 'priority'). If no attributes were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object (StreamTemplate)",
        "description": "The stream object representing a traffic template on which the VLAN header will be edited. Expected to have a unique identifier handle and support querying/modifying headers.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the VLAN header in the list of all VLAN headers associated with the stream. Useful when the stream contains multiple VLAN headers.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Sets the VLAN priority field (also known as PCP - Priority Code Point). This determines the CoS (Class of Service) value for traffic prioritization.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "CFI",
        "type": "int",
        "description": "Sets the Canonical Format Indicator (CFI) bit in the VLAN tag. Used mainly for compatibility between Ethernet and Token Ring networks.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ID",
        "type": "int",
        "description": "Sets the VLAN Identifier (VID), which specifies the VLAN group the frame belongs to.",
        "default": "1",
        "range_or_options": "1-4095"
      },
      {
        "name": "Protocol",
        "type": "hex (str or int)",
        "description": "Sets the EtherType field indicating the type of the payload that follows the VLAN header. Accepts hexadecimal values.",
        "default": "88B5",
        "range_or_options": "0800 0806 8100 8863 8864 86DD 8808 8847 8926 8914 8906 88CC 88B8"
      }
    ],
    "kwargs": [],
    "description": "Modifies specified attributes of a VLAN header within a given stream's packet configuration. The function identifies the correct VLAN header by its level (index) among other VLAN headers and updates its fields such as ID, Priority, CFI, and Protocol if provided. It internally interacts with the system to apply changes and may affect subsequent operations like capturing or transmitting packets.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port[0]} |\n    | ${HeaderTypes} | Create List | EthernetII | VLAN |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header Vlan | Stream=${Stream} | Level=0 | ID=4000 |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[ID] | Type=Increment | Count=10 | Step=2 |\n    | ${Pattern} | Create Capture Pdu Pattern | Port=${Port[1]} | HeaderTypes=${HeaderTypes} | Level=1 | Attribute=${Attribute}[ID] | Value=4000 | MaxValue=4000 |\n    | Edit Capture Filter | Port=${Port} | Expression=${Pattern} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_arp",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated field name (e.g., 'HardwareType') to its corresponding internal attribute name (e.g., 'hardwareType'). If no fields are successfully updated, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the headers to be edited. It must have a 'handle' attribute identifying it uniquely in the system. If a list is provided, only the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ARP header in the list of headers of the stream. This determines which ARP header to modify if multiple exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "HardwareType",
        "type": "int",
        "description": "Sets the hardware type field of the ARP header, which indicates the type of hardware being used (e.g., Ethernet).",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "ProtocolType",
        "type": "hex",
        "description": "Sets the protocol type field of the ARP header, which specifies the type of protocol address being resolved (e.g., IPv4).",
        "default": "0800",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "HardwareSize",
        "type": "int",
        "description": "Sets the size (in bytes) of the hardware address used in the ARP packet.",
        "default": "6",
        "range_or_options": "0-255"
      },
      {
        "name": "ProtocolSize",
        "type": "int",
        "description": "Sets the size (in bytes) of the protocol address used in the ARP packet.",
        "default": "4",
        "range_or_options": "0-255"
      },
      {
        "name": "Opcode",
        "type": "int",
        "description": "Sets the operation code indicating whether the ARP packet is a request or reply.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "SendMac",
        "type": "str",
        "description": "Sets the source MAC address in the ARP packet.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "SendIpv4",
        "type": "str",
        "description": "Sets the source IPv4 address in the ARP packet.",
        "default": "192.168.0.1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "TargetMac",
        "type": "str",
        "description": "Sets the target MAC address in the ARP packet.",
        "default": "00:00:00:00:00:00",
        "range_or_options": "有效的mac地址"
      },
      {
        "name": "TargetIpv4",
        "type": "str",
        "description": "Sets the target IPv4 address in the ARP packet.",
        "default": "0.0.0.0",
        "range_or_options": "有效的ipv4地址"
      }
    ],
    "description": "Edits the fields of an ARP (Address Resolution Protocol) header within a specified stream. This function allows modifying specific fields of an ARP header at a given level in the stream's header hierarchy. The stream is identified by the 'Stream' parameter, and the target ARP header is determined by its position (Level) in the list of headers associated with the stream.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port[0]} |\n    | ${HeaderTypes} | Create List | EthernetII | ARP |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header Arp | Stream=${Stream} | Level=0 | SendMac=00:00:01:01:01:01 |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[SendMac] | Type=Increment | Count=10 | Step=2 |\n    | ${Pattern} | Create Capture Pdu Pattern | Port=${Port[1]} | HeaderTypes=${HeaderTypes} |  Level=1  | Attribute=${Attribute}[SendMac] | Value=00:00:01:01:01:01 | MaxValue=00:00:01:01:01:01 |\n    | Edit Capture Filter | Port=${Port} | Expression=${Pattern} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_mpls",
    "return_type": "dict or False",
    "return": "A dictionary mapping the modified parameter names to their corresponding internal attribute names if any modifications were made. If no parameters are provided or none of the parameters result in changes, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object (StreamTemplate)",
        "description": "The stream object whose MPLS headers are to be edited. Must have a 'handle' attribute that uniquely identifies the stream in the system. If a list of streams is provided, only the first stream is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which MPLS header (in case of multiple MPLS headers) to edit.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Label",
        "type": "int",
        "description": "New value for the MPLS label field.",
        "default": "16",
        "range_or_options": "0-1048575"
      },
      {
        "name": "Exp",
        "type": "bit",
        "description": "New value for the MPLS EXP (experimental) field.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Bottom",
        "type": "bit",
        "description": "New value for the MPLS bottom-of-stack flag.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TTL",
        "type": "int",
        "description": "New value for the MPLS Time-To-Live (TTL) field.",
        "default": "64",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits the fields of an MPLS header at a specified level in a given stream. This function retrieves the list of headers for the provided stream and filters them to include only those of type 'mpls'. It then modifies one or more fields of the MPLS header at the specified level (index). The modified fields are updated based on the provided parameters. If no field is modified (i.e., all parameters are None), the function returns False.",
    "example": ".. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port[0]} |\n    | ${HeaderTypes} | Create List | EthernetII | MPLS | IPv4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header MPLS | Stream=${Stream} | Level=0 | Label=1000 | TTL=100 |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[Label] | Type=Increment | Count=10 | Step=2 |\n    | ${Pattern} | Create Capture Pdu Pattern | Port=${Port[1]} | HeaderTypes=${HeaderTypes} | Level=1 | Attribute=${Attribute}[Label] | Value=1000 | MaxValue=1000 |\n    | Edit Capture Filter | Port=${Port} | Expression=${Pattern} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_goose",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the modified parameter names (e.g., 'Appid', 'Length') to their corresponding attribute names in the header object (e.g., 'appid', 'length'). Returns False if none of the parameters were provided, meaning no modification occurred.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream template object representing the test instrument traffic flow. It must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the 'goose' header in the list of goose headers within the stream to be edited. Level=0 refers to the first goose header found.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Appid",
        "type": "int",
        "description": "If provided, updates the 'appid' field of the goose header to this value.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "If provided, updates the 'length' field of the goose header to this value. Default is <AUTO>8.",
        "default": "8",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "If provided, updates the 'reserve' field of the goose header to this value.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserve1",
        "type": "int",
        "description": "If provided, updates the 'reserve1' field of the goose header to this value.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Apdu",
        "type": "hex",
        "description": "If provided, updates the 'apdu' field of the goose header with the given hexadecimal string. The length should be between 0 and 1493 bytes.",
        "default": "''",
        "range_or_options": "length: 0-1493 bytes hexadecimal string"
      }
    ],
    "description": "Modifies specific fields of a GOOSE type header in a given stream at the specified level. This function retrieves the headers associated with the provided stream and filters them to find those of type 'goose'. It then modifies one or more fields of the goose header at the specified level and returns a dictionary of modified fields. If no modifications are made, it returns False.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | &{Attribute} | Edit Header Goose | Stream=${Stream} | Level=0 | Appid=1000 |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[Appid] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_pause",
    "return_type": "dict or False",
    "return": "A dictionary mapping the modified attribute names ('PauseCode', 'PauseTime') to their corresponding internal attribute names ('pauseCode', 'pauseTime'), indicating which attributes were successfully updated. If no attributes were modified, returns False.",
    "description": "Modifies the pause-related fields of a specific 'pause' header in the given stream. This function retrieves the list of headers for the specified stream and filters them to include only those of type 'pause'. It then selects the header at the specified level (index) from this list and updates its attributes if new values are provided.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the 'pause' headers are to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first element will be used as the stream object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'pause' header in the filtered list of headers to be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "PauseCode",
        "type": "hex",
        "description": "A new value to set for the 'pauseCode' attribute of the selected header. If None, the 'pauseCode' attribute will not be modified.",
        "default": "0001",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "PauseTime",
        "type": "hex",
        "description": "A new value to set for the 'pauseTime' attribute of the selected header. If None, the 'pauseTime' attribute will not be modified.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      }
    ],
    "example": "| &{Attribute} | Edit Header Pause | Stream=${Stream} | Level=0 | PauseCode=FFFF |\n| Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[PauseCode] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_pfc",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping parameter names to the corresponding field names in the PFC header object that were successfully updated. If no changes were made (i.e., none of the optional parameters were provided), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object representing the traffic template on which the PFC header is defined. It must have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the PFC header in the list of all PFC headers associated with the stream. Used to select which PFC header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "OpCode",
        "type": "hex",
        "description": "Sets the OpCode value for the PFC header, typically used to indicate the type of control message.",
        "default": "0101",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "MsOctet",
        "type": "bit",
        "description": "Sets the most significant octet of the Priority Enable Vector, which controls which priorities are enabled for flow control.",
        "default": "00000000",
        "range_or_options": "8-bit binary string"
      },
      {
        "name": "P7",
        "type": "bit",
        "description": "Enables or disables priority 7 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P6",
        "type": "bit",
        "description": "Enables or disables priority 6 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P5",
        "type": "bit",
        "description": "Enables or disables priority 5 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P4",
        "type": "bit",
        "description": "Enables or disables priority 4 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P3",
        "type": "bit",
        "description": "Enables or disables priority 3 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P2",
        "type": "bit",
        "description": "Enables or disables priority 2 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P1",
        "type": "bit",
        "description": "Enables or disables priority 1 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "P0",
        "type": "bit",
        "description": "Enables or disables priority 0 in the PFC frame.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Time0",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 0 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time1",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 1 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time2",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 2 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time3",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 3 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time4",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 4 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time5",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 5 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time6",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 6 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Time7",
        "type": "hex",
        "description": "Specifies the time duration (in arbitrary units) for which priority 7 should be paused.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the attributes of a PFC (Priority Flow Control) header at a specified level within a given stream template. This function allows users to configure various fields of the PFC header such as OpCode, MsOctet, individual priority flags (P0-P7), and pause times (Time0-Time7). If any of the optional parameters are not provided, their default values are used. The function modifies the internal state of the header and returns a dictionary indicating which fields were successfully updated.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | &{Attribute} | Edit Header Pfc | Stream=${Stream} | Level=0 | OpCode=FFFF |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[OpCode] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_vntag",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each successfully updated parameter name to the corresponding attribute name modified on the vntag header (e.g., {'Ver': 'ver'}). Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object whose vntag header needs modification. It must have a 'handle' attribute uniquely identifying the stream. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the vntag header to modify within the filtered list of vntag headers.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Ver",
        "type": "bit",
        "description": "New value for the 'ver' field of the vntag header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Res",
        "type": "bit",
        "description": "New value for the 'res' field of the vntag header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Dir",
        "type": "bit",
        "description": "New value for the 'dir' field of the vntag header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Pointer",
        "type": "bit",
        "description": "New value for the 'pointer' field of the vntag header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DstVif",
        "type": "int",
        "description": "New value for the 'dstVif' field of the vntag header.",
        "default": "14",
        "range_or_options": "0-1"
      },
      {
        "name": "SrcVif",
        "type": "int",
        "description": "New value for the 'srcVif' field of the vntag header.",
        "default": "12",
        "range_or_options": "0-1"
      },
      {
        "name": "Looped",
        "type": "bit",
        "description": "New value for the 'looped' field of the vntag header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "New value for the 'protocol' field of the vntag header.",
        "default": "FFFF",
        "range_or_options": "0800 0806 8100 8864 8863 86DD 8808 8847 88B8 8926"
      }
    ],
    "description": "Edits specific fields of a vntag header at a given level in the header hierarchy of a stream. This function retrieves the headers for the specified stream using `get_stream_header`, filters them to only include vntag-type headers, and selects the one at the specified level. It then updates any of the provided fields (Ver, Res, Dir, Pointer, DstVif, SrcVif, Looped, Protocol) on that header object. Each updated field is recorded in a result dictionary mapping the parameter name to the corresponding attribute name. If no fields are successfully updated, the function returns False.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | &{Attribute} | Edit Header Vntag | Stream=${Stream} | Level=0 | Ver=11 |\n    | Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[Ver] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.common.edit_header_fibre_channel",
    "return_type": "dict or False",
    "return": "A dictionary mapping each updated parameter name to its corresponding attribute name in the Fibre Channel header object if one or more fields were successfully modified. Returns `False` if no fields were updated (i.e., all optional parameters were omitted or None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream template object or a list containing a single stream object. The stream must have a 'handle' attribute for internal identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which Fibre Channel header to modify if multiple FC headers exist in the stream. Level=0 refers to the first FC header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Rctl",
        "type": "hex",
        "description": "Value to update the 'rctl' field of the Fibre Channel header, representing the Routing Control field.",
        "default": "22",
        "range_or_options": "00-FF"
      },
      {
        "name": "DestAddr",
        "type": "hex",
        "description": "Value to update the 'destAddr' (destination address) field, should be a 3-byte hexadecimal number.",
        "default": "000000",
        "range_or_options": "length: 3 bytes"
      },
      {
        "name": "Csctl",
        "type": "hex",
        "description": "Value to update the 'csctl' (class-specific control) field.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "SourceAddr",
        "type": "hex",
        "description": "Value to update the 'sourceAddr' (source address) field, should be a 3-byte hexadecimal number.",
        "default": "000000",
        "range_or_options": "length: 3 bytes"
      },
      {
        "name": "Type",
        "type": "hex",
        "description": "Value to update the 'type' field of the Fibre Channel header.",
        "default": "<AUTO>01",
        "range_or_options": "01"
      },
      {
        "name": "FrameControl",
        "type": "hex",
        "description": "Value to update the 'frameControl' field, should be a 3-byte hexadecimal number.",
        "default": "380000",
        "range_or_options": "length: 3 bytes"
      },
      {
        "name": "SeqID",
        "type": "hex",
        "description": "Value to update the 'seqID' (sequence identifier) field.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "DataField",
        "type": "hex",
        "description": "Value to update the 'dataField' field.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "SeqCount",
        "type": "hex",
        "description": "Value to update the 'seqCount' (sequence count) field.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "OriginatorExchangeID",
        "type": "hex",
        "description": "Value to update the 'originatorExchangeID' field.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "ResponseExchangeID",
        "type": "hex",
        "description": "Value to update the 'responseExchangeID' field.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "ParaRelativeOffset",
        "type": "hex",
        "description": "Value to update the 'paraRelativeOffset' field, typically used for relative offset control.",
        "default": "00000000",
        "range_or_options": "length: 4 bytes"
      }
    ],
    "description": "This function modifies specific fields of a Fibre Channel (FC) header within a given stream. It allows partial modification by updating only the provided fields. If any fields are successfully updated, it returns a dictionary mapping input parameter names to their corresponding internal attribute names in the header object. If no fields are provided for update, it returns `False`.",
    "example": "Robot Framework Example:\n\n| &{Attribute} | Edit Header Fibre Channel | Stream=${Stream} | Level=0 | Rctl=FF |\n| Edit Modifier | Stream=${Stream} | Level=1 | Attribute=${Attribute}[Rctl] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.control_word.edit_header_control_word",
    "return_type": "dict or False",
    "return": "A dictionary mapping modified field names (as strings) to their respective attribute names in the header object (e.g., {'Flags': 'flags'}), indicating which fields were successfully updated. If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object of type StreamTemplate",
        "description": "The stream object for which the Control Word headers need to be edited. Must have a 'handle' attribute that uniquely identifies the stream. If a list of streams is passed, only the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index specifying which Control Word header to modify in case there are multiple CW headers in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Reserved",
        "type": "bitstring (4 bits)",
        "description": "Value to set for the reserved field ('rsvd') in the Control Word header. If None, this field remains unchanged.",
        "default": "0000",
        "range_or_options": "0000-1111"
      },
      {
        "name": "Flags",
        "type": "bitstring (2 bits)",
        "description": "Value to set for the flags field ('flags') in the Control Word header. If None, this field remains unchanged.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Fragment",
        "type": "bitstring (2 bits)",
        "description": "Value to set for the fragment identifier field ('frg') in the Control Word header. If None, this field remains unchanged.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Value to set for the length field ('length') in the Control Word header. If None, this field remains unchanged.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "Sn",
        "type": "int",
        "description": "Value to set for the sequence number field ('sn') in the Control Word header. If None, this field remains unchanged.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies specific fields of a Control Word (CW) header in a given stream at the specified level. The function retrieves the CW headers associated with the provided stream and selects the one at the given level. If any of the optional parameters (Reserved, Flags, Fragment, Length, Sn) are provided, their corresponding field in the selected header is updated.",
    "example": "| Edit Header Control Word | Stream=${Stream} | Level=0 | Flags=11 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.fcoe.edit_header_els_flogi",
    "return_type": "dict or False",
    "return": "A dictionary mapping each modified parameter name to its corresponding attribute key in the header structure if any changes were made. Returns False if no parameters were updated (all provided values were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object which contains the 'elsflogi' header to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first item will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which 'elsflogi' header to edit if there are multiple such headers.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "CommandCode",
        "type": "hex",
        "description": "ELS Command Code",
        "default": "04000000",
        "range_or_options": "4-byte hexadecimal number"
      },
      {
        "name": "FcPhVersion",
        "type": "hex",
        "description": "FC-PH Version - obsolete",
        "default": "2020",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "BtobCredit",
        "type": "int",
        "description": "Buffer-to-buffer Credit",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "CommonFeatures",
        "type": "hex",
        "description": "Common Features",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Bbscn",
        "type": "int",
        "description": "BB_SC_N",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "BtobDataFieldSize",
        "type": "int",
        "description": "Buffer-to-Buffer Receive Data-Field Size",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Reserved field in commonSvcPara",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal number"
      },
      {
        "name": "PortName",
        "type": "hex",
        "description": "Port Name",
        "default": "2000000000123010",
        "range_or_options": "8-byte hexadecimal number"
      },
      {
        "name": "NodeName",
        "type": "hex",
        "description": "Node or Fabric Name",
        "default": "1000000000123010",
        "range_or_options": "8-byte hexadecimal number"
      },
      {
        "name": "Class1serviceOptions",
        "type": "hex",
        "description": "Service Options for Class 1",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class1InitatorControl",
        "type": "hex",
        "description": "Initiator Control for Class 1",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class1recipientControl",
        "type": "hex",
        "description": "Recipient Control for Class 1",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class1reserved1",
        "type": "int",
        "description": "Reserved field in class1SvcPara",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Class1totalConcurrentSeq",
        "type": "int",
        "description": "Total Concurrent Sequence for Class 1",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class1Nx_Porte2eCredit",
        "type": "int",
        "description": "Nx_Port End-to-end Credit for Class 1",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Class1reserved2",
        "type": "int",
        "description": "Reserved field in class1SvcPara",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class1openSeqPerExchange",
        "type": "int",
        "description": "Open Sequence Per Exchange for Class 1",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class1reserved3",
        "type": "int",
        "description": "Reserved field in class1SvcPara",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Class2serviceOptions",
        "type": "hex",
        "description": "Service Options for Class 2",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class2InitatorControl",
        "type": "hex",
        "description": "Initiator Control for Class 2",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class2recipientControl",
        "type": "hex",
        "description": "Recipient Control for Class 2",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class2reserved1",
        "type": "int",
        "description": "Reserved field in class2SvcPara",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Class2totalConcurrentSeq",
        "type": "int",
        "description": "Total Concurrent Sequence for Class 2",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class2Nx_Porte2eCredit",
        "type": "int",
        "description": "Nx_Port End-to-end Credit for Class 2",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Class2reserved2",
        "type": "int",
        "description": "Reserved field in class2SvcPara",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class2openSeqPerExchange",
        "type": "int",
        "description": "Open Sequence Per Exchange for Class 2",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class2reserved3",
        "type": "int",
        "description": "Reserved field in class2SvcPara",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Class3serviceOptions",
        "type": "hex",
        "description": "Service Options for Class 3",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class3InitatorControl",
        "type": "hex",
        "description": "Initiator Control for Class 3",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class3recipientControl",
        "type": "hex",
        "description": "Recipient Control for Class 3",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal number"
      },
      {
        "name": "Class3reserved1",
        "type": "int",
        "description": "Reserved field in class3SvcPara",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Class3totalConcurrentSeq",
        "type": "int",
        "description": "Total Concurrent Sequence for Class 3",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class3Nx_Porte2eCredit",
        "type": "int",
        "description": "Nx_Port End-to-end Credit for Class 3",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Class3reserved2",
        "type": "int",
        "description": "Reserved field in class3SvcPara",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class3openSeqPerExchange",
        "type": "int",
        "description": "Open Sequence Per Exchange for Class 3",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Class3reserved3",
        "type": "int",
        "description": "Reserved field in class3SvcPara",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Obsolete",
        "type": "hex",
        "description": "Obsolete field of the header",
        "default": "00000000000000000000000000000000",
        "range_or_options": "16-byte hexadecimal number"
      },
      {
        "name": "VendorVersionLevel",
        "type": "hex",
        "description": "Vendor Version Level field of the header",
        "default": "00000000000000000000000000000000",
        "range_or_options": "16-byte hexadecimal number"
      }
    ],
    "description": "Edits the attributes of an 'elsflogi' type header within a given stream at a specified level. This function modifies various fields of the 'elsflogi' header object located at the specified level in the list of headers for the provided stream. It updates only those fields that are explicitly provided (not None). The changes are applied directly to the header object and the updated field names along with their corresponding attribute keys are returned in a dictionary.",
    "example": "| Edit Header ELS FLOGI | Stream=${Stream} | Level=0 | commandCode=10203040 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.hdlc.edit_header_hdlc",
    "description": "Edits specific fields of an HDLC (High-Level Data Link Control) header in the specified stream at a given level. This function retrieves the list of headers for the given stream and filters to only include 'chdlc' (Cisco HDLC) headers. It then selects the header at the specified level (index) from this filtered list and updates any combination of its fields (Address, Value, Protocol) if corresponding parameters are provided.",
    "return_type": "dict or bool",
    "return": "A dictionary indicating which fields were updated, mapping parameter names ('Address', 'Value', 'Protocol') to the corresponding attribute names ('address', 'value', 'protocol'). Returns False if none of the optional parameters are provided.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the HDLC header to be edited. It must have a 'handle' attribute used to uniquely identify the stream in the system. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the HDLC header within the list of HDLC headers in the stream. Used when multiple HDLC headers exist and a specific one needs editing.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Address",
        "type": "hex",
        "description": "The new value to set for the 'address' field of the HDLC header. If not None, this will update the header's address.",
        "default": "0F",
        "range_or_options": "00-FF"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "The new value to set for the 'value' field of the HDLC header. If not None, this will update the header's value.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "The new value to set for the 'protocol' field of the HDLC header. If not None, this will update the header's protocol.",
        "default": "0800",
        "range_or_options": "0800 IP 0281 MPLS 0 Custom"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Edit Header Hdlc | Stream=${Stream} | Level=0 | Address=FF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.hsr.edit_header_hsr_tag",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping the modified parameter names to their corresponding attribute names in the header object (e.g., {'PathId': 'pathid'}) if any updates were made. If no changes are applied (i.e., all optional parameters are None), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the HSR Tag headers are to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the HSR Tag header in the filtered list of headers to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "PathId",
        "type": "bit",
        "description": "Value to set for the `pathid` attribute of the selected HSR Tag header. Must be a 4-bit binary value represented as string bits (e.g., '0001').",
        "default": "0001",
        "range_or_options": "0000-1111"
      },
      {
        "name": "LsduSize",
        "type": "int",
        "description": "Value to set for the `lsdusize` attribute of the selected HSR Tag header. Represents the size of the LSDU.",
        "default": "0",
        "range_or_options": "0-4095"
      },
      {
        "name": "SeqNum",
        "type": "int",
        "description": "Value to set for the `seqnum` attribute of the selected HSR Tag header. Used to track sequence numbers in HSR protocols.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "Value to set for the `protocol` attribute of the selected HSR Tag header. This specifies the protocol encapsulated in the HSR tag.",
        "default": "0800",
        "range_or_options": "0800 0806 8100 8864 8863 86DD 8808 8847 88B8 8926 F1C1 892F 88FB"
      }
    ],
    "description": "This function edits specific fields of an 'hsrtag' type header in a given stream at the specified level. The function filters all headers of the stream to only those of type 'hsrtag', selects the one at the provided index (`Level`), and updates its attributes based on the provided keyword arguments. Only the attributes with non-None values will be updated.",
    "example": "| Edit Header Hsr Tag | Stream=${Stream} | Level=0 | SeqNum=10 | PathId=1110 | Protocol=86DD |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_csnp",
    "return_type": "dict",
    "return": "A dictionary mapping the modified field names to their respective paths in the header structure. Returns an empty dictionary if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the CSNP header needs to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list of streams is provided, only the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the CSNP header to edit among the available headers in the stream. Used to select between multiple CSNP headers (e.g., Level 1 and Level 2 CSNPs).",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "InterRoutingProtocolDiscriminator",
        "type": "int",
        "description": "Sets the value of the Inter-Routing Protocol Discriminator field in the CSNP header.",
        "default": "83",
        "range_or_options": "not_found"
      },
      {
        "name": "LengthIndicator",
        "type": "int",
        "description": "Sets the Length Indicator field in the CSNP header.",
        "default": "33",
        "range_or_options": "not_found"
      },
      {
        "name": "VersionIdExtend",
        "type": "int",
        "description": "Sets the Version/ID Extension field in the CSNP header.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "IdLength",
        "type": "int",
        "description": "Sets the ID Length field in the CSNP header.",
        "default": "6",
        "range_or_options": "not_found"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "Sets the first reserved field in the CSNP header.",
        "default": "3",
        "range_or_options": "0-7"
      },
      {
        "name": "PDUType",
        "type": "int",
        "description": "Sets the PDU Type field in the CSNP header.",
        "default": "24",
        "range_or_options": "0-31"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the Version field in the CSNP header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "Sets the second reserved field in the CSNP header.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxAreaAddress",
        "type": "int",
        "description": "Sets the Maximum Area Address field in the CSNP header.",
        "default": "3",
        "range_or_options": "0-3"
      },
      {
        "name": "PDULength",
        "type": "int",
        "description": "Sets the PDU Length field in the CSNP Data Header.",
        "default": "33",
        "range_or_options": "not_found"
      },
      {
        "name": "LspId",
        "type": "hex",
        "description": "Sets the LSP ID field in the CSNP Data Header.",
        "default": "00000000000000",
        "range_or_options": "7-byte hexadecimal number"
      },
      {
        "name": "StartLspId",
        "type": "hex int",
        "description": "Sets the Start LSP ID field in the CSNP Data Header.",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal number"
      },
      {
        "name": "EndLspId",
        "type": "hex int",
        "description": "Sets the End LSP ID field in the CSNP Data Header.",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal number"
      },
      {
        "name": "CsnpDataTlvOptionHeader",
        "type": "list",
        "description": "Sets the TLV Option Header in the CSNP Data Header.",
        "default": "not_found",
        "range_or_options": "IsIsLspEntries AuthentionInfo"
      }
    ],
    "description": "Edits the fields of an ISIS CSNP (Complete Sequence Number PDU) header in a given stream at a specified level. This function retrieves the headers associated with the provided stream and filters for Level 1 or Level 2 CSNP headers based on the `Level` parameter. It then modifies the fields of the selected CSNP header if new values are provided for them.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | l1csnpHeader |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Isis csnp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_tlv_header",
    "return_type": "dict",
    "return": "A dictionary containing the result of the TLV header edit operation, typically including a key like 'TlvCode' indicating the path to the modified field.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or list containing one stream) whose ISIS headers are to be edited. Must have a unique identifier (handle).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "str",
        "description": "Specifies which TLV option to modify. Valid options depend on the type of ISIS header (e.g., L1/L2 Hello, LSP, etc.).",
        "default": "not_found",
        "range_or_options": "IsIsLspEntries AuthentionInfo IsIsAreaAddress Padding ProtocolSupport IpInterfaceAddress Neighbor RestartSignal Ipv6InterfaceAddress ExtendedReachability IsIsIpInterReachability IsIsProtocolsSupported IsIsIPExternalReachability IsIsIpv6Reachability P2pAdjacencyState"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the ISIS header in the list of all ISIS headers for the stream (used to select between multiple ISIS headers).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the specific TLV entry within the selected ISIS header to be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "TlvCode",
        "type": "int",
        "description": "TLV Type code (field identifier).",
        "default": "<AUTO>",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the TLV value field.",
        "default": "<AUTO>",
        "range_or_options": "0-255"
      },
      {
        "name": "AuthenticationType",
        "type": "int",
        "description": "Authentication mechanism used (e.g., simple password, MD5).",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "AuthenticationLength",
        "type": "int",
        "description": "Length of the authentication data.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Authentication",
        "type": "hex",
        "description": "Authentication data in hexadecimal format.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "AreaAddressEntries",
        "type": "int",
        "description": "Number of area address entries in the TLV.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Hexadecimal padding value used to fill unused space in the header.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "NlPIDEntriesField",
        "type": "int",
        "description": "Number of NLPID (Network Layer Protocol Identifier) entries in the protocol support TLV.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4InterfaceAddress",
        "type": "list[str]",
        "description": "List of IPv4 interface addresses associated with the device.",
        "default": "['192.168.0.2']",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "MacAdd",
        "type": "list[str]",
        "description": "List of MAC addresses representing neighboring systems.",
        "default": "['00:00:00:13:40:20']",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "Reserved bitfield in the restart signal TLV.",
        "default": "0",
        "range_or_options": "0-31"
      },
      {
        "name": "SuppressAdjacency",
        "type": "int",
        "description": "Flag to suppress adjacency advertisement during restart.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RestartAck",
        "type": "int",
        "description": "Flag indicating whether restart acknowledgment is sent.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RestartReq",
        "type": "int",
        "description": "Flag indicating whether a restart request was made.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RemainTime",
        "type": "int",
        "description": "Time remaining for the restart process.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RestartNeighborIdField",
        "type": "str",
        "description": "System ID of the restarting neighbor.",
        "default": "000000000000",
        "range_or_options": "6-byte string"
      },
      {
        "name": "Ipv6InterfaceAddress",
        "type": "list[str]",
        "description": "List of IPv6 interface addresses associated with the device.",
        "default": "['2001::2']",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "VirtualFlag",
        "type": "int",
        "description": "Indicates if this is a virtual link.",
        "default": "12",
        "range_or_options": "0-255"
      },
      {
        "name": "MetricEntries",
        "type": "int",
        "description": "Number of metric entries in reachability TLVs.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "NeighborID",
        "type": "hex",
        "description": "Neighbor system ID in hexadecimal format.",
        "default": "00000000000000",
        "range_or_options": "7-byte hex"
      },
      {
        "name": "Metric",
        "type": "hex",
        "description": "Routing metric in hexadecimal format.",
        "default": "000000",
        "range_or_options": "3-byte hex"
      },
      {
        "name": "IisNeighborSubTlv",
        "type": "list[str]",
        "description": "List of supported sub-TLV types inside extended reachability TLVs.",
        "default": "not_found",
        "range_or_options": "AdGroupSubtlv Ipv4InterfaceAddressSubtlv Ipv4NeighborAddressSubtlv MaxLinkBandwidthSubtlv ReservableLinkBandwidthSubtlv UnReservedBandwidthSubtlv InterfaceIpv6Subtlv NeigbhorIpv6Subtlv"
      },
      {
        "name": "InternalmetricEntries",
        "type": "int",
        "description": "Number of internal metric entries in IP inter-reachability TLVs.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "ExternalmetricEntries",
        "type": "int",
        "description": "Number of external metric entries in IP external reachability TLVs.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "Ubit",
        "type": "int",
        "description": "Up/Down bit indicating route origin.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Xbit",
        "type": "int",
        "description": "External Origin Bit indicating if the route is externally originated.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Sbit",
        "type": "int",
        "description": "Sub-TLV Bit indicating presence of sub-TLVs.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Reserved bits in IPv6 reachability TLV.",
        "default": "0",
        "range_or_options": "0-31"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the prefix in bits.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Prefix",
        "type": "hex",
        "description": "IPv6 prefix in hexadecimal format.",
        "default": "00",
        "range_or_options": "length 0-255 byte"
      },
      {
        "name": "IsIsp2pAdjacencyStateType",
        "type": "int",
        "description": "Type of P2P adjacency state TLV.",
        "default": "240",
        "range_or_options": "0-255"
      },
      {
        "name": "IsIsp2pAdjacencyStateLength",
        "type": "int",
        "description": "Length of P2P adjacency state TLV.",
        "default": "15",
        "range_or_options": "0-255"
      },
      {
        "name": "adjacencyState",
        "type": "int",
        "description": "Current adjacency state (up, initializing, down).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "extendLocalCircuitId",
        "type": "byte",
        "description": "Extended local circuit ID in hexadecimal format.",
        "default": "00000000",
        "range_or_options": "4-byte hex"
      },
      {
        "name": "neighborSystemId",
        "type": "byte",
        "description": "Neighbor system ID in hexadecimal format.",
        "default": "000000000000",
        "range_or_options": "6-byte hex"
      },
      {
        "name": "neighborExtendedCID",
        "type": "byte",
        "description": "Neighbor extended circuit ID in hexadecimal format.",
        "default": "00000000",
        "range_or_options": "4-byte hex"
      }
    ],
    "description": "This function modifies a specific TLV (Type-Length-Value) field in an ISIS protocol header within a given traffic stream. It allows customization of various TLV options such as authentication, area address, interface addresses, and more depending on the type of ISIS header (L1/L2 CSNP, PSNP, Hello, LSP, etc.). The `Level` parameter selects which ISIS header to edit when there are multiple instances, and the `Index` selects the specific TLV within that header. Additional keyword arguments define the actual values to set based on the chosen `Option`.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1csnp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_lsp_entry",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the edit operation if successful. Returns False if the operation fails or no result is returned from `editLspEntry`.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the header in the filtered list of headers of types ['l1csnpheader', 'l1psnpheader', 'l2csnpheader', 'l2psnpheader']. Used to identify which ISIS LSP entry header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the TLV within the header where the LSP entry should be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "LspIndex",
        "type": "int",
        "description": "The index of the LSP entry within the specified TLV to be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "RemainTime",
        "type": "int",
        "description": "Specifies the remaining time for the LSP entry before it expires.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "LspId",
        "type": "hex",
        "description": "Specifies the Link State Protocol Identifier (LSP ID) for the entry.",
        "default": "0000000000000001",
        "range_or_options": "0000000000000001-FFFFFFFFFFFFFFFF"
      },
      {
        "name": "LspSeqcenceNum",
        "type": "hex",
        "description": "Specifies the sequence number of the LSP entry.",
        "default": "00000001",
        "range_or_options": "00000001-FFFFFFFF"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Specifies the checksum value for data integrity validation of the LSP entry.",
        "default": "<AUTO>0000",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits an ISIS LSP (Link State Protocol) entry within a specific header of a stream. This function identifies the appropriate header based on its type and level in the stream, then modifies the LSP entry using provided TLV (Type-Length-Value) and LSP indices.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1csnp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header IsisLsp Entry | Stream=${Stream} | TlvIndex=0 | LspIndex=0 | remainTime=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_l1l2_hello",
    "return_type": "dict",
    "return": "A dictionary mapping each modified field name to its internal path representation, indicating where the field resides within the header structure. This provides a way to trace the location of the modified fields in the underlying data model.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the headers are to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list of streams is passed, only the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ISIS header level to edit within the stream's header list.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "InterRoutingProtocolDiscriminator",
        "type": "int",
        "description": "Intradomain Routing Protocol Discriminator",
        "default": "83",
        "range_or_options": "not_found"
      },
      {
        "name": "LengthIndicator",
        "type": "int",
        "description": "Length Indicator",
        "default": "33",
        "range_or_options": "not_found"
      },
      {
        "name": "VersionIdExtend",
        "type": "int",
        "description": "Version/Protocol ID Extension",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "IdLength",
        "type": "int",
        "description": "ID Length",
        "default": "6",
        "range_or_options": "not_found"
      },
      {
        "name": "CommonReserved1",
        "type": "int",
        "description": "Reserved field with common use",
        "default": "3",
        "range_or_options": "0-7"
      },
      {
        "name": "PDUType",
        "type": "int",
        "description": "PDU Type",
        "default": "24",
        "range_or_options": "0-31"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Version number of the protocol",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "CommonReserved2",
        "type": "int",
        "description": "Another reserved field with common use",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxAreaAddress",
        "type": "int",
        "description": "Maximum Area Addresses allowed",
        "default": "3",
        "range_or_options": "0-3"
      },
      {
        "name": "FixedReserve1",
        "type": "int",
        "description": "Fixed reserved field",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "CircuitType",
        "type": "int",
        "description": "Circuit Type",
        "default": "1",
        "range_or_options": "1-3"
      },
      {
        "name": "SenderSystemID",
        "type": "hex",
        "description": "Source ID (6-byte hexadecimal value)",
        "default": "000000000001",
        "range_or_options": "6byte"
      },
      {
        "name": "HolderTimer",
        "type": "int|hex",
        "description": "Holding Timer value",
        "default": "51 (for L1), 0033 (for L2)",
        "range_or_options": "0-65535 / 2byte"
      },
      {
        "name": "PDULength",
        "type": "int",
        "description": "PDU Length",
        "default": "27",
        "range_or_options": "0-65535"
      },
      {
        "name": "FixedReserve2",
        "type": "int",
        "description": "Another fixed reserved field",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Priority value for designated router election",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "DesignatedSystemID",
        "type": "hex",
        "description": "LAN ID (7-byte hexadecimal value)",
        "default": "00000000010001",
        "range_or_options": "7byte"
      },
      {
        "name": "IsIsTlv",
        "type": "list",
        "description": "TLV Header types",
        "default": "",
        "range_or_options": "IsIsAreaAddress AreaAddress Padding AuthentionInfo ProtocolSupport IpInterfaceAddress Neighbor RestartSignal Ipv6InterfaceAddress"
      }
    ],
    "description": "Modifies the fields of an ISIS L1 or L2 Hello header in a specified stream. This function retrieves the headers from the given stream and selects the appropriate ISIS L1 or L2 Hello header based on the provided level. It then updates the specified fields of the selected header with the provided values. Each updated field is tracked and returned in a dictionary mapping field names to their internal representation paths.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1helloHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis hello | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_area_address_entry",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the edit operation if successful, otherwise False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute to uniquely identify it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the header to modify within the filtered list of ISIS headers (L1/L2 Hello/LSP).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the TLV (Type-Length-Value) field to edit within the selected ISIS header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EntryIndex",
        "type": "int",
        "description": "The index of the area address entry to modify within the specified TLV.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "TlvLength",
        "type": "hex",
        "description": "Length of the TLV field. Must match the length of AreaAddress.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "AreaAddress",
        "type": "hex",
        "description": "Area Address value in hexadecimal format. Length can be between 0 and 255 bytes.",
        "default": "00",
        "range_or_options": "variable_length_0-255_bytes"
      }
    ],
    "description": "Edits an ISIS area address entry in a specific header of a stream. The function identifies the appropriate header based on the Level parameter and modifies the area address entry using TlvIndex and EntryIndex along with any additional parameters provided via kwargs. Only certain types of headers such as 'isisl1helloheader', 'l1lspheader', etc., are supported for editing.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1hello | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis Area Address Entry | Stream=${Stream} | TlvIndex=0 | EntryIndex=0 | remainTime=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_nlpid_entry",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the edit operation if successful, otherwise False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing one stream object. Must have a 'handle' attribute to uniquely identify it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which ISIS header (e.g., L1/L2 Hello or LSP) in the hierarchy to target for editing. Only headers of type 'isisl1helloheader', 'l1lspheader', 'isisl2helloheader', 'l2lspheader', or 'p2phelloheader' are considered.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index of the TLV within the selected ISIS header where the NLPID entry should be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NlpidIndex",
        "type": "int",
        "description": "Index of the NLPID entry within the specified TLV to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "TlvLength",
        "type": "hex",
        "description": "Sets the length of the TLV field associated with the NLPID entry.",
        "default": "1",
        "range_or_options": "1-255"
      },
      {
        "name": "EntryId",
        "type": "hex",
        "description": "Specifies the Area Address for the NLPID Entry node.",
        "default": "01",
        "range_or_options": "0-255byte"
      }
    ],
    "description": "Edits the NLPID (Network Layer Protocol Identifier) entry within a specific TLV of an ISIS header in the given stream. This function is used to modify fields like TlvLength and EntryId in the NLPID entry of an ISIS message, such as L1/L2 Hello or LSP headers. Internally, it retrieves the list of headers for the stream, filters to find valid ISIS-related headers, selects the header at the specified level, and invokes its method to edit the NLPID field.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1hello | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis Nlpid Entry | Stream=${Stream} | TlvIndex=0 | NlpidIndex=0 | remainTime=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_lsp",
    "return_type": "dict",
    "return": "A dictionary mapping each modified field name to its hierarchical path in the header structure, indicating which fields were successfully updated. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the IS-IS LSP header to be edited. Must have a 'handle' attribute and can optionally be a list of stream objects (the first one will be used).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the IS-IS LSP header to modify when multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "InterRoutingProtocolDiscriminator",
        "type": "int",
        "description": "Intradomain Routing Protocol Discriminator field value to set.",
        "default": "83",
        "range_or_options": "0-255 (0x00-0xFF)"
      },
      {
        "name": "LengthIndicator",
        "type": "int",
        "description": "Length Indicator field value to set.",
        "default": "27",
        "range_or_options": "0-255"
      },
      {
        "name": "VersionIdExtend",
        "type": "int",
        "description": "Version/Protocol ID Extension field value to set.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "IdLength",
        "type": "int",
        "description": "ID Length field value to set.",
        "default": "6",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "First Reserved field value to set.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "PDUType",
        "type": "int",
        "description": "PDU Type field value to set.",
        "default": "18",
        "range_or_options": "0-31"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Version field value to set.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "Second Reserved field value to set.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxAreaAddress",
        "type": "int",
        "description": "Maximum Area Address field value to set.",
        "default": "3",
        "range_or_options": "0-3"
      },
      {
        "name": "PDULength",
        "type": "int",
        "description": "PDU Length field in the LSP data unit header to set.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "RemainTime",
        "type": "int",
        "description": "Remaining Time field in the LSP data unit header to set.",
        "default": "1",
        "range_or_options": "1-3"
      },
      {
        "name": "LspId",
        "type": "hex",
        "description": "LSP ID field in the LSP data unit header to set (must be 8-byte hex string).",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal"
      },
      {
        "name": "SeqcenceNum",
        "type": "hex",
        "description": "Sequence Number field in the LSP data unit header to set (must be 4-byte hex string).",
        "default": "00000000",
        "range_or_options": "4-byte hexadecimal"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Checksum field in the LSP data unit header to set (must be 2-byte hex string).",
        "default": "0000",
        "range_or_options": "2-byte hexadecimal"
      },
      {
        "name": "PartitionRepair",
        "type": "int",
        "description": "Partition Repair Bit field value to set.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Attchment",
        "type": "int",
        "description": "Attachment field value to set.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "OverloadBit",
        "type": "int",
        "description": "Overload Bit field value to set.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TypeOfIntermediateSystem",
        "type": "int",
        "description": "Type of Intermediate System field value to set.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "LspisIsTlvOptionSet",
        "type": "list",
        "description": "TLV Option Set field in the LSP header. A list of TLV types to include.",
        "default": "",
        "range_or_options": "isIsAreaAddress isIsReachability extendedReachability isIsIpInterReachability isIsProtocolsSupported isIsIPExternalReachability ipInterfaceAddress Ipv6InterfaceAddress isIsIpv6Reachability"
      }
    ],
    "description": "Modifies fields in an IS-IS Link State Protocol (LSP) header of a specified stream. This function allows editing various LSP header parameters depending on whether it's a Level 1 or Level 2 LSP. The function retrieves the headers associated with the given stream, filters for L1 or L2 LSP headers, selects the appropriate header by index, and updates the specified fields.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1helloHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis lsp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_metric_entry",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the edit operation if successful. Each key corresponds to a field that was modified and its value is the path to that field in the header structure. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which IS-IS header level (L1/L2 LSP) to target within the stream. This refers to the index in the filtered list of headers of type 'l1lspheader' or 'l2lspheader'.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index of the TLV block within the selected IS-IS LSP header where the metric entry resides.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EntryIndex",
        "type": "int",
        "description": "Index of the metric entry within the selected TLV block.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Distribution flag used in the Metric Entry, typically a single bit (0 or 1).",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetricIEbit",
        "type": "int",
        "description": "Default Metric I/E Bit indicating internal or external metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetric",
        "type": "int",
        "description": "Default Metric value used for routing cost calculation.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "DelayMetricsbit",
        "type": "int",
        "description": "Delay Metric S bit indicating support for delay metrics.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetricSBit",
        "type": "int",
        "description": "Delay Metric R bit indicating whether the metric is supported or restricted.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetric",
        "type": "int",
        "description": "Delay Metric value representing the link delay.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ExpenseMetricsBit",
        "type": "int",
        "description": "Expense Metric S bit indicating support for expense metrics.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetricIEbit",
        "type": "int",
        "description": "Expense Metric R bit indicating whether the metric is supported or restricted.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetric",
        "type": "int",
        "description": "Expense Metric value representing monetary cost of using the link.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ErrorMetricsBit",
        "type": "int",
        "description": "Error Metric S bit indicating support for error metrics.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetricIEbit",
        "type": "int",
        "description": "Error Metric R bit indicating whether the metric is supported or restricted.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetric",
        "type": "int",
        "description": "Error Metric value representing the link error rate.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "IsNeighbor",
        "type": "hex",
        "description": "IS Neighbor address, represented as a 7-byte hexadecimal string.",
        "default": "00000000000000",
        "range_or_options": "7-byte hex string"
      }
    ],
    "description": "Edits a specific metric entry within an IS-IS Level 1 or Level 2 Link State Packet (LSP) header of a given stream. It selects the appropriate header based on Level, then accesses the specified TLV and metric entry by TlvIndex and EntryIndex respectively, and modifies the fields according to the provided keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1lsp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis Metric Entry | Stream=${Stream} | TlvIndex=0 | EntryIndex=0 | errorMetricIEbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_sub_tlv",
    "return_type": "dict",
    "return": "A dictionary containing the result of the sub-TLV editing operation, such as references to modified fields in the header hierarchy. If the operation fails or returns an empty result, False is returned.",
    "description": "Edits a specific ISIS sub-TLV within a given stream's header at the specified level and TLV index. This function allows for configuration of various sub-TLV types with their respective configurable fields.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose header is to be edited. It must have a 'handle' attribute uniquely identifying it in the system. If a list of streams is provided, the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SubTlv",
        "type": "str",
        "description": "The identifier of the sub-TLV to be edited. Supported values include adGroupSubtlv, ipv4InterfaceAddressSubtlv, ipv4NeighborAddressSubtlv, maxLinkBandwidthSubtlv, reservableLinkBandwidthSubtlv, unReservedBandwidthSubtlv, interfaceIpv6Subtlv, neigbhorIpv6Subtlv.",
        "default": "not_found",
        "range_or_options": "adGroupSubtlv ipv4InterfaceAddressSubtlv ipv4NeighborAddressSubtlv maxLinkBandwidthSubtlv reservableLinkBandwidthSubtlv unReservedBandwidthSubtlv interfaceIpv6Subtlv neigbhorIpv6Subtlv"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies which L1/L2 LSP header to target when multiple such headers exist in the stream. Defaults to 0 (the first one).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the parent TLV under which the sub-TLV resides. Defaults to 0.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SubTlvIndex",
        "type": "int",
        "description": "The index of the sub-TLV within the parent TLV to be edited. Defaults to 0.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "TlvCode",
        "type": "int",
        "description": "Type of the sub-TLV, varies based on the SubTlv type selected.",
        "default": "varies by SubTlv type",
        "range_or_options": "0-255"
      },
      {
        "name": "TlvLength",
        "type": "int",
        "description": "Length of the sub-TLV field, varies based on the SubTlv type selected.",
        "default": "varies by SubTlv type",
        "range_or_options": "0-255"
      },
      {
        "name": "AdminGroupValue",
        "type": "int",
        "description": "Administrative group value for adGroupSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "Ipv4InterfaceAddressValue",
        "type": "str",
        "description": "IPv4 Interface Address for ipv4InterfaceAddressSubtlv.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4NeighborAddressValue",
        "type": "str",
        "description": "IPv4 Neighbor Address for ipv4NeighborAddressSubtlv.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "MaxBandwidthValue",
        "type": "int",
        "description": "Maximum Link Bandwidth for maxLinkBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ReservableLinkBandwidthValue",
        "type": "int",
        "description": "Reservable Link Bandwidth for reservableLinkBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth0Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority0 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth1Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority1 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth2Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority2 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth3Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority3 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth4Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority4 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth5Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority5 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth6Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority6 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "ResBandwidth7Value",
        "type": "int",
        "description": "Unreserved ResBandwidth Priority7 for unReservedBandwidthSubtlv.",
        "default": "0",
        "range_or_options": "0-4294967245"
      },
      {
        "name": "InterfaceIpv6Value",
        "type": "str",
        "description": "Interface IPv6 Value for interfaceIpv6Subtlv.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Neighboripv6Value",
        "type": "str",
        "description": "Neighbor IPv6 Value for neigbhorIpv6Subtlv.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1lsp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis Metric Entry | Stream=${Stream} | TlvIndex=0 | EntryIndex=0 | errorMetricIEbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_internal_metric_entry",
    "description": "Edits an internal metric entry in the IS-IS header of a given stream at specified TLV and entry indices. This function modifies fields within the internal metric entry, such as default metric, delay, expense, error metrics, IP address, subnet mask, and various bit flags.",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each modified field to its corresponding path in the internal structure if successful. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or list containing one stream) whose IS-IS internal metric entry will be edited. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies which IS-IS LSP header to target for modification. Level 0 refers to the first Level 1 LSP header; higher levels may refer to Level 2 headers depending on configuration.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the TLV (Type-Length-Value) block within the IS-IS header where the internal metric entry resides.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EntryIndex",
        "type": "int",
        "description": "The index of the specific internal metric entry within the selected TLV to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Distribution flag used in the metric entry.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetricIEbit",
        "type": "int",
        "description": "Default Metric I/E Bit indicating internal or external routing.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetric",
        "type": "int",
        "description": "Default Metric value for routing cost.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "DelayMetricsbit",
        "type": "int",
        "description": "Delay Metric S bit indicating whether delay metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetricSBit",
        "type": "int",
        "description": "Delay Metric R bit indicating whether delay metric is reliable.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetric",
        "type": "int",
        "description": "Delay Metric value representing network delay.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ExpenseMetricsBit",
        "type": "int",
        "description": "Expense Metric S bit indicating whether expense metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetricIEbit",
        "type": "int",
        "description": "Expense Metric R bit indicating reliability of the expense metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetric",
        "type": "int",
        "description": "Expense Metric value representing cost.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ErrorMetricsBit",
        "type": "int",
        "description": "Error Metric S bit indicating whether error metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetricIEbit",
        "type": "int",
        "description": "Error Metric R bit indicating reliability of the error metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetric",
        "type": "int",
        "description": "Error Metric value representing network error probability.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "IpAddress",
        "type": "str",
        "description": "IP Address associated with the metric entry. Must be a valid IPv4 address.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "SubMask",
        "type": "hex",
        "description": "Subnet Mask in hexadecimal format, exactly 4 bytes long.",
        "default": "00000000",
        "range_or_options": "4-byte hex value"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1lsp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis Internal Metric Entry | Stream=${Stream} | TlvIndex=0 | EntryIndex=0 | errorMetricIEbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_external_metric_entry",
    "return_type": "dict or False",
    "return": "A dictionary mapping the modified fields of the external metric entry to their internal path in the header structure if successful; returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) for which the IS-IS header's external metric entry is to be edited. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of filtered headers ('l1lspheader', 'l2lspheader') to select the target header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index of the TLV field within the IS-IS header where the external metric entry resides.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "EntryIndex",
        "type": "int",
        "description": "Index of the specific external metric entry within the selected TLV to be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Distribution flag, typically used for routing control.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetricIEbit",
        "type": "int",
        "description": "Default Metric I/E Bit indicating internal or external metric type.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DefaultMetric",
        "type": "int",
        "description": "Default Metric value used in routing calculations.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "DelayMetricsbit",
        "type": "int",
        "description": "Delay Metric S bit indicating whether delay metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetricSBit",
        "type": "int",
        "description": "Delay Metric R bit indicating reliability of delay metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DelayMetric",
        "type": "int",
        "description": "Delay Metric value used in routing decisions.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ExpenseMetricsBit",
        "type": "int",
        "description": "Expense Metric S bit indicating whether expense metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetricIEbit",
        "type": "int",
        "description": "Expense Metric R bit indicating reliability of expense metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExpenseMetric",
        "type": "int",
        "description": "Expense Metric value used in routing decisions.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "ErrorMetricsBit",
        "type": "int",
        "description": "Error Metric S bit indicating whether error metric is supported.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetricIEbit",
        "type": "int",
        "description": "Error Metric R bit indicating reliability of error metric.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ErrorMetric",
        "type": "int",
        "description": "Error Metric value used in routing decisions.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "IpAddress",
        "type": "str",
        "description": "IP Address associated with the external metric entry, must be a valid IPv4 address.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "SubMask",
        "type": "hex",
        "description": "Subnet mask in hexadecimal format, must be exactly 4 bytes long.",
        "default": "00000000",
        "range_or_options": "4-byte hex string"
      }
    ],
    "description": "Edits an external metric entry within an IS-IS header of a specified stream. This function targets specific TLV (Type-Length-Value) and entry indices within the selected header level. It allows modification of various metric-related fields including default, delay, expense, and error metrics along with IP address and subnet mask configurations.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | l1csnpHeader |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Isis L1lsp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |\n    | Edit Header Isis Tlv Header | Stream=${Stream} | Option=${Option} | Index=0 | lspEntries=1 |\n    | Edit Header Isis External Metric Entry | Stream=${Stream} | TlvIndex=0 | EntryIndex=0 | errorMetricIEbit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_psnp",
    "return_type": "dict",
    "return": "A dictionary mapping each modified field name to its corresponding internal hierarchical path string (e.g., 'l1psnpCommonHeader.InterRoutingProtocolDiscriminator'). Fields not modified do not appear in the result.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object whose IS-IS L1/L2 PSNP header needs to be edited. If a list is provided, the first element will be used. Must have a unique identifier (handle).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the PSNP header if multiple such headers exist in the stream. Used to specify which PSNP header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "InterRoutingProtocolDiscriminator",
        "type": "int",
        "description": "Intradomain Routing Protocol Discriminator field value.",
        "default": "83",
        "range_or_options": "not_found"
      },
      {
        "name": "LengthIndicator",
        "type": "int",
        "description": "Length Indicator field value.",
        "default": "33",
        "range_or_options": "not_found"
      },
      {
        "name": "VersionIdExtend",
        "type": "int",
        "description": "Version/Protocol ID Extension field value.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "IdLength",
        "type": "int",
        "description": "ID Length field value indicating length of system IDs.",
        "default": "6",
        "range_or_options": "not_found"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "First Reserved field value.",
        "default": "3",
        "range_or_options": "0-7"
      },
      {
        "name": "PDUType",
        "type": "int",
        "description": "PDU Type field value.",
        "default": "24",
        "range_or_options": "0-31"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Version field value for IS-IS protocol.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "Second Reserved field value.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxAreaAddress",
        "type": "int",
        "description": "Maximum Area Addresses field value.",
        "default": "3",
        "range_or_options": "0-3"
      },
      {
        "name": "PDULength",
        "type": "int",
        "description": "PDU Length field value (mapped internally to psnpDataHeader).",
        "default": "33",
        "range_or_options": "not_found"
      },
      {
        "name": "SourceId",
        "type": "hex",
        "description": "Source ID field value, must be 6 bytes long.",
        "default": "000000000000",
        "range_or_options": "6byte"
      },
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Reserved field in data header, must be 1 byte long.",
        "default": "00",
        "range_or_options": "1byte"
      },
      {
        "name": "CsnpDataTlvOptionHeader",
        "type": "list",
        "description": "List of TLV options to insert into the CSNP Data TLV/Option Header.",
        "default": "None",
        "range_or_options": "isIsLspEntries authentionInfo"
      }
    ],
    "description": "Edits the fields of an IS-IS L1 or L2 PSNP (Partial Sequence Number PDU) header in a given stream. This function retrieves the headers associated with the provided stream and selects either the L1 PSNP or L2 PSNP header based on its type. It then updates any specified fields in that header. If certain fields are not provided (None), they are left unchanged. A dictionary mapping updated field names to their corresponding internal path strings is returned.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | l1csnpHeader |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Isis psnp | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.isis.edit_header_isis_p2p_hello",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated parameter name to its corresponding internal path string, indicating where the change was applied in the header structure. If no parameters were updated, returns an empty dictionary.",
    "description": "Edits the fields of an ISIS Point-to-Point Hello (P2P Hello) header in a given stream at a specified level. This function allows users to modify various fields in the ISIS P2P Hello message structure, including common and message-specific header fields. Only non-None provided keyword arguments will be updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象，类型为StreamTemplate。Expected to have a 'handle' attribute that uniquely identifies the stream. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "要修改的ISIS P2P Hello头部在流模板中该类型头部的索引级别。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "InterRoutingProtocolDiscriminator",
        "type": "int",
        "description": "Intradomain Routing Protocol Discriminator field in the common header.",
        "default": "83",
        "range_or_options": "not_found"
      },
      {
        "name": "LengthIndicator",
        "type": "int",
        "description": "Length Indicator field in the common header.",
        "default": "20",
        "range_or_options": "not_found"
      },
      {
        "name": "VersionIdExtend",
        "type": "int",
        "description": "Version/Protocol ID Extension field in the common header.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "IdLength",
        "type": "int",
        "description": "ID Length field in the common header.",
        "default": "6",
        "range_or_options": "not_found"
      },
      {
        "name": "CommonReserved1",
        "type": "int",
        "description": "Common reserved field 1 in the common header.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "PDUType",
        "type": "int",
        "description": "PDU Type field in the common header.",
        "default": "17",
        "range_or_options": "0-31"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Version field in the common header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "CommonReserved2",
        "type": "int",
        "description": "Another reserved field in the common header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "MaxAreaAddress",
        "type": "int",
        "description": "Maximum Area Addresses field in the common header.",
        "default": "1",
        "range_or_options": "0-3"
      },
      {
        "name": "FixedReserve1",
        "type": "int",
        "description": "Fixed reserved field 1 in the message header.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "CircuitType",
        "type": "hex",
        "description": "Circuit Type field in the message header. Length: 1 byte.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "SenderSystemID",
        "type": "hex",
        "description": "System ID of the sender in the message header. Length: 6 bytes.",
        "default": "000000000001",
        "range_or_options": "not_found"
      },
      {
        "name": "HolderTimer",
        "type": "hex",
        "description": "Holding Timer in the message header. Length: 6 bytes.",
        "default": "000000000001",
        "range_or_options": "not_found"
      },
      {
        "name": "PDULength",
        "type": "int",
        "description": "PDU Length field in the message header.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "LocalCircuitId",
        "type": "int",
        "description": "Local Circuit ID in the message header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "IsIsTlv",
        "type": "list",
        "description": "可插入的TLV选项，默认无选项。",
        "default": "[]",
        "range_or_options": "padding areaAddress authentionInfo protocolSupport ipInterfaceAddress Ipv6InterfaceAddress restartSignal p2pAdjacencyState"
      }
    ],
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | p2phelloheader |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Isis P2p Hello | Stream=${Stream} | Level=0 | version=10 | maxAreaAddress=3 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.mstp.edit_header_mstp_config",
    "description": "Edits the MSTP (Multiple Spanning Tree Protocol) configuration header of a specified stream at a given level. This function allows updating various fields of an MSTP Configuration BPDU (Bridge Protocol Data Unit) header, enabling customization of network testing scenarios.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Header Mstp Config | Stream=${Stream} | Level=0 | TopologyChangeAck=1 |",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, the first element will be used. The stream object must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the 'cfg' type header in the stream's header list.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "ProtocolIdentifier",
        "type": "int",
        "description": "Sets the protocol identifier field of the MSTP header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ProtocolVersionIdentifier",
        "type": "int",
        "description": "Sets the version of the protocol being used.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "BPDUType",
        "type": "hex",
        "description": "Sets the type of BPDU (e.g., Configuration, TCN, etc.).",
        "default": "02",
        "range_or_options": "00-FF"
      },
      {
        "name": "TopologyChangeAck",
        "type": "bool",
        "description": "Indicates whether topology change acknowledgment flag is set.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Agreement",
        "type": "bool",
        "description": "Indicates agreement flag status as per MSTP protocol.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Forwarding",
        "type": "bool",
        "description": "Indicates whether forwarding flag is set.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Learning",
        "type": "bool",
        "description": "Indicates whether learning flag is set.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "PortRole",
        "type": "int",
        "description": "Sets the role of the port sending the BPDU.",
        "default": "11",
        "range_or_options": "00-11"
      },
      {
        "name": "Proposal",
        "type": "bool",
        "description": "Indicates whether proposal flag is set.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TopologyChange",
        "type": "bool",
        "description": "Indicates whether a topology change is occurring.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RootBridgePriority",
        "type": "int",
        "description": "Sets the priority value of the root bridge.",
        "default": "8",
        "range_or_options": "0-15"
      },
      {
        "name": "RootSystemIdExtension",
        "type": "int",
        "description": "Extension part of the system ID for the root bridge.",
        "default": "0",
        "range_or_options": "0-4095"
      },
      {
        "name": "RootBridgeSystemID",
        "type": "str",
        "description": "System ID of the root bridge.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "RootPathCost",
        "type": "int",
        "description": "Cost to reach the root bridge.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BridgePriority",
        "type": "int",
        "description": "Priority value of the transmitting bridge.",
        "default": "8",
        "range_or_options": "0-15"
      },
      {
        "name": "BridgeSystemIdExtension",
        "type": "int",
        "description": "Extension part of the system ID for the transmitting bridge.",
        "default": "0",
        "range_or_options": "0-4095"
      },
      {
        "name": "BridgeSystemID",
        "type": "str",
        "description": "System ID of the transmitting bridge.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "PortIdentifier",
        "type": "int",
        "description": "Identifier of the transmitting port.",
        "default": "32769",
        "range_or_options": "0-65535"
      },
      {
        "name": "MessageAge",
        "type": "int",
        "description": "Age of the BPDU message.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MaxAge",
        "type": "int",
        "description": "Maximum age before discarding the BPDU.",
        "default": "5120",
        "range_or_options": "0-65535"
      },
      {
        "name": "HelloTime",
        "type": "int",
        "description": "Interval between BPDU transmissions.",
        "default": "512",
        "range_or_options": "0-65535"
      },
      {
        "name": "ForwardDelay",
        "type": "int",
        "description": "Delay time for transitions between states.",
        "default": "3840",
        "range_or_options": "0-65535"
      },
      {
        "name": "Version1Length",
        "type": "int",
        "description": "Length of Version 1 BPDU data.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Version3Length",
        "type": "int",
        "description": "Length of Version 3 BPDU data.",
        "default": "64",
        "range_or_options": "0-255"
      },
      {
        "name": "ConfigId",
        "type": "int",
        "description": "Configuration ID used for MST instance mapping.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ConfigName",
        "type": "str",
        "description": "Name of the MST configuration.",
        "default": "726567696f6e3100000000000000000000000000000000000000000000000000",
        "range_or_options": "32-byte hexadecimal string"
      },
      {
        "name": "ConfigRevision",
        "type": "int",
        "description": "Revision number of the MST configuration.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ConfigDigest",
        "type": "bytes",
        "description": "Digest of the MST configuration for consistency checks.",
        "default": "b'\\x90\\xfb\\xa5\\xe9wK\\tRJ\\x17\\xeb\\xb7_\\x8d\\x06Z'",
        "range_or_options": "16-byte hexadecimal"
      },
      {
        "name": "CistRootPathCost",
        "type": "int",
        "description": "Path cost to reach the CIST (Common and Internal Spanning Tree) root.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "CistBridgePriority",
        "type": "int",
        "description": "Priority of the CIST bridge.",
        "default": "8",
        "range_or_options": "0-15"
      },
      {
        "name": "CistSystemIdExtension",
        "type": "int",
        "description": "Extension part of the system ID for the CIST bridge.",
        "default": "0",
        "range_or_options": "0-4095"
      },
      {
        "name": "CistBridgeSystemID",
        "type": "str",
        "description": "System ID of the CIST bridge.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "CistRemainingHops",
        "type": "int",
        "description": "Remaining hops allowed for the CIST BPDU.",
        "default": "20",
        "range_or_options": "0-255"
      },
      {
        "name": "MstInstances",
        "type": "list",
        "description": "List of MST instances included in the BPDU.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "return_type": "dict",
    "return": "A dictionary where keys are the names of the parameters that were provided and updated, and values are strings representing the corresponding attribute names in the MSTP header object that were modified.",
    "raises": []
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.mstp.edit_header_mstp_config_mst_instance",
    "return_type": "dict or False",
    "return": "A dictionary mapping the configuration fields to their internal hierarchical paths if the operation is successful. Returns False if no changes were made or if the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one stream object) for which the MSTP MST instance configuration will be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which MSTP 'cfg' header in the stream to target for editing the MST instance.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the MST instance within the selected MSTP configuration header that will be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "TopologyChangeAck",
        "type": "bit",
        "description": "Topology Changed Acknowledgment flag.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Agreement",
        "type": "bit",
        "description": "Agreement flag indicating whether the port agrees to the proposal.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Forwarding",
        "type": "bit",
        "description": "Indicates whether the port is in Forwarding state.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Learning",
        "type": "bit",
        "description": "Indicates whether the port is in Learning state.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "PortRole",
        "type": "bit",
        "description": "Port Role, representing the role of the port in the spanning tree.",
        "default": "11",
        "range_or_options": "00-11"
      },
      {
        "name": "Proposal",
        "type": "bit",
        "description": "Proposal flag used during MSTP negotiation.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TopologyChange",
        "type": "bit",
        "description": "Topology Change flag indicating that a topology change has occurred.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "MST Instance priority value.",
        "default": "8",
        "range_or_options": "0-15"
      },
      {
        "name": "MstId",
        "type": "int",
        "description": "MST ID identifying the Multiple Spanning Tree instance.",
        "default": "1",
        "range_or_options": "0-4095"
      },
      {
        "name": "RegionalRoot",
        "type": "str",
        "description": "MAC address representing the regional root of the MST instance.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "InternalRootPathCost",
        "type": "int",
        "description": "Path cost to the internal root bridge.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "BridgeIdentifierPriority",
        "type": "int",
        "description": "Bridge identifier priority for the MST instance.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "PortIdentifierPriority",
        "type": "int",
        "description": "Port identifier priority for the MST instance.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "RemainingHops",
        "type": "int",
        "description": "Number of remaining hops allowed for this MST instance.",
        "default": "20",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits the MST (Multiple Spanning Tree) instance configuration for a specified MSTP (Multiple Spanning Tree Protocol) header within a stream. This function targets a specific level of the header hierarchy and updates the MST instance based on provided keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | cfg |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Mstp Config | Stream=${Stream} | Level=0 | MstInstances=1 |\n    | Edit Header Mstp Config Mst Instance | Stream=${Stream} | Index=0 | TopologyChangeAck=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.prp.edit_header_prp_tag",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping the modified parameter names to their corresponding internal attribute names in the header object (e.g., {'SequenceNumber': 'seqnum'}). If no parameters were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the 'prptag' header needs to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'prptag' header in the filtered list of headers of type 'prptag'. This specifies which header at that level should be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "New value to set for the sequence number field of the 'prptag' header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "LanId",
        "type": "bit",
        "description": "New value to set for the LAN ID field of the 'prptag' header.",
        "default": "1010",
        "range_or_options": "0000-1111"
      },
      {
        "name": "LsduSize",
        "type": "int",
        "description": "New value to set for the LSDU size field of the 'prptag' header.",
        "default": "52",
        "range_or_options": "0-4095"
      },
      {
        "name": "PrpSuffix",
        "type": "hex",
        "description": "New value to set for the PRP suffix field of the 'prptag' header.",
        "default": "88FB",
        "range_or_options": "length of 2 bytes hexadecimal number"
      }
    ],
    "description": "Edits specific fields of a 'prptag' type header in the specified stream at the given level. The function modifies one or more fields of the header at the specified level. Supported editable fields are SequenceNumber, LanId, LsduSize, and PrpSuffix.",
    "example": "| Edit Header Prp Tag | Stream=${Stream} | Level=0 | SequenceNumber=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L2.rtag.edit_header_r_tag",
    "return_type": "dict or bool",
    "return": "Returns a dictionary indicating the modified fields and their corresponding internal attributes (e.g., {'SeqNum': 'seqnum'}) if any changes were successfully applied. If no fields are modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the headers will be inspected and modified. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the 'rtag' header in the header list to modify. This is useful when multiple 'rtag' headers exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Reserved",
        "type": "hex",
        "description": "Value to set for the 'reserved' field of the selected 'rtag' header. If None, this field is not modified.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "SeqNum",
        "type": "int",
        "description": "Value to set for the 'seqnum' field (sequence number) of the selected 'rtag' header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Protocol",
        "type": "hex",
        "description": "Value to set for the 'protocol' field of the selected 'rtag' header. If None, this field is not modified.",
        "default": "0800",
        "range_or_options": "0800 0806 8100 8864 8863 86DD 8808 8847 88B8 8926 F1C1 892F 88FB"
      }
    ],
    "description": "Modifies specific fields of an 'rtag' type header in the specified stream. The function allows editing of the Reserved, SeqNum (sequence number), and Protocol fields of the selected header. Only non-None parameters are applied. If no valid modifications are made, the function returns False. This function internally interacts with the backend system to apply changes to the stream's header configuration.",
    "example": "| Edit Header R Tag | Stream=${Stream} | Level=0 | SeqNum=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv4",
    "return_type": "dict",
    "return": "A dictionary mapping the updated parameter names to their corresponding internal attribute or path strings (e.g., {'Version': 'version', 'Source': 'source'}). Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the IPv4 header is to be edited. It must have a 'handle' attribute that uniquely identifies the stream within the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the IPv4 header in the list of IPv4 headers associated with the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the IPv4 version field (e.g., 4 for IPv4). Optional.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "HeadLen",
        "type": "int",
        "description": "Sets the Internet Header Length (IHL) field indicating the length of the IPv4 header.",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "TotalLength",
        "type": "int",
        "description": "Sets the total length of the IP packet including header and payload.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Flags",
        "type": "int",
        "description": "Sets the flags field used for fragmentation control.",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "ID",
        "type": "int",
        "description": "Sets the identification field used during fragmentation and reassembly.",
        "default": "123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Offset",
        "type": "int",
        "description": "Sets the fragment offset indicating where in the original payload this fragment belongs.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "TTL",
        "type": "int",
        "description": "Sets the Time-To-Live field which limits the packet's lifetime.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Protocol",
        "type": "int",
        "description": "Sets the protocol field indicating the next-level protocol (e.g., TCP=6, UDP=17).",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the header checksum used for error checking.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "Sets the source IP address.",
        "default": "192.168.0.2",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "Sets the destination IP address.",
        "default": "192.168.0.10",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Sets padding data if present.",
        "default": "000000",
        "range_or_options": "长度0-3字节的十六进制数"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Sets the gateway IP address.",
        "default": "192.168.0.1",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "Tos",
        "type": "int",
        "description": "Sets the entire ToS value. Mapped internally to `tos`.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "TosPrecedence",
        "type": "int",
        "description": "Sets the precedence sub-field of the Type of Service (ToS).",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "TosDelay",
        "type": "int",
        "description": "Sets the delay sub-field of the ToS.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TosThroughput",
        "type": "int",
        "description": "Sets the throughput sub-field of the ToS.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TosReliability",
        "type": "int",
        "description": "Sets the reliability sub-field of the ToS.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TosMonetaryCost",
        "type": "int",
        "description": "Sets the monetary cost sub-field of the ToS.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "TosReserved",
        "type": "int",
        "description": "Sets the reserved sub-field of the ToS.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DiffserveCodepointPrecedence",
        "type": "int",
        "description": "Sets the DSCP code point precedence.",
        "default": "0",
        "range_or_options": "000000-111111"
      },
      {
        "name": "DiffserveClassSelectorPrecedence",
        "type": "int",
        "description": "Sets the class selector precedence in DSCP.",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "DiffserveClassSelectorDrop",
        "type": "int",
        "description": "Sets the drop probability in the class selector of DSCP.",
        "default": "0",
        "range_or_options": "00-11"
      },
      {
        "name": "DiffserveClassSelectorUndefine",
        "type": "int",
        "description": "Sets undefined bits in the DSCP class selector.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DiffserveEcn",
        "type": "int",
        "description": "Sets the ECN (Explicit Congestion Notification) field.",
        "default": "0",
        "range_or_options": "00-11"
      },
      {
        "name": "TosByte",
        "type": "hex",
        "description": "Sets the full ToS byte directly.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "HeaderOption",
        "type": "list",
        "description": "Inserts an IPv4 header option by name. Supports: EndOfOption, Nop, Security, LooseSourceRoute, StrictSourceRoute, RouterAlert, RecordRoute, TimeStamp, StreamIdentifier, General.",
        "default": "[]",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      }
    ],
    "description": "Edits the IPv4 header fields of a specified stream. This function allows modification of various fields in the IPv4 header such as version, length, flags, TTL, source and destination IP addresses, ToS (Type of Service), DSCP (Differentiated Services Code Point), ECN (Explicit Congestion Notification), and more.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 |\n    | ${HeaderOption} | Create List | RouterAlert | EndOfOption | LooseSourceRoute |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header IPv4 | Stream=${Stream} | Level=0 | Source=192.168.1.1 | HeaderOption=${HeaderOption} |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=${Attribute}[Source] | Type=Increment | Count=10 | Step=2 |\n    | &{Attribute} | Edit Header IPv4 Option | Stream=${Stream} | Type=RouterAlert | routerAlertValue=5 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=${Attribute}[routerAlertValue] | Type=Decrement | Count=3 | Step=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv4_option",
    "return_type": "dict",
    "return": "A dictionary mapping modified IPv4 option fields to their corresponding hierarchical identifiers in the stream configuration. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing a single stream) to modify. Must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "str",
        "description": "The type of IPv4 header option to edit. Supported values include: EndOfOption, Nop, Security, LooseSourceRoute, StrictSourceRoute, RouterAlert, RecordRoute, TimeStamp, StreamIdentifier, General.",
        "default": "not_found",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IPv4 header within the stream's header hierarchy. Used when multiple IPv4 headers are present.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific IPv4 Option header among all options in the selected IPv4 header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Header",
        "type": "str",
        "description": "Specifies the type of header to target. Defaults to 'ipv4'. Other supported types include error-related headers like 'destunreach', 'parameterproblem', etc.",
        "default": "'ipv4'",
        "range_or_options": "ipv4 destunreach parameterproblem redirect sourcequench timeexceeded"
      }
    ],
    "kwargs": [
      {
        "name": "Optiontype",
        "type": "int",
        "description": "Specifies the Option Type field for certain IPv4 options. Default value varies depending on the Option type.",
        "default": "varies by Option type",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the option data field. Auto-calculated in some cases; default varies per option type.",
        "default": "varies by Option type",
        "range_or_options": "0-255"
      },
      {
        "name": "Security",
        "type": "int",
        "description": "Used in Security option; specifies security level.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Compartments",
        "type": "int",
        "description": "Used in Security option; compartmentalization identifier.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "HandlingRestrictions",
        "type": "int",
        "description": "Used in Security option; specifies handling restrictions.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "TxControlCode",
        "type": "int",
        "description": "Transmission control code used in Security option.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Pointer",
        "type": "int",
        "description": "Pointer to the next address to be used in routing options like LooseSourceRoute and StrictSourceRoute.",
        "default": "4",
        "range_or_options": "0-255"
      },
      {
        "name": "AddressList",
        "type": "list",
        "description": "IPv4 addresses used in routing options like LooseSourceRoute, StrictSourceRoute, and RecordRoute.",
        "default": "[]",
        "range_or_options": "valid IPv4 addresses"
      },
      {
        "name": "RouterAlertValue",
        "type": "int",
        "description": "Value for the Router Alert option indicating action required at router.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Overflow",
        "type": "int",
        "description": "Number of timestamps that could not be added due to size limitations.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "Flag",
        "type": "int",
        "description": "Indicates how timestamp information should be recorded.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "TimeStamp",
        "type": "hex",
        "description": "Single timestamp value in hexadecimal format.",
        "default": "00000000",
        "range_or_options": "00000000-FFFFFFFF"
      },
      {
        "name": "TimeStampSet",
        "type": "list",
        "description": "Multiple timestamp values in hexadecimal format.",
        "default": "[]",
        "range_or_options": "00000000-FFFFFFFF"
      },
      {
        "name": "SystemId",
        "type": "int",
        "description": "System ID used in the Stream Identifier option.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Option type for general use.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value for general-purpose option data.",
        "default": "\"\"",
        "range_or_options": "0-40 bytes hex string"
      }
    ],
    "description": "Edits an IPv4 header option in a specified stream. This function allows for detailed customization of various IPv4 options such as Security, Source Routing, Timestamps, and more. It retrieves the appropriate header based on Level and Header type, then modifies the specified option using provided parameters.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Init Tester |\n    | ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n    | ${Port} | reserve_port | Locations=${Locations} |\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | &{Attribute} | Edit Header IPv4 | Stream=${Stream} | Level=0 | Source=192.168.1.1 | HeaderOption=RouterAlert |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=${Attribute}[Source] | Type=Increment | Count=10 | Step=2 |\n    | &{Attribute} | Edit Header IPv4 Option | Stream=${Stream} | Option=RouterAlert | routerAlertValue=5 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv4 | Attribute=${Attribute}[routerAlertValue] | Type=Decrement | Count=3 | Step=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each successfully updated parameter name to the corresponding attribute name in the header object (e.g., {'Version': 'version'}). Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing one stream object. If a list is passed, only the first element will be used. Must have a 'handle' attribute that uniquely identifies it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which IPv6 header to modify among all IPv6 headers in the stream. Starts at 0.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the Version field of the IPv6 header.",
        "default": "6",
        "range_or_options": "0-15"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Sets the Traffic Class field of the IPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "Sets the Flow Label field of the IPv6 header.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "Sets the Payload Length field of the IPv6 header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Sets the Next Header field of the IPv6 header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "HopLimit",
        "type": "int",
        "description": "Sets the Hop Limit field of the IPv6 header.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "Sets the Source Address field of the IPv6 header.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "Sets the Destination Address field of the IPv6 header.",
        "default": "2001::1:f1:11",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Sets the Gateway Address field of the IPv6 header.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Modifies the fields of an IPv6 header within a specified stream template at a given level. This function allows updating multiple IPv6 header fields such as version, traffic class, flow label, payload length, next header, hop limit, source, destination, and gateway addresses. It returns a dictionary mapping the successfully updated parameters to their corresponding internal attribute names, or False if no modifications were applied.",
    "example": "robotframework:\n\n| Init Tester |\n| ${Locations} | Create List | //192.168.0.180/1/1 | //192.168.0.180/1/2 |\n| ${Port} | reserve_port | Locations=${Locations} |\n| ${HeaderTypes} | Create List | EthernetII | IPv6 |\n| ${HeaderOption} | Create List | RouterAlert | EndOfOption | LooseSourceRoute |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| &{Attribute} | Edit Header IPv6 | Stream=${Stream} | Level=0 | Source=2000::1 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[Source] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_fragment",
    "return_type": "dict or False",
    "return": "A dictionary mapping the updated parameter names to their corresponding internal attribute names (e.g., {'NextHeader': 'nextHeader'}) if any updates were successfully made. Returns False if no changes were applied.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose IPv6 Fragment header fields will be edited. Expected to have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the IPv6 Fragment header in the stream's list of headers. Used to identify which fragment header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Sets the value of the 'Next Header' field in the IPv6 Fragment Header, indicating the type of the next header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "Sets the value of the first reserved field in the IPv6 Fragment Header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FragOffset",
        "type": "int",
        "description": "Sets the offset of this fragment relative to the original unfragmented packet.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Reserved2",
        "type": "hex",
        "description": "Sets the second reserved field in the IPv6 Fragment Header, typically represented as hexadecimal.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Mflag",
        "type": "bit",
        "description": "Sets the More Fragments flag; indicates whether more fragments follow this one.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ident",
        "type": "int",
        "description": "Sets the Identification field used to uniquely identify the set of fragments that belong to the same original packet.",
        "default": "255",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the fields of an IPv6 Fragment Header in a specified stream. This function allows modification of various fields in an IPv6 fragment header associated with a given stream. It identifies the appropriate header based on the 'Level' parameter and updates only the fields for which non-None values are provided.",
    "example": "| &{Attribute} | Edit Header IPv6 Fragment| Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_routing",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each modified field name to its corresponding internal attribute name if one or more fields are successfully updated. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the IPv6 routing header. The stream is expected to have a 'handle' attribute identifying it uniquely in the system. If a list of streams is provided, only the first stream is considered.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IPv6 routing header in the list of matching headers found in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Value to set for the 'nextHeader' field of the IPv6 routing header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Value to set for the 'length' field of the IPv6 routing header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RoutingType",
        "type": "int",
        "description": "Value to set for the 'routingType' field of the IPv6 routing header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SegLeft",
        "type": "hex",
        "description": "Value to set for the 'segLeft' field of the IPv6 routing header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "Value to set for the 'reserved' field of the IPv6 routing header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Nodes",
        "type": "list",
        "description": "A list of node objects or a single node object to set for the 'nodes' field of the IPv6 routing header. Each node must be compatible with the IPv6 routing header's node structure.",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits the fields of an IPv6 routing header in a given stream at the specified level. This function retrieves the list of headers for the provided stream and filters them to find IPv6 routing headers. It then modifies one or more fields of the IPv6 routing header located at the specified level (index). If any field is provided (not None), it updates the corresponding attribute of the header and records the change in the result dictionary.",
    "example": "| &{Attribute} | Edit Header IPv6 Routing| Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_authentication",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each updated field name to its new value if one or more fields were successfully updated; otherwise, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象，包含要编辑的IPv6 Authentication报文头部。该对象必须具有唯一标识符属性 'handle'。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "指定要修改的IPv6 Authentication头部在流模板中所有此类头部的索引序号。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Authentication Header 的 Next Header 字段值。",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Authentication Header 的 Length 字段值。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "保留字段值。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Spi",
        "type": "hex",
        "description": "Security Parameter Index 值。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SeqNum",
        "type": "bit",
        "description": "Sequence Number 值。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthData",
        "type": "hex",
        "description": "Authentication Data 数据内容。",
        "default": "0000",
        "range_or_options": "not_found"
      },
      {
        "name": "Pad",
        "type": "hex",
        "description": "8字节对齐填充数据，用于确保认证数据长度为8字节的整数倍。",
        "default": "<Auto>0000",
        "range_or_options": "十六进制字符串（长度0-7字节）"
      }
    ],
    "description": "Modifies the fields of an IPv6 Authentication Header in a specified stream. If any field parameter is provided (not None), it updates the corresponding field in the header and records the update in the result dictionary. This function is primarily used for test traffic template configuration in network testing frameworks.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | &{Attribute} | Edit Header IPv6 Authentication| Stream=${Stream} | Level=0 | NextHeader=10 |\n    | Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_destination",
    "return_type": "dict",
    "return": "A dictionary indicating which attributes were updated and their corresponding mapped values. Possible keys include 'NextHeader', 'Length', 'Pad', and 'OptionHeaders'.",
    "description": "Modifies the fields of an IPv6 Destination header in a given stream at the specified level. This includes updating NextHeader, Length, Pad fields or inserting option headers like pad1, padN, generalTLV, bierv6.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which IPv6 destination header to modify when multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Value to set for the 'nextHeader' field of the IPv6 destination header. If provided, this updates the next header protocol type.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Value to set for the 'length' field of the IPv6 destination header. Typically represents the length of the header in octets.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Pad",
        "type": "hex",
        "description": "Value to set for the 'pad' field of the IPv6 destination header. Used for alignment purposes within the header.",
        "default": "<Auto>000000000000",
        "range_or_options": "0-7 bytes hex string"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "List of option headers to insert into the current IPv6 destination header. Supported options are: pad1, padN, generalTLV, bierv6.",
        "default": "not_found",
        "range_or_options": "pad1 padN generalTLV bierv6"
      }
    ],
    "example": "| &{Attribute} | Edit Header IPv6 Destination| Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_destination_option",
    "return_type": "dict",
    "return": "A dictionary containing the result of the edit operation, which varies depending on the specific option edited. For example, for 'padN', it may return keys like 'Type', 'Length', and 'Padding'.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate",
        "description": "The stream object from the test instrument representing the traffic template.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "str",
        "description": "The type of IPv6 Destination Option to edit.",
        "default": "not_found",
        "range_or_options": "pad1 padN generalTLV bierv6"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IPv6 Destination Options header in the stream (used when multiple headers exist).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific option within the selected IPv6 Destination Options header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Pad 1 Option Type or Pad N Option Type depending on option selected.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Pad N Option Length or General TLV Option Length.",
        "default": "1",
        "range_or_options": "0-5 (for padN), 0-255 (for generalTLV)"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Pad N Option Padding content as hexadecimal value.",
        "default": "00",
        "range_or_options": "0-5 bytes hex string"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Custom Data for General TLV Option.",
        "default": "0102030405060708090A",
        "range_or_options": "0-1024 bytes hex string"
      },
      {
        "name": "Optiontype",
        "type": "int",
        "description": "BIERv6 Option Type.",
        "default": "122",
        "range_or_options": "0-255"
      },
      {
        "name": "Optionlen",
        "type": "int",
        "description": "BIERv6 Option Length.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "BiftId",
        "type": "int",
        "description": "BIFT-ID for BIERv6 Option.",
        "default": "1",
        "range_or_options": "0-1048575"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Traffic Class field in BIERv6 Header.",
        "default": "0",
        "range_or_options": "0-7"
      },
      {
        "name": "SBit",
        "type": "bit",
        "description": "sBit flag in BIERv6 Header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Ttl",
        "type": "int",
        "description": "Time-to-Live (TTL) value in BIERv6 Header.",
        "default": "64",
        "range_or_options": "0-255"
      },
      {
        "name": "Nibble",
        "type": "bit",
        "description": "Nibble field in BIERv6 Header (4 bits).",
        "default": "0101",
        "range_or_options": "0000-1111"
      },
      {
        "name": "BierVer",
        "type": "int",
        "description": "BIER Version number.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "Bsl",
        "type": "int",
        "description": "Bit String Length (BSL) in BIERv6 Header.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Entropy",
        "type": "int",
        "description": "Entropy value used in BIERv6 Header.",
        "default": "1",
        "range_or_options": "0-1048575"
      },
      {
        "name": "Oam",
        "type": "int",
        "description": "Operation, Administration, and Maintenance (OAM) flag.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "Rsv",
        "type": "int",
        "description": "Reserved field in BIERv6 Header.",
        "default": "0",
        "range_or_options": "0-3"
      },
      {
        "name": "Dscp",
        "type": "int",
        "description": "Differentiated Services Code Point (DSCP) value.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "Protocol",
        "type": "int",
        "description": "Next Header protocol identifier in BIERv6 Header.",
        "default": "63",
        "range_or_options": "0-63"
      },
      {
        "name": "BfirId",
        "type": "int",
        "description": "BFIR-ID (Bit-Forwarding Ingress Router ID).",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "BierbitString",
        "type": "int",
        "description": "Number of BIER Bit Strings to insert.",
        "default": "0",
        "range_or_options": "0-100"
      }
    ],
    "description": "Edits a specific option within the IPv6 Destination Options header of a given stream. This function identifies the appropriate IPv6 Destination Options header based on the specified level and modifies the selected option type using the provided parameters. It supports editing types such as 'pad1', 'padn', 'generaltlv', and 'bierv6'.",
    "example": "| Edit Header IPv6 Destination | Stream=${Stream} | Level=0 | OptionHeaders=bierv6 |\n| Edit Header Ipv6 Destination Option | Stream=${Stream} | Option=bierv6 | BierbitString=${1} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_destination_bier_bit_string",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the BIER bit string editing operation if successful. Returns False if the operation fails or if no result is returned by the underlying method.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first item will be used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IPv6 destination header within the list of such headers in the stream. Used to select which IPv6 destination header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "BierIndex",
        "type": "int",
        "description": "The index of the BIER subheader to modify. This corresponds to a specific BIER-encapsulated path or segment.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index within the BIER bit string to perform the modification. This typically refers to a specific bit position or field in the BIER header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "bitString",
        "type": "bit",
        "description": "Bit String value to set for the BIER bit string field. Must be a 32-bit binary number.",
        "default": "01010101010101010101010101010101",
        "range_or_options": "32-bit binary number"
      },
      {
        "name": "bitString2",
        "type": "bit",
        "description": "Second Bit String value to set for an additional BIER bit string field. Must also be a 32-bit binary number.",
        "default": "01010101010101010101010101010101",
        "range_or_options": "32-bit binary number"
      }
    ],
    "description": "Edits the BIER (Bit Index Explicit Replication) bit string in a specific IPv6 destination header of a stream. This function retrieves the list of headers for the specified stream and filters them to find IPv6 destination headers. It selects the header at the specified level (index) from this filtered list and calls its method to edit the BIER bit string with the provided parameters.",
    "example": "| Edit Header Ipv6 Destination Bier Bit String | Stream=${Stream} | bitString=10101010101010101010101010101010 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_encapsulation",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated parameter name (e.g., 'Spi', 'SeqNum') to the corresponding internal attribute name in the header object (e.g., 'spi', 'seqNum'). This indicates which fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first element is used. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the IPv6 Encapsulation header to modify when multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Spi",
        "type": "int",
        "description": "Security Parameters Index for IPsec. Sets the 'spi' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SeqNum",
        "type": "int",
        "description": "Sequence number for IPsec. Sets the 'seqNum' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PayloadData",
        "type": "hex",
        "description": "Data carried in the payload. Sets the 'payloadData' field in the header if provided. Must be a hexadecimal string of length 2-128 bytes.",
        "default": "0000",
        "range_or_options": "length 2-128 bytes hex string"
      },
      {
        "name": "PadData",
        "type": "hex",
        "description": "Padding data to align the packet. Sets the 'padData' field in the header if provided. Must be a hexadecimal string of length 0-255 bytes.",
        "default": "00",
        "range_or_options": "length 0-255 bytes hex string"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the encapsulated payload. Sets the 'length' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Identifies the type of the next header. Sets the 'nextHeader' field in the header if provided.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "AuthData",
        "type": "hex",
        "description": "Authentication data for IPsec. Sets the 'authData' field in the header if provided. Must be a hexadecimal string of length 2-128 bytes.",
        "default": "0000",
        "range_or_options": "length 2-128 bytes hex string"
      },
      {
        "name": "Pad",
        "type": "hex",
        "description": "Additional padding size for 8-byte alignment. Sets the 'pad' field in the header if provided. Must be a hexadecimal string of length 0-7 bytes.",
        "default": "",
        "range_or_options": "length 0-7 bytes hex string"
      }
    ],
    "description": "Modifies fields of an IPv6 Encapsulation header in a specified stream. This function allows updating specific attributes of the IPv6 Encapsulation header, such as Security Parameters Index (SPI), sequence number, payload data, padding, length, next header type, authentication data, and pad value. The function retrieves the list of headers associated with the provided stream using `get_stream_header`, filters them to find IPv6 Encapsulation headers, and selects the header at the specified level (index). If any of the optional parameters are provided (Spi, SeqNum, etc.), their corresponding values are updated in the selected header object.",
    "example": "| &{Attribute} | Edit Header IPv6 Encapsulation| Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_hopbyhop",
    "return_type": "dict",
    "return": "A dictionary indicating which fields were successfully updated. Each key corresponds to a parameter name (e.g., 'NextHeader'), and the value corresponds to the internal attribute name that was modified (e.g., 'nextHeader'). If no fields are modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象，必须包含唯一标识流的 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "在多个IPv6 Hop-by-Hop头部中指定要修改的头部索引。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int",
        "description": "设置Hop-by-Hop头部中的Next Header字段值，表示后续头部类型。",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "设置Hop-by-Hop头部长度字段值（以八位字节为单位）。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Pad",
        "type": "hex",
        "description": "用于确保正确对齐的填充值。默认为Auto。",
        "default": "Auto",
        "range_or_options": "not_found"
      },
      {
        "name": "OptionHeaders",
        "type": "list",
        "description": "要插入的选项头部列表。支持的参数包括：pad1, padN, routerAlert, jumbo, generalTLV。",
        "default": "not_found",
        "range_or_options": "pad1 padN routerAlert jumbo generalTLV"
      }
    ],
    "description": "该函数用于修改测试仪表流量模板中的IPv6 Hop-by-Hop报文头部内容。它允许修改NextHeader、Length、Pad等字段，并可插入多种类型的选项头部（如pad1、routerAlert等）。适用于需要自定义IPv6 Hop-by-Hop扩展头部的网络测试场景。",
    "example": "robotframework示例:\n\n| &{Attribute} | Edit Header IPv6 HopByHop | Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_hopbyhop_option",
    "return_type": "dict",
    "return": "A dictionary containing the result of the operation, typically including success status and any relevant metadata returned from the underlying API call. For example, it may include the path to the modified option field in the header structure.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate",
        "description": "The stream object representing the traffic template whose IPv6 Hop-by-Hop Options header is to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "str",
        "description": "The type of IPv6 Hop-by-Hop option to edit. Valid values are: 'pad1', 'padN', 'routerAlert', 'jumbo', or 'generalTLV'.",
        "default": "not_found",
        "range_or_options": "pad1 padN routerAlert jumbo generalTLV"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The hierarchical level of the IPv6 Hop-by-Hop header within the stream's header chain. Used to select which Hop-by-Hop header (if multiple) to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific Option within the selected Hop-by-Hop Options list to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Option Type field for Pad1, PadN, Router Alert, Jumbo Payload, or General TLV options. Default varies per option type.",
        "default": "varies",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the Option data field, applicable to PadN, Router Alert, Jumbo Payload, and General TLV options.",
        "default": "varies",
        "range_or_options": "0-255"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Padding value for PadN option, represented as a hexadecimal string. Length must match specified Length field (up to 5 bytes).",
        "default": "00",
        "range_or_options": "length 0-5 hex string"
      },
      {
        "name": "Value",
        "type": "int",
        "description": "Value for Router Alert option indicating the alert type.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Data",
        "type": "int or hex",
        "description": "Data field for Jumbo Payload (as integer payload size) or General TLV (as hexadecimal data string).",
        "default": "0 or 0102030405060708090A",
        "range_or_options": "0-4294967295 (for Data as int), length 0-1024 hex string (for TLV)"
      }
    ],
    "description": "Edits a specific IPv6 Hop-by-Hop Option in a given stream's header hierarchy. The function allows modification of various standard and custom Hop-by-Hop options such as Pad1, PadN, Router Alert, Jumbo Payload, and General TLV. It supports selecting the target header by Level and the specific Option by Index, with customizable parameters based on the selected Option type.",
    "example": "| Edit Header IPv6 HopByHop | Stream=${Stream} | Level=0 | OptionHeaders=generalTLV |\n| Edit Header Ipv6 HopByHop Option | Stream=${Stream} | Option=generalTLV | Data=FFFFFF |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_sr",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name (e.g., 'NextHeader') to the corresponding internal attribute name (e.g., 'nextHeader'). If OptionHeaders are present, it includes 'OptionHeaders': True.",
    "description": "Edits the fields of an IPv6 Segment Routing (SR) header in a specified stream. This function allows modification of various IPv6 SR header parameters such as NextHeader, Length, RoutingType, Segments Left, Last Entry, SR Header Flags, Tag, and SRH Options.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first element is used. The stream object must have a 'handle' attribute that uniquely identifies the stream in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of IPv6 SR headers found in the stream. Used to select which IPv6 SR header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "NextHeader",
        "type": "int or None",
        "description": "Specifies the type of the next header following the SR header. Updates the 'nextHeader' field in the header if provided.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int or None",
        "description": "Length of the SR header in octets, not including the first 8 octets. Updates the 'length' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RoutingType",
        "type": "int or None",
        "description": "Type of routing information carried in the segment routing header. Updates the 'routingType' field in the header if provided.",
        "default": "4",
        "range_or_options": "0-255"
      },
      {
        "name": "SegLeft",
        "type": "int or None",
        "description": "Number of segments remaining to be processed. Updates the 'segLeft' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "LastEntry",
        "type": "int or None",
        "description": "Index of the last entry in the segments array. Updates the 'lastEntry' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "SRHeaderFlag",
        "type": "int or None",
        "description": "Flags field in the SR header; unused bits can be set here. Updates the 'sRHeaderFlag' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-255 (interpreted as 8-bit binary)"
      },
      {
        "name": "Tag",
        "type": "int or None",
        "description": "Used for matching between segments in different packets. Updates the 'tag' field in the header if provided.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SRHOption",
        "type": "list or None",
        "description": "Additional options related to the SR header. Valid values include: sRSegment, sRIngressNodeTlv, sREgressNodeTlv, sROpaqueContainerTlv, sRHmacTlv, sRPadding1Tlv, sRPaddingTlv, generalTLV.",
        "default": "None",
        "range_or_options": "sRSegment sRIngressNodeTlv sREgressNodeTlv sROpaqueContainerTlv sRHmacTlv sRPadding1Tlv sRPaddingTlv generalTLV"
      }
    ],
    "example": "| &{Attribute} | Edit Header IPv6 Sr| Stream=${Stream} | Level=0 | NextHeader=10 |\n| Edit Modifier | Stream=${Stream} | Level=0 | HeaderType=IPv6 | Attribute=${Attribute}[NextHeader] | Type=Increment | Count=10 | Step=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.common.edit_header_ipv6_sr_option",
    "return_type": "dict",
    "return": "A dictionary containing the results from the edit operation(s). Specific keys and values depend on the operation executed by the underlying methods (e.g., edit_segment(), edit_ingress_node_tlv()).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or list of stream objects. If a list, only the first element is used. The stream must have a 'handle' attribute identifying it uniquely within the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "str",
        "description": "Specifies the type of SRv6 header option to edit. Case-insensitive.",
        "default": "not_found",
        "range_or_options": "'srsegment' 'sringressnodetlv' 'sregressnodetlv' 'sropaquecontainertlv' 'srhmactlv' 'srpadding1tlv' 'srpaddingtlv' 'generaltlv'"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the level/index of the SRv6 header in the stream's header hierarchy. Used when multiple SRv6 headers exist.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Specifies the index within the SRv6 option data structure where modifications should be applied. Typically used when the option contains a list of entries.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Segment",
        "type": "str",
        "description": "IPv6 segment address for the 'srsegment' option.",
        "default": "2000::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "TLV Type field for options like ingress node, egress node, opaque container, HMAC, padding, etc.",
        "default": "varies by option",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "TLV Length field for various TLVs.",
        "default": "varies by option",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Reserved field for various TLVs.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Flags",
        "type": "int",
        "description": "Flag field for various TLVs.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "IngressNode",
        "type": "str",
        "description": "Ingress Node IPv6 address for 'sringressnodetlv'.",
        "default": "2000::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EngressNode",
        "type": "str",
        "description": "Egress Node IPv6 address for 'sregressnodetlv'.",
        "default": "2000::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "OpaqueContainer",
        "type": "str",
        "description": "Opaque Container IPv6 address for 'sropaquecontainertlv'.",
        "default": "2000::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "HmacKeyId",
        "type": "int",
        "description": "HMAC Key ID for 'srhmactlv'.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "hmac",
        "type": "hex",
        "description": "HMAC value for 'srhmactlv'. Must be a 32-byte hexadecimal string.",
        "default": "0000000000000000000000000000000000000000000000000000000000000000",
        "range_or_options": "32-byte hex string"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Padding value for 'srpaddingtlv'. Can be up to 7 bytes.",
        "default": "00",
        "range_or_options": "0-7 byte hex string"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Custom data for 'generaltlv'. Can be up to 1024 bytes.",
        "default": "0102030405060708090A",
        "range_or_options": "0-1024 byte hex string"
      }
    ],
    "description": "Edits specific options of an IPv6 Segment Routing (SRv6) header in a given stream. This function identifies the appropriate SRv6 header based on the Level and then applies the specified Option for editing using the corresponding method. Each option has its own set of parameters that can be passed via keyword arguments (**kwargs).",
    "example": "| Edit Header Ipv6 Sr Option | Stream=${Stream} | Option=generalTLV | Data=FFFFFF"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_echo_request",
    "return_type": "dict",
    "return": "A dictionary mapping the modified field names to their corresponding internal attribute names, indicating which fields were successfully updated. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ICMPv4 Echo Request header needs to be edited. It must have a 'handle' attribute uniquely identifying the stream. If a list is provided, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the ICMPv4 Echo Request header in the header list of the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The value to set for the 'type' field of the ICMPv4 Echo Request header. If None, this field is not modified.",
        "default": "8",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "The value to set for the 'code' field of the ICMPv4 Echo Request header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "The value to set for the 'checksum' field of the ICMPv4 Echo Request header. If None, this field is not modified. Accepts values from '0000' to 'ffff', 'AUTO' (automatically compute checksum), or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "The value to set for the 'identifier' field of the ICMPv4 Echo Request header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "The value to set for the 'sequenceNumber' field of the ICMPv4 Echo Request header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the fields of an ICMPv4 Echo Request header in a specified stream. This function retrieves the ICMPv4 Echo Request headers associated with the given stream and modifies the specified fields at the given level (index) in the header hierarchy. Only the provided parameters are updated; if a parameter is None, the corresponding field remains unchanged.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Icmpv4EchoRequest |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_icmp_echorequest | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_mask_reply",
    "return_type": "dict or False",
    "return": "A dictionary mapping parameter names to their corresponding internal attribute names for all successfully updated fields (e.g., {'Type': 'type', 'Code': 'code'}). Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first element is used. The stream object must have a 'handle' attribute that uniquely identifies the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of ICMP Mask Reply headers found in the stream. This specifies which ICMP Mask Reply header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Value to set for the 'type' field of the ICMP Mask Reply header.",
        "default": "18",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Value to set for the 'code' field of the ICMP Mask Reply header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Value to set for the 'checksum' field of the ICMP Mask Reply header. Can be a hex string between '0000' and 'ffff', 'AUTO' to automatically compute checksum, or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Value to set for the 'identifier' field of the ICMP Mask Reply header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Value to set for the 'sequenceNumber' field of the ICMP Mask Reply header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "AddrMask",
        "type": "int",
        "description": "Value to set for the 'addrMask' field of the ICMP Mask Reply header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Modifies fields of an ICMP Mask Reply header in a specified stream. This function retrieves the list of headers for the provided stream and filters to find ICMP Mask Reply ('icmpmaskreply') headers. The ICMP Mask Reply header at the specified level is then edited with the provided field values. Only fields with non-None values are updated.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Icmpv4MaskReply |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Mask Reply | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_mask_request",
    "return_type": "dict or bool",
    "return": "A dictionary mapping modified field names (as strings) to their corresponding attribute names in the header object if one or more fields were successfully updated. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The test instrument stream object for which the ICMP Mask Request header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element is used as the stream object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMP Mask Request header in the list of such headers within the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The value to set for the 'type' field of the ICMP Mask Request header.",
        "default": "17",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "The value to set for the 'code' field of the ICMP Mask Request header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "The value to set for the 'checksum' field of the ICMP Mask Request header. Can be a hex string between '0000' and 'ffff', 'AUTO' for automatic calculation, or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "The value to set for the 'identifier' field of the ICMP Mask Request header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "The value to set for the 'sequenceNumber' field of the ICMP Mask Request header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "AddrMask",
        "type": "int",
        "description": "The value to set for the 'addrMask' field of the ICMP Mask Request header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Modifies fields of an ICMP Mask Request header in the specified stream. This function retrieves the ICMP Mask Request headers associated with the given stream and modifies the specified fields at the given level (index) in the list of ICMP Mask Request headers. If any field is provided (not None), it updates the corresponding attribute of the header object and records the change in the result dictionary. If no changes are made, it returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Mask Request | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_dest_unreach",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated parameter name to its corresponding internal field name in the ICMP Destination Unreachable header. Returns None if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object or a list containing one stream object. The stream must have a 'handle' attribute representing the traffic template.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which ICMP Destination Unreachable header to modify if multiple exist in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMP message type field.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMP message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the checksum field of the ICMP header. If set to 'AUTO', it will be automatically calculated. If set to 'ffff', it introduces an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Unused",
        "type": "int",
        "description": "Sets the unused field in the destination unreachable message.",
        "default": "3",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Sets the data carried by the ICMP message, should be 8 bytes in hexadecimal format.",
        "default": "0000000000000000",
        "range_or_options": "length=8 bytes"
      },
      {
        "name": "Ipv4HeaderVersion",
        "type": "int",
        "description": "Sets the version field of the encapsulated IPv4 header.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderHeadLen",
        "type": "int",
        "description": "Sets the header length of the encapsulated IPv4 header.",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderTosPrecedence",
        "type": "bit",
        "description": "Sets the precedence part of the TOS byte in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderTosDelay",
        "type": "bit",
        "description": "Sets the delay bit in the TOS field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosThroughput",
        "type": "bit",
        "description": "Sets the throughput bit in the TOS field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReliability",
        "type": "bit",
        "description": "Sets the reliability bit in the TOS field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosMonetaryCost",
        "type": "bit",
        "description": "Sets the monetary cost bit in the TOS field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReserved",
        "type": "bit",
        "description": "Sets the reserved bit in the TOS field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffserveCodePointPrecedence",
        "type": "bit",
        "description": "Sets DSCP code point precedence in the IPv4 header.",
        "default": "000000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveClassSelectorPrecedence",
        "type": "bit",
        "description": "Sets class selector precedence in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderDiffservDscpDrop",
        "type": "bit",
        "description": "Sets drop precedence for DSCP in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderDiffservDscpUndefine",
        "type": "bit",
        "description": "Sets undefined bits in DSCP in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservEcn",
        "type": "bit",
        "description": "Sets Explicit Congestion Notification (ECN) value in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderTosByte",
        "type": "hex",
        "description": "Directly sets the entire TOS byte in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ipv4HeaderTotalLength",
        "type": "int",
        "description": "Sets the total length of the IPv4 packet.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderID",
        "type": "int",
        "description": "Sets the identification field of the IPv4 header.",
        "default": "123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderFlags",
        "type": "bit",
        "description": "Sets the flags field in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderOffset",
        "type": "int",
        "description": "Sets the fragment offset field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Ipv4HeaderTTL",
        "type": "int",
        "description": "Sets the Time To Live (TTL) field in the IPv4 header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderProtocol",
        "type": "int",
        "description": "Sets the protocol field in the IPv4 header.",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderChecksum",
        "type": "hex",
        "description": "Sets the checksum field in the IPv4 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Ipv4HeaderSource",
        "type": "str",
        "description": "Sets the source IP address in the IPv4 header.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderDestination",
        "type": "str",
        "description": "Sets the destination IP address in the IPv4 header.",
        "default": "192.168.0.10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderPadding",
        "type": "hex",
        "description": "Sets padding bytes in the IPv4 header.",
        "default": "000000",
        "range_or_options": "length 0-3 bytes"
      },
      {
        "name": "Ipv4HeaderGateway",
        "type": "str",
        "description": "Sets the gateway IP address in the IPv4 header.",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderHeaderOption",
        "type": "list",
        "description": "Inserts additional options into the IPv4 header. Supported values: EndOfOption, Nop, Security, LooseSourceRoute, StrictSourceRoute, RouterAlert, RecordRoute, TimeStamp, StreamIdentifier, General.",
        "default": "not_found",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      }
    ],
    "description": "Modifies the fields of an ICMP Destination Unreachable (destunreach) header in a given stream. This function retrieves the list of headers associated with the provided stream and filters for headers of type 'destunreach'. It then allows editing of various fields within the specified ICMP Destination Unreachable header at the given level/index. Changes are applied only to the fields that are explicitly provided; all other parameters remain unchanged.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Icmp Dest Unreach | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_echo_reply",
    "return_type": "dict or bool",
    "return": "A dictionary mapping edited parameter names to internal attribute names (e.g., {'Type': 'type'}) if changes were made; returns False if no parameters were provided or modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate or list",
        "description": "测试仪表流量对象，类型为StreamTemplate或仅包含一个StreamTemplate对象的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "要修改的ICMPv4 Echo Reply头部在流模板中的索引位置（序列号）。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "设置ICMP消息的Type字段。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "设置ICMP消息的Code字段。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "设置ICMP头部的校验和字段。可选值为十六进制字符串（如'1234'），'ffff'表示产生错误，'AUTO'表示自动计算。",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "用于匹配请求与回复的标识符字段。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "帮助匹配请求与回复的序列号字段。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "该函数用于修改指定流量模板中某个ICMPv4 Echo Reply报文头部的特定字段内容。支持修改Type、Code、Checksum、Identifier以及SequenceNumber字段，并返回实际被修改字段的映射关系。",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Icmpv4EchoReply |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Echo Reply | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_information_reply",
    "return_type": "dict or False",
    "return": "A dictionary mapping each modified field name (e.g., 'Type', 'Code') to its corresponding attribute name in the header object (e.g., 'type', 'code'). Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the ICMP Information Reply header to be edited. It must have a 'handle' attribute for identification purposes. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMP Information Reply header in the list of such headers within the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the value to set for the ICMP message type field.",
        "default": "16",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Specifies the value to set for the ICMP message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Specifies the value to set for the ICMP checksum field. Can be a hex string (e.g., 'a1b2'), 'AUTO' for automatic calculation, or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Specifies the value to set for the ICMP identifier field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Specifies the value to set for the ICMP sequence number field.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies fields of an ICMP Information Reply header in a specified stream. This function retrieves the ICMP Information Reply headers from the given stream and allows editing of specific fields such as Type, Code, Checksum, Identifier, and Sequence Number. The header to be modified is determined by the 'Level' parameter, which specifies its position in the list of ICMP Information Reply headers associated with the stream.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Information Reply | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_information_request",
    "return_type": "dict or bool",
    "return": "A dictionary mapping parameter names to their updated field names in the ICMP header (e.g., {'Type': 'type', 'Checksum': 'checksum'}) if any changes were made. Returns False if no parameters were provided or no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which ICMP headers will be edited. It must have a 'handle' attribute that uniquely identifies the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMP Information Request header to modify within the stream.",
        "default": "0",
        "range_or_options": "0-N where N is the number of ICMP Information Request headers in the stream."
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The value to set for the 'type' field of the ICMP header.",
        "default": "15",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "The value to set for the 'code' field of the ICMP header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "The value to set for the 'checksum' field of the ICMP header. Can also be 'AUTO' to automatically calculate checksum or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "The value to set for the 'identifier' field of the ICMP header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "The value to set for the 'sequenceNumber' field of the ICMP header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies fields of an ICMP Information Request header in a specified stream. This function retrieves the headers associated with the given stream and filters them to find ICMP Information Request headers. It selects the header at the specified level (index) and updates its fields if corresponding values are provided.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Information Request | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_parameter_problem",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each successfully modified parameter to its internal attribute path if at least one field was updated. Returns False if no modifications were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object associated with the test equipment traffic template that contains the ICMPv4 Parameter Problem header to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which ICMPv4 Parameter Problem header to modify if multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMPv4 Parameter Problem header.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMPv4 Parameter Problem header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the checksum value for the ICMPv4 Parameter Problem header. Can be a hex string (e.g., '1234'), 'AUTO' for automatic calculation, or 'ffff' to simulate an error.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Pointer",
        "type": "int",
        "description": "Sets the pointer field indicating the offset where an error was detected in the original packet.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the unused/reserved field in the ICMPv4 Parameter Problem header.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Sets the data field of the ICMPv4 Parameter Problem header. Must be an 8-byte hexadecimal string.",
        "default": "0000000000000000",
        "range_or_options": "length: 8 bytes"
      },
      {
        "name": "Ipv4HeaderVersion",
        "type": "int",
        "description": "Sets the version field of the encapsulated IPv4 header.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderHeadLen",
        "type": "int",
        "description": "Sets the header length field of the IPv4 header.",
        "default": "<AUTO>5",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderTosPrecedence",
        "type": "bit",
        "description": "Sets the precedence subfield in the TOS byte of the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderTosDelay",
        "type": "bit",
        "description": "Sets the delay subfield in the TOS byte of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosThroughput",
        "type": "bit",
        "description": "Sets the throughput subfield in the TOS byte of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReliability",
        "type": "bit",
        "description": "Sets the reliability subfield in the TOS byte of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosMonetaryCost",
        "type": "bit",
        "description": "Sets the monetary cost subfield in the TOS byte of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReserved",
        "type": "bit",
        "description": "Sets the reserved subfield in the TOS byte of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffserveCodePointPrecedence",
        "type": "bit",
        "description": "Sets the code point precedence in the DSCP field of the TOS byte.",
        "default": "000000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveClassSelectorPrecedence",
        "type": "bit",
        "description": "Sets class selector precedence in the DSCP field of the TOS byte.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderDiffservDscpDrop",
        "type": "bit",
        "description": "Sets drop probability in the DSCP field of the TOS byte.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderDiffservDscpUndefine",
        "type": "bit",
        "description": "Sets undefined bits in the DSCP field of the TOS byte.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservEcn",
        "type": "bit",
        "description": "Sets ECN-related bits in the TOS byte.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderTosByte",
        "type": "hex",
        "description": "Directly sets the entire TOS byte in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ipv4HeaderTotalLength",
        "type": "int",
        "description": "Sets the total length of the IPv4 packet including header and payload.",
        "default": "<AUTO>20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderID",
        "type": "int",
        "description": "Sets the identification field of the IPv4 header used for fragmentation.",
        "default": "<AUTO>123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderFlags",
        "type": "bit",
        "description": "Sets the flags field of the IPv4 header used for fragmentation control.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderOffset",
        "type": "int",
        "description": "Sets the fragment offset field of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Ipv4HeaderTTL",
        "type": "int",
        "description": "Sets the Time To Live (TTL) field of the IPv4 header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderProtocol",
        "type": "int",
        "description": "Sets the protocol field of the IPv4 header indicating the next-level protocol.",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderChecksum",
        "type": "hex",
        "description": "Sets the checksum field of the IPv4 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Ipv4HeaderSource",
        "type": "str",
        "description": "Sets the source IP address in the IPv4 header.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderDestination",
        "type": "str",
        "description": "Sets the destination IP address in the IPv4 header.",
        "default": "192.168.0.10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderPadding",
        "type": "hex",
        "description": "Sets padding data in the IPv4 header. Must be a hex string of length 0-3 bytes.",
        "default": "000000",
        "range_or_options": "length: 0-3 bytes"
      },
      {
        "name": "Ipv4HeaderGateway",
        "type": "str",
        "description": "Sets the gateway address field in the IPv4 header.",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderHeaderOption",
        "type": "list",
        "description": "Inserts or modifies options in the IPv4 header. Supports list values like EndOfOption, Nop, Security, LooseSourceRoute, etc.",
        "default": "not_found",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      }
    ],
    "description": "Edits the fields of an ICMPv4 Parameter Problem header and optionally its encapsulated IPv4 header in a specified stream. This function identifies the appropriate ICMPv4 Parameter Problem header based on the provided level index and updates any specified field(s). Each successfully updated field is recorded in the result dictionary with the input parameter name as the key and the corresponding internal attribute path as the value.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Parameter Problem | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_redirect",
    "return_type": "dict or False",
    "return": "A dictionary mapping successfully modified parameter names to their corresponding internal attribute names in the header object. Returns False if no parameters were updated.",
    "description": "Edits the ICMPv4 Redirect header and its embedded IPv4 header fields for a given stream. This function allows modifying various fields of an ICMP Redirect header and its associated IPv4 header. It selects the appropriate header based on the 'Level' parameter from the list of headers in the stream. Fields that are provided (not None) will be updated in the header object, and the changes are reflected in the system via the underlying header objects.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose ICMP Redirect header needs to be edited. It must have a 'handle' attribute identifying the stream uniquely. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which ICMP Redirect header to modify if multiple such headers exist.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMP message type.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMP message code.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the ICMP checksum value. Values can be hexadecimal (e.g., '0000', 'ffff') or 'AUTO' for automatic calculation.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "GatewayAddress",
        "type": "str",
        "description": "Sets the gateway address in the ICMP Redirect message.",
        "default": "10.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Data",
        "type": "bytes",
        "description": "Sets the header data field as bytes (length must be 8 bytes).",
        "default": "0000000000000000",
        "range_or_options": "8-byte hex string"
      },
      {
        "name": "Ipv4HeaderVersion",
        "type": "int",
        "description": "Sets the IPv4 version field.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderHeadLen",
        "type": "int",
        "description": "Sets the IPv4 header length (header length field).",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderTosPrecedence",
        "type": "int",
        "description": "Sets the ToS precedence sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderTosDelay",
        "type": "int",
        "description": "Sets the ToS delay sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosThroughput",
        "type": "int",
        "description": "Sets the ToS throughput sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReliability",
        "type": "int",
        "description": "Sets the ToS reliability sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosMonetaryCost",
        "type": "int",
        "description": "Sets the ToS monetary cost sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReserved",
        "type": "int",
        "description": "Sets the reserved ToS sub-field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservDscp",
        "type": "int",
        "description": "Sets the Differentiated Services Code Point (DSCP) in the IPv4 header.",
        "default": "0",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveCodePointPrecedence",
        "type": "int",
        "description": "Sets the DSCP code point precedence in the IPv4 header.",
        "default": "0",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveClassSelectorPrecedence",
        "type": "int",
        "description": "Sets the class selector precedence in DSCP.",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderDiffservDscpDrop",
        "type": "int",
        "description": "Sets the drop precedence of the DSCP in the IPv4 header.",
        "default": "0",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderDiffservDscpUndefine",
        "type": "int",
        "description": "Sets undefined bits in the DSCP of the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservEcn",
        "type": "int",
        "description": "Sets the Explicit Congestion Notification (ECN) in the IPv4 header.",
        "default": "0",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderTosByte",
        "type": "int",
        "description": "Sets the entire ToS byte directly in the IPv4 header.",
        "default": "0",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ipv4HeaderTotalLength",
        "type": "int",
        "description": "Sets the total length field in the IPv4 header.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderID",
        "type": "int",
        "description": "Sets the identification field in the IPv4 header.",
        "default": "123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderFlags",
        "type": "int",
        "description": "Sets the flags field in the IPv4 header.",
        "default": "0",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderOffset",
        "type": "int",
        "description": "Sets the fragment offset in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Ipv4HeaderTTL",
        "type": "int",
        "description": "Sets the Time-To-Live (TTL) field in the IPv4 header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderProtocol",
        "type": "int",
        "description": "Sets the protocol field in the IPv4 header.",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderChecksum",
        "type": "hex",
        "description": "Sets the checksum of the IPv4 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Ipv4HeaderSource",
        "type": "str",
        "description": "Sets the source IP address in the IPv4 header.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderDestination",
        "type": "str",
        "description": "Sets the destination IP address in the IPv4 header.",
        "default": "192.168.0.10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderHeaderOption",
        "type": "list or dict",
        "description": "Inserts additional options into the IPv4 header.",
        "default": "not_found",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      },
      {
        "name": "Ipv4HeaderPadding",
        "type": "bytes",
        "description": "Sets padding bytes in the IPv4 header.",
        "default": "000000",
        "range_or_options": "0-3 byte hex string"
      },
      {
        "name": "Ipv4HeaderGateway",
        "type": "str",
        "description": "Sets the gateway IP address in the embedded IPv4 header.",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Redirect | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_source_quench",
    "return_type": "dict or False",
    "return": "A dictionary mapping parameter names to the corresponding internal field names that were modified. Returns False if no parameters were provided (no modifications were made).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object containing the ICMP Source Quench header to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of 'sourcequench' headers associated with the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMP message type field.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMP message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the ICMP checksum value. Valid values: 'AUTO', '0000', 'ffff'.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the reserved field in the ICMP Source Quench message.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Data",
        "type": "bytes or str",
        "description": "Sets the data field in the ICMP header. Must be an 8-byte hexadecimal string.",
        "default": "0000000000000000",
        "range_or_options": "length=8 bytes hex string"
      },
      {
        "name": "Ipv4HeaderVersion",
        "type": "int",
        "description": "Sets the IP version field in the IPv4 header encapsulated within the ICMP message.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderHeadLen",
        "type": "int",
        "description": "Sets the IP header length field in the IPv4 header.",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderTosPrecedence",
        "type": "bit",
        "description": "Sets the ToS precedence bits in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderTosDelay",
        "type": "bit",
        "description": "Sets the ToS delay bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosThroughput",
        "type": "bit",
        "description": "Sets the ToS throughput bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReliability",
        "type": "bit",
        "description": "Sets the ToS reliability bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosMonetaryCost",
        "type": "bit",
        "description": "Sets the ToS monetary cost bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReserved",
        "type": "bit",
        "description": "Sets the reserved ToS bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffserveCodePointPrecedence",
        "type": "bit",
        "description": "Sets the DSCP code point precedence bits.",
        "default": "000000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveClassSelectorPrecedence",
        "type": "bit",
        "description": "Sets the class selector precedence bits.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderDiffservDscpDrop",
        "type": "bit",
        "description": "Sets the drop precedence for DSCP in DiffServ.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderDiffservDscpUndefine",
        "type": "bit",
        "description": "Sets undefined bits in DSCP.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservEcn",
        "type": "bit",
        "description": "Sets ECN (Explicit Congestion Notification) bits.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderTosByte",
        "type": "hex",
        "description": "Sets the full ToS byte directly in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ipv4HeaderTotalLength",
        "type": "int",
        "description": "Sets the total length of the IP packet.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderID",
        "type": "int",
        "description": "Sets the identification field in the IPv4 header.",
        "default": "123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderFlags",
        "type": "bit",
        "description": "Sets the flags in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderOffset",
        "type": "int",
        "description": "Sets the fragment offset in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Ipv4HeaderTTL",
        "type": "int",
        "description": "Sets the Time-to-Live (TTL) value in the IPv4 header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderProtocol",
        "type": "int",
        "description": "Sets the protocol field in the IPv4 header.",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderChecksum",
        "type": "hex",
        "description": "Sets the checksum of the IPv4 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Ipv4HeaderSource",
        "type": "str",
        "description": "Sets the source IP address in the IPv4 header.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderDestination",
        "type": "str",
        "description": "Sets the destination IP address in the IPv4 header.",
        "default": "192.168.0.10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderPadding",
        "type": "bytes or str",
        "description": "Sets padding bytes in the IPv4 header.",
        "default": "000000",
        "range_or_options": "length 0-3 bytes hex string"
      },
      {
        "name": "Ipv4HeaderGateway",
        "type": "str",
        "description": "Sets the gateway address in the IPv4 header.",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderHeaderOption",
        "type": "list",
        "description": "Inserts options into the IPv4 header.",
        "default": "None",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      }
    ],
    "description": "Edits the fields of an ICMP Source Quench header in a given stream at a specified level. This function retrieves the list of headers for the provided stream and filters only those of type 'sourcequench'. It then modifies any of the header fields based on the parameters provided. If no changes are made (i.e., all parameters are None), it returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Source Quench | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_time_exceeded",
    "return_type": "dict or bool",
    "return": "A dictionary mapping parameter names to the actual field names modified in the header. Returns False if no modifications were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose ICMP Time Exceeded header is to be edited. Must have a 'handle' attribute identifying the stream uniquely.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index level of the ICMP Time Exceeded header in the stream's header hierarchy, useful when multiple ICMP headers exist.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMP message type field.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMP message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the ICMP checksum field. Values can be hexadecimal string (e.g., '0000', 'ffff') or 'AUTO' for automatic calculation.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the reserved field in the ICMP Time Exceeded header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "Sets additional data included with the ICMP message. Must be an 8-byte hexadecimal string.",
        "default": "0000000000000000",
        "range_or_options": "length=8 bytes"
      },
      {
        "name": "Ipv4HeaderVersion",
        "type": "int",
        "description": "Sets the version field of the embedded IPv4 header.",
        "default": "4",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderHeadLen",
        "type": "int",
        "description": "Sets the header length field of the embedded IPv4 header.",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "Ipv4HeaderTosPrecedence",
        "type": "bit",
        "description": "Sets the ToS precedence field in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderTosDelay",
        "type": "bit",
        "description": "Sets the ToS delay bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosThroughput",
        "type": "bit",
        "description": "Sets the ToS throughput bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReliability",
        "type": "bit",
        "description": "Sets the ToS reliability bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosMonetaryCost",
        "type": "bit",
        "description": "Sets the ToS monetary cost bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderTosReserved",
        "type": "bit",
        "description": "Sets the reserved ToS bit in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservDscp",
        "type": "int",
        "description": "Sets the DiffServ DSCP value in the IPv4 header.",
        "default": "not_found",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveCodePointPrecedence",
        "type": "bit",
        "description": "Sets the DSCP code point precedence in the IPv4 header.",
        "default": "000000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Ipv4HeaderDiffserveClassSelectorPrecedence",
        "type": "bit",
        "description": "Sets the class selector precedence in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderDiffservDscpDrop",
        "type": "bit",
        "description": "Sets the drop precedence for DSCP in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderDiffservDscpUndefine",
        "type": "bit",
        "description": "Sets undefined bits for DSCP in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Ipv4HeaderDiffservEcn",
        "type": "bit",
        "description": "Sets the ECN settings in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-11"
      },
      {
        "name": "Ipv4HeaderTosByte",
        "type": "hex",
        "description": "Sets the full TOS byte directly in the IPv4 header.",
        "default": "00",
        "range_or_options": "00-FF"
      },
      {
        "name": "Ipv4HeaderTotalLength",
        "type": "int",
        "description": "Sets the total length field in the IPv4 header.",
        "default": "20",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderID",
        "type": "int",
        "description": "Sets the identification field in the IPv4 header.",
        "default": "123",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ipv4HeaderFlags",
        "type": "bit",
        "description": "Sets the flags field in the IPv4 header.",
        "default": "000",
        "range_or_options": "000-111"
      },
      {
        "name": "Ipv4HeaderOffset",
        "type": "int",
        "description": "Sets the fragment offset field in the IPv4 header.",
        "default": "0",
        "range_or_options": "0-8191"
      },
      {
        "name": "Ipv4HeaderTTL",
        "type": "int",
        "description": "Sets the time-to-live (TTL) field in the IPv4 header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderProtocol",
        "type": "int",
        "description": "Sets the protocol field in the IPv4 header.",
        "default": "235",
        "range_or_options": "0-255"
      },
      {
        "name": "Ipv4HeaderChecksum",
        "type": "hex",
        "description": "Sets the checksum field in the IPv4 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Ipv4HeaderSource",
        "type": "str",
        "description": "Sets the source IP address in the IPv4 header.",
        "default": "192.168.0.2",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderDestination",
        "type": "str",
        "description": "Sets the destination IP address in the IPv4 header.",
        "default": "192.168.0.10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderPadding",
        "type": "hex",
        "description": "Sets padding data in the IPv4 header.",
        "default": "000000",
        "range_or_options": "length 0-3 bytes"
      },
      {
        "name": "Ipv4HeaderGateway",
        "type": "str",
        "description": "Sets the gateway address in the IPv4 header (if applicable).",
        "default": "192.168.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4HeaderHeaderOption",
        "type": "list",
        "description": "Inserts options into the IPv4 header.",
        "default": "not_found",
        "range_or_options": "EndOfOption Nop Security LooseSourceRoute StrictSourceRoute RouterAlert RecordRoute TimeStamp StreamIdentifier General"
      }
    ],
    "description": "Edits the fields of an ICMP Time Exceeded header in a specified stream. This function allows modifying various attributes of both the ICMP Time Exceeded message and its encapsulated IPv4 header.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Icmp Time Exceeded | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_time_stamp_reply",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each modified field name to its corresponding attribute in the header object (e.g., {'Type': 'type'}) if any changes were made. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ICMP Timestamp Reply header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'timestampreply' header in the header hierarchy of the stream to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMP message type field. If not None, updates the `type` field of the header.",
        "default": "14",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMP message code field. If not None, updates the `code` field of the header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the checksum value for the ICMP header. If not None, updates the `checksum` field of the header. Accepts hexadecimal values between 0000-ffff or 'AUTO'. 'ffff' means an error is introduced, and 'AUTO' means automatic calculation.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Sets the identifier field used to match requests and replies. If not None, updates the `identifier` field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sets the sequence number field used to match requests and replies. If not None, updates the `sequenceNumber` field of the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OriginateTimestamp",
        "type": "int",
        "description": "Sets the timestamp when the request was originally sent. If not None, updates the `originateTimestamp` field of the header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ReceiveTimestamp",
        "type": "int",
        "description": "Sets the timestamp when the request was received by the responder. If not None, updates the `receiveTimestamp` field of the header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TransmitTimestamp",
        "type": "int",
        "description": "Sets the timestamp when the reply was transmitted. If not None, updates the `transmitTimestamp` field of the header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the fields of an ICMP Timestamp Reply header in a given stream at the specified level. This function retrieves the headers for the provided stream and filters for 'timestampreply' type headers. It then modifies the fields of the ICMP Timestamp Reply header at the specified level (index), if the corresponding parameter is not None. Each modified field is updated in the header object, and the result dictionary tracks which fields were changed and their new values. If no fields are modified, returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Time Stamp Reply | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv4.edit_header_icmp_time_stamp_request",
    "return_type": "Union[dict, bool]",
    "return": "A dictionary mapping the names of modified fields to their corresponding attribute names in the header object, or False if no fields were successfully updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object representing the traffic stream to be edited. It must have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first item will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies which ICMP Timestamp Request header to edit if multiple such headers exist in the stream. Level=0 refers to the first header of this type.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMP Timestamp Request header. Used to specify the ICMP message type.",
        "default": "13",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMP Timestamp Request header. Used to provide further information about the message type.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "str",
        "description": "Sets the 'checksum' field of the ICMP Timestamp Request header. Used for error-checking the header. Valid values include hexadecimal strings from '0000' to 'ffff', and 'AUTO' (for automatic calculation). Using 'ffff' simulates an invalid checksum.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Sets the 'identifier' field, typically used to match requests with replies.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sets the 'sequenceNumber' field, used to help match requests with replies.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "OriginateTimestamp",
        "type": "int",
        "description": "Sets the 'originateTimestamp' field, indicating the time the request was originated (in milliseconds since epoch).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "ReceiveTimestamp",
        "type": "int",
        "description": "Sets the 'receiveTimestamp' field, indicating the time the request was received (in milliseconds since epoch).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TransmitTimestamp",
        "type": "int",
        "description": "Sets the 'transmitTimestamp' field, indicating the time the request was transmitted (in milliseconds since epoch).",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the fields of an ICMP Timestamp Request header in a specified stream. This function allows updating one or more fields of the ICMP Timestamp Request header at a given level in the stream's header hierarchy. The function retrieves the list of headers for the provided stream using `get_stream_header`, filters to find only those of type 'timestamprequest', and selects the header at the specified `Level`. If any field (e.g., Type, Code, Identifier) is provided, it updates the corresponding attribute of the header. Each successfully updated field is recorded in the result dictionary with the field name as the key and the actual attribute name (as used in the object model) as the value. If no fields are successfully updated, the function returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmp Time Stamp Request | Stream=${Stream} | Level=0 | Identifier=100 | SequenceNumber=200 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_destination_unreachable",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping each successfully updated parameter name to its corresponding attribute path in the header object (e.g., {'Type': 'type'}). Returns False if no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object whose headers are to be edited. Expected to have a 'handle' attribute identifying the stream uniquely. Can also be a list, in which case the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'destinationunreachable' header in the filtered list to be edited.",
        "default": "0",
        "range_or_options": "0-N where N is number of DestinationUnreachable headers present"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMPv6 Destination Unreachable header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMPv6 Destination Unreachable header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the 'checksum' field of the ICMPv6 Destination Unreachable header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the 'reserve' field of the ICMPv6 Destination Unreachable header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HeaderData",
        "type": "bytes or str",
        "description": "Sets the 'headerData' payload of the ICMPv6 Destination Unreachable header. Typically represents the embedded IPv6 packet data.",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal string"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the 'version' field of the embedded IPv6 header.",
        "default": "6",
        "range_or_options": "0-15"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Sets the 'trafficClass' field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "Sets the 'FlowLabel' field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "Sets the 'payloadLength' field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Sets the 'nextHeader' field of the embedded IPv6 header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "HopLimit",
        "type": "int",
        "description": "Sets the 'hopLimit' field of the embedded IPv6 header.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "Sets the 'source' IPv6 address in the embedded IPv6 header.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "Sets the 'destination' IPv6 address in the embedded IPv6 header.",
        "default": "2001::1:f1:11",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Sets the 'gateway' IPv6 address in the embedded IPv6 header.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Destination Unreachable header in a specified stream. This function retrieves the list of headers for the given stream and filters only those of type 'destinationunreachable'. It then allows editing of various fields of the ICMPv6 Destination Unreachable header at the specified level. If any field is provided (not None), it updates the corresponding attribute of the header object and records the change in the result dictionary.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv6 | DestinationUnreachable |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Icmpv6 Destination Unreachable | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_echo_reply",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping the modified parameter names to their corresponding attribute names in the ICMPv6 Echo Reply header (e.g., {'Type': 'type', 'Identifier': 'identifier'}) if changes were made. Returns False if no changes were applied.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ICMPv6 Echo Reply header needs to be edited. It must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element is used as the stream object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMPv6 Echo Reply header in the stream's header list to edit.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMPv6 Echo Reply header.",
        "default": "129",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMPv6 Echo Reply header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the 'checksum' field of the ICMPv6 Echo Reply header in hexadecimal format.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Sets the 'identifier' field of the ICMPv6 Echo Reply header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Sets the 'sequenceNumber' field of the ICMPv6 Echo Reply header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Echo Reply header in a given stream at the specified level. Any provided non-None parameter will update the corresponding field in the header. The function returns a dictionary mapping the updated parameter names to their respective attribute names in the header object. If no parameters are provided (i.e., no changes are made), the function returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Icmpv6EchoReply |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Echo Reply | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_echo_request",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the modified parameter names to their corresponding attribute names in the ICMPv6 Echo Request header object (e.g., {'Type': 'type'}) if modifications were made. If no parameters were provided, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the ICMPv6 Echo Request header. Must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMPv6 Echo Request header in the header chain to be edited.",
        "default": "0",
        "range_or_options": "0 - number_of_icmpv6_echo_request_headers - 1"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the value for the 'Type' field of the ICMPv6 Echo Request header.",
        "default": "128",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Specifies the value for the 'Code' field of the ICMPv6 Echo Request header.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Specifies the value for the 'Checksum' field of the ICMPv6 Echo Request header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Identifier",
        "type": "int",
        "description": "Specifies the value for the 'Identifier' field used to match echo requests with replies.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Specifies the value for the 'Sequence Number' field used to help match echo requests with replies.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies specific fields of an ICMPv6 Echo Request header in a given stream. This function retrieves the ICMPv6 Echo Request headers associated with the provided stream and allows editing one or more of its fields (Type, Code, Checksum, Identifier, Sequence Number) at a specified level in the header chain. The changes are applied only if values are provided. Only modified fields are updated.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Icmpv6EchoRequest |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Echo Request | Stream=${Stream} | Level=0 | Identifier=100 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_mldv1_done",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each updated parameter name to the corresponding attribute in the header object if one or more fields were successfully updated. Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object containing the Icmpv6 Mldv1 Done header. Must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the Icmpv6 Mldv1 Done header in the list of headers of the stream to be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMPv6 header.",
        "default": "132",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum value for the ICMPv6 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "MaxRespDelay",
        "type": "int",
        "description": "Sets the maximum response delay for the MLDv1 Done message.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Sets the reserved field in the MLDv1 Done message.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MulticastAddress",
        "type": "str",
        "description": "Sets the multicast address field in the MLDv1 Done message.",
        "default": "FF1E::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Edits the fields of an ICMPv6 MLDv1 Done header within the specified stream. This function allows configuration of various fields such as Type, Code, Checksum, Max Response Delay, Reserved, and Multicast Address. It selects the appropriate header based on the provided Level index and updates only the provided fields. If any fields are successfully updated, it returns a dictionary mapping the parameter names to their corresponding internal attribute names; otherwise, it returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv1Done |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv1 Done | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_mldv1_query",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping updated field names to their corresponding attribute names in the header object if one or more updates were successful. Returns False if no parameter was provided for update.",
    "description": "Modifies fields of an ICMPv6 MLDv1 Query header in a specified stream. Only provided parameters are updated. This function retrieves the list of headers for the given stream and filters for 'mldv1query' type headers. It then updates the specified fields of the header at the given level (index).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is passed, the first element is used. The stream must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'mldv1query' header in the header chain of the stream to be edited. Useful when multiple headers of the same type exist in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The value to set for the 'type' field of the MLDv1 Query header.",
        "default": "130",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "The value to set for the 'code' field of the MLDv1 Query header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "The value to set for the 'checksum' field of the MLDv1 Query header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "MaxRespDelay",
        "type": "int",
        "description": "The value to set for the 'maxRespDelay' field of the MLDv1 Query header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "The value to set for the 'reserved' field of the MLDv1 Query header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MulticastAddress",
        "type": "str",
        "description": "The value to set for the 'multicastAddress' field of the MLDv1 Query header.",
        "default": "::",
        "range_or_options": "有效的ipv6地址"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv1Query |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv1 Query | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_mldv1_report",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping updated field names to their internal attribute names if changes were successfully applied. Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object that contains the headers. It must have a 'handle' attribute used to uniquely identify the stream in the system. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'mldv1report' header in the header list to edit. Defaults to 0 if not provided.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Value to set for the 'type' field of the MLDv1 Report header.",
        "default": "131",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Value to set for the 'code' field of the MLDv1 Report header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Value to set for the 'checksum' field of the MLDv1 Report header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "MaxRespDelay",
        "type": "int",
        "description": "Value to set for the 'maxRespDelay' field of the MLDv1 Report header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Value to set for the 'reserved' field of the MLDv1 Report header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MulticastAddress",
        "type": "str",
        "description": "Value to set for the 'multicastAddress' field of the MLDv1 Report header.",
        "default": "FF1E::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Edits the fields of an ICMPv6 MLDv1 Report header in a specified stream. This function retrieves the list of headers associated with the given stream and filters for headers of type 'mldv1report'. It then allows editing one or more fields of the ICMPv6 MLDv1 Report header at the specified level (index) in the header chain. If any field is provided (not None), it updates the corresponding attribute of the header and records the change in the result dictionary. If no changes are made, the function returns False.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv1Report |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Icmpv6 Mldv1 Report | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_mldv2_query",
    "return_type": "dict or bool",
    "return": "A dictionary mapping parameter names to the corresponding modified attribute names in the header object, e.g., {'Type': 'type', 'GroupAddress': 'groupAddress'}. If no modifications are made (no parameters provided), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ICMPv6 MLDv2 Query header needs to be edited. Must contain a unique identifier (handle).",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index level of the MLDv2 Query header in the stream's header chain. Used when multiple such headers exist.",
        "default": "0",
        "range_or_options": "0-10 (or more depending on the number of headers)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the Type field of the ICMPv6 header.",
        "default": "130",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the Code field of the ICMPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the Checksum value for the header. Hexadecimal format.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "MaxRespCode",
        "type": "int",
        "description": "Maximum Response Delay Code indicating maximum time before response.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Reserved field; typically must be zero unless specified otherwise.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "Multicast group address associated with the query.",
        "default": "FF1E::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Resv",
        "type": "int",
        "description": "Reserved bits within the MLDv2 Query header (4 bits).",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "Sflag",
        "type": "bit",
        "description": "Suppress Router-Side Processing flag. When set, suppresses responses.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Qrv",
        "type": "bit",
        "description": "Querier's Robustness Variable (QRV) indicating querier robustness.",
        "default": "000",
        "range_or_options": "000 001 010 011 100 101 110 111"
      },
      {
        "name": "Qqic",
        "type": "int",
        "description": "Querier's Query Interval Code (QQIC) used to determine query interval.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumberOfSources",
        "type": "int",
        "description": "Number of source addresses included in the query.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "SourceAddressList",
        "type": "list",
        "description": "List of valid IPv6 addresses representing source addresses in the query.",
        "default": "[2000::1]",
        "range_or_options": "valid IPv6 address list, max length: 1000"
      }
    ],
    "description": "Modifies fields of an ICMPv6 MLDv2 Query header in a specified stream. Only the provided (non-default) parameters are updated. The function retrieves the corresponding header via `get_stream_header` and modifies its attributes accordingly.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv2Query |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv2 Query | Stream=${Stream} | Level=0 | Code=1"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_mldv2_report",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping parameter names to their corresponding internal attribute names indicating which fields were successfully updated. Returns False if no changes were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing one) whose ICMPv6 MLDv2 Report header needs to be edited. The stream must have a 'handle' attribute used to identify it uniquely in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which MLDv2 Report header to edit if multiple such headers exist in the stream's header chain.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Value to set for the 'type' field of the MLDv2 Report header. If None, this field remains unchanged.",
        "default": "143",
        "range_or_options": "0-255"
      },
      {
        "name": "Unused",
        "type": "int",
        "description": "Value to set for the 'unused' field of the header. If None, this field remains unchanged.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Value to set for the 'checksum' field of the header. If None, this field remains unchanged.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Value to set for the 'reserved' field of the header (mapped internally as 'reserved2'). If None, this field remains unchanged.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NumberOfGroupRecords",
        "type": "int",
        "description": "Value to set for the 'numberOfGroupRecords' field of the header. If None, this field remains unchanged.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the fields of an ICMPv6 MLDv2 Report header in a given stream. This function allows modification of specific fields of an ICMPv6 MLDv2 Report header at a specified level within a stream's header hierarchy. If a field value is provided, it updates the corresponding attribute of the header object and records the change in the result dictionary.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv2Report |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv2 Report | Stream=${Stream} | Level=0 | Type=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_group_records",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the edit operation if successful, otherwise False if no changes were made or the operation failed.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list of stream objects. If a list is provided, only the first stream is considered. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the filtered list of headers of type `Header`. This determines which instance of the header type to modify.",
        "default": "0",
        "range_or_options": "0-n (where n depends on number of matching headers)"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the group record within the selected header to be edited.",
        "default": "0",
        "range_or_options": "0-n (where n depends on number of group records)"
      },
      {
        "name": "Header",
        "type": "str",
        "description": "The type of header to filter for when searching among the stream's headers. Only headers of this type will be considered.",
        "default": "'mldv2report'",
        "range_or_options": "mldv2report"
      }
    ],
    "kwargs": [
      {
        "name": "RecordType",
        "type": "int",
        "description": "MLDv2 Record Type value to set.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "AuxDataLen",
        "type": "int",
        "description": "Length of auxiliary data associated with the group record.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumberOfSources",
        "type": "int",
        "description": "Number of source addresses included in the group record.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MulticastAddress",
        "type": "str",
        "description": "IPv6 multicast address associated with the group record.",
        "default": "'FF1E::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "SourceAddressList",
        "type": "list",
        "description": "List of IPv6 source addresses associated with the group record.",
        "default": "['2000::1']",
        "range_or_options": "list of valid IPv6 addresses, length 0-1000"
      }
    ],
    "description": "Edits a specific ICMPv6 group record within a stream's header hierarchy. This function targets a particular header of the specified type (e.g., 'mldv2report') at a given level in the header chain and modifies the group record at the provided index using the supplied keyword arguments. Internally, it retrieves the list of headers for the given stream, filters them to only include those matching the specified `Header` type, selects the header at the given `Level`, and then calls `editMldv2GroupRecord` on that header object with the provided `Index` and any additional parameters in `kwargs`.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv2Report |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Icmpv6 Mldv2 Report | Stream=${Stream} | Level=0 | Type=1 |\n| Edit Header Icmpv6 Group Records | Stream=${Stream} | recordType=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_packet_too_big",
    "return_type": "dict or False",
    "return": "A dictionary mapping each successfully modified field name to its internal attribute name in the header object. Returns `False` if no modifications were made.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the ICMPv6 'Packet Too Big' header is to be modified. Must have a 'handle' attribute that uniquely identifies the stream. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the 'packettoobig' header in the header chain of the stream to modify. Useful when multiple headers of the same type exist.",
        "default": "0",
        "range_or_options": "0-n (depending on number of such headers)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMPv6 message type field.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMPv6 message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum field of the ICMPv6 message.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "Sets the MTU value included in the ICMPv6 'Packet Too Big' message.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HeaderData",
        "type": "hex",
        "description": "Sets the raw header data (used to define complex or custom header content). Expected length: 8 bytes.",
        "default": "0000000000000000",
        "range_or_options": "Hex string of exactly 8 bytes"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version field of the embedded IPv6 header.",
        "default": "6",
        "range_or_options": "0-15"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Sets the traffic class field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "Sets the flow label field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "Sets the payload length field of the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Sets the next header field of the embedded IPv6 header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "HopLimit",
        "type": "int",
        "description": "Sets the hop limit field of the embedded IPv6 header.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "Sets the source IPv6 address in the embedded IPv6 header.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "Sets the destination IPv6 address in the embedded IPv6 header.",
        "default": "2001::1:f1:11",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Sets the gateway IPv6 address in the embedded IPv6 header.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Modifies the fields of an ICMPv6 'Packet Too Big' header in a specified stream. This function allows editing various attributes of the ICMPv6 Packet Too Big message and its encapsulated IPv6 header. It retrieves the headers associated with the provided stream, filters for 'packettoobig' type headers, and selects the header at the specified level. If any optional parameters are provided, the corresponding field in the header is updated.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | PacketTooBig |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Packet Too Big | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_parameter_problem",
    "return_type": "dict or False",
    "return": "A dictionary mapping each successfully updated parameter name to its corresponding internal attribute path. Returns `False` if no parameters were successfully updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object (first element will be used). Must have a 'handle' attribute for identification in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the ICMPv6 Parameter Problem header in the list of headers for the stream.",
        "default": "0",
        "range_or_options": "0 - (number of ICMPv6 Parameter Problem headers - 1)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMPv6 message type field.",
        "default": "4",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMPv6 message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "int",
        "description": "Sets the checksum value for the ICMPv6 header.",
        "default": "not_found",
        "range_or_options": "0-65535"
      },
      {
        "name": "Pointer",
        "type": "int or hex",
        "description": "Sets the pointer field indicating the offset of the error in the original packet.",
        "default": "0",
        "range_or_options": "0x00000000 - 0xFFFFFFFF"
      },
      {
        "name": "HeaderData",
        "type": "bytes or str",
        "description": "Sets raw data for the embedded IPv6 header, typically as a hexadecimal string or bytes.",
        "default": "0000000000000000",
        "range_or_options": "8-byte hexadecimal string"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version field in the embedded IPv6 header.",
        "default": "6",
        "range_or_options": "0-15"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "Sets the traffic class field in the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "Sets the flow label field in the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "Sets the payload length field in the embedded IPv6 header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "Sets the next header field in the embedded IPv6 header.",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "HopLimit",
        "type": "int",
        "description": "Sets the hop limit field in the embedded IPv6 header.",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "Sets the source IPv6 address in the embedded IPv6 header.",
        "default": "2001::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "Sets the destination IPv6 address in the embedded IPv6 header.",
        "default": "2001::1:f1:11",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "Sets the gateway IPv6 address in the embedded IPv6 header.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Parameter Problem header in a given stream at the specified level. This function supports modifying both ICMPv6-specific fields and embedded IPv6 header fields. It retrieves the ICMPv6 Parameter Problem headers associated with the provided stream, selects the header at the specified index, and updates its attributes if corresponding values are provided.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Icmpv6ParameterProblem |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Parameter Problem | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_time_exceed",
    "return_type": "dict or bool",
    "return": "A dictionary mapping edited parameter names to the corresponding attribute names in the header object. Returns False if no parameters were provided for modification.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "Either a single stream object or a list containing one stream object. The stream object must have a 'handle' attribute used to identify it in the system when querying for headers.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the ICMPv6 Time Exceeded header in the list of headers of that type within the stream.",
        "default": "0",
        "range_or_options": "0-n (where n is the number of ICMPv6 Time Exceeded headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Value to set the 'type' field of the ICMPv6 Time Exceeded header.",
        "default": "3",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Value to set the 'code' field of the ICMPv6 Time Exceeded header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Value to set the 'checksum' field of the ICMPv6 Time Exceeded header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Value to set the 'reserve' field (reserved data) of the ICMPv6 Time Exceeded header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Modifies fields of an ICMPv6 Time Exceeded header in a specified stream. This function allows editing specific fields such as Type, Code, Checksum, and Reserved data in the ICMPv6 Time Exceeded header. If any of the optional parameters are provided, their values are assigned to the corresponding attributes of the selected header object.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | TimeExceed |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Time Exceed | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_router_solicitation",
    "return_type": "dict",
    "return": "A dictionary mapping the successfully modified field names (like 'Type', 'Code', etc.) to their internal attribute representations (like 'type', 'code', etc.).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, the first item is used. Must have a 'handle' attribute for internal processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the ICMPv6 Router Solicitation header in the list of headers of the stream. Use 0 for the first occurrence, 1 for the second, etc.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'Type' field of the ICMPv6 Router Solicitation header.",
        "default": "133",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'Code' field of the ICMPv6 Router Solicitation header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the 'Checksum' field of the ICMPv6 Router Solicitation header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the 'Reserved' field of the ICMPv6 Router Solicitation header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HeaderOption",
        "type": "object or str",
        "description": "An option header to be inserted into the ICMPv6 Router Solicitation header. If provided, it alters the structure of the header by inserting the new option.",
        "default": "\"\"",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Router Solicitation header in a specified stream. This function retrieves the ICMPv6 Router Solicitation headers from the given stream and modifies the specified fields (Type, Code, Checksum, Reserve, or HeaderOption) of the header at the given level. Any modified field is updated in the corresponding header object, and a dictionary of successfully updated fields is returned.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | routersolicit |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Router Solicitation | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_header_option",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the edit operation, including updated field values. If the operation fails, returns False.",
    "description": "Edits a specific ICMPv6 header option in the given stream object. This function supports editing various types of ICMPv6 options like link-layer addresses, prefix information, MTU, etc., depending on the specified `Option`. It modifies the configuration of the ICMPv6 header within the stream and supports multiple ICMPv6 header types (e.g., routersolicit, neighboradvertise).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or list containing one stream object. Only the first element is used if it's a list. Must have a 'handle' attribute for internal processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Option",
        "type": "string",
        "description": "The type of ICMPv6 header option to be edited. Valid values are: OptionSourceLinkLayerAddress, OptionTargetLinkLayerAddress, OptionPrefixInformation, OptionMTU, GeneralTLV.",
        "default": "not_found",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index level of the ICMPv6 header in the stream’s header hierarchy. Used to locate nested headers.",
        "default": "0",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index within the ICMPv6 header where the option should be modified. Used when multiple entries exist.",
        "default": "0",
        "range_or_options": "0-2147483647"
      },
      {
        "name": "Header",
        "type": "str",
        "description": "Specifies the type of ICMPv6 header being edited. Determines whether to use `editHeaderOption` or `editLinkLayerOption`. Default is 'routersolicit'. Supported values include: routersolicit, routeradvertise, icmpv6redirect, neighborsolicit, neighboradvertise.",
        "default": "'routersolicit'",
        "range_or_options": "routersolicit routeradvertise icmpv6redirect neighborsolicit neighboradvertise"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Option Type value for the ICMPv6 header option.",
        "default": "1 (for OptionSourceLinkLayerAddress), 2 (for OptionTargetLinkLayerAddress), 3 (for OptionPrefixInformation), 5 (for OptionMTU), 0 (for GeneralTLV)",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Length of the option data in bytes. For auto-calculation, default may be <AUTO>.",
        "default": "1 (for most), 2 (for GeneralTLV)",
        "range_or_options": "0-255"
      },
      {
        "name": "Address",
        "type": "str",
        "description": "Link-Layer Address (MAC address) for link-layer options.",
        "default": "00:00:00:12:30:10",
        "range_or_options": "valid MAC address format"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Length of the IPv6 prefix in bits.",
        "default": "64",
        "range_or_options": "0-255"
      },
      {
        "name": "OnLinkFlag",
        "type": "bit",
        "description": "Flag indicating whether the prefix can be used for on-link determination.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "AutonomousFlag",
        "type": "bit",
        "description": "Flag indicating whether the prefix can be used for stateless address autoconfiguration.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "Reserved bits with default value.",
        "default": "000000",
        "range_or_options": "000000 111111"
      },
      {
        "name": "ValidLifetime",
        "type": "int",
        "description": "Time (in seconds) that the prefix is valid for routing.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PreferredLifetime",
        "type": "int",
        "description": "Time (in seconds) that addresses formed from the prefix remain preferred.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "Additional reserved field.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixAddress",
        "type": "str",
        "description": "IPv6 prefix address.",
        "default": "2001::0",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Reserved3",
        "type": "int",
        "description": "Reserved field for OptionMTU.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "Maximum Transmission Unit (MTU) value for the path.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "Hexadecimal value for GeneralTLV option.",
        "default": "\"\"",
        "range_or_options": "0-40 bytes hex string"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv2Report |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv2 Report | Stream=${Stream} | Level=0 | Type=1 |\n    | Edit Header Icmpv6 Group Records | Stream=${Stream} | recordType=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_router_advertise",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding internal attribute name in the header object. For example: {'Type': 'type', 'CurHopLimit': 'curHopLimit'}, etc.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one) to modify. The stream must have a unique 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the ICMPv6 Router Advertisement header to modify if multiple exist. Defaults to 0.",
        "default": "0",
        "range_or_options": "0 - number_of_routeradvertise_headers - 1"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the ICMPv6 message type field. Typically fixed for Router Advertisement messages.",
        "default": "134",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the ICMPv6 message code field. Usually fixed for Router Advertisement messages.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "int",
        "description": "Sets the checksum field of the ICMPv6 Router Advertisement header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "CurHopLimit",
        "type": "int",
        "description": "Sets the current hop limit field, indicating the default hop limit for outgoing packets.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "ManagedAddrFlag",
        "type": "bool",
        "description": "If True, indicates that addresses are available via DHCPv6.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "OtherConfigFlag",
        "type": "bool",
        "description": "If True, indicates that additional configuration information is available via DHCPv6.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Sets the reserved field, which should typically be zero unless defined otherwise by extensions.",
        "default": "0",
        "range_or_options": "0-63"
      },
      {
        "name": "RouterLifetime",
        "type": "int",
        "description": "Sets the router lifetime in seconds, indicating how long this router should be considered the default router.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ReachableTime",
        "type": "int",
        "description": "Sets the reachable time field, indicating the time a node assumes a neighbor is reachable after receiving a reachability confirmation.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "RetransTime",
        "type": "int",
        "description": "Sets the retransmission time field, indicating the time between retransmissions of Neighbor Solicitation messages.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HeaderOption",
        "type": "object",
        "description": "A header option object to insert into the ICMPv6 Router Advertisement header.",
        "default": "None",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      }
    ],
    "description": "Modifies the fields of an ICMPv6 Router Advertisement header in a given stream at the specified level. This function retrieves the list of headers for the provided stream and filters only those of type 'routeradvertise'. It then selects the header at the specified 'Level' index and updates its attributes based on the provided non-None parameters. If a new header option is provided, it is inserted into the selected header.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | routeradvertise |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Router Advertise | Stream=${Stream} | Level=0 | Code=1 | CurHopLimit=64"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_redirect",
    "return_type": "dict",
    "return": "A dictionary mapping the modified field names (keys) to their corresponding internal attribute names in the ICMPv6 Redirect header object. If no fields are modified, an empty dictionary is returned.",
    "description": "Edits the fields of an ICMPv6 Redirect header in a specified stream. This function modifies specific fields of an existing ICMPv6 Redirect packet header within a given stream object at a specified level. Each provided field (non-None) will be updated in the header, and all modifications are tracked and returned.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The test instrument stream object for which the ICMPv6 Redirect header is to be edited. It must have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the ICMPv6 Redirect header in the stream to be edited. Level=0 refers to the first ICMPv6 Redirect header in the stream.",
        "default": "0",
        "range_or_options": "0-N (number of ICMPv6 Redirect headers present in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the 'type' field of the ICMPv6 Redirect header.",
        "default": "137",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Sets the 'code' field of the ICMPv6 Redirect header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the 'checksum' field of the ICMPv6 Redirect header as a hexadecimal value.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Sets the 'reserved' field of the ICMPv6 Redirect header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TargetAddress",
        "type": "str",
        "description": "Sets the 'target address' field of the ICMPv6 Redirect header. Must be a valid IPv6 address.",
        "default": "2001::1:f1:11",
        "range_or_options": "有效的ipv6地址"
      },
      {
        "name": "DestAddress",
        "type": "str",
        "description": "Sets the 'destination address' field of the ICMPv6 Redirect header. Must be a valid IPv6 address.",
        "default": "2001::1:f1:11",
        "range_or_options": "有效的ipv6地址"
      },
      {
        "name": "HeaderOption",
        "type": "list",
        "description": "Inserts a link-layer option into the ICMPv6 Redirect header. Supported options include OptionSourceLinkLayerAddress, OptionTargetLinkLayerAddress, OptionPrefixInformation, OptionMTU, GeneralTLV.",
        "default": "\"\"",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      },
      {
        "name": "RedirectedHdrOption",
        "type": "int",
        "description": "Specifies the number of redirect headers to insert into the ICMPv6 Redirect header using insertRedirectorOption method.",
        "default": "not_found",
        "range_or_options": "0-1"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Icmpv6Redirect |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Redirect | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_redirected_header",
    "return_type": "dict",
    "return": "A dictionary containing the updated ICMPv6 Redirected Header fields such as Type, Code, Checksum, Version, Source, Destination, etc. Returns an empty dictionary if the operation succeeds. If no matching header is found or the operation fails, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象，必须包含唯一标识流的 'handle' 属性。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "用于选择在多个ICMPv6 Redirected头部中的第几个进行操作。适用于多层嵌套结构。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "用于指定ICMPv6 Redirected头部内部要修改的具体选项或字段索引。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Header",
        "type": "str",
        "description": "要编辑的头部类型名称，用于过滤出目标ICMPv6 Redirected头部。",
        "default": "'icmpv6redirect'",
        "range_or_options": "icmpv6redirect"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Option Type 字段值。",
        "default": "4",
        "range_or_options": "1 2 3 4 5"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Option Length 字段值。",
        "default": "4",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "保留字段1。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "保留字段2。",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "数据字段，8字节十六进制字符串。",
        "default": "'0000000000000000'",
        "range_or_options": "8-byte hex string"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "IPv6报头中的版本号。",
        "default": "6",
        "range_or_options": "0-15"
      },
      {
        "name": "TrafficClass",
        "type": "int",
        "description": "IPv6报头中的流量类别字段。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "IPv6报头中的流标签字段。",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "PayloadLength",
        "type": "int",
        "description": "IPv6报头中有效载荷长度。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NextHeader",
        "type": "int",
        "description": "IPv6报头中的下一个头部协议编号。",
        "default": "59",
        "range_or_options": "0-255"
      },
      {
        "name": "HopLimit",
        "type": "int",
        "description": "IPv6报头中的跳数限制字段。",
        "default": "255",
        "range_or_options": "0-255"
      },
      {
        "name": "Source",
        "type": "str",
        "description": "IPv6源地址。",
        "default": "'2001::2'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Destination",
        "type": "str",
        "description": "IPv6目标地址。",
        "default": "'2001::1:f1:11'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Gateway",
        "type": "str",
        "description": "网关地址。",
        "default": "'2001::1'",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "该函数用于修改测试仪表流量模板中某个特定的ICMPv6 Redirected报文头部内容。它允许通过层级（Level）和字段索引（Index）来定位具体要修改的选项，并支持对IPv6头部字段以及扩展选项字段的设置。",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Mldv2Report |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Mldv2 Report | Stream=${Stream} | Level=0 | Type=1 |\n    | Edit Header Icmpv6 Redirected Header | Stream=${Stream} | type=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_neighbor_advertise",
    "return_type": "dict",
    "return": "A dictionary mapping input parameter names to the actual attribute names of the ICMPv6 Neighbor Advertisement header that were modified. For example: {'Type': 'type', 'Code': 'code'}. Returns False if modification fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is passed, only the first element is used. It must have a 'handle' attribute that uniquely identifies the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index (level) of the 'NeighborAdvertise' header in the stream's header list to be edited.",
        "default": "0",
        "range_or_options": "0-N (where N is the number of ICMPv6 Neighbor Advertise headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the type of the ICMPv6 message.",
        "default": "136",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Specifies the code field of the ICMPv6 message.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "The checksum value for the ICMPv6 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Rflag",
        "type": "bit",
        "description": "Router flag; if set, indicates that the sender is a router.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Sflag",
        "type": "bit",
        "description": "Solicited flag; if set, indicates that the advertisement was sent in response to a Neighbor Solicitation.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Oflag",
        "type": "bit",
        "description": "Override flag; if set, indicates that the advertisement should override previous entries.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Reserved field (must be zero unless otherwise specified).",
        "default": "0",
        "range_or_options": "0-536870911"
      },
      {
        "name": "TargetAddress",
        "type": "str",
        "description": "IPv6 address of the target being advertised.",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "HeaderOption",
        "type": "list",
        "description": "List of options to insert into the Neighbor Advertisement header.",
        "default": "\"\"",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Neighbor Advertisement header at a specific level in a given stream. This function allows users to modify various attributes of the ICMPv6 Neighbor Advertisement packet such as Type, Code, Checksum, Flags, Reserved field, and Target Address. Optionally, it can also insert new header options into the packet.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | NeighborAdvertise |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Neighbor Advertise | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.icmpv6.edit_header_icmpv6_neighbor_solicitation",
    "return_type": "dict",
    "return": "A dictionary mapping the modified field names to their internal attribute names (e.g., {'Type': 'type'}). Returns None if no fields are modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, the first element will be used. Must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the ICMPv6 Neighbor Solicitation header to edit when multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the new value for the ICMPv6 message type field.",
        "default": "135",
        "range_or_options": "0-255"
      },
      {
        "name": "Code",
        "type": "int",
        "description": "Specifies the new value for the ICMPv6 message code field.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Specifies the new value for the checksum field of the ICMPv6 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Reserve",
        "type": "int",
        "description": "Specifies the new value for the reserved field in the Neighbor Solicitation header.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "TargetAddress",
        "type": "str",
        "description": "Specifies the new IPv6 address that is being inquired about (target address).",
        "default": "2001::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "HeaderOption",
        "type": "list",
        "description": "Specifies an ICMPv6 header option to be inserted into the Neighbor Solicitation header.",
        "default": "",
        "range_or_options": "OptionSourceLinkLayerAddress OptionTargetLinkLayerAddress OptionPrefixInformation OptionMTU GeneralTLV"
      }
    ],
    "description": "Edits the fields of an ICMPv6 Neighbor Solicitation header in a specified stream. This function allows modification of various fields including Type, Code, Checksum, Reserve, TargetAddress, and insertion of HeaderOptions. If the stream contains multiple ICMPv6 Neighbor Solicitation headers, the Level parameter selects which one to modify.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | NeighborSolicitation |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Icmpv6 Neighbor Solicitation | Stream=${Stream} | Level=0 | Code=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv1_report",
    "return_type": "dict or False",
    "return": "Returns a dictionary indicating which fields were modified and their corresponding attributes in the IGMPv1 header object (e.g., {'Type': 'type', 'GroupAddress': 'groupAddress'}). If no fields were modified (i.e., all provided parameters were None), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list of object",
        "description": "The stream object or a list containing a single stream object. The stream must have been previously created and must contain an IGMPv1 Report header at the specified Level. If a list is passed, only the first element is used. The stream object must have a 'handle' attribute to be uniquely identified by the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IGMPv1 Report header in the stream's header hierarchy to modify. Useful when multiple IGMPv1 headers exist in the same stream. Must be within valid range based on current stream configuration.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Sets the 'Type' field of the IGMPv1 Report header. This is typically used to specify the IGMP message type (e.g., membership report). If not provided, this field remains unchanged.",
        "default": "12",
        "range_or_options": "00-FF"
      },
      {
        "name": "Unused",
        "type": "int",
        "description": "Sets the 'Unused' field of the IGMPv1 Report header. Reserved for future use; if not provided, defaults to 0.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex or str",
        "description": "Sets the checksum value of the IGMPv1 Report header. Can be a hexadecimal string (e.g., 'abcd'), 'AUTO' for automatic calculation, or 'ffff' to simulate an error condition. If not provided, this field remains unchanged.",
        "default": "AUTO",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "Sets the 'Group Address' field of the IGMPv1 Report header. Must be a valid IPv4 address (e.g., '225.0.0.1'). This field specifies the multicast group address the host wants to join or report membership for. If not provided, this field remains unchanged.",
        "default": "225.0.0.1",
        "range_or_options": "ipv4 address"
      }
    ],
    "description": "Modifies specific fields of an IGMPv1 Report header within a given stream template at the specified level. Only fields for which non-None values are provided will be updated. This function interacts with the backend system to update the internal state of the stream’s IGMPv1 Report header and caches stream headers if they haven’t been retrieved before.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv1 |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv1_report | Stream=${Stream} | Level=0 | GroupAddress=225.0.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv1_query",
    "return_type": "Union[dict, bool]",
    "return": "A dictionary mapping the modified IGMPv1 Query header fields to their internal attribute names if at least one field was updated. Returns False if no fields were updated (i.e., all provided values were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the IGMPv1 Query header needs to be edited. Must contain a 'handle' attribute identifying the stream uniquely.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index level of the IGMPv1 Query header in the filtered list of headers of type 'igmpv1query'. Use 0 for the first such header.",
        "default": "0",
        "range_or_options": ">=0"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Sets the Type field of the IGMPv1 Query header.",
        "default": "11",
        "range_or_options": "00-FF"
      },
      {
        "name": "Unused",
        "type": "int",
        "description": "Sets the Unused field of the IGMPv1 Query header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the Header Checksum field of the IGMPv1 Query header. If set to 'AUTO', it will be automatically calculated. If set to 'ffff', it will introduce an error.",
        "default": "AUTO",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "Sets the Group Address field of the IGMPv1 Query header. Must be a valid IPv4 address.",
        "default": "225.0.0.1",
        "range_or_options": "ipv4地址"
      }
    ],
    "description": "Modifies specific fields of an IGMPv1 Query header in a given stream template. This function allows editing one or more attributes (e.g., Type, Unused, Checksum, GroupAddress) of the IGMPv1 Query header located at a specified level within the stream's header hierarchy. The function filters only the IGMPv1 Query headers and selects the one at the provided index level. Each field is updated only if a value is provided; otherwise, it remains unchanged.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv1Query |\n| create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| edit_header_igmpv1_query | Stream=${Stream} | Level=0 | GroupAddress=225.0.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv2_report",
    "return_type": "dict or bool",
    "return": "A dictionary mapping modified field names to their new values (e.g., {'Type': 'type'}) if any changes were made. Returns False if no fields were updated.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the IGMPv2 header to be edited. It must have a 'handle' attribute identifying it uniquely in the system. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which IGMPv2 header to edit if multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-n (depending on number of IGMPv2 headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "New value for the 'type' field of the IGMPv2 header (e.g., membership query, leave group).",
        "default": "16",
        "range_or_options": "00-FF"
      },
      {
        "name": "MaxResponseTime",
        "type": "int",
        "description": "New value for the 'maxResponseTime' field indicating the maximum time, in seconds, that a host should wait before sending a response to a query.",
        "default": "100",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "hex or str",
        "description": "New value for the 'checksum' field used for error detection in the IGMPv2 header. Use 'AUTO' for automatic calculation or 'ffff' to simulate an error.",
        "default": "AUTO",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "New value for the 'groupAddress' field representing the multicast group address.",
        "default": "225.0.0.1",
        "range_or_options": "ipv4地址"
      }
    ],
    "description": "Edits specific fields of an IGMPv2 (Internet Group Management Protocol version 2) header in a given stream. This function retrieves the IGMPv2 headers associated with the provided stream and modifies the specified fields of the IGMPv2 header at the given level. Only the fields for which non-None values are provided will be updated. The changes are applied to the corresponding header object, and a dictionary of successfully updated fields (with keys as field names and values as their new values) is returned. If no fields are updated, False is returned.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv2 |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv2_report | Stream=${Stream} | Level=0 | MaxResponseTime=15 | GroupAddress=225.0.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv2_query",
    "return_type": "dict or bool",
    "return": "A dictionary mapping updated parameter names to their internal attribute names if changes were successfully made (e.g., {'Type': 'type', 'GroupAddress': 'groupAddress'}). If no parameters are provided for update, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object that contains the IGMPv2 Query header to be edited. Must have a 'handle' attribute that uniquely identifies the stream. If a list is provided, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the IGMPv2 Query header in the filtered list of headers of type 'igmpv2query' to edit.",
        "default": "0",
        "range_or_options": "0 - number_of_igmpv2_query_headers - 1"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Specifies the IGMP message type value to set for the IGMPv2 Query header.",
        "default": "12",
        "range_or_options": "00 - FF"
      },
      {
        "name": "MaxResponseTime",
        "type": "int",
        "description": "Sets the maximum time, in units of tenths of a second, that a host waits before sending a response to the query. Used to control the timing of responses during network congestion.",
        "default": "0",
        "range_or_options": "0 - 255"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum field of the IGMPv2 Query header. Used for error-checking of the IGMP header and payload. If set to AUTO, it will be automatically calculated. Setting it to ffff introduces an intentional error.",
        "default": "AUTO",
        "range_or_options": "0000 - ffff AUTO"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "Sets the multicast group address associated with the IGMPv2 Query. This can be represented as a string (e.g., '224.0.0.1').",
        "default": "225.0.0.1",
        "range_or_options": "ipv4_address"
      }
    ],
    "description": "Edits specific fields of an IGMPv2 Query header in a given stream at the specified level. The function filters all headers of type 'igmpv2query' and selects the one at the given Level to update its fields if corresponding values are provided. Supported editable fields include Type, MaxResponseTime, Checksum, and GroupAddress.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv2Query |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv2_query | Stream=${Stream} | Level=0 | MaxResponseTime=15 | GroupAddress=225.0.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv3_report",
    "return_type": "dict or bool",
    "return": "A dictionary mapping modified field names to their internal attribute names if any modifications were made; otherwise, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing one) whose IGMPv3 Report header needs modification. If a list is provided, the first element is used. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the IGMPv3 Report header to modify if multiple such headers exist in the stream.",
        "default": "0",
        "range_or_options": "0-n (where n depends on the number of IGMPv3 Report headers in the stream)"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "any",
        "description": "The new value for the 'type' field of the IGMPv3 Report header.",
        "default": "not_found",
        "range_or_options": "00-FF"
      },
      {
        "name": "Reserved1",
        "type": "any",
        "description": "The new value for the 'reserved1' field of the IGMPv3 Report header.",
        "default": "00",
        "range_or_options": "00-ff"
      },
      {
        "name": "Checksum",
        "type": "any",
        "description": "The new value for the 'checksum' field of the IGMPv3 Report header. Can be a hex value in the range 0000-ffff, or the string 'AUTO'. If set to 'AUTO', checksum will be automatically calculated.",
        "default": "not_found",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "Reserved2",
        "type": "any",
        "description": "The new value for the 'reserved2' field of the IGMPv3 Report header.",
        "default": "0000",
        "range_or_options": "0000-ffff"
      },
      {
        "name": "NumGroupRecords",
        "type": "any",
        "description": "The new value for the 'numGroupRecords' field of the IGMPv3 Report header. This represents the number of group records included in the report.",
        "default": "not_found",
        "range_or_options": "0-65535 AUTO"
      }
    ],
    "description": "Edits the fields of an IGMPv3 Report header in a specified stream. If a field is provided (not None), its value is updated in the header object, and the corresponding attribute name is recorded in the result dictionary. If no fields are successfully modified, the function returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv3 |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv3_report | Stream=${Stream} | Level=0 | NumGroupRecords=15 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv3_query",
    "return_type": "dict",
    "return": "A dictionary mapping each modified field to its updated value (or result of the operation). If no field is modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, only the first element is used. It is expected to have a 'handle' attribute identifying the stream uniquely.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which IGMPv3 Query header to modify when multiple such headers exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "hex",
        "description": "Value to set for the 'type' field of the IGMPv3 Query header.",
        "default": "11",
        "range_or_options": "00-FF"
      },
      {
        "name": "MaxResponseTime",
        "type": "int",
        "description": "Value to set for the 'maxResponseTime' field of the IGMPv3 Query header.",
        "default": "100",
        "range_or_options": "0-255"
      },
      {
        "name": "Checksum",
        "type": "int or str",
        "description": "Value to set for the 'checksum' field of the IGMPv3 Query header. Defaults to 'AUTO'. 'ffff' indicates an error, and 'AUTO' means checksum will be calculated automatically.",
        "default": "0000",
        "range_or_options": "0000-ffff AUTO"
      },
      {
        "name": "GroupAddress",
        "type": "str",
        "description": "Value to set for the 'groupAddress' field of the IGMPv3 Query header. Must be a valid IPv4 address.",
        "default": "225.0.0.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Value to set for the 'reserved' field of the IGMPv3 Query header.",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "SuppressFlag",
        "type": "bit",
        "description": "Value to set for the 'suppressFlag' field of the IGMPv3 Query header.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Qrv",
        "type": "bit",
        "description": "Value to set for the 'qrv' field of the IGMPv3 Query header.",
        "default": "000",
        "range_or_options": "000 001 010 011 100 101 110 111"
      },
      {
        "name": "Qqic",
        "type": "int",
        "description": "Value to set for the 'qqic' field of the IGMPv3 Query header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumberOfSources",
        "type": "int",
        "description": "Value to set for the 'numberOfSources' field of the IGMPv3 Query header.",
        "default": "not_found",
        "range_or_options": "0-65535"
      },
      {
        "name": "SourceAddressList",
        "type": "list",
        "description": "A list of IPv4 addresses to be configured as source addresses. Each entry corresponds to a source address container in the IGMPv3 Query header. Containers are inserted and edited sequentially.",
        "default": "[]",
        "range_or_options": "ipv4 address list, length 0-63"
      }
    ],
    "description": "Edits the fields of an IGMPv3 Query header in a specified stream at a given level. This function retrieves the IGMPv3 Query headers associated with the provided stream and modifies the specified fields of the header at the given level. Additionally, if a source address list is provided, IPv4 address containers are inserted and edited accordingly.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv3Query |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv3_query | Stream=${Stream} | Level=0 | MaxResponseTime=15 | GroupAddress=225.0.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L3.igmp.edit_header_igmpv3_group_records",
    "return_type": "dict",
    "return": "A dictionary containing the results of all operations performed. Each key represents what was modified or added (e.g., 'SourceAddressList: <address>', 'ExceedauxDataList: <data>'), and the corresponding value indicates the result of the operation (typically a status or return value from the underlying API). If no operation returns a result, the function returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or list containing one stream object) whose IGMPv3 group record header needs to be edited. The stream must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the IGMPv3 header within the list of headers of the specified type in the stream.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the group record within the IGMPv3 header to be edited.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Header",
        "type": "str",
        "description": "The type of header to edit; expected to be 'igmpv3report' or similar types.",
        "default": "'igmpv3report'",
        "range_or_options": "igmpv3report"
      },
      {
        "name": "SourceAddressList",
        "type": "list of str",
        "description": "A list of IPv4 addresses to insert into the group record. Each address will be added as a separate container.",
        "default": "[]",
        "range_or_options": "ipv4 address list"
      },
      {
        "name": "ExceedauxDataList",
        "type": "list of str",
        "description": "A list of auxiliary data values (in hexadecimal format, 4 bytes long) to insert into the group record. Each value will be added as a separate auxiliary data container.",
        "default": "[]",
        "range_or_options": "hexadecimal strings (4 bytes each)"
      }
    ],
    "kwargs": [
      {
        "name": "RecordType",
        "type": "int",
        "description": "Record Type for the IGMPv3 group record.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "AuxDataLen",
        "type": "int",
        "description": "Length of auxiliary data associated with the group record.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumberOfSources",
        "type": "int",
        "description": "Number of source addresses included in the group record.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MulticastAddress",
        "type": "str",
        "description": "IPv4 multicast address associated with the group record.",
        "default": "'225.0.0.1'",
        "range_or_options": "ipv4 address"
      }
    ],
    "description": "Edits the IGMPv3 group records in a specified header of a stream. This includes modifying existing group records and optionally inserting additional IPv4 source addresses or auxiliary data containers. The function retrieves the headers associated with the given stream using `get_stream_header`. It identifies the specific header based on the provided type (`Header`) and `Level`. Within that header, it edits the group record at the given `Index` using any additional parameters passed via `**kwargs`. If `SourceAddressList` is provided, this function inserts IPv4 address containers for each address into the specified group record. Similarly, if `ExceedauxDataList` is provided, auxiliary data containers are inserted for each entry in the list.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | IGMPv3 |\n    | create_stream_header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | edit_header_igmpv3_report | Stream=${Stream} | Level=0 | NumGroupRecords=15 |\n    | Edit Header IPv4 Option | Stream=${Stream} | recordType=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.common.edit_header_tcp",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each provided parameter name to the corresponding attribute name on the TCP header object that was modified. If no parameters are provided (i.e., no changes are made), returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing the traffic template whose TCP header is to be edited. It must have a 'handle' attribute used by the system to uniquely identify the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the TCP header in the list of headers within the stream, used when multiple TCP headers exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "SourcePort",
        "type": "int",
        "description": "The new value for the source port field in the TCP header.",
        "default": "1024",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestPort",
        "type": "int",
        "description": "The new value for the destination port field in the TCP header.",
        "default": "1024",
        "range_or_options": "0-65535"
      },
      {
        "name": "SeqNum",
        "type": "int",
        "description": "The new value for the sequence number field in the TCP header.",
        "default": "1024",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AckNum",
        "type": "int",
        "description": "The new value for the acknowledgment number field in the TCP header.",
        "default": "1024",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DataOffset",
        "type": "int",
        "description": "The new value for the data offset field in the TCP header.",
        "default": "5",
        "range_or_options": "0-15"
      },
      {
        "name": "Reserved",
        "type": "bit",
        "description": "The new value for the reserved bits field in the TCP header.",
        "default": "000000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "Flags",
        "type": "bit",
        "description": "The new value for the flags field in the TCP header.",
        "default": "010000",
        "range_or_options": "000000-111111"
      },
      {
        "name": "WindowSize",
        "type": "int",
        "description": "The new value for the window size field in the TCP header.",
        "default": "4096",
        "range_or_options": "0-65535"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "The new value for the checksum field in the TCP header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "UrgentPointer",
        "type": "hex",
        "description": "The new value for the urgent pointer field in the TCP header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "Option",
        "type": "hex",
        "description": "The new value for the options field in the TCP header.",
        "default": "\"\"",
        "range_or_options": "length 0-40 bytes hexadecimal string"
      }
    ],
    "description": "Modifies TCP header fields for a specified stream at a given level in the header chain. This function retrieves the TCP headers associated with the provided stream and allows selective editing of various TCP header fields. Only the fields provided (not None) will be updated on the corresponding TCP header object at the specified level.",
    "example": "| Edit Header Tcp | Stream=${Stream} | Level=0 | SourcePort=1024 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.common.edit_header_udp",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the modified parameter names (e.g., 'SourcePort') to their internal attribute names (e.g., 'sourcePort') if at least one field was modified. If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the UDP header needs to be edited. It is expected to have a 'handle' attribute that uniquely identifies the stream in the system. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the UDP header in the list of UDP headers for the stream. Used to select which UDP header to edit in case there are multiple UDP headers in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "SourcePort",
        "type": "int",
        "description": "New value for the source port field of the UDP header. If not None, this value will update the 'sourcePort' attribute of the selected UDP header.",
        "default": "1024",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestPort",
        "type": "int",
        "description": "New value for the destination port field of the UDP header. If not None, this value will update the 'destPort' attribute of the selected UDP header.",
        "default": "1024",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "New value for the length field of the UDP header. If not None, this value will update the 'length' attribute of the selected UDP header.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "New value for the checksum field of the UDP header. If not None, this value will update the 'checksum' attribute of the selected UDP header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      }
    ],
    "description": "Modifies specific fields of a UDP header in a given stream at the specified level. This function retrieves the list of headers for the provided stream and filters to find UDP headers. It then modifies one or more fields of the UDP header at the specified level (index). If any field is provided (not None), it updates the corresponding attribute of the UDP header. The function returns a dictionary mapping the modified parameter names to their internal attribute names. If no fields are modified, it returns False.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header Udp | Stream=${Stream} | Level=0 | SourcePort=1024 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.gtpv1.edit_header_gtpv1",
    "return_type": "dict or False",
    "return": "A dictionary mapping each modified parameter name to its corresponding internal attribute name if one or more fields were successfully changed. Returns `False` if no changes were applied (i.e., all provided parameters were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list of object",
        "description": "The stream object associated with the GTPv1 header(s) to be modified. If a list is passed, only the first element is used. The stream must have a valid 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which GTPv1 header in the stream's list should be modified. Level=0 refers to the first GTPv1 header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version number field of the GTPv1 header. Used to identify the protocol version.",
        "default": "1",
        "range_or_options": "0-7"
      },
      {
        "name": "Pt",
        "type": "int",
        "description": "Protocol Type flag indicating whether the payload is a G-PDU (1) or a signaling message (0).",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Reserved bit field for future use or special extensions.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Nexthead",
        "type": "int",
        "description": "Indicates presence of an extension header following this GTPv1 header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "Indicates whether the Sequence Number field is present in the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PduNumberPresent",
        "type": "int",
        "description": "Indicates whether the N-PDU number field is present in the header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "MessageType",
        "type": "int",
        "description": "Identifies the type of GTP message being sent (e.g., Echo Request, Create PDP Context).",
        "default": "255 (0xFF)",
        "range_or_options": "0-255 (hex: 00-FF)"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Specifies the length of the payload in bytes (excluding the GTPv1 header itself).",
        "default": "8",
        "range_or_options": "0-65535"
      },
      {
        "name": "Teid",
        "type": "int",
        "description": "Tunnel Endpoint Identifier, used to uniquely identify the tunnel endpoint on the receiving side.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function modifies specified fields of a GTPv1 (GPRS Tunneling Protocol version 1) header associated with a given stream. It allows editing individual header fields such as Version, PT, Reserved bits, Next Header, Sequence Number, Message Type, Length, and TEID. Only the fields explicitly passed as non-None values are updated. The modification is performed at a specific level (index) within the list of GTPv1 headers associated with the stream.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header Gtpv1 | Stream=${Stream} | Level=0 | Teid=1024 | Version=1 | MessageType=0x10"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.gtpv1.edit_header_gtpv1_optional",
    "return_type": "dict or False",
    "return": "A dictionary indicating the fields that were successfully updated. Each key corresponds to the parameter name (e.g., 'Sequence'), and the value corresponds to the internal attribute name modified (e.g., 'sequence'). If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "测试仪表流量对象，用于指定要修改的流量模板。如果传入列表，则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "GTPv1 Optional头部在流量模板中的索引位置（从0开始计数）。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Sequence",
        "type": "int",
        "description": "Sequence Number字段值，用于设置GTPv1 Optional头部的序列号。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NPDUNumber",
        "type": "int",
        "description": "N-PDU Number字段值，用于标识数据单元编号。",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NextHeaderType",
        "type": "int",
        "description": "Next Extension Header Type字段值，用于指定下一个扩展头部类型。",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "该函数用于修改测试仪表流量模板中GTPv1 Optional报文头部的可选字段内容。它会筛选出指定流中的所有GTPv1 Optional头部，并根据提供的Level选择对应索引的头部进行字段更新。支持同时修改多个字段（如Sequence、NPDUNumber、NextHeaderType），仅当提供新值时才会进行修改。",
    "example": "| Edit Header Gtpv1 Optional | Stream=${Stream} | Level=0 | NextHeaderType=255 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.gtpv1.edit_header_gtpv1_extension",
    "return_type": "Union[dict, bool]",
    "return": "A dictionary mapping modified parameter names to their internal attribute names (e.g., {'Length': 'length'}) if any fields were successfully updated. Returns False if no modifications were made (i.e., all optional parameters are None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream should have a 'handle' attribute that uniquely identifies it in the system. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index into the list of GTPv1 extension headers to identify which header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Length",
        "type": "int",
        "description": "New value for the 'length' attribute of the GTPv1 extension header. If not None, this updates the length field of the header.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "BytePattern",
        "type": "str or bytes",
        "description": "New value for the 'bytePattern' attribute of the header. It must be a hexadecimal string representing 2-1500 bytes. If not None, this updates the byte pattern field.",
        "default": "0000",
        "range_or_options": "hex string with length 2-1500 bytes"
      },
      {
        "name": "NextHeaderType",
        "type": "int",
        "description": "New value for the 'nextHeaderType' attribute of the header. If not None, this updates the next header type field.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Modifies specific fields of a GTPv1 extension header in the specified stream at the given level. This function retrieves the list of headers for the provided stream and filters out only the GTPv1 extension headers ('gtpv1exthdr'). It then accesses the header at the specified level/index and updates its attributes if new values are provided. The updated attributes include length, byte pattern, and next header type. If no changes are made (i.e., all input parameters are None), the function returns False.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header Gtpv1 Extension | Stream=${Stream} | Level=0 | NextHeaderType=255 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.gtpv1.edit_header_gtpv1_optional_extension",
    "return_type": "dict or bool",
    "return": "A dictionary mapping the modified parameter names to their corresponding header attribute names if modifications were made, or False if no changes were applied (i.e., all optional parameters are None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list of object",
        "description": "The stream object or a list containing one stream object. This uniquely identifies the traffic stream in which the GTPv1 Optional Extension header will be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the 'gtpv1ext' type header in the filtered list of headers for modification. Level=0 refers to the first GTPv1 Optional Extension header in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Sequence",
        "type": "int",
        "description": "Sets the Sequence Number field of the GTPv1 Optional Extension header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NPDUNumber",
        "type": "int",
        "description": "Sets the N-PDU Number field of the GTPv1 Optional Extension header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NextHeaderType1",
        "type": "int",
        "description": "Sets the Next Extension Header Type (first occurrence) of the GTPv1 Optional Extension header.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Sets the Length field of the GTPv1 Optional Extension header.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "BytePattern",
        "type": "hex",
        "description": "Sets the Byte Pattern field of the GTPv1 Optional Extension header as a hexadecimal string.",
        "default": "0000",
        "range_or_options": "length between 2 and 1500 bytes"
      },
      {
        "name": "NextHeaderType2",
        "type": "int",
        "description": "Sets the Next Extension Header Type (second occurrence) of the GTPv1 Optional Extension header.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Modifies fields of a GTPv1 Optional Extension header in the specified stream at the given level. The function filters out only the 'gtpv1ext' type headers from the stream's header list and selects the one at the specified Level index for modification. It updates the selected header with any provided non-None values for the optional parameters.",
    "example": "| Edit Header Gtpv1 Optional Extension | Stream=${Stream} | Level=0 | NextHeaderType2=255 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp",
    "return_type": "dict",
    "return": "A dictionary mapping the names of modified fields to their corresponding attribute paths in the header object (e.g., {'SourcePort': 'header.sourcePort'}). Fields not modified are not included.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first element is used. The stream must have a 'handle' attribute that uniquely identifies it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the SCTP header in the list of headers of type 'sctp'.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "SourcePort",
        "type": "int or None",
        "description": "Optional. The new source port number to set in the SCTP header.",
        "default": "3001",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestPort",
        "type": "int or None",
        "description": "Optional. The new destination port number to set in the SCTP header.",
        "default": "3002",
        "range_or_options": "0-65535"
      },
      {
        "name": "VerTag",
        "type": "int or None",
        "description": "Optional. The new verification tag to set in the SCTP header.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Checksum",
        "type": "str or None",
        "description": "Optional. The new checksum value to set in the SCTP header. Must be a 4-byte hexadecimal string.",
        "default": "00000000",
        "range_or_options": "4-byte hexadecimal string"
      },
      {
        "name": "ChunkList",
        "type": "list or None",
        "description": "Optional. A new list of chunks to associate with the SCTP header.",
        "default": "0",
        "range_or_options": "0-250"
      }
    ],
    "description": "Modifies specific fields of an SCTP (Stream Control Transmission Protocol) header in a given stream. This function retrieves the SCTP headers from the specified stream and updates the desired fields at the specified level. If a field value is provided (not None), it will be assigned to the corresponding attribute of the SCTP header object. The function returns a dictionary indicating which attributes were updated.",
    "example": "| Edit Header Sctp | Stream=${Stream} | Level=0 | SourcePort=5000 | DestPort=6000 | VerTag=123456 | Checksum=deadbeef | ChunkList=5 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_chunk",
    "return_type": "dict",
    "return": "A dictionary containing the result of the edit operation, typically including field paths or updated values. The exact structure depends on the chunk type and underlying implementation.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object whose SCTP headers are to be edited. Must be a valid StreamTemplate object.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ChunkType",
        "type": "str",
        "description": "Specifies the type of SCTP chunk to edit or insert. Only one chunk type can be edited per call.",
        "default": "not_found",
        "range_or_options": "DataChunk InitChunk InitAckChunk SAckChunk HeartbeatChunk HeartbeatAckChunk AbortChunk ShutdownChunk ShutdownAckChunk ErrorChunk CookieEchoChunk CookieAckChunk ShutdownCompleteChunk"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the SCTP header in the list of all SCTP headers within the stream. Used to select which SCTP header to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "Index of the specific chunk within the selected SCTP header where modifications will be applied.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Chunk type identifier (numeric value assigned to each chunk type).",
        "default": "varies by ChunkType",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Reserved bits for future use, must be set to zero unless otherwise specified.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "Ubit",
        "type": "bit",
        "description": "Unrecognized Parameter Handling bit; controls how unrecognized parameters are handled.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Bbit",
        "type": "bit",
        "description": "Begin bit indicating whether this is the start of a user message.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Ebit",
        "type": "bit",
        "description": "End bit indicating whether this is the end of a user message.",
        "default": "1",
        "range_or_options": "0 1"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Total length of the chunk in bytes, including padding. Can be automatically calculated.",
        "default": "<AUTO>0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Tsn",
        "type": "int",
        "description": "Transmission Sequence Number used for tracking data chunks.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Sid",
        "type": "int",
        "description": "Stream Identifier indicating the stream associated with this chunk.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Ssn",
        "type": "int",
        "description": "Stream Sequence Number used to track messages within a specific stream.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Pid",
        "type": "int",
        "description": "Payload Protocol Identifier indicating the type of payload carried in the chunk.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Data",
        "type": "hex",
        "description": "User data to be included in the chunk, represented as hexadecimal string.",
        "default": "",
        "range_or_options": "0-65535 bytes"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Optional padding to align the chunk to a 4-byte boundary, provided as hex string.",
        "default": "0",
        "range_or_options": "0-3 bytes"
      },
      {
        "name": "InitTag",
        "type": "int",
        "description": "Initiate Tag used during association setup for identifying the association.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Arwc",
        "type": "int",
        "description": "Advertised Receiver Window Credit indicating available buffer space for incoming data.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Nos",
        "type": "int",
        "description": "Number of Outbound Streams supported by the endpoint.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Mis",
        "type": "int",
        "description": "Number of Inbound Streams supported by the endpoint.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Its",
        "type": "int",
        "description": "Initial Transmission Sequence Number used during association setup.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "Ctsnack",
        "type": "int",
        "description": "Cumulative TSN Acknowledgment sent to confirm receipt of data chunks.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "HbInfoType",
        "type": "int",
        "description": "Heartbeat Information Type specifying the kind of heartbeat being sent.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "HbInfoValue",
        "type": "hex",
        "description": "Heartbeat Information Value providing additional heartbeat data if needed.",
        "default": "0",
        "range_or_options": "0-65535 bytes"
      },
      {
        "name": "StateCookieValue",
        "type": "hex",
        "description": "State cookie value used during association initialization acknowledgment.",
        "default": "",
        "range_or_options": "0-65535 bytes"
      },
      {
        "name": "ErrorCauses",
        "type": "list",
        "description": "List of error causes when generating an error chunk. Each entry represents a specific cause.",
        "default": "[]",
        "range_or_options": "InvalidStreamIdentifier MissingMandatoryParameter StaleCookieError OutOfResource UnresolvableAddress UnrecognizedChunk InvalidMandatoryParameter UnrecognizedParameters NoUserData CookieReceivedWhileShuttingDown RestartOfAnAssociationWithNewAddresses UserInitiatedAbort ProtocolViolation"
      },
      {
        "name": "Cookie",
        "type": "hex",
        "description": "Cookie value used in Cookie Echo and Cookie Ack chunks.",
        "default": "0",
        "range_or_options": "0-65535 bytes"
      },
      {
        "name": "InitOptionalParams",
        "type": "int",
        "description": "Number of optional parameter TLVs to insert into the INIT or INIT ACK chunk.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "GapAckBlocks",
        "type": "int",
        "description": "Number of Gap Ack Blocks to insert into a Selective Ack (SAck) chunk.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "DuplicateTSNs",
        "type": "int",
        "description": "Number of Duplicate TSNs to insert into a Selective Ack (SAck) chunk.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "T",
        "type": "bit",
        "description": "Truncation bit used in certain chunks like SHUTDOWN COMPLETE to indicate truncation.",
        "default": "0",
        "range_or_options": "0 1"
      }
    ],
    "description": "This function edits a specific SCTP chunk within the headers of a given stream. It allows modification of various types of SCTP chunks such as DataChunk, InitChunk, SAckChunk, etc., based on the provided ChunkType. The target chunk is identified by its level (index in the list of SCTP headers) and its position (ChunkIndex) within that header. The function applies any additional configuration parameters via the corresponding edit_* method for the chunk type.",
    "example": "| Edit Header Sctp Chunk | Stream=${Stream} | Level=0 | ChunkType=ShutdownCompleteChunk | Padding=1020"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_init_optional_parameters_tlv",
    "return_type": "dict or False",
    "return": "A dictionary containing the paths to the modified fields in the SCTP INIT chunk's optional parameters TLV (e.g., 'InitOptionalParamType', 'Length', 'Value', 'Padding'). If the operation fails, returns False.",
    "description": "Edits the optional parameters TLV (Type-Length-Value) of an SCTP INIT or INIT_ACK chunk header in a given stream. This function allows setting various fields of the TLV such as parameter type, length, value, and padding based on the provided keyword arguments.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "测试仪表流量对象，必须包含有效的句柄以标识该流模板。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "SCTP头部在流模板中的层级索引（用于多层头的情况下），默认值为0。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkType",
        "type": "str",
        "description": "要编辑的SCTP Chunk类型，只能是'InitChunk'或'InitAckChunk'。",
        "default": "not_found",
        "range_or_options": "InitChunk InitAckChunk"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "在SCTP INIT消息中要修改的Chunk的索引，默认值为0。",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "在SCTP INIT Chunk可选参数TLV列表中要修改的TLV项的索引，默认值为0。",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "InitOptionalParamType",
        "type": "int",
        "description": "仅用于InitChunk，表示可选参数的类型。",
        "default": "5",
        "range_or_options": "0-65535"
      },
      {
        "name": "InitAckOptionalParamType",
        "type": "int",
        "description": "仅用于InitAckChunk，表示可选参数的类型。",
        "default": "5",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Parameter Length字段的长度值，默认值为0。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "hex",
        "description": "User Data字段内容，十六进制格式的数据，长度范围为0-65535字节。",
        "default": "0",
        "range_or_options": "0-65535 bytes hex string"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "用于4字节对齐的填充字段，十六进制格式，长度范围为0-3字节。",
        "default": "0",
        "range_or_options": "0-3 bytes hex string"
      }
    ],
    "example": "| Edit Header Sctp Init Optional Parameters Tlv | Stream=${Stream} | ChunkType=InitChunk | Value=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_sack_chunk_gap_ack_block",
    "return_type": "dict",
    "return": "A dictionary containing the result of the operation, such as field paths for Gabs and Gabe. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. Must have a 'handle' attribute to uniquely identify it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which SCTP header to use if multiple SCTP headers are present in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "Index of the SACK chunk within the SCTP header that contains the gap ack block to be edited.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "BlockIndex",
        "type": "int",
        "description": "Index of the gap acknowledgment block within the specified SACK chunk to modify.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "Gabs",
        "type": "int",
        "description": "Gap Ack Block Start offset.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Gabe",
        "type": "int",
        "description": "Gap Ack Block End offset.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies a specific gap acknowledgment block within an SCTP SACK (Selective Acknowledgment) chunk for a given stream. The function allows editing fields like 'start' and 'end' offsets of the gap acknowledgment block by providing keyword arguments. It selects the appropriate SCTP header, SACK chunk, and gap block based on the Level, ChunkIndex, and BlockIndex parameters respectively.",
    "example": "| Edit Header Sctp Sack Chunk Gap Ack Block | Stream=${Stream} | Gabs=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_sack_chunk_duplicate_tsn",
    "return_type": "dict or bool",
    "return": "A dictionary containing the result of the operation (e.g., success status or error message) returned by the underlying `edit_sack_chunk_duplicate_tsn` method. Returns False if the operation fails or no result is returned.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing a single stream object) for which the SCTP header needs to be edited. The stream is expected to have a 'handle' attribute that uniquely identifies it in the system. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which SCTP header to edit if multiple SCTP headers are present in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "Index of the SACK chunk within the SCTP header to be modified.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "TsnIndex",
        "type": "int",
        "description": "Index of the TSN within the SACK chunk to be duplicated.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "Dtsn",
        "type": "int",
        "description": "Value to set for the duplicate TSN field. This simulates a specific Transmission Sequence Number acknowledgment.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the SCTP SACK (Selective Acknowledgment) chunk to duplicate a specific TSN (Transmission Sequence Number) within the specified stream's header structure. This function allows manipulation of the SACK chunk for testing or simulation purposes, such as simulating duplicate acknowledgments. It internally retrieves the appropriate SCTP header and modifies the selected SACK chunk at the specified indices.",
    "example": "| Edit Header Sctp Sack Chunk Duplicate Tsn | Stream=${Stream} | Dtsn=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_chunk_error_cause",
    "return_type": "dict",
    "return": "A dictionary containing the hierarchical paths to the modified fields in the SCTP error cause structure. The exact keys depend on the `CauseType` and may include fields like 'CauseCode', 'CauseLength', 'StreamIdentifier', 'AdditionalInformation', etc.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing the traffic template, typically created via the testing framework. Must contain a valid handle to identify the stream internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the SCTP header within the stream's hierarchy of headers (e.g., 0 for top-level SCTP header).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkType",
        "type": "str",
        "description": "Specifies the type of SCTP chunk being edited. Must be one of the valid chunk types supported by the framework.",
        "default": "not_found",
        "range_or_options": "AbortChunk ErrorChunk"
      },
      {
        "name": "CauseType",
        "type": "str",
        "description": "The type of error cause that will be applied to the specified chunk. Each cause type has its own set of required keyword arguments.",
        "default": "not_found",
        "range_or_options": "InvalidStreamIdentifier MissingMandatoryParameter StaleCookieError OutOfResource UnresolvableAddress UnrecognizedChunk InvalidMandatoryParameter UnrecognizedParameters NoUserData CookieReceivedWhileShuttingDown RestartOfAnAssociationWithNewAddresses UserInitiatedAbort ProtocolViolation"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "Index of the specific chunk within the SCTP header to modify. Used when multiple chunks are present.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "CauseIndex",
        "type": "int",
        "description": "Index of the specific error cause within the chunk to edit. Used when multiple error causes exist.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "CauseCode",
        "type": "int",
        "description": "Numeric code identifying the error cause. Specific to each CauseType.",
        "default": "varies per CauseType",
        "range_or_options": "0-65535"
      },
      {
        "name": "CauseLength",
        "type": "int",
        "description": "Length of the error cause field in bytes. Typically auto-calculated but can be manually set.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "StreamIdentifier",
        "type": "int",
        "description": "Used with InvalidStreamIdentifier cause to indicate which stream is invalid.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "NumberOfMissingParams",
        "type": "int",
        "description": "Number of missing mandatory parameters reported by the error cause.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MissingParamTypes",
        "type": "int",
        "description": "Number of missing parameter types to insert into the error cause.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "MeasureOfStaleness",
        "type": "int",
        "description": "Time in microseconds indicating how stale the cookie was upon arrival.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NewAddressTlvs",
        "type": "int",
        "description": "Number of new address TLVs to insert into the error cause.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "UnrecognizedChunkType",
        "type": "int",
        "description": "Type of unrecognized chunk causing the error.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "UnrecognizedChunkFlagReserved",
        "type": "int",
        "description": "Reserved flag bits in the unrecognized chunk header.",
        "default": "0",
        "range_or_options": "0-31"
      },
      {
        "name": "UnrecognizedChunkFlagUbit",
        "type": "bit",
        "description": "U bit flag in the unrecognized chunk header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "UnrecognizedChunkFlagBbit",
        "type": "bit",
        "description": "B bit flag in the unrecognized chunk header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UnrecognizedChunkFlagEbit",
        "type": "bit",
        "description": "E bit flag in the unrecognized chunk header.",
        "default": "1",
        "range_or_options": "0-1"
      },
      {
        "name": "UnrecognizedChunkLength",
        "type": "int",
        "description": "Length of the unrecognized chunk data.",
        "default": "<AUTO>4",
        "range_or_options": "0-65535"
      },
      {
        "name": "TsnValue",
        "type": "int",
        "description": "TSN value associated with the No UserData error cause.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AdditionalInformation",
        "type": "hex",
        "description": "Hex string providing additional context or reason for the abort (e.g., upper-layer message).",
        "default": "''",
        "range_or_options": "length 0-65535 bytes"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Optional padding to align the field to 4-byte boundaries. Length must be 0-3 bytes.",
        "default": "0",
        "range_or_options": "length 0-3 bytes hex string"
      }
    ],
    "description": "Modifies the error cause information of a specific SCTP chunk within a traffic stream template. This function allows test engineers to simulate various SCTP error scenarios (such as invalid stream identifiers, unrecognized chunks, protocol violations, etc.) by editing the error cause fields of either an Abort Chunk or an Error Chunk. It is used primarily for negative testing and robustness verification in SCTP communication stacks.",
    "example": "| Edit Header Sctp Chunk Error Cause | Stream=${Stream} | ChunkType=AbortChunk | CauseType=ProtocolViolation | AdditionalInformation=FF"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_chunk_error_cause_missing_parameter_type",
    "return_type": "dict",
    "return": "A dictionary containing the result of the edit operation, typically including success status, error messages, or other relevant metadata. For example, it may return a mapping from the modified field to its path in the internal structure.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing one stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The hierarchical level index of the SCTP header in the stream. Used when multiple layers of headers exist.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkType",
        "type": "str or int",
        "description": "The type of the SCTP chunk to be modified. It may be represented as a string name or an integer value corresponding to the chunk type.",
        "default": "not_found",
        "range_or_options": "AbortChunk ErrorChunk"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "The index of the specific chunk within the SCTP header to modify.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "CauseIndex",
        "type": "int",
        "description": "The index of the error cause within the chunk to modify.",
        "default": "0",
        "range_or_options": "0-1023"
      },
      {
        "name": "TypeIndex",
        "type": "int",
        "description": "The index of the missing parameter type within the error cause to modify.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "MissingParamTypeValue",
        "type": "int",
        "description": "The value to set for the missing parameter type field.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Edits the SCTP chunk error cause missing parameter type in a stream's SCTP header at a specified level and returns the result of the operation. This function retrieves the SCTP headers from the given stream, filters them based on hierarchy level, and modifies the error cause related to a missing parameter type within an SCTP chunk. The modification is performed by calling an internal method on the selected SCTP header object.",
    "example": "| Edit Header Sctp Chunk Error Cause Missing Parameter Type | Stream=${Stream} | ChunkType=AbortChunk | MissingParamTypeValue=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_chunk_error_cause_unrecognized_parameter_tlv",
    "return_type": "dict",
    "return": "A dictionary containing the path references to each modified field of the SCTP Unrecognized Parameter TLV in the chunk error cause. These paths can be used for verification or further configuration.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing a traffic template in the test equipment, which must contain SCTP headers and supports modification operations.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index of the SCTP header to modify if multiple SCTP headers exist in the stream. Level=0 refers to the first (and usually only) SCTP header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkType",
        "type": "str",
        "description": "The type of the SCTP chunk that contains the Error Cause to be edited. This must be either 'AbortChunk' or 'ErrorChunk'.",
        "default": "not_found",
        "range_or_options": "AbortChunk ErrorChunk"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "The index of the specific SCTP chunk within the SCTP header to modify. Used when multiple chunks exist.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "CauseIndex",
        "type": "int",
        "description": "The index of the error cause within the specified SCTP chunk to modify. Used when multiple error causes are present.",
        "default": "0",
        "range_or_options": "0-1023"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "The index of the TLV (Type-Length-Value) field within the error cause to modify. Used when multiple unrecognized parameter TLVs exist.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The Type value of the unrecognized parameter TLV. This is an identifier for the kind of unrecognized parameter.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The length in bytes of the Value field of the TLV. If set to 0<AUTO>, it may be automatically calculated based on the Value provided.",
        "default": "0<AUTO>",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "Hex",
        "description": "The hexadecimal value of the unrecognized parameter TLV's data portion. Must be between 0 and 65535 bytes long.",
        "default": "''",
        "range_or_options": "length 0-65535 bytes hex string"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Optional padding used to align the TLV on a 4-byte boundary. It should be a hex string of up to 3 bytes in length.",
        "default": "0",
        "range_or_options": "length 0-3 bytes hex string"
      }
    ],
    "description": "This function modifies the content of an SCTP Chunk's Error Cause, specifically the Unrecognized Parameter TLV fields, in a given traffic stream template. It allows precise control over the structure and values of these fields, typically used during advanced protocol testing scenarios where malformed or custom parameters need to be tested.",
    "example": "| Edit Header Sctp Chunk Error Cause Unrecognized Parameter Tlv | Stream=${Stream} | ChunkType=AbortChunk | Value=10 | Type=1 | Length=4 | Padding=00"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.sctp.edit_header_sctp_chunk_error_cause_new_address_tlv",
    "return_type": "dict",
    "return": "A dictionary containing the result of the operation, typically indicating success or failure along with any relevant metadata or response data. Each key corresponds to a field in the modified TLV (e.g., 'Type', 'Length', 'Value', 'Padding').",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing one stream object. The stream is used to locate the SCTP header for modification. If a list is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the hierarchical level of the SCTP header in the stream. Identifies which SCTP header to modify when multiple headers are present.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "ChunkType",
        "type": "str or int",
        "description": "Identifies the type of the SCTP chunk where the error cause resides. Valid string values are 'AbortChunk' or 'ErrorChunk'.",
        "default": "not_found",
        "range_or_options": "AbortChunk ErrorChunk"
      },
      {
        "name": "ChunkIndex",
        "type": "int",
        "description": "Index of the specific chunk within the SCTP header to modify. Used to select among multiple chunks of the same type.",
        "default": "0",
        "range_or_options": "0-249"
      },
      {
        "name": "CauseType",
        "type": "str or int",
        "description": "Specifies the type of error cause being modified. Valid string values are 'UnresolvableAddress' and 'RestartOfAnAssociationWithNewAddresses'.",
        "default": "not_found",
        "range_or_options": "UnresolvableAddress RestartOfAnAssociationWithNewAddresses"
      },
      {
        "name": "CauseIndex",
        "type": "int",
        "description": "Index of the error cause within the chunk to modify. Used to select among multiple error causes in the same chunk.",
        "default": "0",
        "range_or_options": "0-1023"
      },
      {
        "name": "TlvIndex",
        "type": "int",
        "description": "Index of the TLV field inside the error cause to modify. Used to select among multiple TLVs in the same error cause.",
        "default": "0",
        "range_or_options": "0-1023"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The Type field of the TLV. This identifies what kind of information is contained in the Value field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The length in bytes of the Value field. A value of 0 may indicate automatic calculation based on the Value content.",
        "default": "0 <AUTO>",
        "range_or_options": "0-65535"
      },
      {
        "name": "Value",
        "type": "Hex",
        "description": "The Value field of the TLV, represented as a hexadecimal string. Length must be between 0 and 65535 bytes.",
        "default": "''",
        "range_or_options": "length 0-65535 bytes of hex string"
      },
      {
        "name": "Padding",
        "type": "hex",
        "description": "Optional padding to align the TLV on a 4-byte boundary. Must be a hexadecimal string of 0 to 3 bytes.",
        "default": "0",
        "range_or_options": "length 0-3 bytes of hex string"
      }
    ],
    "description": "Edits the TLV (Type-Length-Value) field of a 'New Address' error cause within an SCTP chunk in the specified stream. This function retrieves the SCTP header at the specified hierarchical level from the given stream and modifies the corresponding error cause TLV associated with the 'New Address' type.",
    "example": "| Edit Header Sctp Chunk Error Cause New Address Tlv | Stream=${Stream} | ChunkType=AbortChunk | CauseType=UnresolvableAddress | Value=10 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.L4.vxlan.edit_header_vxlan",
    "description": "Modifies specific fields of a VXLAN header in the given stream. The VXLAN header to modify is identified by its level (index) within the list of headers of type 'vxlan' for that stream.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing one stream object. If a list is passed, only the first element will be used. The stream must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which VXLAN header to modify among the list of VXLAN headers in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Flags",
        "type": "bit",
        "description": "New value for the 'flags' field of the VXLAN header. If None, this field is not modified.",
        "default": "00001000",
        "range_or_options": "8-bit binary number"
      },
      {
        "name": "Reserved1",
        "type": "int",
        "description": "New value for the 'reserved1' field of the VXLAN header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Vni",
        "type": "int",
        "description": "New value for the 'VNI' (Virtual Network Identifier) field of the VXLAN header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "Reserved2",
        "type": "int",
        "description": "New value for the 'reserved2' field of the VXLAN header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "return_type": "dict or bool",
    "return": "A dictionary mapping parameter names (e.g., 'Flags', 'Reserved1', etc.) to the actual field names in the header object that were successfully updated. Returns False if none of the optional parameters are provided or no changes were made.",
    "example": "| Edit Header Vxlan | Stream=${Stream} | Level=0 | Vni=1000 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.LldpTlv.lldp.edit_header_lldp_chassis_id_tlv",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping updated parameter names to their corresponding internal field paths if changes were successfully made. If no parameters are provided for update, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, only the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the Chassis ID TLV header to be edited within the list of headers of type 'chassisidtlv'.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the type of the TLV header. Updates the 'type' field of the Chassis ID TLV.",
        "default": "1",
        "range_or_options": "0-127"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Specifies the length of the TLV value field. Updates the 'length' field of the Chassis ID TLV.",
        "default": "0",
        "range_or_options": "0-511"
      },
      {
        "name": "ChassisIdSubType",
        "type": "int",
        "description": "Specifies the subtype of the Chassis ID. Updates the 'chassisIdSubType' field.",
        "default": "5",
        "range_or_options": "05: Network Address IPv4"
      },
      {
        "name": "IanaAddressFamily",
        "type": "int",
        "description": "Specifies the IANA Address Family for network addresses. Updates the 'ianaAddressFamily' field.",
        "default": "1",
        "range_or_options": "0-255"
      },
      {
        "name": "ChassisId",
        "type": "str or bytes",
        "description": "Specifies the actual chassis identifier. Updates the 'chassisId' field with the given value, which can be a string or byte representation of the ID.",
        "default": "192.168.0.1",
        "range_or_options": "有效的ipv4地址"
      }
    ],
    "description": "Edits specific fields of the LLDP Chassis ID TLV (Type-Length-Value) header at a specified level in the given stream. This function allows updating various components of the Chassis ID TLV such as type, length, chassis ID subtype, IANA address family, and the actual chassis ID.",
    "example": ".. code:: RobotFramework\n\n    | Edit Header Lldp Chassis Id Tlv | Stream=${Stream} | Level=0 | Type=127 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.LldpTlv.lldp.edit_header_lldp_port_id_tlv",
    "description": "Modifies specific fields of a 'portidtlv' header in the LLDP (Link Layer Discovery Protocol) header hierarchy of a given stream. The function allows updating one or more of the following fields: Type, Length, PortIdSubType, and PortId.",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each updated parameter name to its corresponding attribute path in the header object if any changes were made. Returns False if no changes were requested (i.e., all parameters were None).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object (or a list containing a single stream object) for which the LLDP 'portidtlv' header is to be edited. If a list is passed, only the first element is used. The stream object is expected to have a 'handle' attribute uniquely identifying it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the 'portidtlv' header in the header hierarchy to modify.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "The value to assign to the 'type' attribute of the selected header.",
        "default": "2",
        "range_or_options": "0-127"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "The value to assign to the 'length' attribute of the selected header.",
        "default": "0",
        "range_or_options": "0-511"
      },
      {
        "name": "PortIdSubType",
        "type": "hex",
        "description": "Chassis ID Subtype; updates the 'portIdSubType' field under the 'macAddr' sub-attribute of the 'portId' structure in the header.",
        "default": "03",
        "range_or_options": "03: MAC Address"
      },
      {
        "name": "PortId",
        "type": "str",
        "description": "Port ID; updates the 'portId' field under the 'macAddr' sub-attribute of the 'portId' structure in the header.",
        "default": "00:00:00:00:00:00",
        "range_or_options": "valid MAC address"
      }
    ],
    "example": "| Edit Header Lldp Port Id Tlv | Stream=${Stream} | Level=0 | Type=127 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.LldpTlv.lldp.edit_header_lldp_ttl_tlv",
    "return_type": "dict or bool",
    "return": "A dictionary mapping modified field names ('Type', 'Length', 'Ttl') to their new values if any changes were made. If no fields were updated, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object representing the stream whose LLDP TTL header needs to be edited. Expected to have a 'handle' attribute that uniquely identifies it in the system. If a list is passed, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'ttltlv' header in the filtered header list to modify. Used to select among multiple TTL headers, if present.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "Optional value to assign to the 'type' attribute of the selected TTL header. If None, this field is not modified.",
        "default": "3",
        "range_or_options": "0-127"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "Optional value to assign to the 'length' attribute of the selected TTL header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-511"
      },
      {
        "name": "Ttl",
        "type": "int",
        "description": "Optional value to assign to the 'ttl' attribute of the selected TTL header. If None, this field is not modified.",
        "default": "120",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Modifies specific fields (Type, Length, Ttl) of an LLDP TTL header within a given stream's header hierarchy. The function retrieves the list of headers for the provided stream, filters them to only include those of type 'ttltlv', and selects the header at the specified level. It then updates any of the fields (Type, Length, Ttl) if non-None values are provided. Each update is applied directly to the header object’s corresponding attribute.",
    "example": "| Edit Header Lldp Ttl Tlv | Stream=${Stream} | Level=0 | Type=127 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.LldpTlv.lldp.edit_header_lldp_end_tlv",
    "return_type": "dict or False",
    "return": "A dictionary indicating which fields were updated (e.g., {'Type': 'type', 'Length': 'length'}). Returns False if no update was performed.",
    "description": "Edits the fields of an LLDP end-of-LLDPDU TLV header at a specified level in the given stream. The function filters headers of type 'endtlv' and modifies the specified fields if provided.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is passed, the first element is used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'endtlv' header in the filtered header list to be edited. Defaults to 0 if not specified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "int",
        "description": "New value to set for the 'type' field of the selected header. If not None, this updates the TLV type field.",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "New value to set for the 'length' field of the selected header. If not None, this updates the length field of the TLV.",
        "default": "0",
        "range_or_options": "0-511"
      }
    ],
    "example": "| Edit Header Lldp End Tlv | Stream=${Stream} | Level=0 | Type=127 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_hello",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding path or location within the header structure, indicating where each value was applied in the header hierarchy.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate",
        "description": "The stream template object representing a test traffic flow on which the OSPFv2 Hello header will be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which OSPFv2 Hello header to edit if multiple exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "OSPF version number (e.g., 2 for OSPFv2).",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Type of the OSPF packet (e.g., 1 for Hello packets).",
        "default": "1",
        "range_or_options": "0(Unknown) 1(Hello) 2(Database Description) 3(Link State Request) 4(Link State Update) 5(Link State Acknowledgement)"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Total length of the OSPF packet, including the header.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Identifier of the router generating the packet.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Identifier of the OSPF area this packet belongs to.",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "16-bit one's complement checksum of the header contents for error checking.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Authentication type used for securing the OSPF communication.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "First part of the authentication value; varies depending on AuthType.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Second part of the authentication value; varies depending on AuthType.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PacketOptionsReserved7",
        "type": "bit",
        "description": "Reserved bit 7 in the Options field of the OSPF Hello header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsReserved6",
        "type": "bit",
        "description": "Reserved bit 6 in the Options field of the OSPF Hello header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsDcBit",
        "type": "bit",
        "description": "Demand Circuit bit indicating support for demand circuits.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsEaBit",
        "type": "bit",
        "description": "External Attributes bit used in some OSPF extensions.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsNpBit",
        "type": "bit",
        "description": "NSSA (Not-So-Stubby Area) bit indicating NSSA capability.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsMcBit",
        "type": "bit",
        "description": "Multicast bit indicating support for multicast routing.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsEBit",
        "type": "bit",
        "description": "E-bit indicating external routing information capability.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsReserved0",
        "type": "bit",
        "description": "Reserved bit 0 in the Options field of the OSPF Hello header.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "NetworkMask",
        "type": "str",
        "description": "Subnet mask associated with the interface sending the Hello packet.",
        "default": "255.255.255.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "HelloInterval",
        "type": "int",
        "description": "Interval (in seconds) between Hello packets sent on the interface.",
        "default": "10",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterPriority",
        "type": "int",
        "description": "Priority value used in DR/BDR election (0 means ineligible).",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RouterDeadInterval",
        "type": "int",
        "description": "Time interval (in seconds) after which a neighbor is considered down.",
        "default": "40",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DesignatedRouter",
        "type": "str",
        "description": "IP address of the designated router for the segment.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "BackupDesignatedRouter",
        "type": "str",
        "description": "IP address of the backup designated router.",
        "default": "2.2.2.2",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Neighbors",
        "type": "list",
        "description": "List of neighbor router IDs to include in the Hello packet.",
        "default": "[1.1.1.1]",
        "range_or_options": "list of up to 1024 elements containing IPv4 addresses"
      }
    ],
    "description": "This function edits the fields of an OSPFv2 Hello packet header in a given stream at the specified level. It allows modifying various fields such as version, type, router ID, area ID, checksum, authentication values, options bits, network mask, and neighbor information. Only the provided parameters are updated; all others remain unchanged.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Hello |\n| ${Neighbors} | Create List | 2.2.2.2 | 3.3.3.3 | 4.4.4.4 |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Hello | Stream=${Stream} | Level=0 | AuthType=2 | Neighbors=${Neighbors} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_unknown",
    "return_type": "dict",
    "return": "A dictionary mapping each modified field name to its corresponding hierarchical path string indicating where the change was applied in the header structure. For example: {'RouterID': 'ospfHeader.routerID'}. Authentication values include dynamic references based on the selected authentication method.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. If a list is provided, the first element will be used. The stream object must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Specifies the index level of the 'ospfv2unknown' header type in the stream's header list. Used to select which OSPFv2 Unknown header to modify when multiple exist.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Value to set for the OSPF header's version field.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Value to set for the OSPF header's type field.",
        "default": "0",
        "range_or_options": "0(Unknown) 1(Hello) 2(Database Description) 3(Link State Request) 4(Link State Update) 5(Link State Acknowledgement)"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Value to set for the OSPF header's packet length field.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Value to set for the OSPF header's router ID field.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Value to set for the OSPF header's area ID field.",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Value to set for the OSPF header's checksum field.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Value to set for the OSPF header's authentication type field.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "Value to set for the first authentication value in the OSPF header's authentication selection sub-structure.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Value to set for the second authentication value in the OSPF header's authentication selection sub-structure.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "Modifies fields of an OSPFv2 Unknown header in a given stream. This function allows editing specific attributes of the OSPFv2 Unknown header at a specified level within the stream's header hierarchy. It supports setting various header fields like Version, Type, RouterID, etc., and returns a dictionary describing the updated fields along with their hierarchical paths in the header structure.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Unknown |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Unknown | Stream=${Stream} | Level=0 | AuthType=2 | AuthValue1=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_request",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding path in the internal structure of the header object. For example, {'RouterID': 'ospfHeader.routerID'}, indicating where the update was applied.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object containing the headers. Expected to have a 'handle' attribute uniquely identifying the stream. If a list is passed, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the OSPFv2 Link State Request header in the list of headers of the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the OSPF protocol version in the header.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the type of the OSPF packet.",
        "default": "3",
        "range_or_options": "0:Unknown 1:Hello 2:Database Description 3:Link State Request 4:Link State Update 5:Link State Acknowledgement"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Sets the total length of the OSPF packet, including the header and data.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Sets the router ID of the sending router.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Sets the area ID associated with the OSPF packet.",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum value for error checking of the OSPF header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Sets the authentication type used for this packet.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "First part of the authentication information.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Second part of the authentication information.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaHeaderCount",
        "type": "int",
        "description": "Inserts the specified number of LSA headers into the packet.",
        "default": "0",
        "range_or_options": "0-1024"
      }
    ],
    "description": "Modifies specific fields of an OSPFv2 Link State Request header in a given stream. This function retrieves the headers for the specified stream and locates the OSPFv2 Link State Request header at the given level (index). It then updates any of the provided fields (e.g., Version, Type, RouterID, etc.) in that header. If a field is not None, it will be assigned to the corresponding attribute of the header. Additionally, if authentication values are provided, they are updated in the header's authentication selection block. If LsaHeaderCount is provided, it inserts that number of LSA headers into the packet.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Unknown |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Request | Stream=${Stream} | Level=0 | AuthType=MD5 | LsaHeaderCount=2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_dd",
    "return_type": "dict",
    "return": "A dictionary mapping each modified parameter name to its corresponding path in the header structure, useful for logging or verification purposes.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate",
        "description": "The stream object representing the traffic template on which the OSPFv2 DD header is located.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which OSPFv2 Database Description header to edit if multiple exist in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version number of the OSPF protocol.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the packet type field in the OSPF header.",
        "default": "2",
        "range_or_options": "0 Unknown 1 Hello 2 Database Description 3 Link State Request 4 Link State Update 5 Link State Acknowledgement"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Sets the total length of the OSPF packet including headers.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Sets the router ID of the sender (IPv4 address format).",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Sets the area ID associated with the packet (IPv4 address format).",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum value for the OSPF packet.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Sets the authentication type used for the OSPF packet.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "First part of authentication data (e.g., cryptographic digest).",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Second part of authentication data, if needed.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PacketOptionsReserved7",
        "type": "bit",
        "description": "Reserved bit 7 in the packet options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsReserved6",
        "type": "bit",
        "description": "Reserved bit 6 in the packet options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsDcBit",
        "type": "bit",
        "description": "Demand circuit bit in the packet options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsEaBit",
        "type": "bit",
        "description": "External attributes bit in the packet options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsNpBit",
        "type": "bit",
        "description": "NSSA external bit in the packet options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsMcBit",
        "type": "bit",
        "description": "Multicast bit in the packet options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsEBit",
        "type": "bit",
        "description": "Type-5/Type-7 LSA bit in the packet options.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "PacketOptionsReserved0",
        "type": "bit",
        "description": "Reserved bit 0 in the packet options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "InterfaceMtu",
        "type": "int",
        "description": "Maximum Transmission Unit for the interface sending this packet.",
        "default": "4096",
        "range_or_options": "0-65535"
      },
      {
        "name": "SequenceNumber",
        "type": "int",
        "description": "DD sequence number used for synchronization.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "DdOptionsReserved7",
        "type": "bit",
        "description": "Reserved bit 7 in the DD options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsReserved6",
        "type": "bit",
        "description": "Reserved bit 6 in the DD options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsReserved5",
        "type": "bit",
        "description": "Reserved bit 5 in the DD options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsReserved4",
        "type": "bit",
        "description": "Reserved bit 4 in the DD options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsReserved3",
        "type": "bit",
        "description": "Reserved bit 3 in the DD options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsIBit",
        "type": "bit",
        "description": "Initialization bit indicating the start of adjacency formation.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsMBit",
        "type": "bit",
        "description": "More bit indicating more DD packets will follow.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DdOptionsMsBit",
        "type": "bit",
        "description": "Master/Slave bit indicating role during adjacency negotiation.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "LsaHeaderCount",
        "type": "int",
        "description": "Inserts the specified number of LSA headers into the DD packet.",
        "default": "0",
        "range_or_options": "0-1024"
      }
    ],
    "description": "Modifies the fields of an OSPFv2 Database Description (DD) header within a specified stream. This function allows modification of various fields such as general packet information, authentication values, option bits, and database description-specific options. The header to be edited is identified by its level (index) in the stream's header hierarchy.",
    "example": ".. code:: RobotFramework\n\n        | ${Stream} | add_stream | Port=${Port} |\n        | ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2DatabaseDescription |\n        | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n        | Edit Header Ospfv2 Dd | Stream=${Stream} | Level=0 | InterfaceMtu=9000 | LsaHeaderCount=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_ack",
    "return_type": "dict",
    "return": "A dictionary mapping modified parameter names to their corresponding internal paths in the header structure. Only fields that were changed are included.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object for which the OSPFv2 Acknowledge header needs to be edited. Must have a 'handle' attribute to uniquely identify it within the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index specifying which OSPFv2 Link State Acknowledge header to modify if multiple exist in the stream's header hierarchy.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the version field of the OSPFv2 header.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Specifies the packet type of the OSPFv2 header.",
        "default": "1",
        "range_or_options": "0(Unknown) 1(Hello) 2(Database Description) 3(Link State Request) 4(Link State Update) 5(Link State Acknowledgement)"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Sets the length of the OSPFv2 packet including all headers and data.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Sets the Router ID of the sender, represented as an IPv4 address string.",
        "default": "1.1.1.1",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Sets the Area ID associated with this packet, represented as an IPv4 address string.",
        "default": "0.0.0.0",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the checksum value used for error detection in the OSPFv2 header.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Specifies the authentication type used for securing the OSPFv2 packet.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "First part of the authentication value. The actual path depends on the current AuthType setting.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Second part of the authentication value. The actual path depends on the current AuthType setting.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LsaHeaderCount",
        "type": "int",
        "description": "Specifies the number of LSA (Link-State Advertisement) headers to insert into the packet.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "PacketOptionsReserved7",
        "type": "any",
        "description": "Reserved bit 7 in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsReserved6",
        "type": "any",
        "description": "Reserved bit 6 in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsDcBit",
        "type": "any",
        "description": "DC (Demand Circuit) bit in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsEaBit",
        "type": "any",
        "description": "EA (External Attributes) bit in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsNpBit",
        "type": "any",
        "description": "NP (NSSA External) bit in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsMcBit",
        "type": "any",
        "description": "MC (Multicast) bit in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsEBit",
        "type": "any",
        "description": "E (External Routing) bit in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "PacketOptionsReserved0",
        "type": "any",
        "description": "Reserved bit 0 in options. If None, the field is unchanged.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits the fields of an OSPFv2 Acknowledge (LSAck) packet header within a given stream. This function allows modification of various fields in the OSPFv2 Link-State Acknowledge header at a specified level in the header hierarchy. It retrieves the appropriate header, applies changes if provided values are not None, and returns a dictionary mapping modified parameter names to their corresponding internal representation strings.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Ack | Stream=${Stream} | Level=0 | InterfaceMtu=9000 | LsaHeaderCount=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_lsa",
    "return_type": "dict",
    "return": "A dictionary mapping the modified LSA header fields to their internal identifiers, or False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object in which the OSPFv2 LSA header will be edited. Must have a 'handle' attribute.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderType",
        "type": "str",
        "description": "The type of OSPFv2 header to edit. This determines which part of the packet structure is being modified.",
        "default": "not_found",
        "range_or_options": "Ospfv2LinkStateUpdate Ospfv2LinkStateRequest Ospfv2DatabaseDescription Ospfv2LinkStateAcknowledge"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The hierarchical level of the header within the stream's header list. Used to select the correct header instance when multiple headers of the same type exist.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific LSA header to edit within the selected header structure.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "LsaAge",
        "type": "int",
        "description": "LSA Age field indicating how long the LSA has been in the network (in seconds).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved7",
        "type": "bit",
        "description": "Reserved Bit 7 in the LSA options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved6",
        "type": "bit",
        "description": "Reserved Bit 6 in the LSA options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DcBit",
        "type": "bit",
        "description": "Demand Circuit bit indicating support for demand circuits.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "EaBit",
        "type": "bit",
        "description": "External Attributes bit used in NSSA LSAs.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "NpBit",
        "type": "bit",
        "description": "NSSA/Propagate bit indicating whether the LSA should be propagated.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "McBit",
        "type": "bit",
        "description": "Multicast bit indicating support for multicast routing.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "EBit",
        "type": "bit",
        "description": "External Routing bit indicating whether external routes are included.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved0",
        "type": "bit",
        "description": "Reserved Bit 0 in the LSA options field.",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "LsType",
        "type": "int",
        "description": "LS Type field specifying the type of LSA.",
        "default": "1",
        "range_or_options": "1 2 3 4 5 7"
      },
      {
        "name": "LinkStateId",
        "type": "str",
        "description": "IPv4 address identifying the link state ID.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4地址"
      },
      {
        "name": "AdvertisingRouter",
        "type": "str",
        "description": "IPv4 address of the router that originated the LSA.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4地址"
      },
      {
        "name": "LsSequenceNumber",
        "type": "hex",
        "description": "Sequence number of the LSA, must be a 4-byte hexadecimal value.",
        "default": "80000001",
        "range_or_options": "长度为4字节的十六进制数"
      },
      {
        "name": "LsChecksum",
        "type": "hex",
        "description": "Checksum of the LSA header, must be a 2-byte hexadecimal value.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "LsaLength",
        "type": "int",
        "description": "Length of the LSA in bytes.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "LsTypeWide",
        "type": "int",
        "description": "Extended LS Type field for wide compatibility.",
        "default": "1",
        "range_or_options": "1 2 3 4 5 7"
      }
    ],
    "description": "Edits the OSPFv2 LSA (Link State Advertisement) header of a specified stream at a given level and index. The function modifies the internal state of the selected header by applying changes via `edit_lsa_header`. It retrieves and filters headers based on the provided HeaderType, selects the appropriate one using Level, and then edits the specific LSA header using Index and the provided keyword arguments.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2DatabaseDescription |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Dd | Stream=${Stream} | Level=0 | InterfaceMtu=9000 | LsaHeaderCount=2 |\n| Edit Header Ospfv2 Lsa | Stream=${Stream} | Index=0 | LsaAge=10 | LinkStateId=4.4.4.4 |\n| Edit Header Ospfv2 Lsa | Stream=${Stream} | Index=1 | LsaAge=20 | LinkStateId=5.5.5.5 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update",
    "return_type": "dict",
    "return": "A dictionary mapping each successfully updated field name to its corresponding hierarchical path in the header structure, e.g., {'Version': 'ospfHeader.version'}. If a field was not updated (i.e., None was passed), it is omitted from the result.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object. If a list is provided, the first element will be used. It must have a 'handle' attribute to uniquely identify the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'ospfv2linkstateupdate' header in the stream's header hierarchy. Used when multiple such headers exist.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the OSPF protocol version number in the header.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Type",
        "type": "int",
        "description": "Sets the message type field in the OSPF header.",
        "default": "4",
        "range_or_options": "0(Unknown) 1(Hello) 2(Database Description) 3(Link State Request) 4(Link State Update) 5(Link State Acknowledgement)"
      },
      {
        "name": "PacketLength",
        "type": "int",
        "description": "Sets the total length of the OSPF packet, including the header and data.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterID",
        "type": "str",
        "description": "Sets the router ID of the sender in the OSPF header.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AreaID",
        "type": "str",
        "description": "Sets the area ID to which the packet belongs.",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "Checksum",
        "type": "hex",
        "description": "Sets the 16-bit checksum of the entire OSPF packet, excluding the Authentication field.",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "AuthType",
        "type": "str",
        "description": "Sets the authentication type used for this packet.",
        "default": "NoAuth",
        "range_or_options": "SimplePassword MD5 UserDefined NoAuth"
      },
      {
        "name": "AuthValue1",
        "type": "int",
        "description": "Sets the first part of the authentication data.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "AuthValue2",
        "type": "int",
        "description": "Sets the second part of the authentication data.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "NumberOfLsas",
        "type": "int",
        "description": "Sets the number of LSA headers included in the packet.",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "LsaHeaders",
        "type": "list",
        "description": "A list of LSA header types to insert into the OSPFv2 header. Supported values: Router, Network, Summary, SummaryAsbr, AsExternal.",
        "default": "not_found",
        "range_or_options": "Router Network Summary SummaryAsbr AsExternal"
      }
    ],
    "description": "Modifies the fields of an OSPFv2 Link-State Update header in a given stream. This function allows updating various header parameters such as version, type, packet length, router ID, area ID, checksum, authentication type and values, number of LSAs, and inserting LSA headers.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | ospfv2linkstateupdate |\n| ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update_lsa",
    "return_type": "dict",
    "return": "A dictionary containing references to the modified LSA header fields in the stream template, mapping field names to their updated values in the system's internal representation.",
    "description": "Edits the OSPFv2 Link State Advertisement (LSA) header of a specified type within a stream's packet structure.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system. If a list is passed, only the first item is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "Specifies the type of LSA header to edit.",
        "default": "not_found",
        "range_or_options": "router network summary summaryasbr asexternal"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the list of headers of type 'ospfv2linkstateupdate' for the selected stream. Used to select a specific header when multiple such headers exist in the packet hierarchy.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific LSA within the LSA list in the header to be edited.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "LsaAge",
        "type": "int",
        "description": "LSA Age",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved7",
        "type": "bit",
        "description": "Reserved Bit 7",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved6",
        "type": "bit",
        "description": "Reserved Bit 6",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "DcBit",
        "type": "bit",
        "description": "DC Bit",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "EaBit",
        "type": "bit",
        "description": "EA Bit",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "NpBit",
        "type": "bit",
        "description": "NP Bit",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "McBit",
        "type": "bit",
        "description": "MC Bit",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "EBit",
        "type": "bit",
        "description": "E Bit",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved0",
        "type": "bit",
        "description": "Reserved Bit 0",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "LsType",
        "type": "int",
        "description": "LS Type",
        "default": "1",
        "range_or_options": "1: Router 2: Network 3: Summary 4: Summary-ASBR 5: AS-External Type-5 7: AS-External Type-7"
      },
      {
        "name": "LinkStateId",
        "type": "str",
        "description": "Link State ID",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AdvertisingRouter",
        "type": "str",
        "description": "Advertising Router",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "LsSequenceNumber",
        "type": "hex",
        "description": "LS Sequence Number",
        "default": "80000001",
        "range_or_options": "4-byte hexadecimal number"
      },
      {
        "name": "LsChecksum",
        "type": "hex",
        "description": "LS Checksum",
        "default": "0000",
        "range_or_options": "0000-FFFF"
      },
      {
        "name": "LsaLength",
        "type": "int",
        "description": "LSA Length",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Reserved7Router",
        "type": "bit",
        "description": "Reserved Bit 7 for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved6Router",
        "type": "bit",
        "description": "Reserved Bit 6 for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved5Router",
        "type": "bit",
        "description": "Reserved Bit 5 for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved4Router",
        "type": "bit",
        "description": "Reserved Bit 4 for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "Reserved3Router",
        "type": "bit",
        "description": "Reserved Bit 3 for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "VBitRouter",
        "type": "bit",
        "description": "V Bit for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "EBitRouter",
        "type": "bit",
        "description": "E Bit for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "BBitRouter",
        "type": "bit",
        "description": "B Bit for Router LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "RouterLsaReserved1",
        "type": "int",
        "description": "Reserved field in Router LSA",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "NumberOfLinks",
        "type": "int",
        "description": "Number of Router Links",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterLsaLinkCount",
        "type": "int",
        "description": "Number of Router LSA Links to insert",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "NetworkMask",
        "type": "str",
        "description": "Network Mask for Network/Summary/External LSA",
        "default": "255.255.255.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AttachedRoute1",
        "type": "str",
        "description": "Attached Router1 ID for Network LSA",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "AttachedRouteCount",
        "type": "int",
        "description": "Number of Attached Routers for Network LSA",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "LsaReserved1",
        "type": "int",
        "description": "Reserved field for Summary LSA",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "LsaMetric",
        "type": "int",
        "description": "Metric for Summary LSA",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "TosMetricsCount",
        "type": "int",
        "description": "Number of additional metrics for Summary/External LSA",
        "default": "0",
        "range_or_options": "0-1024"
      },
      {
        "name": "ExternalOptionsEBit",
        "type": "bit",
        "description": "E Bit for External LSA",
        "default": "0",
        "range_or_options": "0-1"
      },
      {
        "name": "ExternalOptionsReserved",
        "type": "bit",
        "description": "Reserved bits for External LSA",
        "default": "0",
        "range_or_options": "0-15"
      },
      {
        "name": "ExternalRouteMetric",
        "type": "int",
        "description": "Route metric for External LSA",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "ForwardingAddress",
        "type": "str",
        "description": "Forwarding Address for External LSA",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "ExternalRouteTag",
        "type": "int",
        "description": "Route tag for External LSA",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n| ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=0 | Type=Router | RouterLsaReserved1=1 |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=1 | Type=Network | NetworkMask=255.255.0.0 |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=2 | Type=Summary | LsaReserved1=1 |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=3 | Type=SummaryAsbr | LsaMetric=1 |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=4 | Type=AsExternal | ExternalOptionsEBit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update_route_lsa_link",
    "return_type": "dict or bool",
    "return": "Returns a dictionary containing the path to the updated Link field if successful, otherwise returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "A stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the 'ospfv2linkstateupdate' header in the filtered list of headers to use for modification.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "LsaIndex",
        "type": "int",
        "description": "The index of the LSA (Link-State Advertisement) within the selected OSPFv2 Link-State Update header to modify.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the link within the specified LSA to edit.",
        "default": "0",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "LinkId",
        "type": "str",
        "description": "Router LSA Link ID. This is an IPv4 address used to identify the link.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "LinkData",
        "type": "str",
        "description": "Router LSA Link Data. Also an IPv4 address indicating additional data about the link.",
        "default": "0.0.0.0",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "RouterLsaLinkType",
        "type": "int",
        "description": "Type of the router LSA link.",
        "default": "1",
        "range_or_options": "1: Point-to-Point 2: Transit 3: Stub 4: Virtual"
      },
      {
        "name": "NumRouterLsaTosMetrics",
        "type": "int",
        "description": "Number of TOS (Type of Service) Metrics associated with this link.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RouterLinkMetrics",
        "type": "int",
        "description": "Metric value for the router link, used in path calculation.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "RouterLsaTosMetricsCount",
        "type": "int",
        "description": "Number of TOS metrics defined for this router LSA link.",
        "default": "0",
        "range_or_options": "0-1024"
      }
    ],
    "description": "Edits a specific link within an OSPFv2 Link-State Advertisement (LSA) contained in the 'ospfv2linkstateupdate' header of the specified stream. The function identifies the correct header based on the Level parameter and modifies the route LSA link at the given LsaIndex and Index using the provided keyword arguments. It internally retrieves the headers associated with the stream using get_stream_header, filters for 'ospfv2linkstateupdate' type headers, selects the one at the specified Level, and calls its method `edit_route_lsa_link` to perform the actual modification.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n    | ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |\n    | Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=0 | Type=Router | RouterLsaLinkCount=2 |\n    | Edit Header Ospfv2 Update Route Lsa Link | Stream=${Stream} | Level=0 | LsaIndex=0 | Index=0 | LinkId=2.2.2.2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update_route_link_tos_metric",
    "return_type": "dict or bool",
    "return": "Returns a dictionary containing the result of the edit operation if successful. If no changes are made or the operation fails, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object (or list containing one stream object) for which the OSPFv2 Link-State Update header is to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index into the list of headers of type 'ospfv2linkstateupdate' retrieved from the stream. This specifies which such header to edit.",
        "default": "0",
        "range_or_options": "0-undefined_max"
      },
      {
        "name": "LsaIndex",
        "type": "int",
        "description": "The index of the LSA (Link State Advertisement) entry within the header that contains the route link metric to modify.",
        "default": "0",
        "range_or_options": "0-undefined_max"
      },
      {
        "name": "MetricIndex",
        "type": "int",
        "description": "The index of the TOS metric within the route link to edit.",
        "default": "0",
        "range_or_options": "0-undefined_max"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "An additional parameter used internally by the header's edit method to identify the exact field or sub-field to update.",
        "default": "0",
        "range_or_options": "0-undefined_max"
      }
    ],
    "kwargs": [
      {
        "name": "RouterLsaLinkType",
        "type": "int",
        "description": "Specifies the type of the link in the Router LSA.",
        "default": "1",
        "range_or_options": "1 2 3 4"
      },
      {
        "name": "RouterLsaMetricReserved",
        "type": "int",
        "description": "Reserved field in the Router LSA metric.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "RouterTosLinkMetrics",
        "type": "int",
        "description": "Router TOS (Type of Service) Link Metric value.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "description": "Edits the TOS (Type of Service) metric for a specific route link in an OSPFv2 Link-State Update header within a given stream. This function identifies the appropriate header based on the level and applies the specified changes to the metric using internal header methods.",
    "example": "| ${Stream} | add_stream | Port=${Port} |\n| ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n| ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n| Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n| Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |\n| Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=0 | Type=Router | RouterLsaLinkCount=2 |\n| Edit Header Ospfv2 Update Route Lsa Link | Stream=${Stream} | Level=0 | LsaIndex=0 | Index=0 | RouterLsaTosMetricsCount=2 |\n| Edit Header Ospfv2 Update Route Link Tos Metric | Stream=${Stream} | Level=0 | LsaIndex=0 | MetricIndex=0 | Index=0 | RouterLsaMetricReserved=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update_network_attached_route",
    "return_type": "dict or False",
    "return": "A dictionary containing the result of the edit operation if successful, typically including field names and their updated values. Returns `False` if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing a test traffic template in the system. It must be an instance of `StreamTemplate` with a valid 'handle' attribute that uniquely identifies it.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the OSPFv2 Link-State Update header within the list of headers for the given stream. Used to select the correct update header when multiple exist.",
        "default": "0",
        "range_or_options": "non-negative integer"
      },
      {
        "name": "LsaIndex",
        "type": "int",
        "description": "The index of the LSA (Link State Advertisement) within the selected OSPFv2 Link-State Update header where the Network LSA's attached routers will be edited.",
        "default": "0",
        "range_or_options": "non-negative integer"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific attached router entry within the Network LSA to be modified.",
        "default": "0",
        "range_or_options": "non-negative integer"
      }
    ],
    "kwargs": [
      {
        "name": "RouterID",
        "type": "str",
        "description": "The new Router ID to set for the attached router in the Network LSA. Must be a valid IPv4 address string.",
        "default": "1.1.1.1",
        "range_or_options": "IPv4 address format (e.g., 1.1.1.1)"
      }
    ],
    "description": "This function modifies the attached router information in the Network LSA of a specified OSPFv2 Link-State Update header within a test traffic stream. The function allows users to customize fields such as Router ID for a specific attached router entry at a given index in the selected LSA and update header level.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n    | ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |\n    | Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=1 | Type=Network | AttachedRouteCount=2 |\n    | Edit Header Ospfv2 Update Network Attached Route | Stream=${Stream} | Level=0 | LsaIndex=1 | Index=0 | RouterID=2.2.2.2 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.ospfv2.edit_header_ospfv2_update_tos_metric",
    "return_type": "dict or None",
    "return": "A dictionary containing the mapping of the updated TOS metric field in the LSA if successful, otherwise returns None or raises a failure.",
    "parameters": [
      {
        "name": "Stream",
        "type": "StreamTemplate object",
        "description": "The stream template object representing the traffic flow where the OSPFv2 Update header resides.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "The type of LSA to modify. Must be one of the following values: 'Summary', 'SummaryAsbr', or 'AsExternal'.",
        "default": "not_found",
        "range_or_options": "Summary SummaryAsbr AsExternal"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the OSPFv2 Link-State Update header within the stream's header hierarchy (used for nested headers).",
        "default": "0",
        "range_or_options": "0-10"
      },
      {
        "name": "LsaIndex",
        "type": "int",
        "description": "The index of the LSA entry inside the Link-State Update header that needs modification.",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Sub-index specifying which TOS metric to modify when multiple TOS metrics exist for the LSA.",
        "default": "0",
        "range_or_options": "0-10"
      }
    ],
    "kwargs": [
      {
        "name": "MetricReserved",
        "type": "int",
        "description": "Reserved field for Summary or SummaryAsbr LSAs. Used to set reserved bits in metric.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "LinkMetrics",
        "type": "int",
        "description": "Link Metric value for Summary or SummaryAsbr LSAs.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "EBit",
        "type": "bit",
        "description": "E Bit indicating external route for AsExternal LSA.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "RouteTos",
        "type": "int",
        "description": "Route Type of Service for AsExternal LSA.",
        "default": "0",
        "range_or_options": "0-127"
      },
      {
        "name": "RouteMetrics",
        "type": "int",
        "description": "Route Metric for AsExternal LSA.",
        "default": "0",
        "range_or_options": "0-16777215"
      },
      {
        "name": "ForwardingAddress",
        "type": "str",
        "description": "IPv4 forwarding address for AsExternal LSA.",
        "default": "1.1.1.1",
        "range_or_options": "ipv4 address"
      },
      {
        "name": "RouteTag",
        "type": "int",
        "description": "Route Tag for AsExternal LSA used to carry additional information.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function modifies the TOS (Type of Service) metric in an OSPFv2 LSA (Link State Advertisement) contained within a specified stream's header. It supports modifying different types of LSAs such as Summary, SummaryAsbr, and AsExternal, each having their own set of configurable parameters. The function navigates through the stream's header structure to locate the appropriate LSA and updates its TOS metric accordingly.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | Ospfv2LinkStateAcknowledge |\n    | ${LsaHeaders} | Create List | Router | Network | Summary | SummaryAsbr | AsExternal |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Update | Stream=${Stream} | Level=0 | AreaID=2.2.2.2 | LsaHeaders=${LsaHeaders} |\n    | Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=2 | Type=Summary | TosMetricsCount=2 |\n    | Edit Header Ospfv2 Update Tos Metric | Stream=${Stream} | Type=Summary | Level=0 | LsaIndex=2 | Index=0 | MetricReserved=1 |\n    | Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=3 | Type=SummaryAsbr | TosMetricsCount=2 |\n    | Edit Header Ospfv2 Update Tos Metric | Stream=${Stream} | Type=SummaryAsbr | Level=0 | LsaIndex=3 | Index=0 | MetricReserved=1 |\n    | Edit Header Ospfv2 Update Lsa | Stream=${Stream} | Level=0 | Index=4 | Type=AsExternal | TosMetricsCount=2 |\n    | Edit Header Ospfv2 Update Tos Metric | Stream=${Stream} | Type=AsExternal | Level=0 | LsaIndex=4 | Index=0 | EBit=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripng",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping updated RIPng header fields to their internal attribute names if any updates were applied. If no fields were modified, returns False.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object (of type StreamTemplate) in which the RIPng header will be modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index level of the RIPng header within the stream's header hierarchy. Used when multiple RIPng headers are present.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Command",
        "type": "int",
        "description": "Sets the 'command' field in the RIPng header, indicating the type of message (e.g., request or response).",
        "default": "1",
        "range_or_options": "1-2"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Sets the 'version' field of the RIPng header. Indicates protocol version being used.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Sets the 'reserved' field of the RIPng header. Typically unused and should remain 0 unless specified otherwise.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "This function modifies specific fields of a RIPng (Routing Information Protocol Next Generation) header in a given stream template. It allows users to edit the command, version, and reserved fields of the selected RIPng header at a specified level in the header stack. This is useful for customizing routing packet behavior during network testing scenarios.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv6 | Ripng |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ripng | Stream=${Stream} | Level=0 | Command=2 | Version=1 | Reserved=0"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.insert_ripng_entries",
    "return_type": "dict or bool",
    "return": "Returns a dictionary containing the result of the operation, such as handles to inserted entries. Returns False if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object (or a list containing a single stream object) to which RIPng entries will be added. It must have a 'handle' attribute that uniquely identifies the stream in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the RIPng header in the list of RIPng headers associated with the stream. Used to select the specific RIPng header where entries will be inserted.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "The number of RIPng entries to insert into the selected header.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Inserts RIPng (Routing Information Protocol next generation) entries into a specified header level of a given stream. This function identifies the RIPng header at the specified level and calls its method to insert the specified number of entries. If the input `Stream` is provided as a list, the first element of the list is used.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Hello |\n    | ${Neighbors} | Create List | 2.2.2.2 | 3.3.3.3 | 4.4.4.4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Hello | Stream=${Stream} | Level=0 | AuthType=2 | Neighbors=${Neighbors} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripng_entry",
    "return_type": "dict or bool",
    "return": "Returns a dictionary containing the updated RIPng header entry details upon successful modification, or raises an exception if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "The stream object representing a traffic template on which the RIPng header is to be edited.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the RIPng header in the list of all RIPng headers within the stream (used when multiple RIPng headers exist).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "Index of the specific RIPng entry inside the selected RIPng header that needs to be modified.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Ipaddr",
        "type": "str",
        "description": "IPv6 address to update for the specified RIPng entry. If not provided, this field remains unchanged.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "RouteTag",
        "type": "int or str",
        "description": "Route tag value to update for the specified RIPng entry. If not provided, this field remains unchanged.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixLen",
        "type": "int",
        "description": "Prefix length associated with the IPv6 address in the RIPng entry. If not provided, this field remains unchanged.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "Routing metric to update for the specified RIPng entry. If not provided, this field remains unchanged.",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "description": "Modifies a specific RIPng (Routing Information Protocol next generation) header entry in a given stream template. This function allows updating fields such as IPv6 address, route tag, prefix length, and metric for a specific RIPng entry identified by its Level and Index.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=RIPng |\n    | Edit Header Ripng Entry | Stream=${Stream} | Level=0 | Index=0 | Ipaddr=2001:db8::1 | Metric=2"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripv1",
    "return_type": "dict or False",
    "return": "Returns a dictionary mapping modified field names (e.g., 'Command', 'Version', 'Reserved') to their corresponding attribute names if changes were made. Returns False if no parameters were provided (i.e., nothing was modified).",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object for which the RIPv1 header is to be edited. It must have a 'handle' attribute that uniquely identifies the stream in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index/hierarchical level of the RIPv1 header in the stream to be edited.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Command",
        "type": "int",
        "description": "Optional value to set the 'command' field of the RIPv1 header. If None, this field is not modified.",
        "default": "1",
        "range_or_options": "1-2"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Optional value to set the 'version' field of the RIPv1 header. If None, this field is not modified.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Optional value to set the 'reserved' field of the RIPv1 header. If None, this field is not modified.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits the fields of a RIPv1 header in the specified stream at the given hierarchical level. This function retrieves the list of headers for the provided stream and filters them to find RIPv1 headers. It then modifies the specified RIPv1 header at the given level with the new values provided for Command, Version, or Reserved fields. Only non-None parameters are updated.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | RIPv1 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header RIPv1 | Stream=${Stream} | Level=0 | Command=2 | Version=1 | Reserved=0 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.insert_ripv1_entries",
    "return_type": "dict or bool",
    "return": "A dictionary containing mapping of RIP header fields to their corresponding identifiers (e.g., neighbor IDs), or a boolean indicating success or failure. If the operation fails, a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object where the ripv1 entries will be inserted. The stream must have a 'handle' attribute for identification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the 'ripv1' header in the list of headers of the stream where entries will be inserted. Used to select which ripv1 header to modify if multiple exist.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of ripv1 entries to insert into the selected header at the specified level.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Inserts one or more RIP version 1 (RIPv1) entries into a specified RIPv1 header of a given stream. This function dynamically modifies the stream's header structure by inserting the defined number of RIPv1 entries at the designated level. It internally handles both single stream objects and lists containing a single stream object. If the insertion fails, it raises an exception; otherwise, it returns the result from the backend operation.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Hello |\n    | ${Neighbors} | Create List | 2.2.2.2 | 3.3.3.3 | 4.4.4.4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Hello | Stream=${Stream} | Level=0 | AuthType=2 | Neighbors=${Neighbors} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripv1_entry",
    "return_type": "object",
    "return": "The result returned by the `editRipngEntries` method of the header object, which typically represents the success or failure status of the edit operation.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing the stream object for which the RIPv1 header entry is to be edited. If a list is provided, the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the RIPv1 header in the stream's header hierarchy.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "The index of the specific RIPv1 entry to modify within the header.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Afi",
        "type": "optional",
        "description": "Address Family Identifier value to update in the RIPv1 header entry.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Reserved",
        "type": "optional",
        "description": "Reserved field value in the RIPv1 header entry.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Reserved1",
        "type": "optional",
        "description": "Additional reserved field 1 to update.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Reserved2",
        "type": "optional",
        "description": "Additional reserved field 2 to update.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipaddr",
        "type": "optional",
        "description": "IP address value to update in the RIPv1 header entry.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Metric",
        "type": "optional",
        "description": "Metric value indicating route cost to update in the RIPv1 header entry.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits a specific RIP version 1 (RIPv1) header entry within a given stream at the specified level and index. This function retrieves the RIPv1 header from the provided stream and updates its fields based on the parameters passed. Only non-None values are updated in the header entry.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=[EthernetII, IPv4, RIP] |\n    | Edit Header Ripv1 Entry | Stream=${Stream} | Level=0 | Index=0 | Afi=2 | Ipaddr=192.168.1.1 | Metric=1 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripv2",
    "return_type": "dict or bool",
    "return": "A dictionary mapping each updated field name (e.g., 'Command', 'Version', 'Reserved') to its corresponding attribute name in the RIPv2 header object if any fields were successfully updated. Returns False if no fields were modified.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object",
        "description": "A stream object representing a traffic template, expected to have a 'handle' attribute uniquely identifying the stream in the system. If a list of streams is provided, the first one will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "The index of the RIPv2 header in the stream's header hierarchy to be edited. This is useful when multiple RIPv2 headers are present in the stream.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Command",
        "type": "int",
        "description": "Optional value to update the 'command' field of the RIPv2 header. If not None, this will modify the command attribute in the header.",
        "default": "1",
        "range_or_options": "1-2"
      },
      {
        "name": "Version",
        "type": "int",
        "description": "Optional value to update the 'version' field of the RIPv2 header. If not None, this will modify the version attribute in the header.",
        "default": "2",
        "range_or_options": "0-255"
      },
      {
        "name": "Reserved",
        "type": "int",
        "description": "Optional value to update the 'reserved' field of the RIPv2 header. If not None, this will modify the reserved attribute in the header.",
        "default": "0",
        "range_or_options": "0-255"
      }
    ],
    "description": "Edits specific fields of a RIPv2 header within the specified stream at the given level. The function filters for all RIPv2 headers in the stream and selects the one at the specified level (index) to update any provided fields (Command, Version, Reserved). If no fields are provided for modification, the function returns False.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | RIPv2 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header RipV2 | Stream=${Stream} | Level=0 | Command=2 | Version=2 | Reserved=0 |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.insert_ripv2_entries",
    "return_type": "dict or bool",
    "return": "Returns a dictionary mapping field names to their internal identifiers (e.g., 'Command', 'NetworkMask', etc.) if successful, or `False` if the operation fails.",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "The stream object or a list containing a single stream object. The stream must have a 'handle' attribute that uniquely identifies it in the system.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "Index of the RIPv2 header in the list of headers within the stream. Used when multiple RIPv2 headers are present (e.g., nested configurations).",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of RIPv2 route entries to insert into the selected header.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Inserts a specified number of RIPv2 route entries into a specific RIPv2 header of a given stream. This function is used for dynamically modifying RIPv2 headers during test configuration. If the operation fails, a ContinuableFailure exception is raised.",
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | OSPFv2Hello |\n    | ${Neighbors} | Create List | 2.2.2.2 | 3.3.3.3 | 4.4.4.4 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ospfv2 Hello | Stream=${Stream} | Level=0 | AuthType=2 | Neighbors=${Neighbors} |"
  },
  {
    "method_name": "TesterLibrary.Stream.Header.Routing.rip.edit_header_ripv2_entry",
    "description": "修改测试仪表流量模板中RIPv2报文头部中的指定Entry内容。",
    "return_type": "dict or False",
    "return": "包含操作结果的字典，若失败则返回False。示例返回值包括字段映射信息。",
    "parameters": [
      {
        "name": "Stream",
        "type": "object or list",
        "description": "表示测试仪表流量对象的StreamTemplate实例或仅包含一个StreamTemplate实例的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "int",
        "description": "要修改的RIPv2头部在流模板中所有RIPv2头部中的层级序号。",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "Index",
        "type": "int",
        "description": "要修改的RIPv2条目在RIPv2头部中的索引序号。",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [
      {
        "name": "Afi",
        "type": "any, optional",
        "description": "Address Family Identifier (AFI) 值，用于更新RIPv2条目中的地址族标识符。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "RouteTag",
        "type": "any, optional",
        "description": "路由标签值，用于更新RIPv2条目中的路由标记。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SubnetMask",
        "type": "any, optional",
        "description": "子网掩码值，用于更新RIPv2条目中的子网掩码。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "any, optional",
        "description": "下一跳IP地址，用于更新RIPv2条目中的下一跳字段。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipaddr",
        "type": "str, optional",
        "description": "目标IP地址，用于更新RIPv2条目中的目标网络地址。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Metric",
        "type": "any, optional",
        "description": "度量值（路由成本），用于更新RIPv2条目中的metric字段。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | ${Stream} | add_stream | Port=${Port} |\n    | ${HeaderTypes} | Create List | EthernetII | IPv4 | RIPv2 |\n    | Create Stream Header | Stream=${Stream} | HeaderTypes=${HeaderTypes} |\n    | Edit Header Ripv2 Entry | Stream=${Stream} | Level=0 | Index=1 | Afi=2 | Ipaddr=192.168.1.0 | Metric=2 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.create_benchmark",
    "return_type": "tuple",
    "return": "A tuple containing two elements: (1) the benchmark wizard object used to configure and manage the test suite, and (2) a list of test configuration objects corresponding to each test item in the benchmark.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of benchmark test suite to create, based on networking standards or custom configurations.",
        "default": "'rfc2544'",
        "range_or_options": "rfc2544 rfc2889 rfc3918 Asymmetric"
      },
      {
        "name": "Items",
        "type": "list",
        "description": "List of test items to include in the benchmark. Each test item corresponds to a specific performance metric or behavior defined by the selected standard.",
        "default": "not_found",
        "range_or_options": "throughput backtoback frameloss latency addressCachingCapacity addressLearningRate broadcastLatency broadcastForwarding congestionControl erroredFrameFilter forwarding mixedThroughput scaledGroupForwarding multicastThroughput multicastGroupCapacity multicastLatency multicastJoinLeaveLatency"
      }
    ],
    "kwargs": [],
    "description": "This function creates a benchmark test suite using the specified standard or mode (e.g., RFC2544, RFC2889, RFC3918, or Asymmetric). It initializes a wizard object that guides the setup and configuration of the benchmark, and returns both the wizard object and the list of configured test items. This is typically used in automated network testing to evaluate device performance under various standardized conditions.",
    "example": "| ${Items} | Create List | throughput | frameloss |\n| ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.relate_benchmark_ports",
    "return_type": "bool",
    "return": "A boolean value indicating whether the operation to relate benchmark ports to the configuration was successful.",
    "parameters": [
      {
        "name": "Config",
        "type": "wizard_config",
        "description": "The configuration object representing the test suite or context in which the benchmark ports are being associated. This object must have a method called `relate_ports` that is used internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Ports",
        "type": "list of Port",
        "description": "A list of port objects that will be associated with the given configuration for benchmarking purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function associates the specified benchmark ports with a given configuration. It acts as a wrapper around the `relate_ports` method of the provided `Config` object. If the operation fails (i.e., returns False), it raises a `ContinuableFailure` exception. Otherwise, it returns True upon success.",
    "example": ".. code:: robotframework\n\n    | ${Items} | Create List | throughput | frameloss |\n    | ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n    | Relate Benchmark Ports | Config=${Wizard} | Ports=${Ports} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.create_benchmark_streams",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Config",
        "type": "wizard_config",
        "description": "仪表测试测试套件配置对象，包含用于创建流的 `create_streams` 方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Items",
        "type": "list",
        "description": "指定要创建的测试项列表。支持的测试项目包括：throughput, backtoback, frameloss, latency 等。",
        "default": "not_found",
        "range_or_options": "throughput backtoback frameloss latency addressCachingCapacity addressCachingRate broadcastLatency broadcastForwarding congestionControl erroredFrameFilter forwarding forwardPressure maxForwarding mixedThroughput scaledGroupForwarding multicastThroughput multicastGroupCapacity multicastLatency multicastJoinLeaveLatency"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "绑定流的类型，定义流量协议或类型，如以太网、IPv4、IPv6。",
        "default": "not_found",
        "range_or_options": "eth ipv4 ipv6"
      },
      {
        "name": "SrcPoints",
        "type": "list",
        "description": "源端点对象列表，表示流量的发送端口或接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DstPoints",
        "type": "list",
        "description": "目的端点对象列表，表示流量的目标端口或接口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Bidirectional",
        "type": "bool",
        "description": "是否启用双向流量，默认为 False。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "绑定流的拓扑模式，定义源和目的之间的映射关系。",
        "default": "'1v1'",
        "range_or_options": "1v1 m2m meshed congestion"
      },
      {
        "name": "Mapping",
        "type": "str",
        "description": "绑定流的端点映射策略。",
        "default": "'roundrobin'",
        "range_or_options": "roundrobin manytomany"
      },
      {
        "name": "Monitors",
        "type": "list",
        "description": "作为镜像端口的测试仪表端点对象列表。",
        "default": "()",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于创建基准测试流量，基于给定的配置和参数生成具有特定特性的网络流量。它封装了 `Config.create_streams` 方法，允许灵活配置流量模式，适用于性能测试场景。",
    "example": ".. code:: robotframework\n\n    | ${Items} | Create List | throughput | frameloss |\n    | ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n    | Relate Benchmark Ports | Config=${Wizard} | Ports=${Ports} |\n    | Create Benchmark Streams | Config=${Wizard} | Items=@{RFC2544Items} | Type=eth | SrcPoints=@{SrcPoints} | DstPoints=@{SrcPoints} | Mode=meshed | Mapping=roundrobin |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.benchmark_stream_use_exist",
    "return_type": "bool",
    "return": "True if all specified streams exist in the provided configuration; False otherwise.",
    "parameters": [
      {
        "name": "Config",
        "type": "object or iterable (list, set, tuple)",
        "description": "A configuration object that supports the `use_stream_exist` method. If an iterable (e.g., list), only the first element will be used for checking.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "str or list of str",
        "description": "The name(s) of the stream(s) to check for existence. Can be a single string or a list of strings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function checks whether the specified streams exist in the given configuration. It wraps the backend function and raises a `ContinuableFailure` exception if the check fails (i.e., returns False).",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | @{Items} | Create List | throughput | frameloss |\n    | @{FrameSize} | Create List | 256 | 1024 | 16383 |\n    | ${Streams} | Add Stream | Type=binding | | SrcPoints=@{SrcPoints} | DstPoints=@{SrcPoints} |\n    | ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n    | Edit Benchmark Path | Configs=${Config} | Path=C:/test |\n    | Relate Benchmark Ports | Config=${Wizard} | Ports=${Ports} |\n    | Benchmark Stream Use Exist | Config=${Wizard} | Streams=${Streams} |\n    | Edit Benchmark Learning | Configs=${Config} | Frequency=once |\n    | Edit Benchmark Duration | Config=${Config} | Count=1000 |\n    | Edit Benchmark Frame | Config=${Config} | Type=custom | Custom=@{FrameSize} |\n    | Edit Benchmark Search | Config=${Config} | Init=100 |\n    | Expand Benchmark | Config=${Wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.expand_benchmark",
    "return_type": "bool",
    "return": "A boolean indicating whether the benchmark expansion was successful (True) or not (False).",
    "parameters": [
      {
        "name": "Config",
        "type": "wizard_config",
        "description": "The configuration object for the benchmark test suite. This object must have an `expand_benchmark` method that performs the actual expansion logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function expands a benchmark configuration by invoking the `expand_benchmark` method on the provided Config object. It acts as a wrapper to trigger the core benchmark expansion logic, typically used after setting up benchmark parameters such as items, ports, streams, learning settings, duration, frame size, and search parameters. The function raises a `ContinuableFailure` exception if the expansion fails (i.e., returns False), otherwise it returns the result of the expansion.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Items} | Create List | throughput | frameloss |\n    | ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n    | Relate Benchmark Ports | Config=${Wizard} | Ports=${Ports} |\n    | Create Benchmark Streams | Config=${Wizard} | Items=@{RFC2544Items} | Type=eth | SrcPoints=@{SrcPoints} | DstPoints=@{SrcPoints} | Mode=meshed | Mapping=roundrobin |\n    | Edit Benchmark Learning | Configs=${Config} | Frequency=once |\n    | Edit Benchmark Duration | Config=${Config} | Count=${L2_TestTime} |\n    | Edit Benchmark Frame | Config=${Config} | Type=custom | Custom=@{L2_FrameSize} |\n    | Edit Benchmark Search | Config=${Config} | Init=100 |\n    | Expand Benchmark | Config=${Wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.del_benchmark",
    "return_type": "bool",
    "return": "A boolean value indicating the success or failure of the benchmark deletion operation.",
    "parameters": [],
    "kwargs": [],
    "description": "Deletes or clears the current benchmark settings or configurations in the RenixAPI context. This function is used to reset or remove any previously defined benchmarking environment by invoking an internal method. It ensures cleanup of benchmark-related commands or settings that were set during testing or execution.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${Items} | Create List | throughput | frameloss |\n    | ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n    | Relate Benchmark Ports | Config=${Wizard} | Ports=${Ports} |\n    | Create Benchmark Streams | Config=${Wizard} | Items=@{RFC2544Items} | Type=eth | SrcPoints=@{SrcPoints} | DstPoints=@{SrcPoints} | Mode=meshed | Mapping=roundrobin |\n    | Edit Benchmark Learning | Configs=${Config} | Frequency=once |\n    | Edit Benchmark Duration | Config=${Config} | Count=${L2_TestTime} |\n    | Edit Benchmark Frame | Config=${Config} | Type=custom | Custom=@{L2_FrameSize} |\n    | Edit Benchmark Search | Config=${Config} | Init=100 |\n    | Expand Benchmark | Config=${Wizard} |\n    | Del Benchmark"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_frame",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功应用（True 表示成功，False 表示失败）。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or iterable",
        "description": "配置对象或包含配置对象的可迭代结构。如果是列表、集合或元组，则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "帧长度类型，定义如何选择帧大小。",
        "default": "'custom'",
        "range_or_options": "fixed random step custom imix"
      },
      {
        "name": "Length",
        "type": "int",
        "description": "固定帧长值，用于 Type='fixed' 或其他需要单一帧长的情况。",
        "default": "128",
        "range_or_options": "58-16383"
      },
      {
        "name": "Min",
        "type": "int",
        "description": "最小帧长值，用于支持范围的类型（如 'random', 'step' 等）。",
        "default": "128",
        "range_or_options": "58-16383"
      },
      {
        "name": "Max",
        "type": "int",
        "description": "最大帧长值，用于支持范围的类型。",
        "default": "256",
        "range_or_options": "58-16383"
      },
      {
        "name": "Start",
        "type": "int",
        "description": "起始帧长值，用于逐步变化的类型（如 'step'）。",
        "default": "128",
        "range_or_options": "58-16383"
      },
      {
        "name": "End",
        "type": "int",
        "description": "结束帧长值，用于逐步变化的类型。",
        "default": "256",
        "range_or_options": "58-16383"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "步长值，用于逐步变化帧长时递增。",
        "default": "128",
        "range_or_options": "58-16383"
      },
      {
        "name": "Custom",
        "type": "list",
        "description": "自定义帧长列表，用于 Type='custom'。",
        "default": "[64, 128, 256, 512, 1024, 1280, 1518]",
        "range_or_options": "58-16383"
      },
      {
        "name": "ImixTemplates",
        "type": "list",
        "description": "IMIX 模板列表，用于定义混合流量模式。",
        "default": "None",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于编辑测试套件中帧长度的配置，支持多种类型的帧长度设置，包括固定值、随机范围、逐步增加、自定义列表和 IMIX 模板。",
    "example": "| @{FrameSize} | Create List | 256 | 1024 | 16383 |\n| Edit Benchmark Frame | Config=${Config} | Type=custom | Custom=@{FrameSize} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_latency",
    "return_type": "bool",
    "return": "Returns True if the latency settings were successfully applied to all configurations, False otherwise.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list of config objects",
        "description": "A list of configuration objects that support the `edit_latency` method. These objects typically represent test configurations for benchmarking.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of queuing mechanism or latency model to be applied. This defines how packets are queued and processed in the system.",
        "default": "'FIFO'",
        "range_or_options": "FIFO LIFO LILO FILO"
      },
      {
        "name": "DelayBefore",
        "type": "int",
        "description": "The delay time before the traffic starts, in seconds. It ensures a controlled start to the test after initialization.",
        "default": "2",
        "range_or_options": "1-3600"
      },
      {
        "name": "DelayAfter",
        "type": "int",
        "description": "The delay time after the traffic stops, in seconds. This allows for proper measurement after the stream ends.",
        "default": "10",
        "range_or_options": "1-3600"
      }
    ],
    "description": "This function modifies the latency settings for one or more configuration objects by applying a uniform latency type and delay values (before and after processing). It wraps the backend call to `renix.edit_benchmark_latency`, ensuring consistent application of settings across multiple configurations. It is typically used during benchmark setup to define timing behavior for accurate performance measurements.",
    "example": "robotframework:\n\n| @{Items} | Create List | throughput | frameloss |\n| ${Wizard} | ${Config} | Create Benchmark | Type=rfc2544 | Items=${Items} |\n| Edit Benchmark Latency | Config=${Config} | Type=LIFO | DelayBefore=5 | DelayAfter=15"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_learning",
    "return_type": "bool",
    "return": "A boolean value indicating the success or failure of the operation. Returns True for success, False if any error occurred during execution.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list of config objects",
        "description": "List of configuration objects representing test items in the network testing framework. Each object must support the `edit_address_learning` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Frequency",
        "type": "str",
        "description": "The frequency at which address learning should be performed. This determines how often learning is triggered during benchmarking.",
        "default": "'once'",
        "range_or_options": "once trial frame iter"
      }
    ],
    "kwargs": [
      {
        "name": "EnableLearning",
        "type": "bool",
        "description": "Whether to enable address learning for the configurations.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "LearningRate",
        "type": "int",
        "description": "The rate at which learning occurs, expressed in frames per second. Controls how fast the system learns MAC addresses.",
        "default": "1000",
        "range_or_options": "1-14880952"
      },
      {
        "name": "LearningRepeat",
        "type": "int",
        "description": "Number of times the address learning process should be repeated.",
        "default": "5",
        "range_or_options": "1-65536"
      },
      {
        "name": "DelayBefore",
        "type": "int",
        "description": "Time delay (in seconds) before starting the address learning process.",
        "default": "2",
        "range_or_options": "1-65536"
      },
      {
        "name": "EnableArp",
        "type": "bool",
        "description": "Whether to enable ARP learning for Layer 3 address resolution.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ArpRate",
        "type": "int",
        "description": "Rate at which ARP packets are sent during learning, typically in packets per second.",
        "default": "1000",
        "range_or_options": "1-14880952"
      },
      {
        "name": "ArpRepeat",
        "type": "int",
        "description": "Number of times the ARP learning process should be repeated.",
        "default": "5",
        "range_or_options": "1-65536"
      }
    ],
    "description": "This function edits the address learning settings for one or more test configurations in a network testing framework. It allows fine-tuning of both standard MAC address learning and Layer 3 ARP learning parameters. These settings are applied to each configuration object via its internal `edit_address_learning` method. The function ensures uniform configuration across all provided test items.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Learning | Config=${Config} | Frequency=trial | EnableLearning=True |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_duration",
    "return_type": "bool",
    "return": "布尔值，表示测试时长设置是否成功修改（True 表示成功，False 表示失败）。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or list",
        "description": "仪表测试测试套件测试项对象。如果传入的是列表，则仅使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Trial",
        "type": "int",
        "description": "测试验次数，用于区分不同的测试运行或试验。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "模式，指定时间单位或测量模式，支持 'second' 和 'burst'。",
        "default": "'second'",
        "range_or_options": "second burst"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "突发包个数（帧）或时长（秒），取决于 Mode 的取值。",
        "default": "100",
        "range_or_options": "1-80000000"
      }
    ],
    "kwargs": [],
    "description": "编辑测试套件的测试时长设置。该函数将调用底层配置对象的 `edit_duration` 方法来更新基准测试时长。若传入的 Config 是列表，则只使用其第一个元素。返回布尔值表示操作是否成功，并在失败时抛出异常。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Duration | Config=${Config} | Trial=10 | Mode=burst |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_transport_layer",
    "return_type": "bool",
    "return": "Returns True if the transport layer configuration was successfully edited for all provided configurations, otherwise False.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list (config)",
        "description": "List of test configuration objects to modify. These are typically benchmark test item objects from the tester framework.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderType",
        "type": "str",
        "description": "Specifies the type of transport layer header to use. This determines whether a TCP, UDP, or no header is used in the traffic configuration.",
        "default": "none",
        "range_or_options": "none tcp udp"
      },
      {
        "name": "EnableRandomPort",
        "type": "bool",
        "description": "Enables randomization of source and destination ports during testing. If enabled, port values will be randomized rather than following the base/step/count pattern.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "SrcPortBase",
        "type": "int",
        "description": "Starting value for the source port number. This is the first port number used when generating multiple source ports.",
        "default": "7",
        "range_or_options": "0-65535"
      },
      {
        "name": "SrcPortStep",
        "type": "int",
        "description": "Increment step between consecutive source ports. For example, a step of 2 would generate ports like 1000, 1002, 1004, etc.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "SrcPortCount",
        "type": "int",
        "description": "Number of source ports to generate. A value of 0 means only one port will be used.",
        "default": "0",
        "range_or_options": "0-65535"
      },
      {
        "name": "DstPortBase",
        "type": "int",
        "description": "Starting value for the destination port number. Similar to SrcPortBase but applies to destination ports.",
        "default": "7",
        "range_or_options": "0-65535"
      },
      {
        "name": "DstPortStep",
        "type": "int",
        "description": "Increment step between consecutive destination ports.",
        "default": "1",
        "range_or_options": "0-65535"
      },
      {
        "name": "DstPortCount",
        "type": "int",
        "description": "Number of destination ports to generate. A value of 0 means only one port will be used.",
        "default": "0",
        "range_or_options": "0-65535"
      }
    ],
    "kwargs": [],
    "description": "This function edits the transport layer configuration for one or more benchmark test configurations. It allows users to customize transport layer properties such as header type (TCP, UDP, none) and configure source and destination port ranges with options for base, step, and count. Random port selection can also be enabled or disabled.",
    "example": "| Edit Benchmark Transport Layer | Configs=${Configs} | SrcPortBase=1000 | DstPortBase=2000 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_path",
    "return_type": "bool",
    "return": "Returns True if the benchmark paths were successfully updated, False otherwise.",
    "description": "This function modifies the benchmark result storage path for one or more test configuration objects. It ensures that all provided configurations are redirected to the new specified file system path for storing test results. If the operation fails, a ContinuableFailure exception is raised.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list of config objects",
        "description": "A list of configuration objects representing test suites or test items. These objects will have their benchmark result path updated to the specified path.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Path",
        "type": "str",
        "description": "The absolute file system path where benchmark result files (e.g., DB files) should be saved. The path must exist; otherwise, an error is raised.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "example": "| Edit Benchmark Path | Configs=${Configs} | Path=${Path} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_result_file_name",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or iterable (list, set, tuple)",
        "description": "仪表测试测试套件测试项对象或其容器。若传入可迭代对象，则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableCustomResult",
        "type": "bool",
        "description": "是否启用自定义测试结果文件名。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ResultFileName",
        "type": "str or None",
        "description": "自定义的测试结果文件名称，仅在 EnableCustomResult 为 True 时生效。",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "AddTimeStamp",
        "type": "bool",
        "description": "是否向结果文件名添加时间戳以确保唯一性。",
        "default": "True",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "配置基准测试的结果文件名设置，支持启用自定义名称和添加时间戳。此函数调用底层方法 `Config.edit_result_file_name()`，并对参数进行封装处理。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Result File Name | Config=${Config} | ResultFileName=${FileName} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_search",
    "return_type": "bool",
    "return": "布尔值，表示编辑操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Config",
        "type": "config",
        "description": "仪表测试测试套件测试项对象。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "负载类型，用于指定搜索算法的模式。",
        "default": "'binary'",
        "range_or_options": "binary step combo"
      },
      {
        "name": "Lower",
        "type": "int or float",
        "description": "速率下限（%），用于定义搜索范围的最小值。",
        "default": "1",
        "range_or_options": "0.001-100"
      },
      {
        "name": "Upper",
        "type": "int or float",
        "description": "速率上限（%），用于定义搜索范围的最大值。",
        "default": "100",
        "range_or_options": "0.001-100"
      },
      {
        "name": "Init",
        "type": "int or float",
        "description": "初始速率（%），用于设置搜索的起始点。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "Step",
        "type": "int or float",
        "description": "步长（%），在逐步搜索时使用。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "Resolution",
        "type": "int or float",
        "description": "精度（%），用于控制搜索的精细程度。",
        "default": "1",
        "range_or_options": "0.001-100"
      },
      {
        "name": "Ratio",
        "type": "int or float",
        "description": "二分法查找百分比（%），用于特定搜索模式下的阈值计算。",
        "default": "50",
        "range_or_options": "0.001-99.9999"
      },
      {
        "name": "Acceptance",
        "type": "int or float",
        "description": "可接受的丢包率（%），用于收敛判断。",
        "default": "0",
        "range_or_options": "0-100"
      },
      {
        "name": "Ignore",
        "type": "bool",
        "description": "忽略上下限，如果为 True，则跳过某些验证。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableLatency",
        "type": "bool",
        "description": "是否启用时延吞吐量监控。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Maxlatency",
        "type": "int or float",
        "description": "最大允许时延，仅在 EnableLatency 为 True 时生效。",
        "default": "30",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于编辑测试套件中的基准测试搜索配置。它支持多种搜索模式和参数调整，例如搜索范围、步长、精度以及延迟约束等。底层调用 `Config.edit_search` 方法进行实际配置修改，并返回布尔值指示操作是否成功。",
    "example": "| Edit Benchmark Search | Config=${Config} | Mode=step | Init=1 | Step=10 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_traffic_load_loop",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or list/set/tuple",
        "description": "仪表测试测试套件测试项配置对象。若传入列表、集合或元组，则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LoadUnit",
        "type": "str",
        "description": "流量负载单位。默认值：'percent'。",
        "default": "'percent'",
        "range_or_options": "percent fps mbps kbps bps Bps ifg"
      },
      {
        "name": "LoadMode",
        "type": "str",
        "description": "负载模式类型。默认值：'custom'。",
        "default": "'custom'",
        "range_or_options": "fixed random step custom"
      },
      {
        "name": "FixedLoad",
        "type": "int or float",
        "description": "固定负载值，当 LoadMode 为 'fixed' 时使用。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadMin",
        "type": "int or float",
        "description": "最小负载值，当 LoadMode 为范围模式时使用。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadMax",
        "type": "int or float",
        "description": "最大负载值，当 LoadMode 为范围模式时使用。",
        "default": "50",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadStart",
        "type": "int or float",
        "description": "迭代起始负载值。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadEnd",
        "type": "int or float",
        "description": "迭代结束负载值。",
        "default": "50",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadStep",
        "type": "int or float",
        "description": "从 LoadStart 到 LoadEnd 的步长值。",
        "default": "10",
        "range_or_options": "0.001-100"
      },
      {
        "name": "LoadCustom",
        "type": "list[int] or tuple",
        "description": "自定义负载值序列，当 LoadMode 为 'custom' 时使用。",
        "default": "[10, 20, 50]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于编辑网络测试框架中的测试套件流量负载设置。支持多种负载模式，包括固定负载、随机负载、逐步递增负载和自定义负载序列。同时提供多种负载单位选项，允许用户根据需求灵活配置测试场景。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Traffic Load Loop | Config=${Config} | LoadUnit=step | FixedLoad=20 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_backtoback_binary_search",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful (True) or not (False).",
    "parameters": [
      {
        "name": "Config",
        "type": "object",
        "description": "The configuration object representing a test item in the test suite. Must support the `edit_duration_parameters` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MinDuration",
        "type": "float",
        "description": "Minimum duration for the binary search to adjust the test duration, in seconds.",
        "default": "6.4e-05",
        "range_or_options": "not_found"
      },
      {
        "name": "MinFrameCount",
        "type": "int",
        "description": "Minimum number of frames required for the test.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "DurationResolution",
        "type": "float",
        "description": "Step size for adjusting duration during binary search (in seconds).",
        "default": "0.0001",
        "range_or_options": "not_found"
      },
      {
        "name": "FrameCountResolution",
        "type": "int",
        "description": "Step size for adjusting frame count during binary search.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "AcceptFrameLoss",
        "type": "int",
        "description": "Flag indicating whether frame loss is acceptable during the test. A non-zero value means it's allowed.",
        "default": "0",
        "range_or_options": "0 1"
      }
    ],
    "kwargs": [],
    "description": "Adjusts the duration parameters of an RFC2544 benchmark configuration using a binary search approach for back-to-back testing scenarios. If a sequence of configurations is provided, only the first one is used. This function forwards parameters to the `edit_duration_parameters` method of the given Config object and returns the result.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    Edit Benchmark Backtoback Binary Search | Config=${Config} | MinDuration=1 | MinFrameCount=10"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_burst_count_loop",
    "return_type": "bool",
    "return": "A boolean indicating whether the burst count loop configuration was successfully updated (True) or not (False).",
    "parameters": [
      {
        "name": "Config",
        "type": "object or iterable (list, set, tuple)",
        "description": "The configuration object that contains burst count settings. If an iterable is provided, only the first element will be used for modification.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Mode",
        "type": "str",
        "description": "The mode to determine how the burst count should be modified. Possible values include 'step' and 'custom'.",
        "default": "'step'",
        "range_or_options": "step custom"
      },
      {
        "name": "Start",
        "type": "int",
        "description": "The starting value for the burst count when Mode is 'step'. Ignored if Mode is 'custom'.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "End",
        "type": "int",
        "description": "The ending value for the burst count when Mode is 'step'. Ignored if Mode is 'custom'.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Step",
        "type": "int",
        "description": "The increment between successive burst counts when Mode is 'step'. Ignored if Mode is 'custom'.",
        "default": "1",
        "range_or_options": "1-65535"
      },
      {
        "name": "Custom",
        "type": "list[int]",
        "description": "A sequence of burst counts to use when Mode is 'custom'. Ignored if Mode is not 'custom'.",
        "default": "[1, 2]",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function modifies the burst count loop settings for a benchmark configuration based on the specified mode. It allows either step-based progression or a custom-defined sequence of burst values. The actual configuration is delegated to the Config object's edit_burst_count_loop method. This function is used in RFC2889 test suites for tests such as Broadcast Frame Forwarding, Congestion Control, Error Frame Filtering, and Forwarding Tests.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    Edit Benchmark Burst Count Loop | Config=${Config} | Mode=custom | Custom=${custom}"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_address_learning_capacity",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功（True）或失败（False）。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or sequence",
        "description": "仪表测试套件的配置对象。如果传入的是序列（如列表、元组、集合），则只使用第一个元素进行配置编辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MinAddressCount",
        "type": "int",
        "description": "系统在基准测试中应能学习的最小地址数量。",
        "default": "1",
        "range_or_options": "1-16777216"
      },
      {
        "name": "MaxAddressCount",
        "type": "int",
        "description": "系统在基准测试中应能学习的最大地址数量。",
        "default": "65536",
        "range_or_options": "1-16777216"
      },
      {
        "name": "InitAddressCount",
        "type": "int",
        "description": "基准测试开始时初始学习的地址数量。",
        "default": "20480",
        "range_or_options": "1-16777216"
      },
      {
        "name": "Resolution",
        "type": "int",
        "description": "在基准测试期间调整地址计数的粒度或步长（以百分比表示）。",
        "default": "2",
        "range_or_options": "1-100"
      },
      {
        "name": "AgingTime",
        "type": "int",
        "description": "未使用的地址条目被视为过期并被移除的时间（以秒为单位）。",
        "default": "15",
        "range_or_options": "1-3600"
      },
      {
        "name": "LearningRate",
        "type": "int",
        "description": "新地址的学习速率，以每秒地址数表示。",
        "default": "10000",
        "range_or_options": "1-148809523"
      }
    ],
    "kwargs": [],
    "description": "该函数用于编辑与地址学习容量相关的基准测试参数。它允许设置地址学习的最小值、最大值和初始值，以及控制学习过程的其他参数，如精度、老化时间和学习速率。此函数封装了一个底层配置对象的方法，以便灵活地设置学习行为。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Address Learning Capacity | Config=${Config} | LearningRate=100 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_address_learning_rate",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Config",
        "type": "object or collection",
        "description": "仪表测试套件配置对象或配置集合。若为集合类型，则仅使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "MinRateCount",
        "type": "int",
        "description": "每秒学习地址的最小速率，默认值: 1488。",
        "default": "1488",
        "range_or_options": "1-148809523"
      },
      {
        "name": "MaxRateCount",
        "type": "int",
        "description": "每秒学习地址的最大速率，默认值: 1488。",
        "default": "1488",
        "range_or_options": "1-148809523"
      },
      {
        "name": "InitRateCount",
        "type": "int",
        "description": "初始地址学习速率（每秒地址数），默认值: 1488。",
        "default": "1488",
        "range_or_options": "1-148809523"
      },
      {
        "name": "Resolution",
        "type": "int",
        "description": "调整学习速率的步长精度（百分比），默认值: 2。",
        "default": "2",
        "range_or_options": "1-100"
      },
      {
        "name": "AgingTime",
        "type": "int",
        "description": "老化时间（秒），即地址在未更新后被视为过期的时间，默认值: 15。",
        "default": "15",
        "range_or_options": "1-3600"
      },
      {
        "name": "AddressCount",
        "type": "int",
        "description": "预期学习的唯一地址总数，默认值: 1000。",
        "default": "1000",
        "range_or_options": "1-4294967295"
      }
    ],
    "kwargs": [],
    "description": "该函数用于编辑RFC2889网络性能基准测试中的地址学习速率参数。它通过调用Renix API中`Config.edit_address_learning_rate()`方法来实现对地址学习行为的配置，包括学习速率范围、老化时间和地址总数等。适用于模拟MAC表动态变化情况下的网络设备性能测试。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Address Learning Rate | Config=${Config} | AddressCount=100 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_errored_frame_filtering",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Config",
        "type": "config object or list/set/tuple containing config object",
        "description": "仪表测试套件的测试项配置对象。如果传入的是集合类型（如列表、集合、元组），则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "CrcTested",
        "type": "bool",
        "description": "启用或禁用CRC错误帧过滤功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CrcFrameLength",
        "type": "int",
        "description": "设置用于检测CRC错误的帧长度。",
        "default": "64",
        "range_or_options": "64-10000"
      },
      {
        "name": "UndersizedTested",
        "type": "bool",
        "description": "启用或禁用超短帧长度过滤功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "UndersizedFrameLength",
        "type": "int",
        "description": "设置最小合法帧长度，低于该长度的帧将被识别为超短帧。",
        "default": "60",
        "range_or_options": "58-63"
      },
      {
        "name": "OversizedTested",
        "type": "bool",
        "description": "启用或禁用超长帧长度过滤功能。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "OversizedFrameLength",
        "type": "int",
        "description": "设置最大合法帧长度，超过该长度的帧将被识别为超长帧。",
        "default": "1519",
        "range_or_options": "1519-16383"
      },
      {
        "name": "MaxLegalFrameLength",
        "type": "int",
        "description": "定义网络流量中允许的最大帧大小，作为判断超长帧的参考。",
        "default": "1518",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "BurstSize",
        "type": "int",
        "description": "连续错误帧的数量阈值，达到该阈值才被视为有效错误突发。",
        "default": "1",
        "range_or_options": "1-4294967295"
      }
    ],
    "kwargs": [],
    "description": "该函数用于配置基准测试中的错误帧过滤参数，以控制在RFC2889网络性能测试期间如何识别和统计不同类型的错误帧。支持配置CRC错误、超短帧、超长帧的过滤条件，并可调整错误突发的敏感度。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Errored Frame Filtering | Config=${Config} | BurstSize=100 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_base_parameters",
    "return_type": "bool",
    "return": "True if the operation was successful, False otherwise.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list (object)",
        "description": "List of configuration objects representing test items in the benchmark suite.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Version",
        "type": "str",
        "description": "Multicast protocol version to use for the test.",
        "default": "'igmpv2'",
        "range_or_options": "igmpv1 igmpv2 igmpv3 mldv1 mldv2"
      },
      {
        "name": "Ipv4GroupAddressStart",
        "type": "str",
        "description": "Starting IPv4 multicast group address.",
        "default": "'225.0.0.1'",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4GroupAddressStep",
        "type": "str",
        "description": "Increment step for IPv4 group addresses when multiple groups are used.",
        "default": "'0.1.0.0'",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv4 group addresses.",
        "default": "32",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv6GroupAddressStart",
        "type": "str",
        "description": "Starting IPv6 multicast group address.",
        "default": "'ff1e::1'",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6GroupAddressStep",
        "type": "str",
        "description": "Increment step for IPv6 group addresses when multiple groups are used.",
        "default": "'0:0:0:1::'",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv6 group addresses.",
        "default": "128",
        "range_or_options": "1-128"
      },
      {
        "name": "GroupIncrement",
        "type": "int",
        "description": "Number of multicast groups to increment per iteration.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "JoinGroupDelay",
        "type": "int",
        "description": "Delay (in seconds) before joining a multicast group.",
        "default": "15",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "LeaveGroupDelay",
        "type": "int",
        "description": "Delay (in seconds) before leaving a multicast group.",
        "default": "15",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "JoinLeaveSendRate",
        "type": "int",
        "description": "Rate at which join/leave messages are sent (messages per second).",
        "default": "1000",
        "range_or_options": "0-1000000000"
      },
      {
        "name": "GroupDistributeMode",
        "type": "str",
        "description": "Distribution mode for multicast groups.",
        "default": "'even'",
        "range_or_options": "even weighted"
      }
    ],
    "kwargs": [],
    "description": "Edits the multicast base parameters for one or more benchmark configurations. This function allows setting both IPv4 and IPv6 multicast group addresses, IGMP/MLD versions, timing delays, message send rate, and group distribution mode. It supports customization across a range of test scenarios involving multicast traffic behavior.",
    "example": "| Edit Benchmark Multicast Base Parameters | Configs=${Configs} | GroupDistributeMode=weighted | JoinLeaveSendRate=2000"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_stream_tos",
    "return_type": "bool",
    "return": "Returns True if the operation was successfully applied to all configuration objects; otherwise returns False.",
    "parameters": [
      {
        "name": "Configs",
        "type": "list of config objects",
        "description": "List of test suite configuration objects representing multicast streams that will have their QoS parameters modified.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Tos",
        "type": "int",
        "description": "IPv4 Type of Service value for packet precedence, delay, throughput, and reliability. Used in IPv4 headers.",
        "default": "0",
        "range_or_options": "0-255"
      },
      {
        "name": "FlowLabel",
        "type": "int",
        "description": "IPv6 Flow Label value used to identify packets belonging to the same traffic flow. Applies only to IPv6 traffic.",
        "default": "0",
        "range_or_options": "0-1048575"
      },
      {
        "name": "TTL",
        "type": "int",
        "description": "Time To Live value that specifies how many hops a multicast packet can travel before being discarded. Each router decrements this value by one.",
        "default": "10",
        "range_or_options": "1-255"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "VLAN priority level associated with the multicast stream. May influence scheduling or queuing behavior in network devices.",
        "default": "0",
        "range_or_options": "0-7"
      }
    ],
    "kwargs": [],
    "description": "This function modifies Quality of Service (QoS) parameters such as Type of Service (TOS), IPv6 Flow Label, Time To Live (TTL), and VLAN Priority for one or more multicast stream configuration objects in an RFC3918 benchmarking context. It is typically used in automated testing environments to configure or adjust traffic characteristics for multicast performance testing.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Multicast Stream Tos | Configs=${Configs} | Tos=7 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_other",
    "return_type": "bool",
    "return": "True if the multicast configurations were successfully edited, False otherwise.",
    "parameters": [
      {
        "name": "Configs",
        "type": "object or iterable of objects",
        "description": "A single configuration object or an iterable (list, set, tuple) of configuration objects to be edited. Each configuration object must have an 'edit_multicast_other' method.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StopTestWhenFailed",
        "type": "bool",
        "description": "If True, stops the test execution when a failure is detected during the multicast test.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "VerifyFreq",
        "type": "str",
        "description": "Specifies the frequency at which verification should occur during the test.",
        "default": "'topo_changed'",
        "range_or_options": "none topo_changed frame_size iteration"
      },
      {
        "name": "DurationMode",
        "type": "str",
        "description": "Specifies the time unit used for duration parameters.",
        "default": "'second'",
        "range_or_options": "second burst"
      },
      {
        "name": "TimeDurationCount",
        "type": "int",
        "description": "The total duration of the test in units specified by DurationMode.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "BurstDurationCount",
        "type": "int",
        "description": "The burst duration count used in controlling how long bursts last during the test.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "TxFrameRate",
        "type": "int",
        "description": "The transmit frame rate in frames per second.",
        "default": "1000",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function applies multicast-related settings across multiple configuration objects for benchmarking purposes. It ensures uniform configuration updates and supports both single and multiple configuration inputs. Internally, it calls the 'edit_multicast_other' method on each configuration object with the provided arguments.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | Edit Benchmark Multicast Other | Configs=${Configs} | TimeDurationCount=100 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_traffic_ratio_loop",
    "return_type": "bool",
    "return": "布尔值，表示函数执行是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Config",
        "type": "object or list/set/tuple",
        "description": "配置对象，用于编辑组播流量比例设置。如果传入的是序列类型（如列表、集合或元组），则使用第一个元素。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LoopMode",
        "type": "str",
        "description": "控制组播流量比例如何在基准测试期间变化的模式。",
        "default": "'step'",
        "range_or_options": "'fixed' 'minmax' 'startend' 'custom'"
      },
      {
        "name": "FixedRatio",
        "type": "int",
        "description": "当 LoopMode 为 'fixed' 时使用的固定组播流量比例。",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MinRatio",
        "type": "int",
        "description": "当 LoopMode 为 'minmax' 时使用的最小组播流量比例。",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxRatio",
        "type": "int",
        "description": "当 LoopMode 为 'minmax' 时使用的最大组播流量比例。",
        "default": "50",
        "range_or_options": "not_found"
      },
      {
        "name": "StartRatio",
        "type": "int",
        "description": "当 LoopMode 为 'startend' 时使用的起始组播流量比例。",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "EndRatio",
        "type": "int",
        "description": "当 LoopMode 为 'startend' 时使用的结束组播流量比例。",
        "default": "50",
        "range_or_options": "not_found"
      },
      {
        "name": "StepRatio",
        "type": "int",
        "description": "当 LoopMode 为 'startend' 时使用的步长（组播流量比例增量）。",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomRatio",
        "type": "tuple",
        "description": "当 LoopMode 为 'custom' 时使用的自定义组播流量比例列表。",
        "default": "(10, 20, 100)",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于配置 RFC3918 测试套件中组播混合吞吐量的组播流量比例循环设置。支持多种循环模式（fixed、minmax、startend、custom），允许用户根据需要灵活设定组播流量比例。实际配置由底层 `Config.edit_multicast_traffic_ratio_loop()` 方法完成。",
    "example": "robotframework 示例:\n\n| Edit Benchmark Multicast Traffic Ratio Loop | Config=${Config} | LoopMode=step |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_group_count_loop",
    "return_type": "bool",
    "return": "Returns True if the multicast group count loop configuration was successfully edited; otherwise, returns False (though in practice, it raises an exception on failure).",
    "parameters": [
      {
        "name": "Config",
        "type": "object or list/tuple/set",
        "description": "The test configuration object to be modified. If a collection is provided, only the first element is used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "LoopMode",
        "type": "str",
        "description": "Specifies the looping mode for multicast group counts during benchmarking.",
        "default": "'step'",
        "range_or_options": "'fixed' 'random' 'step' 'custom'"
      },
      {
        "name": "FixedGroup",
        "type": "int",
        "description": "Number of multicast groups to use if LoopMode is set to 'fixed'.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MinGroup",
        "type": "int",
        "description": "Minimum number of multicast groups when generating a range of group counts.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MaxGroup",
        "type": "int",
        "description": "Maximum number of multicast groups when generating a range of group counts.",
        "default": "50",
        "range_or_options": "not_found"
      },
      {
        "name": "StartGroup",
        "type": "int",
        "description": "Starting value for the multicast group count in 'step' mode.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "EndGroup",
        "type": "int",
        "description": "Ending value for the multicast group count in 'step' mode.",
        "default": "50",
        "range_or_options": "not_found"
      },
      {
        "name": "StepGroup",
        "type": "int",
        "description": "Increment step size between StartGroup and EndGroup in 'step' mode.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomGroup",
        "type": "list[int] or tuple[int]",
        "description": "A custom sequence of multicast group counts to use if LoopMode is set to 'custom'.",
        "default": "(10, 20, 100)",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function edits the multicast group count loop configuration for benchmarking tests, supporting different modes such as fixed, stepped, and custom-defined values. It modifies the given test configuration object to apply the specified looping behavior for multicast group counts during testing.",
    "example": "| Edit Benchmark Multicast Group Count Loop | Config=${Config} | LoopMode=fixed |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_mixed_throughput_unicast_streams",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful (True) or not (False).",
    "parameters": [
      {
        "name": "Config",
        "type": "object or list",
        "description": "A configuration object that implements the `edit_mixed_throughput_unicast_streams` method, or a list containing such an object. If a list is provided, only the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Streams",
        "type": "list",
        "description": "A list of stream objects. Each stream must have a `handle` attribute that uniquely identifies it. These handles are passed to the underlying configuration method as unicast stream identifiers.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Modifies the unicast stream settings for a multicast mixed throughput benchmark configuration. This function ensures that only one configuration object is used (taking the first if a list is given), and then calls the corresponding edit method with the handles of the specified streams. It is typically used in RFC3918 test scenarios for network performance evaluation.",
    "example": "robotframework:\n\n| Edit Benchmark Multicast Mixed Throughput Unicast Streams | Config=${Config} | Streams=${Streams} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.edit_benchmark_multicast_join_leave_delay",
    "return_type": "bool",
    "return": "Always returns True to indicate successful execution of the configuration change. Returns False only if an error occurs internally, which raises a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Config",
        "type": "object or iterable (list/set/tuple)",
        "description": "A configuration object that supports the `edit_multicast_join_leave_delay` method. If Config is a list, set, or tuple, the first element will be used for editing.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DelayBetweenJoinAndStartStream",
        "type": "int",
        "description": "The delay in seconds between joining a multicast group and starting the data stream.",
        "default": "10",
        "range_or_options": "0-3600"
      },
      {
        "name": "DelayBetweenJoinAndLeave",
        "type": "int",
        "description": "The delay in seconds between joining and leaving a multicast group.",
        "default": "10",
        "range_or_options": "0-3600"
      }
    ],
    "kwargs": [],
    "description": "This function modifies the multicast join and leave delay settings for a benchmark configuration. It configures how long to wait before starting traffic after joining a multicast group and how long to stay in the group before sending a leave message. This is primarily used during RFC3918 multicast performance testing to simulate different network behaviors.",
    "example": "robotframework:\n\n| Edit Benchmark Multicast Join Leave Delay | Config=${Config} | DelayBetweenJoinAndStartStream=100 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.run_benchmark",
    "return_type": "str or list of str",
    "return": "If blocking is enabled (default), returns a list of absolute file paths pointing to the result database (.db) files generated by the benchmark. If blocking is disabled, returns True immediately after starting the benchmark.",
    "parameters": [
      {
        "name": "Mode",
        "type": "int",
        "description": "Specifies the execution mode for the benchmark test script.",
        "default": "0",
        "range_or_options": "0 1"
      },
      {
        "name": "Timer",
        "type": "int",
        "description": "Sets the maximum time in seconds to wait for the benchmark to complete if blocking is enabled.",
        "default": "1800",
        "range_or_options": "not_found"
      },
      {
        "name": "Analyzer",
        "type": "bool",
        "description": "Enables or disables the automatic opening of the analyzer after the benchmark completes.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "kwargs": [],
    "description": "Executes a benchmark test using the SmartScripter engine and manages its lifecycle including result collection. This function starts the SmartScripter command, monitors its execution state, logs progress information at intervals, handles timeout conditions, and collects result files upon completion. It optionally blocks until the benchmark finishes or returns immediately based on the internal `Block` parameter (not exposed to the user but used in backend logic).",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${result} | Run Benchmark |\n    | ${result} | Run Benchmark | Mode==1 |\n    | ${result} | Run Benchmark | Timer==3600 |\n    | ${result} | Run Benchmark | Analyzer==True |\n    | ${result} | Run Benchmark | Mode==1 | Timer==3600 | Analyzer==True |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.get_benchmark_result",
    "return_type": "list of dict or pandas.DataFrame",
    "return": "Benchmark result data retrieved from the database, either as a list of dictionaries (each representing a row) or a pandas DataFrame depending on the ReturnType parameter.",
    "parameters": [
      {
        "name": "DB",
        "type": "str, set, list, or tuple",
        "description": "The path to the SQLite database file. If a set, list, or tuple is provided, the first element will be used.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "A string indicating the type of benchmark data to retrieve. It must correspond to one of the members of EnumBenchmarkDbTable. The matching is case-insensitive.",
        "default": "not_found",
        "range_or_options": "RFC2544 Asymmetric RFC2889 RFC3918"
      }
    ],
    "kwargs": [
      {
        "name": "ReturnType",
        "type": "str",
        "description": "Specifies the format of the returned data. If 'dict' (default), the result is returned as a list of dictionaries (each representing a row). Otherwise, it returns a pandas DataFrame.",
        "default": "'dict'",
        "range_or_options": "'dict' or any other value for pandas.DataFrame"
      }
    ],
    "description": "Retrieves benchmark results from a specified database table and returns the data in the desired format. This function connects to an SQLite database, executes a SQL query to fetch all records from a specific benchmark-related table (based on the provided Type), and returns the result either as a dictionary or a pandas DataFrame.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${DB}  == \"C:/TestSuite/Benchmark/2021_07_29_21_10_36/Asymmetric_throughput_summary2021-07-29_21-11-08/Asymmetric_throughput_summary_2021-07-29_21-11-08.db\") |\n    | ${Type} == \"Asymmetric\" |\n    | ${result} | Get Benchmark Result | ${DB} | ${Type} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.format_benchmark_result",
    "return_type": "Union[PrettyTable, str]",
    "return": "A formatted table representation of the input data. If input is a pandas DataFrame, returns a string from `tabulate`. If input is a list of dictionaries, returns a PrettyTable object.",
    "parameters": [
      {
        "name": "Result",
        "type": "Union[pandas.DataFrame, List[Dict]]",
        "description": "The benchmark result data to be formatted. It can either be a pandas DataFrame or a list of dictionaries where each dictionary represents a row in the table with keys as column headers.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Formats the benchmark result for display or logging purposes. This function takes a result object (either a pandas DataFrame or a list of dictionaries) and converts it into a formatted table string using appropriate formatting libraries. If the input is a pandas DataFrame, it uses `tabulate` to format the DataFrame in 'psql' style. If the input is a list of dictionaries, it constructs a PrettyTable with the dictionary keys as headers and adds each dictionary's values as rows. The resulting table is logged before being returned.",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${result} | Format Benchmark Result | ${Result} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.benchmark.export_benchmark_result",
    "return_type": "bool",
    "return": "布尔值，表示导出操作是否成功。如果成功返回True，否则返回False。",
    "parameters": [
      {
        "name": "Result",
        "type": "list of dict",
        "description": "包含基准测试结果的列表，每个元素是一个字典，字典的键为列标题，值为对应单元格的内容。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Path",
        "type": "str",
        "description": "要保存Excel文件的路径（包括文件名），例如：'C:/Report.xlsx'。如果目录不存在，会自动创建。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Sheet",
        "type": "str",
        "description": "Excel文件中用于写入数据的工作表名称。如果该工作表已存在，则直接使用；否则新建。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "将给定的基准测试结果导出到指定路径的Excel文件中，并同时保存到默认路径 'C:/CMCC/Report.xlsx'。函数接收一个由字典组成的列表作为数据源，将每条记录写入Excel表格中对应的行。若目标目录不存在，会自动创建。",
    "example": "robotframework:\n\n.. code:: robotframework\n\n    | ${result} | Export Benchmark Result | ${Result} | ${Path} | ${Sheet} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.create_bgp_route_wizard",
    "return_type": "BgpRouteWizardConfig",
    "return": "An instance of the BgpRouteWizard class that allows further configuration or manipulation of BGP routes.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of BGP protocol session objects to associate with the route wizard.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "BgpRouteType",
        "type": "str",
        "description": "Specifies the type of BGP routes to be configured.",
        "default": "NO_ROUTES",
        "range_or_options": "IPV4_ROUTES IPV6_ROUTES IPV4_IPV6 NO_ROUTES"
      },
      {
        "name": "EnableLinkState",
        "type": "bool",
        "description": "Enables link state route configuration.",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and returns a BGP route wizard instance, which is used to configure or manipulate BGP routes within the context of the provided sessions. It accepts both positional and keyword arguments for flexible setup.",
    "example": "| Create Bgp Route Wizard | Sessions=@{sessions} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.config_bgp_route_wizard_ipv4",
    "return_type": "list or BgpRouteWizardConfig",
    "return": "If multiple wizards are provided, returns a list of results from each `config_ipv4_route` call. If only one wizard is provided, returns the single result directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (e.g., list, tuple, set) of wizard objects. Each wizard must have a `config_ipv4_route` method to apply configuration settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TotalIpv4RouteCount",
        "type": "int",
        "description": "Number of IPv4 routes to generate. Must be greater than session count if generating per-session routes.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DuplicateIpv4Route",
        "type": "str",
        "description": "Percentage of duplicate routes to generate for redundancy.",
        "default": "0.0",
        "range_or_options": "0.0-100.0"
      },
      {
        "name": "FirstRoute",
        "type": "str",
        "description": "Starting IPv4 route address.",
        "default": "\"192.0.1.0\"",
        "range_or_options": "Valid IPv4 address"
      },
      {
        "name": "LastRoute",
        "type": "str",
        "description": "Ending IPv4 route address.",
        "default": "\"233.255.255.255\"",
        "range_or_options": "Valid IPv4 address"
      },
      {
        "name": "IPv4DistributionType",
        "type": "str",
        "description": "Specifies how IPv4 prefixes should be distributed.",
        "default": "\"FIXED\"",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "PrefixLength",
        "type": "int",
        "description": "Prefix length for generated IPv4 routes.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "EndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for variable distribution types like LINEAR.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "CustomPrefixLength",
        "type": "list",
        "description": "List of 32 float values indicating custom prefix length distribution percentages.",
        "default": "not_found",
        "range_or_options": "List of 32 elements with total sum = 100.0"
      },
      {
        "name": "InternetPrefixLength",
        "type": "list",
        "description": "Predefined internet-style prefix length distribution.",
        "default": "not_found",
        "range_or_options": "List of 32 elements with total sum = 100.0"
      },
      {
        "name": "UseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Whether to use BGP session address as the next hop.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "NextHop",
        "type": "str",
        "description": "Next hop IP address for the routes.",
        "default": "\"192.0.0.1\"",
        "range_or_options": "Valid IPv4 address"
      },
      {
        "name": "NextHopStep",
        "type": "str",
        "description": "Increment step for the next hop address across routes.",
        "default": "\"0.0.0.1\"",
        "range_or_options": "Valid IPv4 address"
      },
      {
        "name": "LocalPref",
        "type": "int",
        "description": "BGP Local Preference path attribute.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "LocalPrefStep",
        "type": "int",
        "description": "Increment step for Local Preference value.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableMed",
        "type": "bool",
        "description": "Enables MULTI_EXIT_DISC (MED) path attribute.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MultExitDisc",
        "type": "int",
        "description": "Value for the MED path attribute.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "MultExitDiscStep",
        "type": "int",
        "description": "Increment step for MED value.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv4AsPathDistributionType",
        "type": "str",
        "description": "Specifies how AS paths should be distributed for IPv4 routes.",
        "default": "\"FIXED\"",
        "range_or_options": "FIXED INTERNET CUSTOM"
      },
      {
        "name": "CustomAsPath",
        "type": "list",
        "description": "Custom AS path length distribution (percentages).",
        "default": "not_found",
        "range_or_options": "List of 32 elements with total sum = 100.0"
      },
      {
        "name": "InternetAsPath",
        "type": "list",
        "description": "Predefined internet-style AS path distribution.",
        "default": "not_found",
        "range_or_options": "List of 32 elements with total sum = 100.0"
      },
      {
        "name": "Ipv4AsPathSuffix",
        "type": "str",
        "description": "Suffix to append to primary AS path strings.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4AsPathIncrement",
        "type": "str",
        "description": "Increment value for AS path suffix.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4SecondaryAsPathSuffix",
        "type": "str",
        "description": "Suffix for secondary AS path strings.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4SecondaryAsPathIncrement",
        "type": "str",
        "description": "Increment value for secondary AS path suffix.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures IPv4 BGP route settings using one or more route wizards. It wraps the `config_ipv4_route` method of each wizard and allows batch configuration of BGP route parameters such as network addresses, prefix lengths, next hops, local preference, AS paths, etc. The function ensures consistent behavior whether a single wizard or multiple wizards are passed.",
    "example": "| Config Bgp Route Wizard Ipv4 | Wizards=@{wizard} | TotalIpv4RouteCount=100 | PrefixLength=24 | NextHop=192.0.0.1 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.config_bgp_route_wizard_ipv6",
    "return_type": "list or BgpRouteWizardConfig",
    "return": "A list of configuration results if multiple wizards are provided, or a single configuration result object if only one wizard is used. Each result typically represents the configured IPv6 BGP route or confirms successful configuration.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (list, set, tuple) of wizard objects that support the `config_ipv6_route` method. Each wizard will be used to configure an IPv6 BGP route.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TotalIpv6RouteCount",
        "type": "int",
        "description": "Number of IPv6 routes to configure per wizard.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "DuplicateIpv6Route",
        "type": "str",
        "description": "Percentage of duplicate IPv6 routes to generate for each route.",
        "default": "0.0",
        "range_or_options": "0.0-100.0"
      },
      {
        "name": "IPv6DistributionType",
        "type": "str",
        "description": "Prefix distribution type for IPv6 routes.",
        "default": "\"FIXED\"",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "FirstIpv6Route",
        "type": "str",
        "description": "Starting IPv6 route address.",
        "default": "\"2000::\"",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "LastIpv6Route",
        "type": "str",
        "description": "Ending IPv6 route address.",
        "default": "\"3ffe::\"",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv6 routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "EndIpv6PrefixLength",
        "type": "int",
        "description": "Ending prefix length for IPv6 routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "CustomPrefixLength",
        "type": "list",
        "description": "List of prefix lengths used when distribution type is 'CUSTOM'. The list must have 128 entries and their total percentage should sum to 100.0.",
        "default": "not_found",
        "range_or_options": "list of length 128, sum = 100.0"
      },
      {
        "name": "InternetPrefixLength",
        "type": "list",
        "description": "List of prefix lengths used when distribution type is 'INTERNET'. The list must have 128 entries and their total percentage should sum to 100.0.",
        "default": "not_found",
        "range_or_options": "list of length 128, sum = 100.0"
      },
      {
        "name": "Ipv6RouteUseSessionAddressAsNextHop",
        "type": "bool",
        "description": "Whether to use the BGP session address as the next hop for all routes.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6NextHop",
        "type": "str",
        "description": "Next hop address for the configured routes.",
        "default": "\"2001::1\"",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6NextHopStep",
        "type": "str",
        "description": "Increment step for the next hop address across routes.",
        "default": "\"::1\"",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6RouteLocalPref",
        "type": "int",
        "description": "Local preference value assigned to the routes.",
        "default": "10",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv6RouteLocalPrefStep",
        "type": "int",
        "description": "Increment step for Local Preference values across routes.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv6RouteEnableMed",
        "type": "bool",
        "description": "Whether to enable MULTI_EXIT_DISC path attribute.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6RouteMultExitDisc",
        "type": "int",
        "description": "MULTI_EXIT_DISC value assigned to the routes.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv6RouteMultExitDiscStep",
        "type": "int",
        "description": "Increment step for MULTI_EXIT_DISC values across routes.",
        "default": "0",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "Ipv6AsPathDistributionType",
        "type": "str",
        "description": "AS path length distribution type for routes.",
        "default": "\"FIXED\"",
        "range_or_options": "FIXED INTERNET CUSTOM"
      },
      {
        "name": "CustomAsPath",
        "type": "list",
        "description": "Custom AS path distribution. A list of length 128 whose sum must equal 100.0.",
        "default": "not_found",
        "range_or_options": "list of length 128, sum = 100.0"
      },
      {
        "name": "InternetAsPath",
        "type": "list",
        "description": "Internet-style AS path distribution. A list of length 128 whose sum must equal 100.0.",
        "default": "not_found",
        "range_or_options": "list of length 128, sum = 100.0"
      },
      {
        "name": "Ipv6AsPathSuffix",
        "type": "str",
        "description": "Suffix to append to the primary AS path.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6AsPathIncrement",
        "type": "str",
        "description": "Increment step for the primary AS path suffix.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6SecondaryAsPathSuffix",
        "type": "str",
        "description": "Suffix to append to the secondary AS path.",
        "default": "\"\"",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6SecondaryAsPathIncrement",
        "type": "str",
        "description": "Increment step for the secondary AS path suffix.",
        "default": "\"\"",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures IPv6 BGP route settings using one or more wizard objects. It ensures that the provided `Wizards` argument is in an iterable format and applies the same configuration (`**kwargs`) to each wizard by calling its `config_ipv6_route` method. If multiple wizards are provided, it returns a list of configuration results; otherwise, it returns a single configuration result.",
    "example": "| Config Bgp Route Wizard Ipv6 | Wizards=@{wizard} | TotalIpv6RouteCount=1000 | IPv6DistributionType=LINEAR | Ipv6NextHop=2001::2 | Ipv6AsPathDistributionType=CUSTOM | CustomAsPath=[0.1, 0.2, ..., 0.7] |"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.config_bgp_route_wizard_igp_topo",
    "return_type": "list or BgpLinkStateRouteWizardConfig",
    "return": "If multiple wizards are provided, returns a list of results from calling `config_igp_topo` on each wizard. If only one wizard is provided, returns the result from that single wizard's `config_igp_topo` call.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single wizard object or an iterable (e.g., list, tuple) containing wizard objects. Each wizard must have a `config_igp_topo` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ProtocolType",
        "type": "str",
        "description": "IGP Protocol type to be configured for the topology.",
        "default": "OSPFV2",
        "range_or_options": "OSPFV2 ISIS_IPV4"
      },
      {
        "name": "NumberOfArea",
        "type": "int",
        "description": "Number of IGP areas to configure in the topology.",
        "default": "2",
        "range_or_options": "1-100"
      },
      {
        "name": "Topology",
        "type": "str",
        "description": "Type of topology to apply at the backbone level.",
        "default": "FULL_MESH",
        "range_or_options": "FULL_MESH GRID"
      },
      {
        "name": "BackboneHeadendRouters",
        "type": "int",
        "description": "Number of headend routers in the backbone area.",
        "default": "2",
        "range_or_options": "1-1000"
      },
      {
        "name": "CoreRouterNum",
        "type": "int",
        "description": "Number of core routers in the network topology.",
        "default": "4",
        "range_or_options": "1-100"
      },
      {
        "name": "BackboneRows",
        "type": "int",
        "description": "Number of rows in the grid layout for the backbone topology.",
        "default": "2",
        "range_or_options": "2-10000"
      },
      {
        "name": "BackboneColumns",
        "type": "int",
        "description": "Number of columns in the grid layout for the backbone topology.",
        "default": "2",
        "range_or_options": "2-10000"
      },
      {
        "name": "ABRNumber",
        "type": "str",
        "description": "Configuration option for number of Area Border Routers (ABRs).",
        "default": "CONFIG_1",
        "range_or_options": "CONFIG_1 CONFIG_2"
      },
      {
        "name": "IntraTopology",
        "type": "str",
        "description": "Type of intra-area topology configuration.",
        "default": "TREE",
        "range_or_options": "GRID TREE"
      },
      {
        "name": "NonBackboneHeadendRouters",
        "type": "int",
        "description": "Number of headend routers per non-backbone area.",
        "default": "2",
        "range_or_options": "1-1000"
      },
      {
        "name": "NonBackboneRows",
        "type": "int",
        "description": "Number of rows in the grid layout for non-backbone topologies.",
        "default": "2",
        "range_or_options": "2-10000"
      },
      {
        "name": "NonBackboneColumns",
        "type": "int",
        "description": "Number of columns in the grid layout for non-backbone topologies.",
        "default": "2",
        "range_or_options": "2-10000"
      },
      {
        "name": "TotalIntraRouters",
        "type": "int",
        "description": "Total number of routers within an area.",
        "default": "6",
        "range_or_options": "1-10000"
      },
      {
        "name": "InterfaceType",
        "type": "str",
        "description": "Type of interface used in intra-area connections.",
        "default": "POINT_TO_POINT",
        "range_or_options": "POINT_TO_POINT BROADCAST"
      },
      {
        "name": "MaxInterfacePerRouter",
        "type": "int",
        "description": "Maximum number of interfaces allowed per router.",
        "default": "3",
        "range_or_options": "1-1000"
      },
      {
        "name": "MaxRouterPerTransit",
        "type": "int",
        "description": "Maximum number of routers allowed per transit network.",
        "default": "3",
        "range_or_options": "2-1000"
      }
    ],
    "description": "This function configures the Interior Gateway Protocol (IGP) topology for one or more BGP route wizard objects. It supports both single and multiple wizard inputs and ensures consistent application of the specified IGP topology parameters by delegating the configuration to each wizard’s internal `config_igp_topo` method. The function abstracts away the complexity of handling both scalar and iterable wizard inputs.",
    "example": "| Config Bgp Route Wizard Igp Topo | Wizards=@{wizard} | ProtocolType=OSPFV2 | NumberOfArea=2 | Topology=FULL_MESH | BackboneHeadendRouters=2 | CoreRouterNum=4 | BackboneRows=2 | BackboneColumns=2 | ABRNumber=CONFIG_1 | IntraTopology=TREE | NonBackboneHeadendRouters=2 | NonBackboneRows=2 | NonBackboneColumns=2 | TotalIntraRouters=6 | InterfaceType=POINT_TO_POINT | MaxInterfacePerRouter=3 | MaxRouterPerTransit=3 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.config_bgp_route_wizard_igp",
    "return_type": "BgpLinkStateRouteWizardConfig or list of BgpLinkStateRouteWizardConfig",
    "return": "Returns the configuration result(s) from applying IGP settings to the provided wizard(s). If a single wizard is passed, returns the result directly. If multiple wizards are passed, returns a list of results.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single wizard object or an iterable (list, set, tuple) containing multiple wizard objects. Each wizard must have a `config_igp` method that accepts arbitrary keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv4Prefix",
        "type": "str",
        "description": "Starting IPv4 prefix",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EndIpv4Prefix",
        "type": "str",
        "description": "Ending IPv4 prefix",
        "default": "223.225.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "IPv4 Prefix Length",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "StartSystemId",
        "type": "str",
        "description": "Starting System ID",
        "default": "10:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "SystemIdStep",
        "type": "str",
        "description": "System ID Step",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "EnableAdvLoopback",
        "type": "bool",
        "description": "Advertise router ID for loopback address",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "RouterId",
        "type": "str",
        "description": "Router ID",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "Router ID Step",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableIGPmetric",
        "type": "bool",
        "description": "Enable IGP metric",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "IgpMetricTypeIsis",
        "type": "str",
        "description": "IGP Metric TLV Type for ISIS",
        "default": "ISIS_SMALL",
        "range_or_options": "ISIS_SMALL ISIS_WIDE"
      },
      {
        "name": "IgpMetricTypeOspf",
        "type": "str",
        "description": "IGP Metric TLV Type for OSPF",
        "default": "OSPF_LINK",
        "range_or_options": "OSPF_LINK"
      },
      {
        "name": "EnableSegmentRouting",
        "type": "bool",
        "description": "Enable segment routing",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Algorithm",
        "type": "str",
        "description": "Algorithms used in Segment Routing",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelType",
        "type": "str",
        "description": "SID/Label Type",
        "default": "BIT20_LABEL",
        "range_or_options": "BIT20_LABEL BIT32_SID"
      },
      {
        "name": "SidLabelBase",
        "type": "int",
        "description": "SID/Label Base value",
        "default": "100",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SidLabelRange",
        "type": "int",
        "description": "SID/Label Range value",
        "default": "100",
        "range_or_options": "1-16777215"
      },
      {
        "name": "LinkAdjSidLabel",
        "type": "int",
        "description": "Link SID/Label",
        "default": "9001",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "PrefixAdjSidLabel",
        "type": "int",
        "description": "Prefix SID/Label",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "SidLabelStep",
        "type": "int",
        "description": "Link SID/Label Step",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableTeOptions",
        "type": "bool",
        "description": "Enable traffic engineering options",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableVaryheaderendMetric",
        "type": "bool",
        "description": "Vary headerend router metric",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderendMetricEnableIGPMetric",
        "type": "bool",
        "description": "Use IGP metric in headerend metric",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderendMetricEnableSegmentRoutingWeight",
        "type": "bool",
        "description": "Use Segment Routing weight in headerend metric",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "HeaderendMetricEnablePrefixMetric",
        "type": "bool",
        "description": "Use Prefix metric in headerend metric",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableReservableStep",
        "type": "bool",
        "description": "Enable Reservable step",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ReservableStep",
        "type": "int",
        "description": "Reservable step value",
        "default": "10000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUnreserved",
        "type": "bool",
        "description": "Enable Unreserved bandwidth per priority",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 0",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 1",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 2",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 3",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 4",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 5",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 6",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Unreserved Bandwidth Priority 7",
        "default": "100000",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "This function configures the Interior Gateway Protocol (IGP) settings for one or more BGP route wizard objects. It standardizes input handling by ensuring the 'Wizards' parameter is always treated as an iterable, even if a single object is passed. The provided keyword arguments are then passed to each wizard's `config_igp` method, and the results are collected and returned accordingly.",
    "example": ".. code:: RobotFramework\n\n    | Config Bgp Route Wizard Igp | Wizards=@{wizard} | Ipv4Prefix=1.1.1.0 | RouterId=1.1.1.1"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.config_bgp_route_wizard_igp_te_option",
    "return_type": "list or BgpLsTeLinkConfig",
    "return": "If a single wizard is provided, returns the configuration result object (BgpLsTeLinkConfig). If multiple wizards are provided, returns a list of configuration results for each wizard.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single BGP route wizard object or an iterable (e.g., list) of wizard objects. Each must have a `config_link_state_route_te` method to apply the IGP TE configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableInterfaceIp",
        "type": "bool",
        "description": "Enables local IPv4 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIp",
        "type": "str",
        "description": "Local IPv4 address to be used if EnableInterfaceIp is True.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableNeighborIp",
        "type": "bool",
        "description": "Enables remote IPv4 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIp",
        "type": "str",
        "description": "Remote IPv4 address to be used if EnableNeighborIp is True.",
        "default": "0.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableInterfaceIpv6",
        "type": "bool",
        "description": "Enables local IPv6 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIpv6",
        "type": "str",
        "description": "Local IPv6 address to be used if EnableInterfaceIpv6 is True.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableNeighborIpv6",
        "type": "bool",
        "description": "Enables remote IPv6 address configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIpv6",
        "type": "str",
        "description": "Remote IPv6 address to be used if EnableNeighborIpv6 is True.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableGroup",
        "type": "bool",
        "description": "Enables group configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Group",
        "type": "int",
        "description": "Group number for grouping links.",
        "default": "1",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUniLinkLoss",
        "type": "bool",
        "description": "Enables unidirectional link loss configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LinkLoss",
        "type": "int",
        "description": "Unidirectional link loss value in percentage.",
        "default": "3",
        "range_or_options": "1-100"
      },
      {
        "name": "LinkLossAflag",
        "type": "bool",
        "description": "A-flag for link loss metric.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableUniDelay",
        "type": "bool",
        "description": "Enables unidirectional delay configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniDelay",
        "type": "int",
        "description": "Unidirectional delay value in microseconds.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UniAflag",
        "type": "bool",
        "description": "A-flag for unidirectional delay metric.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableUniMinMaxDelay",
        "type": "bool",
        "description": "Enables unidirectional minimum/maximum delay range.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniMinMaxAflag",
        "type": "bool",
        "description": "A-flag for unidirectional min/max delay metric.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniMinDelay",
        "type": "int",
        "description": "Minimum unidirectional delay in microseconds.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UniMaxDelay",
        "type": "int",
        "description": "Maximum unidirectional delay in microseconds.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUniDelayVariation",
        "type": "bool",
        "description": "Enables unidirectional delay variation (jitter).",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniVarDelay",
        "type": "int",
        "description": "Unidirectional delay variation in microseconds.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUniResidual",
        "type": "bool",
        "description": "Enables unidirectional residual bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniResBandwidth",
        "type": "int",
        "description": "Unidirectional residual bandwidth in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUniAva",
        "type": "bool",
        "description": "Enables unidirectional available bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniAvaBandwidth",
        "type": "int",
        "description": "Unidirectional available bandwidth in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUniUtilized",
        "type": "bool",
        "description": "Enables unidirectional utilized bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UniUtilized",
        "type": "int",
        "description": "Unidirectional utilized bandwidth in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableMaximum",
        "type": "bool",
        "description": "Enables maximum bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Maximum",
        "type": "int",
        "description": "Maximum bandwidth in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableReservable",
        "type": "bool",
        "description": "Enables reservable bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Reservable",
        "type": "int",
        "description": "Reservable bandwidth in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableUnreserved",
        "type": "bool",
        "description": "Enables unreserved bandwidth priority configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Unreserved bandwidth priority level 0 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Unreserved bandwidth priority level 1 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Unreserved bandwidth priority level 2 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Unreserved bandwidth priority level 3 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Unreserved bandwidth priority level 4 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Unreserved bandwidth priority level 5 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Unreserved bandwidth priority level 6 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Unreserved bandwidth priority level 7 in bytes per second.",
        "default": "100000",
        "range_or_options": "1-4294967295"
      },
      {
        "name": "EnableTeDefaultMetric",
        "type": "bool",
        "description": "Enables default TE metric configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TeDefaultValue",
        "type": "int",
        "description": "Default TE metric value.",
        "default": "0",
        "range_or_options": "1-4294967295"
      }
    ],
    "description": "This function configures Traffic Engineering (TE) options under IGP (Interior Gateway Protocol) for one or more BGP route wizards. It wraps and uniformly applies configurations via the internal `config_link_state_route_te` method on each wizard object. The configuration parameters can include interface IP settings, link metrics, delay, bandwidth, and other TE-specific properties.",
    "example": "| Create Bgp Route Wizard Igp Te Option | Wizards=@{Wizards} | EnableInterfaceIp=True | InterfaceIp=192.168.1.1 | EnableNeighborIp=True | NeighborIp=192.168.1.2 | EnableUniDelay=True | UniDelay=50000"
  },
  {
    "method_name": "TesterLibrary.Wizard.bgp_route.expand_bgp_route_wizard",
    "return_type": "bool",
    "return": "True to indicate successful expansion of all provided wizards; False will raise a ContinuableFailure exception.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single wizard object or an iterable containing multiple wizard objects. Each wizard is expected to have an `expand()` method for configuration generation.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "Expands the BGP route wizard(s) provided. This function supports both single wizard objects and collections of wizards (lists, sets, or tuples). Internally, it converts single wizard objects into a list for uniform processing. It then calls the `expand()` method on each wizard to perform the configuration generation. If any wizard fails to expand, a `ContinuableFailure` exception is raised.",
    "example": ".. code:: RobotFramework\n\n    | Expand Bgp Route Wizard | Wizards=@{Wizards} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.create_isis_lsp_wizard",
    "return_type": "IsisLspWizardConfig",
    "return": "An initialized instance of ``IsisLspWizardConfig`` configured with the provided sessions and optional settings. This object can be used to perform further operations related to ISIS LSP configuration and control.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of session objects associated with ISIS protocol sessions. These sessions will be used by the wizard for configuring and managing ISIS LSPs.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CreateLspLevel",
        "type": "str",
        "description": "Specifies the level(s) at which LSPs are created. If not specified, defaults to CREATE_L2_LSP.",
        "default": "CREATE_L2_LSP",
        "range_or_options": "CREATE_L1_LSP CREATE_L2_LSP CREATE_L1_L2_LSP"
      }
    ],
    "description": "This function creates an ISIS LSP (Link State Protocol) Wizard object that is used to configure and manage ISIS LSP sessions in the test framework. It accepts a list of session objects and optional keyword arguments to define specific behaviors such as LSP creation level. The returned wizard object allows for further configuration and execution of ISIS-related actions within the test scenario.",
    "example": ".. code:: RobotFramework\n\n    | Create Isis Lsp Wizard | Sessions=@{sessions} | CreateLspLevel=CREATE_L1_LSP"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_network_topo",
    "return_type": "bool or list of bool",
    "return": "If a single wizard is configured, returns a boolean indicating success or failure. If multiple wizards are configured, returns a list of booleans for each configuration result.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list or object",
        "description": "A list or single instance of IS-IS LSP wizard objects to configure the network topology on.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "The type of network topology to configure.",
        "default": "TREE",
        "range_or_options": "NONE TREE GRID FULL_MESH RING HUB_SPOKE"
      }
    ],
    "kwargs": [
      {
        "name": "TreeSimulatedRoutersCount",
        "type": "int",
        "description": "Number of simulated routers in tree topology.",
        "default": "10",
        "range_or_options": "1-10000"
      },
      {
        "name": "TreeInterfaceType",
        "type": "str",
        "description": "Interface type in tree topology.",
        "default": "BROADCAST",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "TreeMaxInterfacesPerRouter",
        "type": "int",
        "description": "Maximum interfaces per router in tree topology.",
        "default": "4",
        "range_or_options": "2-100"
      },
      {
        "name": "TreeMaxRoutersPerTransitNetwork",
        "type": "int",
        "description": "Maximum number of routers per transit network in tree topology.",
        "default": "5",
        "range_or_options": "2-10000"
      },
      {
        "name": "GridSimulatedRoutersCount",
        "type": "int",
        "description": "Number of simulated routers in grid topology.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "GridSimulatedRoutersPerEmulatedRouter",
        "type": "int",
        "description": "Number of simulated routers per emulated router in grid topology.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "GridNumberOfRows",
        "type": "int",
        "description": "Number of rows in grid topology.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "GridNumberOfColumns",
        "type": "int",
        "description": "Number of columns in grid topology.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "GridEmulatedRouterPosition",
        "type": "str",
        "description": "Position of emulated router in grid topology.",
        "default": "ATTACHED",
        "range_or_options": "ATTACHED MEMBER"
      },
      {
        "name": "GridEmulatedRouterRowIndex",
        "type": "int",
        "description": "Row index of emulated router in grid topology.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "GridEmulatedRouterColumnIndex",
        "type": "int",
        "description": "Column index of emulated router in grid topology.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "MeshSimulatedRoutersCount",
        "type": "int",
        "description": "Number of simulated routers in full mesh topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MeshSimulatedRoutersPerEmulatedRouter",
        "type": "int",
        "description": "Number of simulated routers per emulated router in full mesh topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "MeshNumberOfRouters",
        "type": "int",
        "description": "Number of routers in full mesh topology.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "MeshEmulatedRouterPosition",
        "type": "str",
        "description": "Position of emulated router in full mesh topology.",
        "default": "ATTACHED",
        "range_or_options": "ATTACHED MEMBER"
      },
      {
        "name": "RingSimulatedRoutersCount",
        "type": "int",
        "description": "Number of simulated routers in ring topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "RingSimulatedRoutersPerEmulatedRouter",
        "type": "int",
        "description": "Number of simulated routers per emulated router in ring topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "RingNumberOfRouters",
        "type": "int",
        "description": "Number of routers in ring topology.",
        "default": "10",
        "range_or_options": "1-10000"
      },
      {
        "name": "RingEmulatedRouterPosition",
        "type": "str",
        "description": "Position of emulated router in ring topology.",
        "default": "ATTACHED",
        "range_or_options": "ATTACHED MEMBER"
      },
      {
        "name": "HubSimulatedRoutersCount",
        "type": "int",
        "description": "Number of simulated routers in hub-and-spoke topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "HubSimulatedRoutersPerEmulatedRouter",
        "type": "int",
        "description": "Number of simulated routers per emulated router in hub-and-spoke topology.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "HubNumberOfRouters",
        "type": "int",
        "description": "Number of routers in hub-and-spoke topology.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "HubEmulatedRouterPosition",
        "type": "str",
        "description": "Position of emulated router in hub-and-spoke topology.",
        "default": "ATTACHED_TO_HUB",
        "range_or_options": "ATTACHED_TO_HUB ATTACHED_TO_SPOKE MEMBERAS_HUB MEMBERAS_SPOKE"
      }
    ],
    "description": "This function configures the network topology for one or more IS-IS LSP (Link State Packet) wizards. It supports multiple topology types such as TREE, GRID, FULL_MESH, RING, and HUB_SPOKE, with corresponding parameters specific to each topology. Each wizard must have a method named `config_network_topo` that accepts the provided parameters.",
    "example": "| Config Isis Lsp Wizard Network Topo | Wizards=@{wizard} | Type=TREE | TreeSimulatedRoutersCount=20 | TreeInterfaceType=P2P |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_isis",
    "return_type": "bool",
    "return": "True if the IS-IS configuration was successfully applied to all wizards, False otherwise.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list",
        "description": "A list of IS-IS LSP wizard objects that will have the IS-IS configuration applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "InterfaceStartIpv4Prefix",
        "type": "str",
        "description": "The starting IPv4 prefix for interfaces/routes.",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "InterfaceEndIpv4Prefix",
        "type": "str",
        "description": "The ending IPv4 prefix for interfaces/routes.",
        "default": "223.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "InterfaceStartIpv6Prefix",
        "type": "str",
        "description": "The starting IPv6 prefix for interfaces/routes.",
        "default": "2000::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "InterfaceEndIpv6Prefix",
        "type": "str",
        "description": "The ending IPv6 prefix for interfaces/routes.",
        "default": "3ffe::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "AdvertiseLoopbackAddress",
        "type": "bool",
        "description": "Whether to advertise loopback addresses via IS-IS.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableTrafficEngine",
        "type": "bool",
        "description": "Enables Traffic Engineering (TE) configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSegmentRouting",
        "type": "bool",
        "description": "Enables Segment Routing (SR) configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSegmentRoutingIPv6",
        "type": "bool",
        "description": "Enables Segment Routing for IPv6 (SRv6) configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableFlexAlgo",
        "type": "bool",
        "description": "Enables Flex Algorithm configuration in IS-IS.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StartSystemId",
        "type": "str",
        "description": "Starting System ID (in MAC address format).",
        "default": "10:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "SystemIdStep",
        "type": "str",
        "description": "Step increment for System ID.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "valid MAC address"
      },
      {
        "name": "StartRouterId",
        "type": "str",
        "description": "Starting Router ID (IPv4 address format).",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "Step increment for Router ID (IPv4 address format).",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "StartIPv6RouterId",
        "type": "str",
        "description": "Starting Router ID for IPv6 (IPv6 address format).",
        "default": "2000::2",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "RouterIdIPv6Step",
        "type": "int",
        "description": "Step increment for IPv6 Router ID.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures IS-IS protocol settings on one or more LSP (Link State PDU) wizards. It allows setting various IS-IS parameters such as interface prefixes, system IDs, router IDs, and advanced features like Segment Routing (SR), SRv6, and Flex Algorithm. The function applies the provided configuration to each wizard object in the list. If any configuration fails, it raises a ContinuableFailure exception.",
    "example": ".. code:: RobotFramework\n\n    | Config Isis Lsp Wizard Isis | Wizards=@{wizard} | InterfaceStartIpv4Prefix=192.168.1.0 | EnableSegmentRouting=True"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_isis_te",
    "return_type": "IsisTeWizardConfig or list of IsisTeWizardConfig",
    "return": "Returns a single `IsisTeWizardConfig` object if one wizard is processed, or a list of such objects if multiple wizards are provided.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list",
        "description": "A list of IS-IS LSP configuration wizard objects that will have TE parameters configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableInterfaceIp",
        "type": "bool",
        "description": "Whether to include the local IPv4 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIp",
        "type": "str",
        "description": "Local IPv4 address. Must be a valid IP address.",
        "default": "'0.0.0.0'",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableNeighborIp",
        "type": "bool",
        "description": "Whether to include the neighbor's IPv4 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIp",
        "type": "int",
        "description": "Neighbor's IPv4 address represented as an integer. (Note: This may be an unusual representation and should be verified.)",
        "default": "10",
        "range_or_options": "valid IPv4 address representation as int"
      },
      {
        "name": "EnableInterfaceIpv6",
        "type": "bool",
        "description": "Whether to include the local IPv6 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "InterfaceIpv6",
        "type": "str",
        "description": "Local IPv6 address. Must be a valid IPv6 address.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableNeighborIpv6",
        "type": "bool",
        "description": "Whether to include the neighbor's IPv6 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "NeighborIpv6",
        "type": "str",
        "description": "Neighbor IPv6 address. Must be a valid IPv6 address.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableTeGroup",
        "type": "bool",
        "description": "Whether to include the TE group identifier.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "TeGroup",
        "type": "int",
        "description": "TE group identifier value.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMaxBandwidth",
        "type": "bool",
        "description": "Whether to include the maximum link bandwidth.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximunLink",
        "type": "int",
        "description": "Maximum link bandwidth in bytes per second.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableResBandwidth",
        "type": "bool",
        "description": "Whether to include the maximum reservable bandwidth.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximumReservableLink",
        "type": "int",
        "description": "Maximum reservable bandwidth in bytes per second.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableUnresBandwidth",
        "type": "bool",
        "description": "Whether to include unreserved bandwidth values for each priority level.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 0 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 1 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 2 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 3 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 4 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 5 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 6 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Unreserved bandwidth at priority level 7 in bytes per second.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures Traffic Engineering (TE) parameters for one or more IS-IS LSP wizards. It wraps the internal Renix-specific function and ensures that all keyword arguments passed are applied to each wizard. If only one wizard is used, the result is returned directly; otherwise, a list of results is returned.",
    "example": "| Config Isis Lsp Wizard Isis Te | Wizards=@{wizard} | EnableInterfaceIp=True | InterfaceIp=192.168.1.1 | TeGroup=10 | MaximunLink=10000000 | UnreservedBandwidth0=1000000 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_isis_sr",
    "return_type": "list or object",
    "return": "If multiple wizards are provided, returns a list of configuration results from each wizard's `config_isis_sr` method. If only one wizard is provided, returns the result of its `config_isis_sr` method directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single ISIS LSP wizard object or an iterable containing multiple wizard objects. Each wizard must have a `config_isis_sr` method that accepts arbitrary keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ValueType",
        "type": "str",
        "description": "Specifies the value type for SR capability Sub-TLV.",
        "default": "BIT20",
        "range_or_options": "BIT20 BIT32"
      },
      {
        "name": "CapabilityFlags",
        "type": "list",
        "description": "List of flags indicating SR capabilities.",
        "default": "['IPv4_CAPABLE']",
        "range_or_options": "IPv4_CAPABLE IPv6_CAPABLE"
      },
      {
        "name": "SidLabelBase",
        "type": "list",
        "description": "SID/Label base values.",
        "default": "[800000]",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelRange",
        "type": "list",
        "description": "SID/Label range values.",
        "default": "[80000]",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableMappingServer",
        "type": "bool",
        "description": "Enables/disables Mapping Server.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidStart",
        "type": "int",
        "description": "Starting SID/Index for Node SID.",
        "default": "101",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidStep",
        "type": "int",
        "description": "Step increment for Node SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidAlgorithm",
        "type": "int",
        "description": "Algorithm used for Node SID.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidFlags",
        "type": "list",
        "description": "Flags associated with Node SID.",
        "default": "['NODESID', 'NOPHP']",
        "range_or_options": "NOSHOW ADVERTISEMENT NODESID NOPHP EXPLICIT VALUE LOCAL"
      },
      {
        "name": "EnablePrefixSid",
        "type": "bool",
        "description": "Enables/disables Prefix SID.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixSidStart",
        "type": "int",
        "description": "Starting SID/Index for Prefix SID.",
        "default": "11000",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixSidStep",
        "type": "int",
        "description": "Step increment for Prefix SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableNeighborSid",
        "type": "bool",
        "description": "Enables/disables Neighbor SID.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "NeighborSidStart",
        "type": "int",
        "description": "Starting SID/Index for Neighbor SID.",
        "default": "9001",
        "range_or_options": "not_found"
      },
      {
        "name": "NeighborSidStep",
        "type": "int",
        "description": "Step increment for Neighbor SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "NeighborSidWeight",
        "type": "int",
        "description": "Weight assigned to Neighbor SID.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "NeighborSidFlags",
        "type": "list",
        "description": "Flags associated with Neighbor SID.",
        "default": "['VALUE', 'LOCAL']",
        "range_or_options": "NOSHOW ADDRESS BACKUP VALUE LOCAL SET PERSISTENT"
      },
      {
        "name": "EnableAnycastSid",
        "type": "bool",
        "description": "Enables/disables Anycast SID.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastRangeSize",
        "type": "int",
        "description": "Size of the Anycast SID range.",
        "default": "80000",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastBaseSid",
        "type": "int",
        "description": "Base SID for Anycast.",
        "default": "800000",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastSidStart",
        "type": "int",
        "description": "Starting SID/Index for Anycast SID.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastSidFlags",
        "type": "list",
        "description": "Flags associated with Anycast SID.",
        "default": "['NODESID', 'NOPHP']",
        "range_or_options": "NOSHOW ADVERTISEMENT NODESID NOPHP EXPLICIT VALUE LOCAL"
      },
      {
        "name": "AnycastIpv4Address",
        "type": "str",
        "description": "IPv4 address for Anycast SID.",
        "default": "192.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "AnycastIpv6Address",
        "type": "str",
        "description": "IPv6 address for Anycast SID.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      }
    ],
    "description": "Configures ISIS SR (Segment Routing) settings for one or more ISIS LSP (Link State Packet) wizards. This function ensures uniform configuration across multiple wizards by invoking the `config_isis_sr` method on each of them with the provided keyword arguments.",
    "example": "| Config Isis Lsp Wizard Isis Sr | Wizards=@{wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_isis_srv6",
    "return_type": "list or IsisSrv6WizardConfig",
    "return": "如果提供多个向导对象，则返回包含每个向导配置结果的列表；如果仅提供一个向导对象，则直接返回该向导的配置结果。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "单个或多个ISIS LSP向导对象。这些对象必须具有`config_isis_srv6`方法以接受SRv6配置参数。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "MtId",
        "type": "int",
        "description": "多拓扑ID，用于区分不同的拓扑结构。",
        "default": "2",
        "range_or_options": "not_found"
      },
      {
        "name": "Metric",
        "type": "int",
        "description": "路由度量值，表示路径成本。",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "Flags",
        "type": "list",
        "description": "LSP标志位，控制某些行为。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN D_BIT A_BIT UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "使用的路径计算算法，默认为0。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NumLocator",
        "type": "int",
        "description": "Locator数量，用于定义SRv6定位器的数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "LocatorSize",
        "type": "int",
        "description": "Locator大小（前缀长度），单位为比特。",
        "default": "64",
        "range_or_options": "not_found"
      },
      {
        "name": "Locator",
        "type": "str",
        "description": "Locator地址，IPv6格式。",
        "default": "'aaaa:1:1:1::'",
        "range_or_options": "not_found"
      },
      {
        "name": "LocatorStep",
        "type": "int",
        "description": "每次创建新Locator时的步长增量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "EndFlags",
        "type": "list",
        "description": "端点标志位，用于控制端点行为。",
        "default": "['UNKNOWN']",
        "range_or_options": "UNKNOWN UNUSED0 UNUSED1 UNUSED2 UNUSED3 UNUSED4 UNUSED5 UNUSED6 UNUSED7"
      },
      {
        "name": "EndpointFunc",
        "type": "str",
        "description": "端点行为，定义了SRv6端点的功能。",
        "default": "'END_NO'",
        "range_or_options": "END_NO END_PSP END_USP END_PSP_USP END_X_NO END_X_PSP END_X_USP END_X_PSP_USP END_T_NO END_T_PSP END_T_USP END_T_PSPS_USP END_B6 END_B6_ENCAPS END_BM END_DX6 END_DX4 EDN_DT6 END_DT4 END_DT46 END_DX2 END_DX2V END_DX2U END_DX2M END_S END_B6_RED END_B6_ENCAPS_RED END_WITH_USD END_PSP_USD END_USP_USD END_PSP_USP_USD END_X_USD END_X_PSP_USD END_X_USP_USD END_X_PSP_USP_USD END_T_USD END_T_PSP_USD END_T_USP_USD END_T_PSP_USP_USD"
      },
      {
        "name": "EnableCustom",
        "type": "bool",
        "description": "是否启用自定义端点行为。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomFunc",
        "type": "int",
        "description": "自定义端点行为编号，当`EnableCustom`为True时有效。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NumOfSid",
        "type": "int",
        "description": "SID（Segment Identifier）数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "SID",
        "type": "str",
        "description": "SID地址，IPv6格式。",
        "default": "'::1'",
        "range_or_options": "not_found"
      },
      {
        "name": "SIDStep",
        "type": "str",
        "description": "每次创建新SID时的步长增量，IPv6格式。",
        "default": "'::1'",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于在IS-IS协议中配置SRv6功能。它接收一个或多个ISIS LSP向导对象，并统一应用SRv6相关配置参数。支持对Locator、SID、端点行为等SRv6特性的详细设置。",
    "example": "| Config Isis Lsp Wizard Isis Srv6 | Wizards=@{wizard} | MtId=2 | Metric=10 | EndpointFunc=END_PSP | NumLocator=2 | Locator=bbbb:2:2:2:: | SID=::2 | SIDStep=::1"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_isis_flex_algo",
    "return_type": "IsisFlexAlgoWizardConfig or list of IsisFlexAlgoWizardConfig",
    "return": "If a single wizard is provided, returns the configured ISIS Flex Algorithm Wizard object. If multiple wizards are provided, returns a list of configured objects.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single LSP wizard object or an iterable (list, set, tuple) of LSP wizard objects for which the ISIS Flex Algorithm configuration will be applied.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "FlexAlgo",
        "type": "int",
        "description": "Flex Algorithm number to configure.",
        "default": "128",
        "range_or_options": "128-255"
      },
      {
        "name": "Count",
        "type": "int",
        "description": "Number of FAD sub-TLVs to configure.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "AlgorithmStep",
        "type": "int",
        "description": "Step value for Flex Algorithm.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "MetricType",
        "type": "str",
        "description": "Metric type used in Flex Algorithm calculation.",
        "default": "IGP_METRIC",
        "range_or_options": "IGP_METRIC MIN_LINK_DELAY TE_METRIC"
      },
      {
        "name": "CalType",
        "type": "int",
        "description": "Calculation type for the algorithm.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "Priority level for the Flex Algorithm.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableExcludeAdmin",
        "type": "bool",
        "description": "Whether to enable Exclude Admin Group filtering.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ExcludeAdmin",
        "type": "list",
        "description": "List of admin groups to exclude.",
        "default": "[0]",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableIncludeAnyAdmin",
        "type": "bool",
        "description": "Whether to enable Include-Any Admin Group filtering.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "IncludeAnyAdmin",
        "type": "list",
        "description": "List of admin groups for Include-Any condition.",
        "default": "[0]",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableIncludeAllAdmin",
        "type": "bool",
        "description": "Whether to enable Include-All Admin Group filtering.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "IncludeAllAdmin",
        "type": "list",
        "description": "List of admin groups for Include-All condition.",
        "default": "[0]",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableDefinitionFlags",
        "type": "bool",
        "description": "Whether to enable Definition Flags.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "DefinitionFlags",
        "type": "list",
        "description": "List of definition flags values.",
        "default": "[80]",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableExcludeSRLG",
        "type": "bool",
        "description": "Whether to enable Exclude SRLG (Shared Risk Link Group).",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ExcludeSRLG",
        "type": "list",
        "description": "List of SRLG values to exclude.",
        "default": "[0]",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures ISIS Flex Algorithm settings for one or more LSP (Label Switched Path) wizards. It accepts either a single wizard object or a collection of wizard objects and applies the same configuration across all of them using the `config_isis_flex_algorithm` method of each wizard. This ensures uniformity in Flex Algorithm configurations for multiple LSPs.",
    "example": "| Config Isis Lsp Wizard Isis Flex Algo | Wizards=@{wizard} | FlexAlgo=130 | MetricType=TE_METRIC | EnableExcludeAdmin=True | ExcludeAdmin=[10, 20] |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_ipv4_internal_route",
    "return_type": "bool",
    "return": "Returns True if the configuration is successful, otherwise False.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list or object",
        "description": "A single wizard object or an iterable (e.g., list) of wizard objects representing ISIS LSPs to configure.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv4InternalAdvEmulatedRouters",
        "type": "bool",
        "description": "Whether to advertise IPv4 internal routes for emulated routers.",
        "default": "False",
        "range_or_options": "True: ALL; False: None"
      },
      {
        "name": "Ipv4InternalAdvSimulatedRouter",
        "type": "str",
        "description": "Which simulated routers to advertise IPv4 internal routes for.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "Ipv4InternalTotalNumberOfRoutes",
        "type": "int",
        "description": "The number of IPv4 internal routes to create.",
        "default": "20",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv4InternalRoutesOverride",
        "type": "bool",
        "description": "Enables overriding the default IPv4 prefix range for internal routes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4InternalStartRoutesPrefix",
        "type": "str",
        "description": "Starting IP prefix for IPv4 internal routes.",
        "default": "2.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4InternalEndRoutesPrefix",
        "type": "str",
        "description": "Ending IP prefix for IPv4 internal routes.",
        "default": "255.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4InternalRoutesNoneSeq",
        "type": "bool",
        "description": "Enables preventing route aggregation by disabling sequential prefixes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4InternalRoutesPrefixLenType",
        "type": "str",
        "description": "Distribution type for prefix lengths of IPv4 internal routes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "Ipv4InternalRoutesPrefixLenStart",
        "type": "int",
        "description": "Starting prefix length for IPv4 internal routes.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4InternalRoutesPrefixLenEnd",
        "type": "int",
        "description": "Ending prefix length for IPv4 internal routes.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4InternalRoutesPrefixLenInternet",
        "type": "list",
        "description": "Prefix length distribution for 'INTERNET' type, must be a list of 32 floats summing to 100.0.",
        "default": "not_found",
        "range_or_options": "length=32, sum=100.0"
      },
      {
        "name": "Ipv4InternalRoutesPrefixLenCustom",
        "type": "list",
        "description": "Prefix length distribution for 'CUSTOM' type, must be a list of 32 floats summing to 100.0.",
        "default": "not_found",
        "range_or_options": "length=32, sum=100.0"
      },
      {
        "name": "Ipv4InternalNarrowMetric",
        "type": "int",
        "description": "Default IS-IS metric value for IPv4 internal routes.",
        "default": "10",
        "range_or_options": "0-63"
      },
      {
        "name": "Ipv4InternalWideMetric",
        "type": "int",
        "description": "Extended IS-IS metric value for IPv4 internal routes.",
        "default": "10",
        "range_or_options": "0-16777214"
      }
    ],
    "description": "This function configures IPv4 internal route settings for one or more ISIS LSP (Link State PDU) wizards. It supports various configurations such as enabling/disabling route advertisement, specifying start/end IP ranges, defining prefix length distributions, and setting IS-IS metrics. The function ensures consistent configuration across multiple wizards and adapts its return type based on input count—returns a list of results for multiple wizards or a single result for one wizard.",
    "example": "| Config Isis Lsp Wizard Ipv4 Internal Route | Wizards=@{wizard} | Ipv4InternalTotalNumberOfRoutes=50 | Ipv4InternalStartRoutesPrefix=192.168.0.0 | Ipv4InternalEndRoutesPrefix=192.168.255.255 | Ipv4InternalNarrowMetric=20"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_ipv4_external_route",
    "return_type": "bool or list",
    "return": "If a single wizard is provided, returns a bool indicating success (True) or failure (False). If multiple wizards are provided, returns a list of results from each configuration.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list or object",
        "description": "A single wizard object or an iterable (e.g., list, set, tuple) of ISIS LSP wizard objects. Each must support the `config_ipv4_external_route` method for configuring IPv4 external routes.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv4ExternalAdvEmulatedRouters",
        "type": "bool",
        "description": "Enable advertising emulated routers as external routes.",
        "default": "False",
        "range_or_options": "True: ALL; False: None"
      },
      {
        "name": "Ipv4ExternalAdvSimulatedRouter",
        "type": "str",
        "description": "Specify which simulated routers to advertise as external routes.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "Ipv4ExternalTotalNumberOfRoutes",
        "type": "int",
        "description": "Number of IPv4 external routes to create.",
        "default": "0",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv4ExternalRoutesOverride",
        "type": "bool",
        "description": "Enable overriding default IPv4 prefix range for external routes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4ExternalStartRoutesPrefix",
        "type": "str",
        "description": "Starting IP prefix for external routes.",
        "default": "3.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4ExternalEndRoutesPrefix",
        "type": "str",
        "description": "Ending IP prefix for external routes.",
        "default": "255.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4ExternalRoutesNoneSeq",
        "type": "bool",
        "description": "Enable preventing route aggregation.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4ExternalRoutesPrefixLenType",
        "type": "str",
        "description": "Distribution type for prefix lengths of external routes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "Ipv4ExternalRoutesPrefixLenStart",
        "type": "int",
        "description": "Starting prefix length for distribution.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4ExternalRoutesPrefixLenEnd",
        "type": "int",
        "description": "Ending prefix length for distribution.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4ExternalRoutesPrefixLenInternet",
        "type": "list",
        "description": "List of 32 values representing percentage distribution of prefix lengths for Internet-type distribution.",
        "default": "not_found",
        "range_or_options": "Length 32 list with total sum equal to 100.0"
      },
      {
        "name": "Ipv4ExternalRoutesPrefixLenCustom",
        "type": "list",
        "description": "List of 32 values representing custom distribution of prefix lengths.",
        "default": "not_found",
        "range_or_options": "Length 32 list with total sum equal to 100.0"
      },
      {
        "name": "Ipv4ExternalNarrowMetric",
        "type": "int",
        "description": "Default IS-IS metric value for external routes.",
        "default": "10",
        "range_or_options": "0-63"
      },
      {
        "name": "Ipv4ExternalWideMetric",
        "type": "int",
        "description": "Extended IS-IS metric value for external routes.",
        "default": "10",
        "range_or_options": "0-16777214"
      }
    ],
    "description": "配置一个或多个ISIS LSP向导的IPv4外部路由设置。该函数允许批量配置多个向导对象，并返回每个配置的结果。",
    "example": "| Config Isis Lsp Wizard Ipv4 External Route | Wizards=@{wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_ipv6_internal_route",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list",
        "description": "Isis LSP 配置向导对象的列表。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv6InternalAdvEmulatedRouters",
        "type": "bool",
        "description": "控制是否通告模拟路由器的IPv6内部路由。",
        "default": "False",
        "range_or_options": "True: ALL; False: None"
      },
      {
        "name": "Ipv4InternalAdvSimulatedRouter",
        "type": "str",
        "description": "指定要通告的模拟IPv4路由器类型。",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "Ipv6InternalTotalNumberOfRoutes",
        "type": "int",
        "description": "创建的IPv6内部路由数量。",
        "default": "0",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv6InternalRoutesOverride",
        "type": "bool",
        "description": "是否覆盖默认的IPv6前缀范围。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6InternalStartRoutesPrefix",
        "type": "str",
        "description": "IPv6内部路由的起始IP前缀。",
        "default": "3000::",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "Ipv6InternalEndRoutesPrefix",
        "type": "str",
        "description": "IPv6内部路由的结束IP前缀。",
        "default": "3ffe::",
        "range_or_options": "有效的IPv6地址"
      },
      {
        "name": "Ipv6InternalRoutesNoneSeq",
        "type": "bool",
        "description": "是否禁用路由聚合。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv6InternalRoutesPrefixLenType",
        "type": "str",
        "description": "IPv6前缀长度分布类型。",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "Ipv6InternalRoutesPrefixLenStart",
        "type": "int",
        "description": "IPv6前缀长度的起始值。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6InternalRoutesPrefixLenEnd",
        "type": "int",
        "description": "IPv6前缀长度的结束值。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6InternalRoutesPrefixLenInternet",
        "type": "list",
        "description": "当PrefixLenType为INTERNET时使用的前缀长度分布。",
        "default": "not_found",
        "range_or_options": "长度为128的浮点数列表，总和为100.0"
      },
      {
        "name": "Ipv6InternalRoutesPrefixLenCustom",
        "type": "list",
        "description": "当PrefixLenType为CUSTOM时使用的自定义前缀长度分布。",
        "default": "not_found",
        "range_or_options": "长度为128的浮点数列表，总和为100.0"
      },
      {
        "name": "Ipv6InternalWideMetric",
        "type": "int",
        "description": "ISIS扩展度量值。",
        "default": "10",
        "range_or_options": "0-16777214"
      }
    ],
    "description": "该函数用于为一个或多个ISIS LSP（Link State PDU）向导配置IPv6内部路由设置。它接受一个Wizard对象列表，并将任意数量的关键字参数传递给每个向导的底层 `config_ipv6_internal_route` 方法，以统一配置IPv6内部路由信息。",
    "example": ".. code:: RobotFramework\n\n    | Config Isis Lsp Wizard Ipv6 Internal Route | Wizards=@{wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.config_isis_lsp_wizard_ipv6_external_route",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list",
        "description": "包含一个或多个 ISIS LSP 向导对象的列表，用于配置 IPv6 外部路由。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv6ExternalAdvEmulatedRouters",
        "type": "bool",
        "description": "控制是否通告模拟路由器（Emulated Routers）。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6ExternalAdvSimulatedRouter",
        "type": "str",
        "description": "指定要通告的模拟路由器类型。",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "Ipv6ExternalTotalNumberOfRoutes",
        "type": "int",
        "description": "创建的 IPv6 外部路由数量。",
        "default": "0",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv6ExternalRoutesOverride",
        "type": "bool",
        "description": "是否覆盖默认的 IPv6 前缀范围。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6ExternalStartRoutesPrefix",
        "type": "str",
        "description": "IPv6 外部路由起始 IP 前缀。",
        "default": "3001::",
        "range_or_options": "有效的 IPv6 地址"
      },
      {
        "name": "Ipv6ExternalEndRoutesPrefix",
        "type": "str",
        "description": "IPv6 外部路由结束 IP 前缀。",
        "default": "3ffe::",
        "range_or_options": "有效的 IPv6 地址"
      },
      {
        "name": "Ipv6ExternalRoutesNoneSeq",
        "type": "bool",
        "description": "是否防止路由聚合。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6ExternalRoutesPrefixLenType",
        "type": "str",
        "description": "前缀长度分布类型。",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "Ipv6ExternalRoutesPrefixLenStart",
        "type": "int",
        "description": "前缀长度的起始值。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6ExternalRoutesPrefixLenEnd",
        "type": "int",
        "description": "前缀长度的结束值。",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6ExternalRoutesPrefixLenInternet",
        "type": "list",
        "description": "当 PrefixLenType 为 INTERNET 时使用的前缀长度分布。",
        "default": "not_found",
        "range_or_options": "长度为128的列表，总和为100.0"
      },
      {
        "name": "Ipv6ExternalRoutesPrefixLenCustom",
        "type": "list",
        "description": "当 PrefixLenType 为 CUSTOM 时使用的自定义前缀长度分布。",
        "default": "not_found",
        "range_or_options": "长度为128的列表，总和为100.0"
      },
      {
        "name": "Ipv6ExternalWideMetric",
        "type": "int",
        "description": "ISIS 扩展度量值，用于影响路由选择。",
        "default": "10",
        "range_or_options": "0-16777214"
      }
    ],
    "description": "该函数用于在一个或多个 ISIS LSP 向导中配置 IPv6 外部路由设置。它将提供的关键字参数传递给每个向导的 `config_ipv6_external_route` 方法，并统一返回配置结果。如果配置失败，会抛出异常；否则返回 True。",
    "example": "| Config Isis Lsp Wizard Ipv6 External Route | Wizards=@{wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.isis_lsp.expand_isis_lsp_wizard",
    "return_type": "bool",
    "return": "True if all provided IS-IS LSP wizards are successfully expanded, otherwise False (though False will raise a ContinuableFailure).",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list or object",
        "description": "A single wizard object or an iterable (list, set, tuple) of wizard objects that represent IS-IS LSP configuration wizards. Each wizard must have an `expand()` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "This function expands one or more IS-IS LSP (Link State Protocol) wizards by invoking their `expand()` method. It is typically used in network testing scenarios to trigger configuration logic for the IS-IS protocol. If any expansion fails, it raises a ContinuableFailure exception with an appropriate message.",
    "example": ".. code:: RobotFramework\n\n    | Expand Isis Lsp Wizard | Wizards=@{Wizards} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.create_mpls_wizard",
    "return_type": "WizardConfig or False",
    "return": "Returns a WizardConfig object representing the created MPLS wizard configuration if successful, or False if the provided type is not supported.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "The type of MPLS wizard to create.",
        "default": "not_found",
        "range_or_options": "mpls_ip_vpn mpls_6vpe bgp_vpls ldp_vpls pwe"
      }
    ],
    "kwargs": [
      {
        "name": "enable_vpls_scalability",
        "type": "bool",
        "description": "Enables VPLS scalability option for applicable MPLS types.",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates an MPLS wizard configuration based on the specified type. It serves as a factory method that instantiates specific MPLS-related configuration objects (e.g., 'mpls_ip_vpn', 'bgp_vpls') depending on the input type. If the type is invalid or unsupported, it returns False. The optional keyword argument 'enable_vpls_scalability' can be used to enable scalability features when applicable.",
    "example": "| Create Mpls Wizard | Type=mpls_ip_vpn | enable_vpls_scalability=True |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.expand_mpls_wizard",
    "return_type": "bool",
    "return": "布尔值，表示MPLS向导配置是否成功生成",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "包含MPLS向导配置信息的对象，通常是一个Wizard实例，用于提供expand方法所需的上下文和逻辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于生成测试仪表中MPLS向导的配置。它调用底层实现函数renix.expand_mpls_wizard，并传入提供的Wizard对象。如果返回结果为False，则抛出ContinuableFailure异常以指示操作失败；否则返回True，表示配置成功生成。此函数通常作为对Wizard对象的expand方法的封装调用，并可能结合装饰器（如@abnormal_check）进行前置或后置处理。",
    "example": "| Expand Mpls Wizard | Wizard=${Wizard} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_port",
    "return_type": "bool",
    "return": "布尔值，表示配置操作是否成功（True）或失败（False）。",
    "description": "该函数用于通过提供的向导对象 (Wizard) 配置MPLS提供商侧端口。它封装了底层 `edit_provider_port` 方法，并允许通过关键字参数灵活设置MPLS相关配置参数。",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "向导配置对象，负责实际执行MPLS端口的编辑逻辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "list of :obj:`Port`",
        "description": "测试仪表端口对象列表，指定要配置的MPLS提供商端口。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PortIndex",
        "type": "int",
        "description": "端口索引，用于选择多个端口时的具体位置。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableSubInterface",
        "type": "bool",
        "description": "是否启用子接口。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SubInterfaceCount",
        "type": "int",
        "description": "启用子接口时的子接口数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "DUT设备的IPv4地址。",
        "default": "'192.85.1.1'",
        "range_or_options": "not_found"
      },
      {
        "name": "DutIpv4AddressStep",
        "type": "str",
        "description": "DUT IPv4地址步长，用于批量配置。",
        "default": "'0.0.1.0'",
        "range_or_options": "not_found"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "IPv4地址前缀长度。",
        "default": "24",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanId",
        "type": "int",
        "description": "VLAN ID，用于划分虚拟局域网。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanIdStep",
        "type": "int",
        "description": "VLAN ID步长，用于批量配置。",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "example": "| Edit Mpls Provider Port | Wizard=${Wizard} | Port=${Port} | EnableSubInterface=True |",
    "extended_description": "此函数简化了MPLS提供商端口的配置过程，将所有配置参数通过向导对象 (`Wizard`) 转发给底层 `edit_provider_port` 方法。支持子接口、IP地址配置、VLAN等关键MPLS设置，适用于复杂的网络测试场景。若配置失败，则抛出异常；否则返回布尔值表示成功状态。"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_customer_port",
    "return_type": "bool",
    "return": "A boolean value indicating whether the MPLS customer port configuration was successfully applied (True) or failed (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "The wizard configuration object that manages and applies changes to the test setup.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Port",
        "type": "list of :obj:`Port`",
        "description": "A list of test instrument port objects representing the customer-side ports to be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "PortIndex",
        "type": "int",
        "description": "The index of the port in the port list being configured. Used to select a specific port from the list.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableSubInterface",
        "type": "bool",
        "description": "Whether to enable sub-interfaces on the customer port for advanced segmentation of traffic.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "SubInterfaceCount",
        "type": "int",
        "description": "Number of sub-interfaces to create if sub-interface functionality is enabled.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "DutIpv4Address",
        "type": "str",
        "description": "IPv4 address assigned to the Device Under Test (DUT) interface.",
        "default": "'192.85.1.1'",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "DutIpv4AddressStep",
        "type": "str",
        "description": "Increment step for IPv4 addresses when multiple ports or sub-interfaces are involved.",
        "default": "'0.0.1.0'",
        "range_or_options": "IPv4 address format"
      },
      {
        "name": "Ipv4PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv4 subnet mask, used with the DUT's IPv4 address.",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "DutIpv6Address",
        "type": "str",
        "description": "IPv6 address assigned to the Device Under Test (DUT) interface.",
        "default": "'::'",
        "range_or_options": "IPv6 address format"
      },
      {
        "name": "DutIpv6AddressStep",
        "type": "str",
        "description": "Increment step for IPv6 addresses when multiple ports or sub-interfaces are involved.",
        "default": "'0:0:0:1::'",
        "range_or_options": "IPv6 address format"
      },
      {
        "name": "Ipv6PrefixLength",
        "type": "int",
        "description": "Prefix length for IPv6 subnet mask, used with the DUT's IPv6 address.",
        "default": "64",
        "range_or_options": "0-128"
      },
      {
        "name": "VlanId",
        "type": "int",
        "description": "VLAN identifier associated with the customer port or sub-interface.",
        "default": "1",
        "range_or_options": "1-4094"
      },
      {
        "name": "VlanIdStep",
        "type": "int",
        "description": "Increment step for VLAN IDs when configuring multiple ports or sub-interfaces.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures an MPLS customer-side port using a provided `WizardConfig` object and port information. It wraps the internal backend method which delegates configuration to `Wizard.edit_customer_port`, allowing dynamic configuration through keyword arguments. The function supports enabling sub-interfaces, setting IP addresses (IPv4/IPv6), prefix lengths, and VLAN configurations.",
    "example": ".. code:: RobotFramework\n\n    | Edit Mpls Customer Port | Wizard=${Wizard} | Port=${Port} | EnableSubInterface=True"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_router_basic_parameters",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功。True 表示成功，False 表示失败。",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "向导配置对象，用于执行MPLS提供商侧路由的参数编辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "DutRouterId",
        "type": "str",
        "description": "DUT路由ID",
        "default": "'10.0.0.1'",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "DutAsNumber",
        "type": "int",
        "description": "DUT自治域编号",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable4ByteDutAs",
        "type": "bool",
        "description": "是否启用4字节DUT自治域编号",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "FourByteDutAsNumber",
        "type": "int",
        "description": "DUT的4字节自治域编号",
        "default": "'1:1'",
        "range_or_options": "not_found"
      },
      {
        "name": "IgpProtocol",
        "type": "str",
        "description": "IGP协议类型",
        "default": "OSPF",
        "range_or_options": "OSPF ISIS RIP"
      },
      {
        "name": "MplsProtocol",
        "type": "str",
        "description": "MPLS协议类型",
        "default": "LDP",
        "range_or_options": "LDP OSPF_SR ISIS_SR"
      },
      {
        "name": "EnablePRouter",
        "type": "bool",
        "description": "是否启用P路由器",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "PRoutersPerInterface",
        "type": "int",
        "description": "每个端口/子接口中P路由器的数量",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "TopologyType",
        "type": "str",
        "description": "拓扑类型",
        "default": "Tree",
        "range_or_options": "Tree Grid"
      },
      {
        "name": "PRouterStartIp",
        "type": "str",
        "description": "P路由器接口IP地址起始值",
        "default": "'1.0.0.1'",
        "range_or_options": "有效的ipv4地址"
      },
      {
        "name": "PRouterPrefixLength",
        "type": "int",
        "description": "P路由器接口IP地址前缀长度",
        "default": "24",
        "range_or_options": "not_found"
      },
      {
        "name": "PRouterIdStart",
        "type": "str",
        "description": "P路由器ID起始地址",
        "default": "'192.0.1.1'",
        "range_or_options": "not_found"
      },
      {
        "name": "PRouterIdStep",
        "type": "str",
        "description": "P路由器ID步长",
        "default": "'0.0.1.0'",
        "range_or_options": "not_found"
      },
      {
        "name": "PeRoutersPerInterface",
        "type": "int",
        "description": "每个端口/子接口中PE路由器的数量",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "PeRouterIdStart",
        "type": "str",
        "description": "PE路由器ID起始地址",
        "default": "'10.0.0.2'",
        "range_or_options": "not_found"
      },
      {
        "name": "PeRouterIdStep",
        "type": "str",
        "description": "PE路由器ID步长",
        "default": "'0.0.0.1'",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableRouteReflectors",
        "type": "bool",
        "description": "是否启用路由反射器",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Enable6Vpe",
        "type": "bool",
        "description": "是否启用6VPE",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于通过给定的Wizard对象及其配置参数来编辑MPLS提供商侧路由器的基本参数。它是一个封装函数，实际调用底层`renix.edit_mpls_provider_router_basic_parameters`方法，并将所有关键字参数传递给该方法以完成配置。如果返回结果为False，则抛出ContinuableFailure异常；否则返回True。",
    "example": "| Edit Mpls Provider Router Basic Parameters | Wizard=${Wizard} | Port=${Port} | EnableSubInterface=True |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_router_ldp",
    "return_type": "bool",
    "return": "A boolean indicating whether the MPLS Provider Router LDP configuration was successfully updated (True) or not (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "The wizard configuration object used to manage and apply the MPLS Provider Router LDP settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "HelloType",
        "type": "str",
        "description": "Specifies the type of LDP Hello message to be used for discovery.",
        "default": "DIRECT",
        "range_or_options": "DIRECT TARGETED DIRECT_TARGETED"
      },
      {
        "name": "TransportAddressTlvMode",
        "type": "str",
        "description": "Specifies the mode for Transport Address TLV in LDP messages.",
        "default": "TESTER_IP",
        "range_or_options": "TESTER_IP ROUTER_ID NONE"
      },
      {
        "name": "LabelAdvertisementMode",
        "type": "str",
        "description": "Determines how labels are advertised between LDP peers.",
        "default": "DU",
        "range_or_options": "DU DOD"
      },
      {
        "name": "EgressLabelMode",
        "type": "str",
        "description": "Defines how egress labels are handled for outgoing packets.",
        "default": "NEXT_AVAILABLE",
        "range_or_options": "NEXT_AVAILABLE IMPLICIT EXPLICIT"
      },
      {
        "name": "MinLabel",
        "type": "int",
        "description": "Sets the minimum value for label allocation.",
        "default": "16",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationMode",
        "type": "str",
        "description": "Specifies the authentication method used for securing LDP sessions.",
        "default": "NONE",
        "range_or_options": "NONE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "The password used for authenticating LDP sessions if MD5 authentication is enabled.",
        "default": "xinertel",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures the Label Distribution Protocol (LDP) settings on an MPLS Provider Router. It acts as a wrapper that delegates the actual configuration task to the `edit_provider_router_mpls_ldp` method of the provided `Wizard` object, passing along all keyword arguments. This allows flexible and dynamic configuration updates using named parameters without requiring strict positional argument handling.",
    "example": "| Edit Mpls Provider Router Ldp | Wizard=${Wizard} | HelloType=DIRECT |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_router_ospf",
    "return_type": "bool",
    "return": "布尔值，表示配置是否成功（True 表示成功，False 表示失败）",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "向导配置对象，封装了用于网络设备配置的方法。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "AreaId",
        "type": "str",
        "description": "OSPF区域ID。",
        "default": "0.0.0.0",
        "range_or_options": "有效的IP地址格式"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "OSPF接口的网络类型。",
        "default": "BROADCAST",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "RouterPriority",
        "type": "int",
        "description": "路由器优先级，影响DR/BDR选举。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationType",
        "type": "str",
        "description": "认证类型。",
        "default": "NONE",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "认证密码。",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5Key",
        "type": "int",
        "description": "MD5密钥标识符。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Options",
        "type": "list",
        "description": "OSPF LSA选项标志。",
        "default": "EBIT",
        "range_or_options": "NONTBIT TOSBIT EBIT MCBIT NPBIT EABIT DCBIT OBIT DNBIT"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "是否启用平滑重启功能。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "GracefulRestartReason",
        "type": "str",
        "description": "平滑重启的原因。",
        "default": "UNKNOWN",
        "range_or_options": "UNKNOWN SOFTWARE RELOADORUPGRADE SWITCH"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "是否启用BFD（双向转发检测）。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "SR算法编号。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelBase",
        "type": "int",
        "description": "Segment Routing SID/标签的起始值。",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelRange",
        "type": "int",
        "description": "Segment Routing SID/标签的范围大小。",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidIndex",
        "type": "int",
        "description": "节点SID索引。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidIndexStep",
        "type": "int",
        "description": "节点SID索引步长。",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于在MPLS环境中配置提供商侧路由路由器的OSPF协议。它是一个封装函数，调用底层`renix.edit_mpls_provider_router_ospf`方法进行实际配置。支持的参数包括区域ID、网络类型、认证方式、BFD、SR相关配置等。若配置失败，则抛出ContinuableFailure异常；若成功，则返回True。",
    "example": ".. code:: RobotFramework\n\n    | Edit Mpls Provider Router Ospf | Wizard=${Wizard} | AreaId=1.1.1.1 | NetworkType=P2P | AuthenticationType=MD5 | Password=secure123 | EnableBfd=True"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_router_isis",
    "return_type": "bool",
    "return": "A boolean indicating whether the ISIS protocol configuration for the MPLS provider router was successfully updated (True) or not (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "An instance of WizardConfig that provides methods to configure and edit network settings, particularly for MPLS routers.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "UseSrcMacAsSystemId",
        "type": "bool",
        "description": "Indicates whether the source MAC address should be used as the System ID in ISIS.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "SystemId",
        "type": "str",
        "description": "The System ID used by ISIS. This is a unique identifier for the router in the ISIS domain.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "not_found"
      },
      {
        "name": "SystemIdStep",
        "type": "str",
        "description": "The increment step used when assigning multiple System IDs.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "not_found"
      },
      {
        "name": "Level",
        "type": "str",
        "description": "The ISIS routing level to operate on.",
        "default": "L2",
        "range_or_options": "L1 L2 L1L2"
      },
      {
        "name": "NetworkType",
        "type": "str",
        "description": "The type of network the interface is connected to.",
        "default": "BROADCAST",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "RouterPriority",
        "type": "int",
        "description": "The priority value used in DIS (Designated Intermediate System) elections.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "MetricMode",
        "type": "str",
        "description": "The metric style used by ISIS for path selection.",
        "default": "NARROWWIDE",
        "range_or_options": "NARROW WIDE NARROWWIDE"
      },
      {
        "name": "AuthenticationMode",
        "type": "str",
        "description": "The mode of authentication used in ISIS packets.",
        "default": "None",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "The password used for simple or MD5 authentication.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "AreaId",
        "type": "int",
        "description": "The area identifier for the ISIS routing domain.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableGracefulRestart",
        "type": "bool",
        "description": "Enables graceful restart functionality for ISIS.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "MultiTopologyId",
        "type": "list",
        "description": "Specifies which topologies are supported for ISIS.",
        "default": "None",
        "range_or_options": "NOSHOW IPV4 IPV6"
      },
      {
        "name": "EnableBfd",
        "type": "bool",
        "description": "Enables BFD (Bidirectional Forwarding Detection) support for fast failure detection.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "HelloPadding",
        "type": "bool",
        "description": "Controls whether padding is added to Hello packets.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "Algorithm",
        "type": "int",
        "description": "Specifies the algorithm used for Segment Routing (SR).",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelBase",
        "type": "int",
        "description": "The base value for SR SID/Label allocation.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelRange",
        "type": "int",
        "description": "The range of SR SIDs/Labels allocated from the base.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidIndex",
        "type": "int",
        "description": "The index used for the node's SR SID.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidIdnexStep",
        "type": "int",
        "description": "The step size used to increment the Node SID Index for multiple assignments.",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures the ISIS routing protocol on an MPLS provider edge (PE) router using a provided Wizard object. It wraps around a backend method `renix.edit_mpls_provider_router_isis` and forwards all keyword arguments to it. The function returns True if the configuration was successful, and raises a ContinuableFailure exception if it fails.",
    "example": "| Edit Mpls Provider Router Isis | Wizard=${Wizard} | Level=L2 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_router_rip",
    "return_type": "bool",
    "return": "A boolean indicating whether the RIP configuration for the MPLS provider router was successfully edited.",
    "description": "Configures or modifies the RIP (Routing Information Protocol) settings on an MPLS provider router using a Wizard configuration object. This function provides a simplified interface to configure various RIP parameters such as version, update type, authentication, and route update behavior.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object used to apply changes to the MPLS provider router's RIP settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RipVersion",
        "type": "str",
        "description": "Specifies the version of the RIP protocol to be used.",
        "default": "RIPV2",
        "range_or_options": "RIPV1 RIPV2 RIPNG"
      },
      {
        "name": "UpdateType",
        "type": "str",
        "description": "Defines how route updates are transmitted across the network.",
        "default": "MULTICAST",
        "range_or_options": "BROADCAST MULTICAST UNICAST"
      },
      {
        "name": "UpdateInterval",
        "type": "int",
        "description": "Sets the interval (in seconds) between periodic route updates.",
        "default": "30",
        "range_or_options": "not_found"
      },
      {
        "name": "UpdateJitter",
        "type": "int",
        "description": "Introduces random jitter to the update interval to avoid synchronization issues.",
        "default": "0",
        "range_or_options": "0-5"
      },
      {
        "name": "MaxRouteNumPerUpdate",
        "type": "int",
        "description": "Limits the maximum number of routes included in each update packet.",
        "default": "25",
        "range_or_options": "not_found"
      },
      {
        "name": "AuthenticationMode",
        "type": "str",
        "description": "Specifies the authentication method used for secure routing updates.",
        "default": "None",
        "range_or_options": "NONE SIMPLE MD5"
      },
      {
        "name": "Password",
        "type": "str",
        "description": "Defines the password used for simple or MD5 authentication.",
        "default": "Xinertel",
        "range_or_options": "not_found"
      },
      {
        "name": "Md5KeyId",
        "type": "int",
        "description": "Identifies the MD5 key used for authentication.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "SplitHorizon",
        "type": "bool",
        "description": "Enables or disables the split horizon mechanism to prevent routing loops.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "example": "| Edit Mpls Provider Router Rip | Wizard=${Wizard} | RipVersion=RIPNG |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_provider_route_reflector",
    "return_type": "bool",
    "return": "True if the MPLS provider route reflector configuration was successfully updated, False otherwise.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "An instance of WizardConfig that manages and applies configurations for the MPLS provider route reflector.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "RouteReflectorSource",
        "type": "str",
        "description": "Specifies whether Renix or DUT acts as the route reflector.",
        "default": "RenixAsRouteReflector",
        "range_or_options": "RenixAsRouteReflector DutAsRouteReflector"
      },
      {
        "name": "TotalBgpSessions",
        "type": "int",
        "description": "The total number of BGP sessions to be configured.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RrRouterIds",
        "type": "list",
        "description": "List of router IDs for the route reflectors.",
        "default": "[]",
        "range_or_options": "not_found"
      },
      {
        "name": "RrsPerPortOrSubInterface",
        "type": "int",
        "description": "Number of route reflectors per port or sub-interface.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RrsPerPe",
        "type": "int",
        "description": "Number of route reflectors per PE (Provider Edge) device.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RrRouterIdStart",
        "type": "str",
        "description": "Starting value for RR (Route Reflector) router IDs in IP address format.",
        "default": "7.7.7.7",
        "range_or_options": "not_found"
      },
      {
        "name": "RrRouterIdStep",
        "type": "str",
        "description": "Increment step for RR router IDs in IP address format.",
        "default": "0.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "ClusterIdStart",
        "type": "str",
        "description": "Starting value for cluster IDs in IP address format.",
        "default": "0.0.0.0",
        "range_or_options": "not_found"
      },
      {
        "name": "ClusterIdStep",
        "type": "str",
        "description": "Increment step for cluster IDs in IP address format.",
        "default": "0.0.0.1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures an MPLS provider-side route reflector by delegating the operation to the underlying `edit_provider_route_reflector` method via a `WizardConfig` object. It supports customization of various parameters such as source of route reflection, number of BGP sessions, router ID ranges, and clustering settings.",
    "example": "| Edit Mpls Provider Router Reflector | Wizard=${Wizard} | RouteReflectorSource=DutAsRouteReflector | TotalBgpSessions=5 | RrRouterIdStart=8.8.8.8 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_traffic_parameters",
    "return_type": "bool",
    "return": "A boolean value indicating whether the operation to edit traffic parameters was successful (True) or failed (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "An instance of a wizard configuration object that manages and applies traffic parameter changes internally.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TrafficFlow",
        "type": "str",
        "description": "Specifies the type of traffic flow to be configured for MPLS.",
        "default": "FullyMeshedInVpn",
        "range_or_options": "None FullyMeshedInVpn FullyMeshedInVpls Customer2Provider Provider2Customer CustomerProviderBoth"
      },
      {
        "name": "StreamBlockGrouping",
        "type": "str",
        "description": "Determines how stream blocks are grouped when generating traffic.",
        "default": "Aggregate",
        "range_or_options": "Aggregate VPNAggregate NotAggregate"
      },
      {
        "name": "UseSingleStreamNumber",
        "type": "bool",
        "description": "Indicates whether a single stream number should be used for each pair of ports.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "TrafficLoadPercentProvider",
        "type": "int",
        "description": "Specifies the percentage of traffic load applied to provider-side ports.",
        "default": "10",
        "range_or_options": "not_found"
      },
      {
        "name": "TrafficLoadPercentCustomer",
        "type": "int",
        "description": "Specifies the percentage of traffic load applied to customer-side ports.",
        "default": "10",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function is used to configure or modify MPLS traffic parameters through a provided Wizard configuration object. It delegates the actual editing process to an internal implementation within the Wizard instance, passing along any specified keyword arguments as traffic settings. If the operation fails, it raises a ContinuableFailure exception; otherwise, it returns a boolean result indicating success.",
    "example": "| Edit Traffic Parameters | Wizard=${Wizard} | TrafficFlow=FullyMeshedInVpls |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_lsp_ping",
    "return_type": "bool",
    "return": "布尔值，表示LSP Ping配置是否成功设置（True为成功，False为失败）。",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "向导配置对象，用于调用底层`edit_lsp_ping`方法进行实际的LSP Ping参数配置。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableLspPing",
        "type": "bool",
        "description": "是否启用LSP Ping功能。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DestinationIpv4Address",
        "type": "str",
        "description": "LSP Ping的目的IPv4地址。",
        "default": "'127.0.0.1'",
        "range_or_options": "not_found"
      },
      {
        "name": "PingInterval",
        "type": "int",
        "description": "发送测试包的时间间隔（单位：秒）。",
        "default": "4",
        "range_or_options": "not_found"
      },
      {
        "name": "PingTimeout",
        "type": "int",
        "description": "单次探测的超时时间（单位：秒）。",
        "default": "2",
        "range_or_options": "not_found"
      },
      {
        "name": "TimeToLive",
        "type": "int",
        "description": "数据包的生存时间（TTL值）。",
        "default": "255",
        "range_or_options": "not_found"
      },
      {
        "name": "LspExpValue",
        "type": "int",
        "description": "LSP EXP优先级值，用于QoS标记。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "ValidateFecStack",
        "type": "bool",
        "description": "是否校验FEC（转发等价类）堆栈。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "PadMode",
        "type": "str",
        "description": "填充模式，控制如何处理PAD TLV字段。",
        "default": "TransmitWithoutPadTlv",
        "range_or_options": "TransmitWithoutPadTlv RequestPeerToDropPadTlv RequestPeerToCopyPadTlv"
      },
      {
        "name": "PadData",
        "type": "list",
        "description": "自定义的填充数据列表。",
        "default": "[]",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于通过给定的Wizard对象配置MPLS网络中的LSP Ping参数。它是一个封装函数，内部调用了`renix.edit_lsp_ping`来执行实际配置。如果配置失败，会抛出异常；如果成功，则返回True。",
    "example": "| Edit Lsp Ping | Wizard=${Wizard} | EnableLspPing=True | DestinationIpv4Address=192.168.1.1 | PingInterval=5 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_parameters",
    "return_type": "bool",
    "return": "A boolean value indicating whether the MPLS VPN parameters were successfully edited (True for success, False for failure).",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "An instance of a configuration wizard class that provides methods to edit MPLS VPN settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NumberOfVpns",
        "type": "int",
        "description": "Number of VPNs to configure. This determines how many distinct VPN instances will be created or modified.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RdAssignment",
        "type": "str",
        "description": "Specifies how the Route Distinguisher (RD) is assigned for the MPLS VPN. If set to 'UseRT', RD uses the same value as RT. If set to 'Manual', RD must be specified separately.",
        "default": "UseRT",
        "range_or_options": "UseRT Manual"
      },
      {
        "name": "RouteTargetStart",
        "type": "str",
        "description": "Starting value for the Route Target (RT) used in route propagation. It defines the base RT value for the first VPN and follows the format 'X:Y'.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "RouteTargetStep",
        "type": "str",
        "description": "Increment step for the Route Target (RT) for each subsequent VPN. It determines how much the RT increases per additional VPN and follows the format 'X:Y'.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures or modifies basic MPLS VPN parameters through a provided Wizard object. It wraps an internal backend method (`renix.edit_mpls_vpn_parameters`) and allows flexible parameter input via keyword arguments. The function supports setting the number of VPNs, RD assignment strategy, starting RT value, and RT increment step. Upon failure, it raises a `ContinuableFailure` exception; otherwise, it returns a success boolean.",
    "example": ".. code:: RobotFramework\n\n    | Edit Mpls Vpn Parameters | Wizard=${Wizard} | NumberOfVpns=10"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_customer_parameters",
    "return_type": "bool",
    "return": "Returns True if the MPLS VPN customer parameters were successfully configured; otherwise, returns False.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object used to edit MPLS VPN customer-side parameters.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "VpnAssignment",
        "type": "int",
        "description": "Specifies how the VRFs are assigned to CEs. Default: RoundRobin.",
        "default": "RoundRobin",
        "range_or_options": "RoundRobin Sequential"
      },
      {
        "name": "CeProtocol",
        "type": "str",
        "description": "CE protocol used for routing. Default: BGP.",
        "default": "BGP",
        "range_or_options": "BGP RIP ISIS OSPF Static Mixed"
      },
      {
        "name": "CeProAssignment",
        "type": "str",
        "description": "Assigns a specific CE protocol with a percentage weight. Default: 'BGP=100%'.",
        "default": "'BGP=100%'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStart",
        "type": "str",
        "description": "Starting Route Distinguisher (RD) value for customer. Default: '1:0'.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerVpnEnabled",
        "type": "bool",
        "description": "Enables stepping of RD per each VPN instance. Default: True.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerVpn",
        "type": "str",
        "description": "RD step increment between each successive VPN instance when enabled. Default: '1:0'.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerCeEnabled",
        "type": "bool",
        "description": "Enables stepping of RD per each CE instance. Default: False.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerCe",
        "type": "str",
        "description": "RD step increment between each successive CE instance when enabled. Default: '0:0'.",
        "default": "'0:0'",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures the customer-side parameters for an MPLS-based Virtual Private Network (VPN) using a provided `Wizard` configuration object. It allows customization of various settings such as CE routing protocols, RD values, and assignment strategies. The actual implementation is delegated to the backend `edit_vpn_customer_parameters` method of the `Wizard` object.",
    "example": "| Edit Mpls Vpn Customer Parameters | Wizard=${Wizard} | CeProtocol=RIP |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_provider_parameters",
    "return_type": "bool",
    "return": "A boolean indicating whether the MPLS VPN provider parameters were successfully edited (True) or not (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object used to edit the MPLS VPN provider parameters.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ProviderDisSel",
        "type": "str",
        "description": "Provider distribution selector. Specifies how the distribution of Provider Edge (PE) and Virtual Private Networks (VPNs) is managed.",
        "default": "VPNsPerPE",
        "range_or_options": "VPNsPerPE PEsPerVPN"
      },
      {
        "name": "ProviderDisSelCount",
        "type": "int",
        "description": "Provider distribution selector count, determining the number of PEs per VPN or vice versa depending on ProviderDisSel value.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderMeshed",
        "type": "bool",
        "description": "Indicates if the provider network is meshed (fully interconnected).",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStart",
        "type": "str",
        "description": "Starting Route Distinguisher (RD) value for the provider side.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerVpnEnabled",
        "type": "bool",
        "description": "Whether a step increment in RD is applied per VPN.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerVpn",
        "type": "str",
        "description": "Route Distinguisher (RD) step value applied per VPN when enabled.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerCeEnabled",
        "type": "bool",
        "description": "Whether a step increment in RD is applied per Customer Edge (CE) when enabled.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerCe",
        "type": "str",
        "description": "Route Distinguisher (RD) step value applied per CE when enabled.",
        "default": "'0:0'",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures or modifies the provider-side parameters of an MPLS VPN using a Wizard configuration object. It allows setting various aspects of the provider's routing and topology behavior, such as route distinguishers, meshing, and distribution strategies. The function internally calls the backend method `renix.edit_mpls_vpn_provider_parameters` to perform the actual configuration update. If the operation fails (returns False), a `ContinuableFailure` exception is raised with a relevant message; otherwise, it returns True.",
    "example": "| Edit Mpls Vpn Provider Parameters | Wizard=${Wizard} | ProviderMeshed=True | ProviderDisSel=PEsPerVPN | ProviderRdStepPerVpn='2:0'"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_as_number",
    "return_type": "bool",
    "return": "布尔值，表示配置MPLS VPN自治域操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "向导配置对象，用于调用内部方法 edit_vpn_as_number。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CustomerEnable4ByteAsNumber",
        "type": "bool",
        "description": "启用客户侧的4字节自治系统(AS)编号。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerCeAsNumberStart",
        "type": "int",
        "description": "客户侧CE设备使用的起始AS编号。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerCeAsNumberStepPerVpnEnabled",
        "type": "bool",
        "description": "启用客户侧每个VPN的AS编号步长。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerCeAsNumberStepPerVpn",
        "type": "str",
        "description": "客户侧每个VPN的AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerCeAsNumberStepPerCeEnabled",
        "type": "bool",
        "description": "启用客户侧每个CE的AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerCeAsNumberStepPerCe",
        "type": "int",
        "description": "客户侧每个CE的AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerCe4ByteAsNumberStart",
        "type": "int",
        "description": "客户侧CE设备使用的4字节AS编号的起始值。",
        "default": "1:1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerCe4ByteAsNumberStepPerVpnEnabled",
        "type": "bool",
        "description": "启用客户侧每个VPN的4字节AS编号步长。",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerCe4ByteAsNumberStepPerVpn",
        "type": "str",
        "description": "客户侧每个VPN的4字节AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerCe4ByteAsNumberStepPerCeEnabled",
        "type": "bool",
        "description": "启用客户侧每个CE的4字节AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerCe4ByteAsNumberStepPerCe",
        "type": "str",
        "description": "客户侧每个CE的4字节AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderAppendCeAsToPath",
        "type": "str",
        "description": "在提供商侧路径中添加CE的AS编号。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderEnable4ByteAsNumber",
        "type": "int",
        "description": "启用提供商侧的4字节AS编号。",
        "default": "False",
        "range_or_options": "0 1"
      },
      {
        "name": "ProviderCeAsNumberStart",
        "type": "int",
        "description": "提供商侧CE设备使用的起始AS编号。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderCeAsNumberStepPerVpnEnabled",
        "type": "bool",
        "description": "启用提供商侧每个VPN的AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderCeAsNumberStepPerVpn",
        "type": "int",
        "description": "提供商侧每个VPN的AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderCeAsNumberStepPerCeEnabled",
        "type": "bool",
        "description": "启用提供商侧每个CE的AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderCeAsNumberStepPerCe",
        "type": "int",
        "description": "提供商侧每个CE的AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderCe4ByteAsNumberStart",
        "type": "int",
        "description": "提供商侧CE设备使用的4字节AS编号的起始值。",
        "default": "'1:1'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderCe4ByteAsNumberStepPerVpnEnabled",
        "type": "bool",
        "description": "启用提供商侧每个VPN的4字节AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderCe4ByteAsNumberStepPerVpn",
        "type": "int",
        "description": "提供商侧每个VPN的4字节AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderCe4ByteAsNumberStepPerCeEnabled",
        "type": "bool",
        "description": "启用提供商侧每个CE的4字节AS编号步长。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderCe4ByteAsNumberStepPerCe",
        "type": "int",
        "description": "提供商侧每个CE的4字节AS编号步长。",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于配置MPLS网络中的VPN自治系统(AS)编号。它通过传入的Wizard对象调用底层方法edit_vpn_as_number，并将所有关键字参数传递给该方法以进行实际配置。适用于自动化测试框架中动态修改MPLS VPN的AS编号设置。",
    "example": "| Edit Mpls Vpn As Number | Wizard=${Wizard} | CustomerEnable4ByteAsNumber=True |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_ipv4_route_customer_parameters",
    "return_type": "bool",
    "return": "A boolean indicating whether the operation was successful (True) or failed (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "The wizard configuration object used to edit MPLS/VPN IPv4 route settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CustomerStartRoute",
        "type": "str",
        "description": "Starting IP address for customer-side routes.",
        "default": "10.1.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRouteStep",
        "type": "str",
        "description": "Incremental step between customer-side routes (in dotted decimal format).",
        "default": "0.0.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerPrefixLength",
        "type": "int",
        "description": "Prefix length for customer-side routes.",
        "default": "24",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRoutesPerCe",
        "type": "int",
        "description": "Number of routes per CE (Customer Edge router) on the customer side.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerOverlapRoutes",
        "type": "bool",
        "description": "Enable overlapping routes on the customer side.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerRouteType",
        "type": "str",
        "description": "Type of customer-side route.",
        "default": "Internal",
        "range_or_options": "Internal External"
      }
    ],
    "description": "This function configures customer-specific IPv4 route parameters for an MPLS-based VPN environment using a provided Wizard configuration object. It acts as a user-facing method that wraps the actual backend call to `edit_vpn_ipv4_route_customer_parameters` within the Wizard, allowing flexible and dynamic parameter updates via keyword arguments. This is typically used in test automation scenarios where custom routing behaviors are required on the customer side of an MPLS/VPN setup.",
    "example": "| Edit Mpls Vpn Ipv4 Route Customer Parameters | Wizard=${Wizard} | CustomerStartRoute=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_ipv4_route_provider_parameters",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "向导配置对象，用于管理MPLS VPN路由提供商端侧参数的配置流程。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ProviderStartRoute",
        "type": "str",
        "description": "提供商侧起始IPv4路由地址。",
        "default": "110.1.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRouteStep",
        "type": "str",
        "description": "提供商侧路由步长，每次递增的IP地址跨度。",
        "default": "0.0.1.0",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderPrefixLength",
        "type": "int",
        "description": "提供商侧路由的前缀长度（子网掩码位数）。",
        "default": "24",
        "range_or_options": "0-32"
      },
      {
        "name": "ProviderRoutesPerCe",
        "type": "int",
        "description": "每个CE（Customer Edge）设备中模拟的路由数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderOverlapRoutes",
        "type": "bool",
        "description": "是否启用重叠路由（Overlapping Routes）。",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderLabelType",
        "type": "str",
        "description": "MPLS标签分配类型。",
        "default": "LabelPerSite",
        "range_or_options": "LabelPerSite LabelPerRoute"
      },
      {
        "name": "ProviderStartLabel",
        "type": "int",
        "description": "MPLS起始标签值。",
        "default": "16",
        "range_or_options": "16-1048575"
      }
    ],
    "description": "该函数用于通过指定的Wizard配置对象来设置或修改MPLS VPN IPv4路由的提供商端侧参数。它是一个封装函数，内部调用底层RENIX API来执行实际的配置操作。支持设置起始路由、路由步长、前缀长度、标签类型等关键参数，并可通过关键字参数传递任意数量的可选配置。",
    "example": "| Edit Mpls Vpn Ipv4 Route Provider Parameters | Wizard=${Wizard} | ProviderStartRoute=1.1.1.1 | ProviderPrefixLength=28 | ProviderLabelType=LabelPerRoute | ProviderStartLabel=100"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_ipv6_route_customer_parameters",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "向导配置对象，用于编辑MPLS VPN IPv6路由的客户端参数。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "CustomerStartRoute",
        "type": "str",
        "description": "客户侧开始路由地址，默认值：'2000::'",
        "default": "'2000::'",
        "range_or_options": "IPv6 address format"
      },
      {
        "name": "CustomerRouteStep",
        "type": "str",
        "description": "路由步长，默认值：'0:0:0:1::'",
        "default": "'0:0:0:1::'",
        "range_or_options": "IPv6 address step format"
      },
      {
        "name": "CustomerPrefixLength",
        "type": "int",
        "description": "前缀长度，默认值：64",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "CustomerRoutesPerCe",
        "type": "int",
        "description": "每个CE中的路由数量，默认值：1",
        "default": "1",
        "range_or_options": "1-..."
      },
      {
        "name": "CustomerOverlapRoutes",
        "type": "bool",
        "description": "是否启用重叠路由，默认值：False",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "CustomerRouteType",
        "type": "str",
        "description": "路由类型，默认值：Internal",
        "default": "Internal",
        "range_or_options": "Internal External"
      }
    ],
    "description": "该函数用于配置MPLS VPN中客户端侧IPv6路由的相关参数。通过传入一个Wizard对象和一组可选的关键字参数，可以设置起始路由、路由步长、前缀长度、每CE的路由数等参数。这些参数将被传递给Wizard对象的内部方法进行实际处理。",
    "example": ".. code:: RobotFramework\n\n    | Edit Mpls Vpn Ipv6 Route Customer Parameters | Wizard=${Wizard} | CustomerStartRoute=3000:: | CustomerPrefixLength=128"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpn_ipv6_route_provider_parameters",
    "return_type": "bool",
    "return": "True if the MPLS VPN IPv6 route provider parameters were successfully edited, False otherwise.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object used to edit MPLS VPN IPv6 route provider parameters.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ProviderStartRoute",
        "type": "str",
        "description": "Starting route for the provider in IPv6 format.",
        "default": "'2001::'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRouteStep",
        "type": "str",
        "description": "Step increment between successive routes in IPv6 format.",
        "default": "'0:0:0:1::'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderPrefixLength",
        "type": "int",
        "description": "Length of the prefix for IPv6 routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "ProviderRoutesPerCe",
        "type": "int",
        "description": "Number of routes per CE (Customer Edge device).",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderOverlapRoutes",
        "type": "bool",
        "description": "Enable overlapping routes for the provider.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "ProviderLabelType",
        "type": "str",
        "description": "MPLS label type to be used for provider routes.",
        "default": "LabelPerSite",
        "range_or_options": "LabelPerSite LabelPerRoute"
      },
      {
        "name": "ProviderStartLabel",
        "type": "int",
        "description": "Starting label value for MPLS label allocation.",
        "default": "16",
        "range_or_options": "16-1048575"
      }
    ],
    "description": "This function configures or edits the MPLS VPN IPv6 route provider parameters using a provided Wizard configuration object. It delegates the actual editing operation to an internal backend method (`renix.edit_mpls_vpn_ipv6_route_provider_parameters`) and wraps the result with exception handling. This is typically used in test automation or network configuration contexts to adjust provider-side IPv6 routing settings for an MPLS-based VPN environment.",
    "example": "| Edit Mpls Vpn Ipv6 Route Provider Parameters | Wizard=${Wizard} | ProviderStartRoute=2002:: | ProviderPrefixLength=128 | ProviderLabelType=LabelPerRoute"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_host",
    "return_type": "bool",
    "return": "True if the MPLS host configuration was successfully updated; otherwise, False.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object used to edit the MPLS host settings. This object must implement the `edit_host` method for actual configuration changes.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "HostMacStart",
        "type": "str",
        "description": "Starting MAC address for the host. Used in generating sequential MAC addresses for multiple hosts.",
        "default": "00:00:01:00:00:01",
        "range_or_options": "not_found"
      },
      {
        "name": "HostMacStep",
        "type": "str",
        "description": "Increment step for the host MAC address. Defines how the MAC addresses are incremented for each new host.",
        "default": "00:00:00:00:00:01",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableOverlapHosts",
        "type": "bool",
        "description": "Whether overlapping hosts (with same MAC or IP) should be enabled.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "EnableHostVlan",
        "type": "bool",
        "description": "Whether VLAN support should be enabled for the host.",
        "default": "True",
        "range_or_options": "True False"
      },
      {
        "name": "NumberOfCustomerSideVlanHeaders",
        "type": "int",
        "description": "Number of VLAN headers added on the customer side.",
        "default": "1",
        "range_or_options": "0-2"
      },
      {
        "name": "NumberOfProviderSideVlanHeaders",
        "type": "int",
        "description": "Number of VLAN headers added on the provider side.",
        "default": "1",
        "range_or_options": "0-2"
      },
      {
        "name": "VlanIdStart",
        "type": "int",
        "description": "Starting VLAN ID for the first VLAN header.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanIdStepPerVpls",
        "type": "int",
        "description": "Increment step for VLAN ID per VPLS instance.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanIdStepPerHost",
        "type": "int",
        "description": "Increment step for VLAN ID per host.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "HostAssignmentVpls",
        "type": "int",
        "description": "Specifies how hosts are assigned across VPLS instances.",
        "default": "HostsOrMacsPerCe",
        "range_or_options": "HostsOrMacsPerCe HostsOrMacsPerVpls TotalHostsOrMacs"
      },
      {
        "name": "HostsPerCustomerCe",
        "type": "int",
        "description": "Number of hosts per customer CE router.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "HostsPerProviderCe",
        "type": "int",
        "description": "Number of hosts per provider CE router.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "HostsPerVpls",
        "type": "int",
        "description": "Number of hosts per VPLS instance.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerHostPercent",
        "type": "int",
        "description": "Percentage of total hosts assigned to the customer side.",
        "default": "50",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderHostPercent",
        "type": "int",
        "description": "Percentage of total hosts assigned to the provider side.",
        "default": "50",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits an existing MPLS host configuration using the provided Wizard object and keyword arguments. This function acts as a wrapper around the `edit_host` method of the `Wizard` object, passing along any additional parameters provided via `**kwargs`. It is typically used to modify existing MPLS host settings within a test or network configuration context.",
    "example": "| Edit Mpls Host | Wizard=${Wizard} | VlanIdStart=10 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_fec128",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "封装了MPLS FEC 128配置逻辑的配置向导对象",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StartVcId",
        "type": "int",
        "description": "VC ID起始值",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "StepVcId",
        "type": "int",
        "description": "VC ID步长",
        "default": "1",
        "range_or_options": "not_found"
      }
    ],
    "description": "该函数用于编辑MPLS FEC (Forwarding Equivalence Class) 类型128的配置。它是一个封装函数，调用底层 `renix.edit_mpls_fec128` 方法，并通过关键字参数传递配置参数。典型用途包括设置VC ID的起始值和步长。",
    "example": "| Edit Mpls Fec128 | Wizard=${Wizard} | StartVcId=10 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_fec129",
    "return_type": "bool",
    "return": "Returns True if the MPLS FEC 129 configuration is successfully updated, otherwise returns False.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object that provides the method to edit MPLS FEC 129 settings.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Agi",
        "type": "str",
        "description": "AGI (Abstract Group Identifier) value for the MPLS FEC 129 configuration.",
        "default": "100:1",
        "range_or_options": "not_found"
      },
      {
        "name": "AgiIncrement",
        "type": "str",
        "description": "Increment step for AGI value.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "Saii",
        "type": "str",
        "description": "SAII (Source Address of Inter-AS ID) value for the MPLS FEC 129 configuration.",
        "default": "10.0.0.2",
        "range_or_options": "not_found"
      },
      {
        "name": "SaiiIncrement",
        "type": "str",
        "description": "Increment step for SAII value.",
        "default": "0.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "Taii",
        "type": "str",
        "description": "TAII (Target Address of Inter-AS ID) value for the MPLS FEC 129 configuration.",
        "default": "10.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "TaiiIncrement",
        "type": "str",
        "description": "Increment step for TAII value.",
        "default": "0.0.0.0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableBgpAutoDiscovery",
        "type": "bool",
        "description": "Enables BGP auto-discovery for the MPLS FEC 129 configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "DutAsNumber",
        "type": "int",
        "description": "Autonomous system number of the DUT (Device Under Test).",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RdAssignment",
        "type": "str",
        "description": "Route Distinguisher (RD) assignment method.",
        "default": "UseRT",
        "range_or_options": "UseRT Manual"
      },
      {
        "name": "AgiAssignment",
        "type": "str",
        "description": "AGI assignment method.",
        "default": "UseRT",
        "range_or_options": "UseRT Manual"
      },
      {
        "name": "Rt",
        "type": "str",
        "description": "Route Target (RT) value used for route distribution.",
        "default": "1:0",
        "range_or_options": "not_found"
      },
      {
        "name": "RtIncrement",
        "type": "str",
        "description": "Increment step for RT value.",
        "default": "0:1",
        "range_or_options": "not_found"
      },
      {
        "name": "Rd",
        "type": "str",
        "description": "Route Distinguisher (RD) value used for route separation.",
        "default": "1:0",
        "range_or_options": "not_found"
      },
      {
        "name": "RdIncrement",
        "type": "str",
        "description": "Increment step for RD value.",
        "default": "0:1",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures and edits the parameters related to MPLS FEC 129 (Forwarding Equivalence Class) using a provided Wizard configuration object. It delegates the actual configuration to the backend `edit_fec129` method of the Wizard class. The function supports various configuration options such as AGI, SAII, TAII, BGP auto-discovery, RD/RT values, and their respective increments.",
    "example": "| Edit Mpls Fec129 | Wizard=${Wizard} | Saii=1.1.1.1 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_bgp_vpls",
    "return_type": "bool",
    "return": "A boolean indicating whether the BGP VPLS configuration was successfully edited (True) or not (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "The wizard configuration object that manages the underlying BGP VPLS editing logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NumberOfVpls",
        "type": "int",
        "description": "Number of VPLS instances to configure.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "RdAssignment",
        "type": "str",
        "description": "Route Distinguisher assignment method.",
        "default": "UseRT",
        "range_or_options": "UseRT Manual"
      },
      {
        "name": "RouteTargetStart",
        "type": "str",
        "description": "Starting value for route target.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "RouteTartStep",
        "type": "str",
        "description": "Step increment for route target.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "MTU size for VPLS instance.",
        "default": "1500",
        "range_or_options": "not_found"
      },
      {
        "name": "VplsAssignment",
        "type": "str",
        "description": "Method to assign VPLS instances.",
        "default": "RoundRobin",
        "range_or_options": "RoundRobin Sequential"
      },
      {
        "name": "CustomerRdStart",
        "type": "str",
        "description": "Starting value for customer route distinguisher.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerVeIdStart",
        "type": "int",
        "description": "Starting VE ID for customer side.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerStepPerVplsEnabled",
        "type": "bool",
        "description": "Enable step per VPLS on customer side.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerVpls",
        "type": "str",
        "description": "Customer RD step per VPLS.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerStepPerCeEnabled",
        "type": "bool",
        "description": "Enable step per CE on customer side.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerRdStepPerCe",
        "type": "str",
        "description": "Customer RD step per CE.",
        "default": "'0:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerVeIdStepPerCe",
        "type": "int",
        "description": "VE ID step per CE on customer side.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "CustomerOverlapEnabled",
        "type": "bool",
        "description": "Enable overlapping VE IDs across VPLS on customer side.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderDistributionSelector",
        "type": "str",
        "description": "Provider distribution selector mode.",
        "default": "VPLSsPerPE",
        "range_or_options": "VPLSsPerPE PEsPerVPLS"
      },
      {
        "name": "ProviderDistributionSelectorCount",
        "type": "int",
        "description": "Provider distribution selector count.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderMeshed",
        "type": "bool",
        "description": "Enable full mesh between PEs on provider side.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStart",
        "type": "str",
        "description": "Starting RD for provider side.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderVeIdStart",
        "type": "int",
        "description": "Starting VE ID for provider side.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderStepPerVplsEnabled",
        "type": "bool",
        "description": "Enable step per VPLS on provider side.",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerVpls",
        "type": "str",
        "description": "Provider RD step per VPLS.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderStepPerCeEnabled",
        "type": "bool",
        "description": "Enable step per CE on provider side.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderRdStepPerCe",
        "type": "str",
        "description": "Provider RD step per CE.",
        "default": "'1:0'",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderVeIdStepPerCe",
        "type": "int",
        "description": "Provider VE ID step per CE.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderOverlapEnabled",
        "type": "bool",
        "description": "Enable overlapping CE IDs across VPLS on provider side.",
        "default": "False",
        "range_or_options": "not_found"
      }
    ],
    "description": "Edits the BGP VPLS (Virtual Private LAN Service) configuration using the provided Wizard object and keyword arguments. This function acts as a wrapper that invokes the `edit_bgp_vpls` method of the `Wizard` object, passing along all the provided keyword arguments. It is typically used to modify existing BGP VPLS settings in a network test or simulation setup.",
    "example": "| Edit Mpls Vpls Basic Parameters | Wizard=${Wizard} | Mtu=1518 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_vpls_basic_parameters",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizard",
        "type": "WizardConfig",
        "description": "向导配置对象，用于执行VPLS基本参数编辑操作。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NumberOfVpls",
        "type": "int",
        "description": "VPLS实例的数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "最大传输单元（MTU）大小。",
        "default": "1500",
        "range_or_options": "not_found"
      },
      {
        "name": "GroupId",
        "type": "int",
        "description": "Group ID，用于标识一组相关的VPLS实例。",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableCBit",
        "type": "bool",
        "description": "是否启用C-Bit（控制位）。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "IncludeStatusTlv",
        "type": "bool",
        "description": "是否包含状态TLV（Type-Length-Value）信息。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "StatusCode",
        "type": "list",
        "description": "PW（Pseudowire）的状态码列表，用于指定状态信息。",
        "default": "['PseudowireNotForwarding']",
        "range_or_options": "PseudowireNotForwarding LocalAttachmentCircuitReceiveFault LocalAttachmentCircuitTransmitFault LocalPsnFacingPwIngressReceiveFault LocalPsnFacingPwEgressTransmitFault"
      },
      {
        "name": "EnableOverrideEncapsulation",
        "type": "bool",
        "description": "是否启用封装类型的覆盖设置。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "Encapsulation",
        "type": "str",
        "description": "封装类型，决定如何封装数据。",
        "default": "EthernetVlan",
        "range_or_options": "EthernetVlan Ethernet EthernetVpls"
      },
      {
        "name": "VplsAssignment",
        "type": "str",
        "description": "VPLS分配策略，定义如何将VPLS分配给PE设备。",
        "default": "RoundRobin",
        "range_or_options": "RoundRobin Sequential"
      },
      {
        "name": "ProviderDistributionSelector",
        "type": "str",
        "description": "供应商侧配置选项，定义VPLS和PE之间的分布方式。",
        "default": "VPLSsPerPE",
        "range_or_options": "VPLSsPerPE PEsPerVPLS"
      },
      {
        "name": "ProviderDistributionSelectorCount",
        "type": "int",
        "description": "供应商侧配置选项数量。",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "ProviderEnableAll",
        "type": "bool",
        "description": "是否在所有供应商侧启用VPLS。",
        "default": "True",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableCreateProviderHostsForUnusedVpls",
        "type": "bool",
        "description": "是否为未使用的VPLS创建提供商侧主机。",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "FecType",
        "type": "str",
        "description": "FEC（转发等价类）类型，用于区分PW的FEC类型。",
        "default": "FEC128",
        "range_or_options": "FEC128 FEC129"
      }
    ],
    "description": "该函数用于通过提供的Wizard对象配置MPLS VPLS的基本参数。它是一个用户接口函数，调用底层`renix.edit_mpls_vpls_basic_parameters`函数，并根据返回结果判断是否抛出异常或返回布尔状态。",
    "example": "| Edit Mpls Vpls Basic Parameters | Wizard=${Wizard} | Mtu=1518 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.mpls.edit_mpls_pwe_basic_parameters",
    "return_type": "bool",
    "return": "A boolean indicating whether the MPLS PWE configuration was successfully updated (True) or failed (False).",
    "parameters": [
      {
        "name": "Wizard",
        "type": ":obj:`WizardConfig`",
        "description": "An instance of WizardConfig that provides access to the method for editing MPLS PWE basic parameters.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NumberOfPseudoWire",
        "type": "int",
        "description": "Number of pseudowires to configure.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "Mtu",
        "type": "int",
        "description": "Maximum Transmission Unit (MTU) size for the pseudowire.",
        "default": "1500",
        "range_or_options": "not_found"
      },
      {
        "name": "GroupId",
        "type": "int",
        "description": "Group ID associated with the pseudowire.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableCBit",
        "type": "bool",
        "description": "Whether to enable the C-Bit in the pseudowire control word.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "IncludeStatusTlv",
        "type": "bool",
        "description": "Whether to include the status TLV in LDP signaling.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StatusCode",
        "type": "list",
        "description": "List of status codes for pseudowire status notifications.",
        "default": "['PseudowireNotForwarding']",
        "range_or_options": "PseudowireNotForwarding LocalAttachmentCircuitReceiveFault LocalAttachmentCircuitTransmitFault LocalPsnFacingPwIngressReceiveFault LocalPsnFacingPwEgressTransmitFault"
      },
      {
        "name": "EnableOverrideEncapsulation",
        "type": "bool",
        "description": "Whether to override the default encapsulation type.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Encapsulation",
        "type": "str",
        "description": "Type of encapsulation used for the pseudowire.",
        "default": "EthernetVlan",
        "range_or_options": "EthernetVlan Ethernet EthernetVpls"
      },
      {
        "name": "EnableOverlapVcidsOnDifferentPes",
        "type": "bool",
        "description": "Whether to allow overlapping VC IDs on different PEs.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableCreateProviderHostsForUnusedVpls",
        "type": "bool",
        "description": "Whether to create provider-side hosts for unused VPLS instances.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "FecType",
        "type": "str",
        "description": "The Forwarding Equivalence Class (FEC) type used for LDP sessions.",
        "default": "FEC128",
        "range_or_options": "FEC128 FEC129"
      }
    ],
    "description": "This function configures the basic parameters of an MPLS Pseudowire Emulation (PWE) using a provided Wizard object. It delegates the actual configuration to the `edit_pwe_basic_parameters` method of the underlying Wizard instance, and wraps the call in logic to raise an exception if the result is False. This function is typically used in test automation environments to adjust pseudowire settings such as MTU, encapsulation, group ID, and other protocol-related flags.",
    "example": "| Edit Mpls Pwe Basic Parameters | Wizard=${Wizard} | Mtu=1518 | NumberOfPseudoWire=4 | Encapsulation=Ethernet | EnableCBit=True | FecType=FEC129 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.create_ospfv2_lsa_wizard",
    "return_type": "Ospfv2LsaWizard",
    "return": "An instance of the Ospfv2LsaWizard class initialized with the provided sessions and configuration options.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list, set, tuple, or single session",
        "description": "A session or collection of sessions for which the OSPFv2 LSA Wizard will be created.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Optional keyword arguments",
        "type": "dict",
        "description": "Additional configuration properties for the OSPFv2 LSA Wizard.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function initializes and returns an Ospfv2LsaWizard object, which is used to manage and generate OSPFv2 LSAs (Link State Advertisements) for one or more sessions. The function ensures that the 'Sessions' parameter is always treated as an iterable by converting it into a list if necessary. It also supports optional keyword arguments for further configuration of the wizard instance.",
    "example": "| Create Ospfv2 Lsa Wizard | Sessions=@{sessions} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_topo",
    "return_type": "list or object",
    "return": "If multiple wizards are provided, returns a list of results from calling `config_ospfv2_topo` on each wizard. If only one wizard is provided, returns the result of its `config_ospfv2_topo` call directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (list, set, or tuple) of wizard objects. Each wizard must have a `config_ospfv2_topo` method that accepts 'Type' and additional keyword arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str or int",
        "description": "The type of OSPFv2 topology to configure. This could be a string identifier or integer code, depending on the expected input of the underlying `config_ospfv2_topo` method.",
        "default": "TREE",
        "range_or_options": "NONE TREE GRID FULLMESH RING HUBSPOKE"
      }
    ],
    "kwargs": [
      {
        "name": "SimulatedRoutersCount",
        "type": "int",
        "description": "Number of Simulated Routers for Tree topology.",
        "default": "50",
        "range_or_options": "1-10000"
      },
      {
        "name": "InterfaceType",
        "type": "str",
        "description": "Interface type for Tree topology.",
        "default": "P2P",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "RouterMaxInterfaceCount",
        "type": "int",
        "description": "Maximum number of interfaces per router in Tree topology.",
        "default": "4",
        "range_or_options": "1-100"
      },
      {
        "name": "TransitNetworkMaxRouterCount",
        "type": "int",
        "description": "Maximum number of routers per transit network in Tree topology.",
        "default": "5",
        "range_or_options": "2-10000"
      },
      {
        "name": "UneditableSimulatedRoutersCount",
        "type": "int",
        "description": "Number of Simulated Routers for Grid topology.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "EmulatedRouterPossessSimulatedRouterCount",
        "type": "int",
        "description": "Number of Simulated Routers per Emulated Router in Grid topology.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "RowCount",
        "type": "int",
        "description": "Number of rows in Grid topology.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "ColumnCount",
        "type": "int",
        "description": "Number of columns in Grid topology.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "GridEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Grid topology.",
        "default": "ATTACHEDTOGRID",
        "range_or_options": "ATTACHEDTOGRID MEMBEROFGRID"
      },
      {
        "name": "EmulatedRouterAttachRowIndex",
        "type": "int",
        "description": "Row index where Emulated Router belongs in Grid topology.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "EmulatedRouterAttachColumnIndex",
        "type": "int",
        "description": "Column index where Emulated Router belongs in Grid topology.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "MeshRouterCount",
        "type": "int",
        "description": "Total number of routers in Full Mesh topology.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "MeshEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Full Mesh topology.",
        "default": "ATTACHEDTOMESH",
        "range_or_options": "ATTACHEDTOMESH MEMBEROFMESH"
      },
      {
        "name": "RingRouterCount",
        "type": "int",
        "description": "Total number of routers in Ring topology.",
        "default": "10",
        "range_or_options": "1-10000"
      },
      {
        "name": "RingEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Ring topology.",
        "default": "ATTACHEDTORING",
        "range_or_options": "ATTACHEDTORING MEMBEROFRING"
      },
      {
        "name": "HubSpokeRouterCount",
        "type": "int",
        "description": "Total number of routers in Hub-Spoke topology.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "HubSpokeEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Hub-Spoke topology.",
        "default": "ATTACHEDTOHUB",
        "range_or_options": "ATTACHEDTOHUB ATTACHEDTOSPOKE MEMBERASHUB MEMBERASSPOKE"
      }
    ],
    "description": "This function configures the OSPFv2 topology for one or more LSA (Link State Advertisement) wizards. It supports passing multiple wizards and delegates the actual configuration to each wizard's `config_ospfv2_topo` method with the given parameters. It ensures uniform configuration of OSPFv2 topology settings across multiple LSA wizards by abstracting looping logic and handling both single and multiple inputs consistently.",
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 Topo | Wizards=@{wizard} | Type=TREE |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2",
    "return_type": "list or object",
    "return": "If multiple wizards are provided, returns a list of the return values from each wizard's `config_ospfv2` method. If only one wizard is provided, returns the single result directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single wizard object or an iterable (like list, set, or tuple) containing multiple wizard objects. Each wizard must have a `config_ospfv2` method that accepts keyword arguments for OSPFv2 LSA configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StartingPrefixRange",
        "type": "str",
        "description": "The starting IPv4 prefix range to be used for generating prefixes in the LSA.",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EndingPrefixRange",
        "type": "str",
        "description": "The ending IPv4 prefix range to be used for generating prefixes in the LSA.",
        "default": "235.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableP2pLinks",
        "type": "bool",
        "description": "Enables creation of Point-to-Point (P2P) links.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableTeOption",
        "type": "bool",
        "description": "Enables Traffic Engineering (TE) option within OSPFv2 LSA.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "EnableSegmentRouting",
        "type": "bool",
        "description": "Enables Segment Routing functionality in the LSA.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "AreaType",
        "type": "str",
        "description": "Specifies the type of the OSPF area.",
        "default": "REGULAR",
        "range_or_options": "REGULAR STUB STUBNOSUMMARY NSSA NSSANOSUMMARY"
      },
      {
        "name": "StartingInterfaceIp",
        "type": "str",
        "description": "The starting IPv4 address for interface IP generation.",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "InterfacePrefixLength",
        "type": "int",
        "description": "The prefix length for the interface IP addresses.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "InterfaceOverride",
        "type": "bool",
        "description": "Enables overriding existing interface settings.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "StartingRouterId",
        "type": "str",
        "description": "The starting IPv4 address for router IDs.",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableAdvertiseRouterId",
        "type": "bool",
        "description": "Enables advertising the router ID as a loopback address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "The increment step used when assigning router IDs across multiple instances.",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "description": "Configures OSPFv2 LSA (Link-State Advertisement) settings using one or more wizard objects. This function applies the specified configuration parameters by calling the `config_ospfv2` method on each provided wizard object. It ensures consistent configuration across all wizards and returns the results either as a list or a single value depending on the number of input wizards.",
    "example": ".. code:: RobotFramework\n\n    | Config Ospfv2 Lsa Wizard Ospfv2 | Wizards=@{wizard} | StartingPrefixRange=192.168.0.0 | EndingPrefixRange=192.168.255.255 | AreaType=STUB | InterfacePrefixLength=30"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_te_option",
    "return_type": "list or TrafficEngineeringConfig",
    "return": "If a single wizard is provided, returns the result of its configuration (TrafficEngineeringConfig object). If multiple wizards are provided, returns a list of results from each wizard's configuration.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (e.g., list, set, tuple) of wizard objects for which the OSPFv2 TE option will be configured. Each wizard must implement the `config_ospfv2_te_option` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "EnableLocalIp",
        "type": "bool",
        "description": "Whether to enable inclusion of the local IPv4 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LocalIp",
        "type": "str",
        "description": "The local IPv4 address to be used if EnableLocalIp is True.",
        "default": "'0.0.0.0'",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableRemoteIp",
        "type": "bool",
        "description": "Whether to enable inclusion of the remote (neighbor) IPv4 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RemoteIp",
        "type": "str",
        "description": "The remote IPv4 address to be used if EnableRemoteIp is True.",
        "default": "10",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "EnableLocalIpv6",
        "type": "bool",
        "description": "Whether to enable inclusion of the local IPv6 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "LocalIpv6",
        "type": "str",
        "description": "The local IPv6 address to be used if EnableLocalIpv6 is True.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableRemoteIpv6",
        "type": "bool",
        "description": "Whether to enable inclusion of the remote (neighbor) IPv6 address.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "RemoteIpv6",
        "type": "str",
        "description": "The remote IPv6 address to be used if EnableRemoteIpv6 is True.",
        "default": "'2000::1'",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EnableGroup",
        "type": "bool",
        "description": "Whether to enable the group setting.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Group",
        "type": "int",
        "description": "The group number to be assigned if EnableGroup is True.",
        "default": "1",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableMaxBandwidth",
        "type": "bool",
        "description": "Whether to enable maximum bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximunLink",
        "type": "int",
        "description": "Maximum link bandwidth in bytes per second if EnableMaxBandwidth is True.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableResBandwidth",
        "type": "bool",
        "description": "Whether to enable reserved bandwidth configuration.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "MaximumReservableLink",
        "type": "int",
        "description": "Maximum reservable bandwidth in bytes per second if EnableResBandwidth is True.",
        "default": "1000",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "EnableUnresBandwidth",
        "type": "bool",
        "description": "Whether to enable unreserved bandwidth configuration for priority levels.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "UnreservedBandwidth0",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 0 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth1",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 1 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth2",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 2 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth3",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 3 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth4",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 4 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth5",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 5 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth6",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 6 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      },
      {
        "name": "UnreservedBandwidth7",
        "type": "int",
        "description": "Unreserved bandwidth value for priority level 7 if EnableUnresBandwidth is True.",
        "default": "0",
        "range_or_options": "0-4294967295"
      }
    ],
    "description": "This function configures the OSPFv2 Traffic Engineering (TE) option for one or more LSA wizard objects. It supports enabling and configuring various TE parameters such as IP addresses, group settings, and bandwidth values. The function applies the configuration by calling the `config_ospfv2_te_option` method on each wizard object with the provided keyword arguments.",
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 Te Option | Wizards=@{wizard} | EnableLocalIp=True | LocalIp=192.168.1.1 | EnableMaxBandwidth=True | MaximunLink=1000000"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_sr",
    "return_type": "list or Ospfv2SrConfig",
    "return": "A list of configuration results if multiple wizards are provided, or a single Ospfv2SrConfig object if only one wizard is used.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (e.g., list) of wizard objects that support the `config_ospfv2_sr` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SidLabelType",
        "type": "str",
        "description": "The type of SID/Label to be used in Segment Routing.",
        "default": "BIT20",
        "range_or_options": "BIT20 BIT32"
      },
      {
        "name": "SidLabelBase",
        "type": "list",
        "description": "List of base values for SID/Label allocation.",
        "default": "[800000]",
        "range_or_options": "not_found"
      },
      {
        "name": "SidLabelRange",
        "type": "list",
        "description": "List of ranges for SID/Label allocation.",
        "default": "[80000]",
        "range_or_options": "not_found"
      },
      {
        "name": "Algorithms",
        "type": "int",
        "description": "Algorithm number to be advertised with SR capability.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidIndexLabel",
        "type": "int",
        "description": "SID/Index/Label value for node segment.",
        "default": "101",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeSidStep",
        "type": "int",
        "description": "Increment step for Node SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeAlgorithm",
        "type": "int",
        "description": "Algorithm associated with the Node SID.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "NodeFlags",
        "type": "list",
        "description": "List of flags associated with the Node SID.",
        "default": "['NoPhp']",
        "range_or_options": "NoPhp MappingServer ExplicitNull ValueIndex LocalGlobal"
      },
      {
        "name": "GenerateSidForLink",
        "type": "bool",
        "description": "Enable generating SID for adjacency segments.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AdjacencySid",
        "type": "int",
        "description": "Starting value for Adjacency SID.",
        "default": "24001",
        "range_or_options": "not_found"
      },
      {
        "name": "AdjacencyStep",
        "type": "int",
        "description": "Increment step for Adjacency SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "GenerateSidForPrefix",
        "type": "bool",
        "description": "Enable generating SID for prefix segments.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixSidIndexLabel",
        "type": "int",
        "description": "SID/Index/Label value for prefix segment.",
        "default": "11000",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixSidStep",
        "type": "int",
        "description": "Increment step for Prefix SID.",
        "default": "1",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixFlags",
        "type": "list",
        "description": "List of flags associated with the Prefix SID.",
        "default": "['NoPhp']",
        "range_or_options": "NoPhp MappingServer ExplicitNull ValueIndex LocalGlobal"
      },
      {
        "name": "PrefixExtTLV",
        "type": "int",
        "description": "Percentage of extended prefix TLVs to be included.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "PrefixExtRangeTLV",
        "type": "int",
        "description": "Percentage of extended prefix range TLVs to be included.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "EnableAnycast",
        "type": "bool",
        "description": "Enable Anycast SID configuration.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastRangeSize",
        "type": "int",
        "description": "Range size for Anycast SID.",
        "default": "8000",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastSidLabelBase",
        "type": "int",
        "description": "Base SID/Label value for Anycast.",
        "default": "16000",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastSidIndex",
        "type": "int",
        "description": "SID/Index value for Anycast configuration.",
        "default": "100",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastIpv4Address",
        "type": "str",
        "description": "IPv4 address associated with Anycast SID.",
        "default": "192.0.0.1",
        "range_or_options": "not_found"
      },
      {
        "name": "AnycastFlags",
        "type": "list",
        "description": "List of flags associated with Anycast Prefix SID.",
        "default": "['NoPhp']",
        "range_or_options": "NoPhp MappingServer ExplicitNull ValueIndex LocalGlobal"
      }
    ],
    "description": "This function configures OSPFv2 Segment Routing (SR) settings on one or more LSA wizards. It abstracts away the iteration and data normalization logic, allowing uniform configuration of SR parameters across multiple wizard instances by forwarding all keyword arguments to each wizard's internal `config_ospfv2_sr` method.",
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 Sr | Wizards=@{wizard} | SidLabelType=BIT32 | NodeSidIndexLabel=200 | GenerateSidForPrefix=True | PrefixSidIndexLabel=12000 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_stub_network",
    "return_type": "list or Ospfv2LsaWizardConfig",
    "return": "If multiple wizard objects are provided, returns a list of configuration results; if only one wizard is provided, returns the configuration result of that wizard directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (list, set, or tuple) of wizard objects that will be used to configure the OSPFv2 stub network. Each wizard must have a method named `config_ospfv2_stub_network`.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StubEmulated",
        "type": "str",
        "description": "Specifies which emulated routers should be configured.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "StubSimulated",
        "type": "str",
        "description": "Specifies which simulated routers should be configured.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "StubRoutesCount",
        "type": "int",
        "description": "Number of routes to create for the stub network.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "StubOverride",
        "type": "bool",
        "description": "Enables override mode for route configuration.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "StubStartingIpPrefix",
        "type": "str",
        "description": "Starting IP prefix for generated routes (IPv4 address).",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "StubEndingIpPrefix",
        "type": "str",
        "description": "Ending IP prefix for generated routes (IPv4 address).",
        "default": "223.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "StubDistributionType",
        "type": "str",
        "description": "Specifies how prefixes are distributed.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "StubStartPrefixLength",
        "type": "int",
        "description": "Starting prefix length for fixed or linear distribution.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "StubEndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for linear distribution.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "StubInternetPrefixLength",
        "type": "list",
        "description": "List of 32 values representing prefix lengths for Internet-type distribution (sum must be 100.0).",
        "default": "not_found",
        "range_or_options": "list of 32 floats summing to 100.0"
      },
      {
        "name": "StubCustomPrefixLength",
        "type": "list",
        "description": "List of 32 values representing prefix lengths for Custom-type distribution (sum must be 100.0).",
        "default": "not_found",
        "range_or_options": "list of 32 floats summing to 100.0"
      },
      {
        "name": "StubPrimaryMetric",
        "type": "int",
        "description": "Metric value assigned to the generated stub routes.",
        "default": "1",
        "range_or_options": "1-16777215"
      }
    ],
    "description": "This function configures OSPFv2 stub network settings using one or more LSA wizards. It acts as a wrapper to invoke the `config_ospfv2_stub_network` method on each provided wizard object. The function supports both single and multiple inputs by handling them consistently. If multiple wizards are provided, it returns a list of configuration results; otherwise, it returns the result of a single wizard directly. This function includes error checking via the `@abnormal_check()` decorator, although its exact behavior is not described here.",
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 Stub Network | Wizards=@{wizard} | StubEmulated=EDGE | StubRoutesCount=100 | StubStartingIpPrefix=192.168.0.0 | StubEndingIpPrefix=192.168.255.255 | StubDistributionType=LINEAR | StubStartPrefixLength=16 | StubEndPrefixLength=24 | StubPrimaryMetric=10 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_summary_route",
    "return_type": "list or object",
    "return": "A list of return values from each wizard's `config_ospfv2_summary_route` call if multiple wizards are provided. If only a single wizard is used, returns the result directly (not wrapped in a list).",
    "description": "Configures OSPFv2 summary routes using one or more LSA wizards. This function wraps the `config_ospfv2_summary_route` method of individual OSPFv2 LSA wizard objects, allowing for batch configuration of summary routes. It ensures consistent application of the provided configuration parameters across all specified wizards.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "One or more wizard objects that manage OSPFv2 LSA configurations. Each wizard must have a `config_ospfv2_summary_route` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "SummaryEmulated",
        "type": "str",
        "description": "Specifies which emulated routers to summarize routes for.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "SummarySimulated",
        "type": "str",
        "description": "Specifies which simulated routers to summarize routes for.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "SummaryRoutesCount",
        "type": "int",
        "description": "Number of summary routes to create.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "SummaryOverride",
        "type": "bool",
        "description": "Enable override of existing settings.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "SummaryStartingIpPrefix",
        "type": "str",
        "description": "Starting IP prefix for the summary route range.",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "SummaryEndingIpPrefix",
        "type": "str",
        "description": "Ending IP prefix for the summary route range.",
        "default": "223.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "SummaryDistributionType",
        "type": "str",
        "description": "Distribution type for the prefixes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "SummaryStartPrefixLength",
        "type": "int",
        "description": "Starting prefix length for the summary routes.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "SummaryEndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for the summary routes.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "SummaryInternetPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for internet-type distribution (length 32, total sum 100.0).",
        "default": "not_found",
        "range_or_options": "list of length 32 with total sum 100.0"
      },
      {
        "name": "SummaryCustomPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for custom-type distribution (length 32, total sum 100.0).",
        "default": "not_found",
        "range_or_options": "list of length 32 with total sum 100.0"
      },
      {
        "name": "SummaryPrimaryMetric",
        "type": "int",
        "description": "Metric value for the summary route.",
        "default": "1",
        "range_or_options": "1-16777215"
      }
    ],
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 Summary Route | Wizards=@{wizard} | SummaryEmulated=EDGE | SummaryRoutesCount=10 | SummaryStartPrefixLength=16 | SummaryPrimaryMetric=100"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.config_ospfv2_lsa_wizard_ospfv2_external_route",
    "return_type": "list or Ospfv2LsaWizardConfig",
    "return": "If multiple wizard objects are provided, returns a list of configuration results; if only one wizard is provided, returns the configured Ospfv2LsaWizardConfig object directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (like list, set, tuple) of wizard objects that will be used to configure OSPFv2 external routes.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ExternalEmulated",
        "type": "str",
        "description": "Specifies which emulated routers should be used for generating external routes.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "ExternalSimulated",
        "type": "str",
        "description": "Specifies which simulated routers should be used for generating external routes.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "ExternalRoutesCount",
        "type": "int",
        "description": "Number of external routes to create.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "ExternalOverride",
        "type": "bool",
        "description": "Whether to enable overriding existing configurations.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ExternalStartingIpPrefix",
        "type": "str",
        "description": "The starting IP prefix for the external route range.",
        "default": "1.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "ExternalEndingIpPrefix",
        "type": "str",
        "description": "The ending IP prefix for the external route range.",
        "default": "223.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "ExternalDistributionType",
        "type": "str",
        "description": "Distribution type for the prefix allocation.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "ExternalStartPrefixLength",
        "type": "int",
        "description": "Starting prefix length for the IP prefixes generated.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "ExternalEndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for the IP prefixes generated.",
        "default": "24",
        "range_or_options": "1-32"
      },
      {
        "name": "ExternalInternetPrefixLength",
        "type": "list",
        "description": "A list of 32 float values representing distribution percentages for 'INTERNET' type prefixes.",
        "default": "not_found",
        "range_or_options": "length 32 list with sum 100.0"
      },
      {
        "name": "ExternalCustomPrefixLength",
        "type": "list",
        "description": "A list of 32 float values representing custom distribution percentages for prefix lengths.",
        "default": "not_found",
        "range_or_options": "length 32 list with sum 100.0"
      },
      {
        "name": "ExternalPrimaryMetric",
        "type": "int",
        "description": "Primary metric value for the external routes.",
        "default": "1",
        "range_or_options": "1-16777215"
      }
    ],
    "description": "This function configures OSPFv2 external route settings using the provided wizard(s). It applies uniform configuration parameters across all given wizards by calling their internal `config_ospfv2_external_route` method. The function supports both single and multiple wizard inputs and ensures consistent behavior in return types based on input structure.",
    "example": "| Config Ospfv2 Lsa Wizard Ospfv2 External Route | Wizards=@{wizard} | ExternalRoutesCount=10 | ExternalStartingIpPrefix=2.0.0.0 | ExternalEndPrefixLength=28 | ExternalPrimaryMetric=100"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv2_lsa.expand_ospfv2_lsa_wizard",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list or object",
        "description": "要展开的一个或多个OSPFv2 LSA向导对象。如果传入的是单个对象，则会被自动封装为列表进行处理。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于展开一个或多个OSPFv2 LSA（链路状态通告）向导配置。它调用底层库函数来执行展开操作，并在失败时抛出可继续执行的异常（ContinuableFailure）。每个向导对象必须实现`expand()`方法以支持此操作。",
    "example": "| Expand Ospfv2 Lsa Wizard | Wizards=@{Wizards} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.create_ospfv3_lsa_wizard",
    "return_type": "Ospfv3LsaWizardConfig",
    "return": "An instance of the Ospfv3LsaWizardConfig class representing the OSPFv3 LSA configuration wizard.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "list",
        "description": "A list of OSPFv3 protocol session objects to associate with the LSA wizard.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "LSA type",
        "type": "str or int",
        "description": "Type of the Link-State Advertisement (e.g., Router LSA, Network LSA).",
        "default": "not_found",
        "range_or_options": "Router LSA Network LSA InterAreaPrefix LSA InterAreaRouter LSA ASExternal LSA NSSA Type-7 LSA Link LSA IntraAreaPrefix LSA"
      },
      {
        "name": "advertisement_settings",
        "type": "dict",
        "description": "Settings for advertisement behavior such as frequency or route details.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "timers",
        "type": "dict",
        "description": "Timer-related configurations like LSRefreshTime, MinLSInterval, etc.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "other_configurations",
        "type": "any",
        "description": "Additional protocol-specific configurations that can vary based on requirements.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function creates and returns an OSPFv3 LSA (Link-State Advertisement) configuration wizard, enabling users to define and manage LSA settings for one or more associated sessions. It provides support for flexible configuration through optional keyword arguments.",
    "example": "| Create Ospfv3 Lsa Wizard | Sessions=@{sessions} | LSA type=ASExternal | timers={'MinLSInterval': 5} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.config_ospfv3_lsa_wizard_ospfv3_topo",
    "return_type": "list or object",
    "return": "If multiple wizards are provided, returns a list of configuration results from each wizard's `config_ospfv3_topo` method. If only one wizard is provided, returns the result directly from that single configuration call.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (like list, set, tuple) containing multiple wizard objects. Each wizard must implement the `config_ospfv3_topo` method for actual topology configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Type",
        "type": "str",
        "description": "The type of OSPFv3 topology to configure. This determines which additional keyword arguments are relevant.",
        "default": "TREE",
        "range_or_options": "NONE TREE GRID FULLMESH RING HUBSPOKE"
      }
    ],
    "kwargs": [
      {
        "name": "SimulatedRoutersCount",
        "type": "int",
        "description": "Number of Simulated Routers in Tree Topology. Applicable when Type=TREE.",
        "default": "50",
        "range_or_options": "1-10000"
      },
      {
        "name": "InterfaceType",
        "type": "str",
        "description": "Interface type for Tree Topology. Applicable when Type=TREE.",
        "default": "P2P",
        "range_or_options": "BROADCAST P2P"
      },
      {
        "name": "RouterMaxInterfaceCount",
        "type": "int",
        "description": "Maximum interface count per router in Tree Topology. Applicable when Type=TREE.",
        "default": "4",
        "range_or_options": "1-100"
      },
      {
        "name": "TransitNetworkMaxRouterCount",
        "type": "int",
        "description": "Maximum number of routers in each transit network for Tree Topology. Applicable when Type=TREE.",
        "default": "5",
        "range_or_options": "2-10000"
      },
      {
        "name": "UneditableSimulatedRoutersCount",
        "type": "int",
        "description": "Number of Simulated Routers in Grid Topology that cannot be edited. Applicable when Type=GRID.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "EmulatedRouterPossessSimulatedRouterCount",
        "type": "int",
        "description": "Number of Simulated Routers on each Emulated Router in Grid Topology. Applicable when Type=GRID.",
        "default": "16",
        "range_or_options": "0-10000"
      },
      {
        "name": "RowCount",
        "type": "int",
        "description": "Number of rows in Grid Topology. Applicable when Type=GRID.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "ColumnCount",
        "type": "int",
        "description": "Number of columns in Grid Topology. Applicable when Type=GRID.",
        "default": "4",
        "range_or_options": "1-10000"
      },
      {
        "name": "GridEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Grid Topology. Applicable when Type=GRID.",
        "default": "ATTACHEDTOGRID",
        "range_or_options": "ATTACHEDTOGRID MEMBEROFGRID"
      },
      {
        "name": "EmulatedRouterAttachRowIndex",
        "type": "int",
        "description": "Row index where Emulated Router is attached in Grid Topology. Applicable when Type=GRID.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "EmulatedRouterAttachColumnIndex",
        "type": "int",
        "description": "Column index where Emulated Router is attached in Grid Topology. Applicable when Type=GRID.",
        "default": "1",
        "range_or_options": "1-10000"
      },
      {
        "name": "MeshRouterCount",
        "type": "int",
        "description": "Total number of routers in Full Mesh Topology. Applicable when Type=FULLMESH.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "MeshEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Full Mesh Topology. Applicable when Type=FULLMESH.",
        "default": "ATTACHEDTOMESH",
        "range_or_options": "ATTACHEDTOMESH MEMBEROFMESH"
      },
      {
        "name": "RingRouterCount",
        "type": "int",
        "description": "Total number of routers in Ring Topology. Applicable when Type=RING.",
        "default": "10",
        "range_or_options": "1-10000"
      },
      {
        "name": "RingEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Ring Topology. Applicable when Type=RING.",
        "default": "ATTACHEDTORING",
        "range_or_options": "ATTACHEDTORING MEMBEROFRING"
      },
      {
        "name": "HubSpokeRouterCount",
        "type": "int",
        "description": "Total number of routers in Hub-Spoke (Star) Topology. Applicable when Type=HUBSPOKE.",
        "default": "10",
        "range_or_options": "1-100"
      },
      {
        "name": "HubSpokeEmulatedRouterPosition",
        "type": "str",
        "description": "Position of Emulated Router in Star Topology. Applicable when Type=HUBSPOKE.",
        "default": "ATTACHEDTOHUB",
        "range_or_options": "ATTACHEDTOHUB ATTACHEDTOSPOKE MEMBERASHUB MEMBERASSPOKE"
      }
    ],
    "description": "Configures the OSPFv3 topology for one or more LSA (Link State Advertisement) wizards. This function applies a specific OSPFv3 topology configuration to a list of wizard objects. Each wizard is expected to have a method called `config_ospfv3_topo` that performs the actual configuration. The function supports passing detailed configuration parameters via keyword arguments based on the selected topology type.",
    "example": "| Config Ospfv3 Lsa Wizard Ospfv3 Topo | Wizards=@{wizard} | Type=TREE |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.config_ospfv3_lsa_wizard_ospfv3",
    "return_type": "list or Ospfv3LsaWizardConfig",
    "return": "If multiple wizards are configured, returns a list of results; if only one wizard is provided, returns the result directly as an Ospfv3LsaWizardConfig object.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single wizard object or an iterable (e.g., list, set, tuple) of wizard objects that support the `config_ospfv3` method for OSPFv3 configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "StartingPrefixRange",
        "type": "str",
        "description": "The starting IPv6 prefix to be used in the OSPFv3 configuration.",
        "default": "2000::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "EndingPrefixRange",
        "type": "str",
        "description": "The ending IPv6 prefix to be used in the OSPFv3 configuration.",
        "default": "3ffe::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "AreaType",
        "type": "str",
        "description": "Specifies the type of the OSPFv3 area.",
        "default": "REGULAR",
        "range_or_options": "REGULAR STUB STUBNOSUMMARY NSSA NSSANOSUMMARY"
      },
      {
        "name": "StartingRouterId",
        "type": "str",
        "description": "The starting IPv4 router ID for the OSPFv3 configuration.",
        "default": "1.0.0.1",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "RouterIdStep",
        "type": "str",
        "description": "The step increment for assigning router IDs in the OSPFv3 configuration.",
        "default": "0.0.0.1",
        "range_or_options": "valid IPv4 address"
      }
    ],
    "description": "This function configures OSPFv3 LSA (Link-State Advertisement) settings using a wizard-based approach. It accepts either a single wizard object or a collection of wizard objects and applies the specified OSPFv3 configuration parameters to each by calling their respective `config_ospfv3` method. The return value adapts based on the number of input wizards: it returns a list if multiple configurations are applied or a single result if only one wizard is processed.",
    "example": "| Config Ospfv3 Lsa Wizard Ospfv3 | Wizards=@{wizard} | StartingPrefixRange=2001::1 | EndingPrefixRange=3fff::1 | AreaType=NSSA | StartingRouterId=1.0.0.2 | RouterIdStep=0.0.0.2 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.config_ospfv3_lsa_wizard_ospfv3_intra_area_route",
    "return_type": "list or Ospfv3LsaWizardConfig",
    "return": "If a single wizard is provided, returns the configuration result for that wizard directly. If multiple wizards are provided, returns a list of configuration results corresponding to each wizard.",
    "description": "Configure OSPFv3 intra-area routes using the provided LSA wizards. This function acts as a wrapper to invoke `config_ospfv3_intra_area_route` on one or more OSPFv3 LSA Wizard instances with the same set of configuration parameters. It supports bulk configuration by accepting a single wizard or an iterable (list, set, or tuple) of wizards.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "One or more LSA wizard objects that support the `config_ospfv3_intra_area_route` method. If a single object is passed, it is wrapped into a list internally for uniform processing.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "IntraAreaEmulated",
        "type": "str",
        "description": "Specifies which emulated routers should be used for generating intra-area routes.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "IntraAreaSimulated",
        "type": "str",
        "description": "Specifies which simulated routers should be used for generating intra-area routes.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "IntraAreaRoutesCount",
        "type": "int",
        "description": "Number of intra-area routes to create.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "IntraAreaOverride",
        "type": "bool",
        "description": "Enables overriding existing route configurations.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "IntraAreaStartingIpPrefix",
        "type": "str",
        "description": "IPv6 prefix from which route generation starts.",
        "default": "2000::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "IntraAreaEndingIpPrefix",
        "type": "str",
        "description": "IPv6 prefix at which route generation ends.",
        "default": "3ffe::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "IntraAreaDistributionType",
        "type": "str",
        "description": "Type of distribution for route prefixes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "IntraAreaStartPrefixLength",
        "type": "int",
        "description": "Starting prefix length for generated routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "IntraAreaEndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for generated routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "IntraAreaInternetPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for 'INTERNET' type distribution. Must be a list of length 128, summing to 100.0.",
        "default": "not_found",
        "range_or_options": "list of 128 elements, total sum must be 100.0"
      },
      {
        "name": "IntraAreaCustomPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for 'CUSTOM' type distribution. Must be a list of length 128, summing to 100.0.",
        "default": "not_found",
        "range_or_options": "list of 128 elements, total sum must be 100.0"
      },
      {
        "name": "IntraAreaPrimaryMetric",
        "type": "int",
        "description": "Primary metric value for the routes.",
        "default": "1",
        "range_or_options": "1-65535"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Config Ospfv3 Lsa Wizard Ospfv3 Intra Area Route | Wizards=@{wizard} | IntraAreaRoutesCount=10 | IntraAreaPrimaryMetric=50",
    "examples": []
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.config_ospfv3_lsa_wizard_ospfv3_inter_area_route",
    "return_type": "list or Ospfv3LsaWizardConfig",
    "return": "A list of configuration results from each wizard if multiple wizards are provided, otherwise a single configuration result.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or a collection of wizard objects that support the `config_ospfv3_inter_area_route` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "InterAreaEmulated",
        "type": "str",
        "description": "Specify which emulated routers to apply the inter-area route settings to.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "InterAreaSimulated",
        "type": "str",
        "description": "Specify which simulated routers to apply the inter-area route settings to.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "InterAreaRoutesCount",
        "type": "int",
        "description": "Number of inter-area routes to create.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "InterAreaOverride",
        "type": "bool",
        "description": "Enable override for inter-area route settings.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "InterAreaStartingIpPrefix",
        "type": "str",
        "description": "The starting IPv6 prefix for inter-area route generation.",
        "default": "2000::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "InterAreaEndingIpPrefix",
        "type": "str",
        "description": "The ending IPv6 prefix for inter-area route generation.",
        "default": "3ffe::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "InterAreaDistributionType",
        "type": "str",
        "description": "Specifies how prefixes are distributed in the generated inter-area routes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "InterAreaStartPrefixLength",
        "type": "int",
        "description": "Starting prefix length for inter-area route prefixes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "InterAreaEndPrefixLength",
        "type": "int",
        "description": "Ending prefix length for inter-area route prefixes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "InterAreaInternetPrefixLength",
        "type": "list",
        "description": "Custom distribution for internet-type prefixes (length must be 128, values sum to 100.0).",
        "default": "not_found",
        "range_or_options": "length 128 list with total sum of elements equal to 100.0"
      },
      {
        "name": "InterAreaCustomPrefixLength",
        "type": "list",
        "description": "Custom distribution for custom-type prefixes (length must be 128, values sum to 100.0).",
        "default": "not_found",
        "range_or_options": "length 128 list with total sum of elements equal to 100.0"
      },
      {
        "name": "InterAreaPrimaryMetric",
        "type": "int",
        "description": "Metric value assigned to the inter-area routes.",
        "default": "100",
        "range_or_options": "1-65535"
      }
    ],
    "description": "This function configures OSPFv3 inter-area route settings using one or more LSA wizards. It allows applying the same configuration across multiple wizard instances in a single call. Each wizard's internal `config_ospfv3_inter_area_route` method is called with the provided parameters. If multiple wizards are provided, the return value will be a list of individual results; otherwise, it returns the single result directly.",
    "example": "| Config Ospfv3 Lsa Wizard Ospfv3 Inter Area Route | Wizards=@{wizard} | InterAreaRoutesCount=10 | InterAreaPrimaryMetric=50"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.config_ospfv3_lsa_wizard_ospfv3_external_route",
    "return_type": "Ospfv3LsaWizardConfig or list of Ospfv3LsaWizardConfig",
    "return": "Returns a single configuration object or a list of configuration objects depending on the number of wizard instances provided. Each result corresponds to the configuration output from each individual wizard's `config_ospfv3_external_route` method.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects",
        "description": "A single wizard object or an iterable (e.g., list, set, tuple) of wizard objects that support the `config_ospfv3_external_route` method. Each wizard is expected to handle configuration of OSPFv3 external route settings based on the provided arguments.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "ExternalEmulated",
        "type": "str",
        "description": "Specifies which emulated routers should be used for external routes.",
        "default": "NONE",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "ExternalSimulated",
        "type": "str",
        "description": "Specifies which simulated routers should be used for external routes.",
        "default": "ALL",
        "range_or_options": "NONE ALL EDGE"
      },
      {
        "name": "ExternalRoutesCount",
        "type": "int",
        "description": "Number of external routes to create.",
        "default": "0",
        "range_or_options": "not_found"
      },
      {
        "name": "ExternalOverride",
        "type": "bool",
        "description": "Enables override mode for external routes.",
        "default": "False",
        "range_or_options": "not_found"
      },
      {
        "name": "ExternalStartingIpPrefix",
        "type": "str",
        "description": "The starting IPv6 prefix for external route generation.",
        "default": "2000::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "ExternalEndingIpPrefix",
        "type": "str",
        "description": "The ending IPv6 prefix for external route generation.",
        "default": "3ffe::1",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "ExternalDistributionType",
        "type": "str",
        "description": "The type of prefix distribution for external routes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR INTERNET CUSTOM"
      },
      {
        "name": "ExternalStartPrefixLength",
        "type": "int",
        "description": "The length of the starting prefix for external routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "ExternalEndPrefixLength",
        "type": "int",
        "description": "The length of the ending prefix for external routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "ExternalInternetPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for Internet-type distribution (must be a list of length 128 with total sum equal to 100.0).",
        "default": "not_found",
        "range_or_options": "length 128 list, sum = 100.0"
      },
      {
        "name": "ExternalCustomPrefixLength",
        "type": "list",
        "description": "List of prefix lengths for Custom-type distribution (must be a list of length 128 with total sum equal to 100.0).",
        "default": "not_found",
        "range_or_options": "length 128 list, sum = 100.0"
      },
      {
        "name": "ExternalPrimaryMetric",
        "type": "int",
        "description": "Metric value for external routes.",
        "default": "1000",
        "range_or_options": "1-65535"
      }
    ],
    "description": "This function configures OSPFv3 external route settings using one or more LSA wizards. It accepts a wizard object or an iterable of such objects and applies the given keyword arguments to configure external route parameters like emulated/simulated routers, route count, IP prefixes, metric, and distribution types. The function returns either a single configuration result or a list of results if multiple wizards are provided.",
    "example": "| Config Ospfv3 Lsa Wizard Ospfv3 External Route | Wizards=@{wizard} | ExternalRoutesCount=10 | ExternalDistributionType=LINEAR | ExternalPrimaryMetric=2000"
  },
  {
    "method_name": "TesterLibrary.Wizard.ospfv3_lsa.expand_ospfv3_lsa_wizard",
    "return_type": "bool",
    "return": "布尔值，表示 OSPFv3 LSA 向导扩展操作是否成功执行。总是返回 True 表示操作已成功尝试；若失败则抛出异常。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable (list, set, tuple)",
        "description": "一个或多个 OSPFv3 LSA 向导对象。每个向导必须包含 `expand()` 方法以执行具体的扩展逻辑。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于触发一个或多个 OSPFv3 LSA（链路状态通告）向导的扩展操作。通常，扩展是指基于向导配置生成或更新 LSA 数据。此方法接受单个向导对象或可迭代集合（如列表、集合、元组），并对其中每个向导调用其 `expand()` 方法。如果传入的是单个对象而非可迭代类型，则自动将其转换为列表以统一处理。若任何向导缺少 `expand()` 方法，将引发 TypeError 异常。此外，若底层调用返回 False，则会抛出 ContinuableFailure 异常以指示失败但允许测试继续执行。",
    "example": "| Expand Ospfv3 Lsa Wizard | Wizards=@{Wizards} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.rip_route.create_rip_route_wizard",
    "return_type": "RipRouteWizard",
    "return": "An instance of the RipRouteWizard class initialized with the provided sessions and options.",
    "parameters": [
      {
        "name": "Sessions",
        "type": "session-like or iterable of session-like",
        "description": "A single session or a collection (list, set, or tuple) of sessions that the RipRouteWizard will operate on.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "arbitrary keyword arguments",
        "description": "Additional configuration options passed directly to the RipRouteWizard constructor.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Creates and returns a RipRouteWizard instance configured with the provided sessions and optional parameters. This function initializes a RipRouteWizard object, typically used to configure or manage RIP route settings in a network testing or simulation environment. The Sessions parameter can be a single session or a collection of sessions, which will be passed to the RipRouteWizard constructor. Additional configuration options can be passed via keyword arguments.",
    "example": ".. code:: RobotFramework\n\n    | Create Rip Route Wizard | Sessions=@{sessions} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.rip_route.config_rip_route_wizard_ipv4",
    "return_type": "list or RipRouteWizardConfig",
    "return": "If multiple wizards are provided, returns a list of configuration results; otherwise, returns the result of its configuration directly.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single wizard object or an iterable (list, set, tuple) containing multiple wizard objects. Each wizard must have a `config_ipv4_route` method.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv4TotalNumberOfRoutes",
        "type": "int",
        "description": "The total number of routes to be created.",
        "default": "20",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv4StartRoutesPrefix",
        "type": "str",
        "description": "The starting prefix for IPv4 routes.",
        "default": "2.0.0.0",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4EndRoutesPrefix",
        "type": "str",
        "description": "The ending prefix for IPv4 routes.",
        "default": "255.255.255.255",
        "range_or_options": "valid IPv4 address"
      },
      {
        "name": "Ipv4RoutesNoneSeq",
        "type": "bool",
        "description": "Prevents route aggregation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv4RoutesPrefixLenType",
        "type": "str",
        "description": "Distribution type for route prefixes.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR"
      },
      {
        "name": "Ipv4RoutesPrefixLenStart",
        "type": "int",
        "description": "Starting prefix length for IPv4 routes.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4RoutesPrefixLenEnd",
        "type": "int",
        "description": "Ending prefix length for IPv4 routes.",
        "default": "16",
        "range_or_options": "1-32"
      },
      {
        "name": "Ipv4Metric",
        "type": "int",
        "description": "Metric for route selection in RIP.",
        "default": "1",
        "range_or_options": "1-16"
      }
    ],
    "description": "This function configures IPv4 routing for RIP (Routing Information Protocol) using one or more route wizards. It applies the provided configuration parameters to each wizard's `config_ipv4_route` method. If multiple wizards are provided, it returns a list of configuration results. If only one wizard is provided, it returns the result directly.",
    "example": "| Config Rip Route Wizard Ipv4 | Wizards=@{wizard} | Ipv4TotalNumberOfRoutes=100 | Ipv4StartRoutesPrefix=192.168.0.0 | Ipv4EndRoutesPrefix=192.168.255.255 | Ipv4RoutesNoneSeq=True | Ipv4RoutesPrefixLenType=LINEAR | Ipv4RoutesPrefixLenStart=24 | Ipv4RoutesPrefixLenEnd=32 | Ipv4Metric=5 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.rip_route.config_rip_route_wizard_ipv6",
    "return_type": "RipRouteWizardConfig or list of RipRouteWizardConfig",
    "return": "Returns a single configuration result if one wizard is provided, or a list of results if multiple wizards are provided.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable (list, set, tuple)",
        "description": "A single wizard object or an iterable of wizard objects. Each wizard must have a `config_ipv6_route` method to handle the actual IPv6 route configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Ipv6TotalNumberOfRoutes",
        "type": "int",
        "description": "The total number of routes to create.",
        "default": "20",
        "range_or_options": "0-10000000"
      },
      {
        "name": "Ipv6StartRoutesPrefix",
        "type": "str",
        "description": "Starting prefix for IPv6 routes.",
        "default": "3000::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6EndRoutesPrefix",
        "type": "str",
        "description": "Ending prefix for IPv6 routes.",
        "default": "3ffe::",
        "range_or_options": "valid IPv6 address"
      },
      {
        "name": "Ipv6RoutesNoneSeq",
        "type": "bool",
        "description": "Flag to prevent route aggregation.",
        "default": "False",
        "range_or_options": "True False"
      },
      {
        "name": "Ipv6RoutesPrefixLenType",
        "type": "str",
        "description": "Distribution type for route prefix lengths.",
        "default": "FIXED",
        "range_or_options": "FIXED LINEAR"
      },
      {
        "name": "Ipv6RoutesPrefixLenStart",
        "type": "int",
        "description": "Starting prefix length for IPv6 routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6RoutesPrefixLenEnd",
        "type": "int",
        "description": "Ending prefix length for IPv6 routes.",
        "default": "64",
        "range_or_options": "1-128"
      },
      {
        "name": "Ipv6Metric",
        "type": "int",
        "description": "Metric value for the routes.",
        "default": "1",
        "range_or_options": "1-16"
      }
    ],
    "description": "This function configures IPv6 RIP route settings using the provided wizard(s) and additional configuration parameters. It supports both single and multiple wizard inputs and standardizes their processing by applying the same configuration to each wizard. The actual configuration is delegated to the `config_ipv6_route` method of each wizard object.",
    "example": "| Config Rip Route Wizard Ipv6 | Wizards=@{wizard} | Ipv6TotalNumberOfRoutes=50 | Ipv6StartRoutesPrefix=2001:: | Ipv6RoutesPrefixLenStart=48 | Ipv6Metric=5 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.rip_route.expand_rip_route_wizard",
    "return_type": "bool",
    "return": "布尔值，表示操作是否成功（True/False）。",
    "parameters": [
      {
        "name": "Wizards",
        "type": "list",
        "description": "RIP Route向导对象的集合，可以是单个向导对象或包含多个向导对象的列表、集合或元组。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于展开RIP路由配置向导。支持传入单个向导对象或者一个包含多个向导对象的可迭代结构（如列表、集合或元组）。每个向导对象必须具有`expand()`方法，并通过调用该方法完成实际的展开逻辑。",
    "example": ".. code:: RobotFramework\n\n    | Expand Rip Route Wizard | Wizards=@{Wizards} |"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.create_tsn_wizard",
    "return_type": "Union[TsnAvbWizard, TsnQcrWizard, BgpVpls, Pwe, bool]",
    "return": "Returns an instance of a specific wizard/configuration object based on the Type parameter. If the type is unknown, returns False.",
    "parameters": [
      {
        "name": "Type",
        "type": "str",
        "description": "A string indicating the type of TSN wizard or configuration to create. This is case-insensitive.",
        "default": "not_found",
        "range_or_options": "'avb' 'qcr' 'frame_pre_emption' 'cb'"
      }
    ],
    "kwargs": [
      {
        "name": "TalkerPort",
        "type": "Port",
        "description": "Required for 'avb' type; specifies the Talker port.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ListenerPort",
        "type": "Port",
        "description": "Required for 'avb' type; specifies the Listener port.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "NonAvbPort",
        "type": "Port",
        "description": "Optional for 'avb' type; specifies a non-AVB port.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IsAppended",
        "type": "bool",
        "description": "Optional for 'avb' type; indicates whether the configuration should be appended.",
        "default": "False",
        "range_or_options": "True False"
      }
    ],
    "description": "This function acts as a factory method to create and return specific Time-Sensitive Networking (TSN) wizard or configuration objects based on the provided `Type`. It wraps the backend API call and handles failure by raising a ContinuableFailure exception if the internal API call fails (returns False). Valid types include 'avb', 'qcr', 'frame_pre_emption', and 'cb', each mapping to a different class. Additional keyword arguments can be passed depending on the selected type to configure the object accordingly.",
    "example": "| Create Tsn Wizard | Type=avb | TalkerPort=port1 | ListenerPort=port2 | IsAppended=True"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.config_tsn_avb_qav",
    "return_type": "bool or WizardConfig",
    "return": "Returns True if the configuration was successfully applied to all Wizards. Returns False if an exception occurred during configuration of any Wizard. Also may return a WizardConfig object in some contexts.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "Wizard or list of Wizard",
        "description": "The Wizard instance or collection of instances whose Qav settings need to be configured.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "FrameSize",
        "type": "int",
        "description": "Size of the frame in bytes.",
        "default": "not_found",
        "range_or_options": "60-16383"
      },
      {
        "name": "SrClassVid",
        "type": "int",
        "description": "Stream reservation class VLAN ID.",
        "default": "not_found",
        "range_or_options": "1-4093"
      },
      {
        "name": "EnableClassA",
        "type": "bool",
        "description": "Enables Class A traffic shaping.",
        "default": "not_found",
        "range_or_options": "True False"
      },
      {
        "name": "ClassABwRsvPct",
        "type": "int",
        "description": "Bandwidth reservation percentage for Class A.",
        "default": "not_found",
        "range_or_options": "0-100"
      },
      {
        "name": "ClassAStreamNum",
        "type": "int",
        "description": "Number of Class A streams.",
        "default": "not_found",
        "range_or_options": "0-256"
      },
      {
        "name": "ClassAStreamsBwRsvPct",
        "type": "list",
        "description": "List of bandwidth reservation percentages for individual Class A streams.",
        "default": "not_found",
        "range_or_options": "60-16383"
      },
      {
        "name": "EnableClassB",
        "type": "bool",
        "description": "Enables Class B traffic shaping.",
        "default": "not_found",
        "range_or_options": "True False"
      },
      {
        "name": "ClassBBwRsvPct",
        "type": "int",
        "description": "Bandwidth reservation percentage for Class B.",
        "default": "not_found",
        "range_or_options": "0-100"
      },
      {
        "name": "ClassBStreamNum",
        "type": "int",
        "description": "Number of Class B streams.",
        "default": "not_found",
        "range_or_options": "0-256"
      },
      {
        "name": "ClassBStreamsBwRsvPct",
        "type": "list",
        "description": "List of bandwidth reservation percentages for individual Class B streams.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures TSN AVB (Audio Video Bridging) Qav (Queuing and Time-Sensitive Networking features) settings for one or more Wizard objects. It applies the configuration using provided keyword arguments. If any error occurs during configuration, it catches the exception, sets result to False, and raises a ContinuableFailure exception. Otherwise, it returns True indicating successful configuration.",
    "example": "| Config Tsn Avb Qav | FrameSize=128 | EnableClassA=True | ClassABwRsvPct=75 | ClassAStreamNum=5 | ClassAStreamsBwRsvPct=[70, 70, 70, 70, 70] | EnableClassB=False"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.config_tsn_avb_gptp",
    "return_type": "bool or WizardConfig",
    "return": "Returns True if the configuration was successfully applied to all Wizards; False if an exception occurred during configuration. In case of success, it also returns the wizard config object.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable",
        "description": "A single Wizard object or an iterable (list, set, tuple) containing multiple Wizard objects to configure.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "Priority1",
        "type": "int",
        "description": "Sets Priority1 value for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "Priority2",
        "type": "int",
        "description": "Sets Priority2 value for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "ClockAccuracy",
        "type": "str",
        "description": "Specifies the Clock Accuracy type for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "CLOCK_ACCURACY_0 CLOCK_ACCURACY_20 CLOCK_ACCURACY_21 CLOCK_ACCURACY_22 CLOCK_ACCURACY_23 CLOCK_ACCURACY_24 CLOCK_ACCURACY_25 CLOCK_ACCURACY_26 CLOCK_ACCURACY_27 CLOCK_ACCURACY_28 CLOCK_ACCURACY_29 CLOCK_ACCURACY_2A CLOCK_ACCURACY_2B CLOCK_ACCURACY_2C CLOCK_ACCURACY_2D CLOCK_ACCURACY_2E CLOCK_ACCURACY_2F CLOCK_ACCURACY_30 CLOCK_ACCURACY_31"
      },
      {
        "name": "LogAnnounceInterval",
        "type": "int",
        "description": "Sets Log Announce Interval for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "-10-10"
      },
      {
        "name": "LogSyncInterval",
        "type": "int",
        "description": "Sets Log Sync Interval for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "-10-10"
      },
      {
        "name": "AnnounceReceiptTimeout",
        "type": "int",
        "description": "Sets Announce Receipt Timeout for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "3-255"
      },
      {
        "name": "PropagationDelay",
        "type": "int",
        "description": "Sets Propagation Delay for gPTP configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "This function configures TSN/AVB GPTP (gPTP) settings for one or more Wizard objects. It applies the provided gPTP configurations using keyword arguments and ensures that all given Wizard objects are properly updated. If any exception occurs during configuration, it raises a ContinuableFailure exception indicating failure in execution.",
    "example": ".. code:: RobotFramework\n\n    | Create Tsn Wizard | Type=avb |"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.config_tsn_avb_non_stream",
    "return_type": "bool",
    "return": "True if all configurations were successfully applied without exceptions; False if an exception occurred during configuration of any wizard.",
    "description": "Configures non-stream settings for TSN/AVB using the provided wizard objects. This function applies the non-stream configuration to each of the given wizard objects by calling their internal `config_non_stream` method. It is designed to be robust and handles exceptions gracefully, ensuring that failures in configuration do not interrupt execution.",
    "parameters": [
      {
        "name": "Wizards",
        "type": "object or iterable of objects (list, set, tuple)",
        "description": "A single wizard object or an iterable containing wizard objects. Each wizard must have a `config_non_stream` method that accepts keyword arguments for configuration.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "NonAvbFrameSize",
        "type": "int",
        "description": "The frame size to be used for non-AVB traffic in bytes.",
        "default": "not_found",
        "range_or_options": "60-16383"
      },
      {
        "name": "LoadRate",
        "type": "int",
        "description": "The percentage of bandwidth utilization (load rate) for traffic generation.",
        "default": "not_found",
        "range_or_options": "0-100"
      },
      {
        "name": "StreamNumber",
        "type": "int",
        "description": "The number of streams to be configured for non-stream TSN/AVB settings.",
        "default": "not_found",
        "range_or_options": "0-256"
      }
    ],
    "example": ".. code:: RobotFramework\n\n    | Create Tsn Wizard | Type=avb |"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.create_tsn_qcr_stream",
    "return_type": "any",
    "return": "The result returned by the underlying `Wizard.create_qcr_stream()` method, which typically represents the created stream or configuration object. Returns `False` on failure.",
    "parameters": [
      {
        "name": "Wizard",
        "type": "object or iterable",
        "description": "A Wizard object (or an iterable containing a Wizard object as its first element) that provides the `create_qcr_stream` method for creating a stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "TalkerPort",
        "type": "any",
        "description": "The port associated with the talker (sender) in the stream configuration.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "ListenerPortList",
        "type": "list",
        "description": "A list of ports associated with listeners (receivers) in the stream configuration.",
        "default": "None",
        "range_or_options": "not_found"
      },
      {
        "name": "Priority",
        "type": "int",
        "description": "The priority value for the stream, typically used for traffic classification.",
        "default": "None",
        "range_or_options": "0-7 (IEEE 802.1Q)"
      },
      {
        "name": "LoadUnit",
        "type": "str",
        "description": "The unit of load measurement (e.g., 'Mbps', 'Percent').",
        "default": "None",
        "range_or_options": "'Mbps' 'Percent'"
      },
      {
        "name": "Load",
        "type": "float",
        "description": "The load value to apply to the stream, expressed in the given LoadUnit.",
        "default": "None",
        "range_or_options": "0.0 - max depending on LoadUnit"
      },
      {
        "name": "FrameLengthType",
        "type": "str",
        "description": "Type of frame length configuration (e.g., 'Fixed', 'Increment', 'Random').",
        "default": "None",
        "range_or_options": "'Fixed' 'Increment' 'Random'"
      },
      {
        "name": "FixedFrameSize",
        "type": "int",
        "description": "Frame size in bytes when FrameLengthType is 'Fixed'.",
        "default": "None",
        "range_or_options": "64 - 9216"
      },
      {
        "name": "MinFrameSize",
        "type": "int",
        "description": "Minimum frame size in bytes when FrameLengthType is 'Increment' or 'Random'.",
        "default": "None",
        "range_or_options": "64 - 9216"
      },
      {
        "name": "MaxFrameSize",
        "type": "int",
        "description": "Maximum frame size in bytes when FrameLengthType is 'Increment' or 'Random'.",
        "default": "None",
        "range_or_options": "64 - 9216"
      },
      {
        "name": "StepFrameSize",
        "type": "int",
        "description": "Step size in bytes when FrameLengthType is 'Increment'.",
        "default": "None",
        "range_or_options": "1 - 9216"
      }
    ],
    "description": "Creates a QCR (Quick Configuration for Stream) stream for TSN (Time-Sensitive Networking) using the provided Wizard object. This function wraps the `create_qcr_stream` method of the Wizard instance to configure and create a stream with specified parameters for testing or configuration purposes. If multiple Wizard instances are provided, only the first one is used.",
    "example": "| Create Tsn Qcr Stream | Wizard=${wizard} | TalkerPort=${talker_port} | ListenerPortList=@{listener_ports} | Priority=3 | LoadUnit=Mbps | Load=100 | FrameLengthType=Fixed | FixedFrameSize=1500 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.config_tsn_qcr_stream_identification_function",
    "return_type": "bool",
    "return": "Returns True if the configuration is successfully applied; otherwise, raises an exception.",
    "parameters": [
      {
        "name": "Configs",
        "type": "object or iterable of objects, optional",
        "description": "A single configuration object or a list/set/tuple of configuration objects to apply the settings to. If not an iterable, it will be converted into a list containing one element.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "StreamIdentificationFunction",
        "type": "str or object, optional",
        "description": "The stream identification function to configure. This could be a string representing the function name or an object defining the function logic.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "SourceMacAddress",
        "type": "str, optional",
        "description": "The source MAC address used for identifying the stream. Format should be a valid MAC address string like '00:11:22:33:44:55'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DestinationMacAddress",
        "type": "str, optional",
        "description": "The destination MAC address used for identifying the stream. Format should be a valid MAC address string like '00:11:22:33:44:55'.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "VlanId",
        "type": "int, optional",
        "description": "VLAN ID associated with the stream. Must be an integer between 0 and 4095.",
        "default": "not_found",
        "range_or_options": "0-4095"
      },
      {
        "name": "AddUdpHeader",
        "type": "bool, optional",
        "description": "Whether to include a UDP header in the stream identification. True enables it, False disables it.",
        "default": "not_found",
        "range_or_options": "True False"
      },
      {
        "name": "SourcePort",
        "type": "int, optional",
        "description": "The source port number to identify the stream. Valid range is typically 0-65535.",
        "default": "not_found",
        "range_or_options": "0-65535"
      },
      {
        "name": "DestinationPort",
        "type": "int, optional",
        "description": "The destination port number to identify the stream. Valid range is typically 0-65535.",
        "default": "not_found",
        "range_or_options": "0-65535"
      },
      {
        "name": "AddIpHeader",
        "type": "bool, optional",
        "description": "Whether to include an IP header in the stream identification. True enables it, False disables it.",
        "default": "not_found",
        "range_or_options": "True False"
      },
      {
        "name": "SourceIpAddress",
        "type": "str, optional",
        "description": "The source IPv4 or IPv6 address used for identifying the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "DestinationIpAddress",
        "type": "str, optional",
        "description": "The destination IPv4 or IPv6 address used for identifying the stream.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IpDscp",
        "type": "int, optional",
        "description": "DSCP (Differentiated Services Code Point) value in the IP header, used for Quality of Service (QoS) purposes.",
        "default": "not_found",
        "range_or_options": "not_found"
      },
      {
        "name": "IpNextProtocol",
        "type": "int, optional",
        "description": "The next protocol field in the IP header (e.g., TCP=6, UDP=17). Used to further qualify the packet type.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [
      {
        "name": "**kwargs",
        "type": "dict, optional",
        "description": "Additional keyword arguments that may be required for specific implementations or extensions.",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "description": "Configures the TSN (Time-Sensitive Networking) QCR (Queuing and Credit Reconciliation) stream identification function for one or more configuration objects. This function wraps the configuration process and applies it across multiple configuration instances if provided.",
    "example": "| Config Tsn Qcr Stream Identification Function | SourceMacAddress=00:11:22:33:44:55 | DestinationMacAddress=FF:EE:DD:CC:BB:AA | VlanId=100 | AddIpHeader=True | SourceIpAddress=192.168.1.1 | DestinationIpAddress=192.168.1.2 | IpDscp=46 | IpNextProtocol=17 | AddUdpHeader=True | SourcePort=5000 | DestinationPort=6000 |"
  },
  {
    "method_name": "TesterLibrary.Wizard.tsn.expand_tsn_wizard",
    "return_type": "bool",
    "return": "布尔值，表示向导配置是否成功生成。",
    "parameters": [
      {
        "name": "Wizard",
        "type": "list",
        "description": "TSN 向导对象列表。每个对象应为一个包含必要配置信息的 Wizard 实例或结构。",
        "default": "not_found",
        "range_or_options": "not_found"
      }
    ],
    "kwargs": [],
    "description": "该函数用于生成 ISIS LSP 的 TSN 向导配置。它会调用底层 `renix.expand_wizard` 方法来展开传入的向导对象。如果执行失败（返回 False），则抛出一个可继续的异常；否则返回 True 表示操作成功。",
    "example": "| Expand Isis Lsp Wizard | Wizards=@{Wizards} |"
  }
]